// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package nutanix

import (
	"context"
	"reflect"

	"errors"
	"github.com/pierskarsenbarg/pulumi-nutanix/sdk/go/nutanix/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides Nutanix resource to create Policy Based Routing inside VPCs.
//
// ## Example Usage
// ### pbr creation with vpc name with any source or destination or protocol with permit action
//
// ```go
// package main
//
// import (
//
//	"github.com/pierskarsenbarg/pulumi-nutanix/sdk/go/nutanix"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := nutanix.NewPbr(ctx, "pbr", &nutanix.PbrArgs{
//				Action: pulumi.String("PERMIT"),
//				Destination: &nutanix.PbrDestinationArgs{
//					AddressType: pulumi.String("ALL"),
//				},
//				Priority:     pulumi.Int(123),
//				ProtocolType: pulumi.String("ALL"),
//				Source: &nutanix.PbrSourceArgs{
//					AddressType: pulumi.String("ALL"),
//				},
//				VpcName: pulumi.String("test123"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ## source
//
// source address of an IP packet. This could be either an ip prefix or an addressType .
//
// * `address` - (Optional) address type of source. Should be one of {INTERNET, ALL}.
// * `subnetIp` - (Optional) IP subnet provided as an address.
// * `prefixLength` - (Optional) prefix length of provided subnet.
//
// ## destination
//
// destination address of an IP packet. This could be either an ip prefix or an addressType .
//
// * `address` - (Optional) address type of source. Should be one of {INTERNET, ALL}.
// * `subnetIp` - (Optional) IP subnet provided as an address.
// * `prefixLength` - (Optional) prefix length of provided subnet.
//
// ## protocolParameters
//
// # Routing policy IP protocol parameters
//
// * `tcp` - (Optional) TCP parameters in routing policy
// * `udp` - (Optional) UDP parameters in routing policy
// * `icmp` - (Optional) ICMP parameters in routing policy.
// * `protocolNumber` - (Optional) Protocol number in routing policy
//
// ## tcp, udp
//
// * `sourcePortRange` - (Required) Range of TCP/UDP ports.
// * `destinationPortRange` - (Required) Range of TCP/UDP ports.
//
// ## source_port_range, destinationPortRange
//
// * `startPort` - (Required) start port number
// * `endPort` - (Required) end port number
type Pbr struct {
	pulumi.CustomResourceState

	// Routing policy action. Must be one of {DENY, PERMIT, REROUTE} .
	Action pulumi.StringOutput `pulumi:"action"`
	// The version of the API.
	ApiVersion  pulumi.StringOutput  `pulumi:"apiVersion"`
	Destination PbrDestinationOutput `pulumi:"destination"`
	// Additionally create Policy in reverse direction. Should be used with {TCP, UDP with start and end port ranges and ICMP with icmp code and type}. Supported with 2022.x.
	IsBidirectional pulumi.BoolOutput `pulumi:"isBidirectional"`
	// The routing policies kind metadata.
	Metadata pulumi.StringMapOutput `pulumi:"metadata"`
	// name of policy
	Name pulumi.StringOutput `pulumi:"name"`
	// priority of policy
	Priority           pulumi.IntOutput               `pulumi:"priority"`
	ProtocolParameters PbrProtocolParametersPtrOutput `pulumi:"protocolParameters"`
	// Protocol type of policy based routing. Must be one of {TCP, UDP, ICMP, PROTOCOL_NUMBER, ALL} .
	ProtocolType pulumi.StringOutput `pulumi:"protocolType"`
	// IP addresses of network services. This field is valid only when action is REROUTE.
	ServiceIpLists pulumi.StringArrayOutput `pulumi:"serviceIpLists"`
	Source         PbrSourceOutput          `pulumi:"source"`
	// The reference to a vpc. Should not be used with {vpc_reference_uuid}
	VpcName pulumi.StringOutput `pulumi:"vpcName"`
	// The reference to a vpc . Should not be used with {vpc_name} .
	VpcReferenceUuid pulumi.StringOutput `pulumi:"vpcReferenceUuid"`
}

// NewPbr registers a new resource with the given unique name, arguments, and options.
func NewPbr(ctx *pulumi.Context,
	name string, args *PbrArgs, opts ...pulumi.ResourceOption) (*Pbr, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Action == nil {
		return nil, errors.New("invalid value for required argument 'Action'")
	}
	if args.Destination == nil {
		return nil, errors.New("invalid value for required argument 'Destination'")
	}
	if args.Priority == nil {
		return nil, errors.New("invalid value for required argument 'Priority'")
	}
	if args.ProtocolType == nil {
		return nil, errors.New("invalid value for required argument 'ProtocolType'")
	}
	if args.Source == nil {
		return nil, errors.New("invalid value for required argument 'Source'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Pbr
	err := ctx.RegisterResource("nutanix:index/pbr:Pbr", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPbr gets an existing Pbr resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPbr(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PbrState, opts ...pulumi.ResourceOption) (*Pbr, error) {
	var resource Pbr
	err := ctx.ReadResource("nutanix:index/pbr:Pbr", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Pbr resources.
type pbrState struct {
	// Routing policy action. Must be one of {DENY, PERMIT, REROUTE} .
	Action *string `pulumi:"action"`
	// The version of the API.
	ApiVersion  *string         `pulumi:"apiVersion"`
	Destination *PbrDestination `pulumi:"destination"`
	// Additionally create Policy in reverse direction. Should be used with {TCP, UDP with start and end port ranges and ICMP with icmp code and type}. Supported with 2022.x.
	IsBidirectional *bool `pulumi:"isBidirectional"`
	// The routing policies kind metadata.
	Metadata map[string]string `pulumi:"metadata"`
	// name of policy
	Name *string `pulumi:"name"`
	// priority of policy
	Priority           *int                   `pulumi:"priority"`
	ProtocolParameters *PbrProtocolParameters `pulumi:"protocolParameters"`
	// Protocol type of policy based routing. Must be one of {TCP, UDP, ICMP, PROTOCOL_NUMBER, ALL} .
	ProtocolType *string `pulumi:"protocolType"`
	// IP addresses of network services. This field is valid only when action is REROUTE.
	ServiceIpLists []string   `pulumi:"serviceIpLists"`
	Source         *PbrSource `pulumi:"source"`
	// The reference to a vpc. Should not be used with {vpc_reference_uuid}
	VpcName *string `pulumi:"vpcName"`
	// The reference to a vpc . Should not be used with {vpc_name} .
	VpcReferenceUuid *string `pulumi:"vpcReferenceUuid"`
}

type PbrState struct {
	// Routing policy action. Must be one of {DENY, PERMIT, REROUTE} .
	Action pulumi.StringPtrInput
	// The version of the API.
	ApiVersion  pulumi.StringPtrInput
	Destination PbrDestinationPtrInput
	// Additionally create Policy in reverse direction. Should be used with {TCP, UDP with start and end port ranges and ICMP with icmp code and type}. Supported with 2022.x.
	IsBidirectional pulumi.BoolPtrInput
	// The routing policies kind metadata.
	Metadata pulumi.StringMapInput
	// name of policy
	Name pulumi.StringPtrInput
	// priority of policy
	Priority           pulumi.IntPtrInput
	ProtocolParameters PbrProtocolParametersPtrInput
	// Protocol type of policy based routing. Must be one of {TCP, UDP, ICMP, PROTOCOL_NUMBER, ALL} .
	ProtocolType pulumi.StringPtrInput
	// IP addresses of network services. This field is valid only when action is REROUTE.
	ServiceIpLists pulumi.StringArrayInput
	Source         PbrSourcePtrInput
	// The reference to a vpc. Should not be used with {vpc_reference_uuid}
	VpcName pulumi.StringPtrInput
	// The reference to a vpc . Should not be used with {vpc_name} .
	VpcReferenceUuid pulumi.StringPtrInput
}

func (PbrState) ElementType() reflect.Type {
	return reflect.TypeOf((*pbrState)(nil)).Elem()
}

type pbrArgs struct {
	// Routing policy action. Must be one of {DENY, PERMIT, REROUTE} .
	Action string `pulumi:"action"`
	// The version of the API.
	ApiVersion  *string        `pulumi:"apiVersion"`
	Destination PbrDestination `pulumi:"destination"`
	// Additionally create Policy in reverse direction. Should be used with {TCP, UDP with start and end port ranges and ICMP with icmp code and type}. Supported with 2022.x.
	IsBidirectional *bool `pulumi:"isBidirectional"`
	// name of policy
	Name *string `pulumi:"name"`
	// priority of policy
	Priority           int                    `pulumi:"priority"`
	ProtocolParameters *PbrProtocolParameters `pulumi:"protocolParameters"`
	// Protocol type of policy based routing. Must be one of {TCP, UDP, ICMP, PROTOCOL_NUMBER, ALL} .
	ProtocolType string `pulumi:"protocolType"`
	// IP addresses of network services. This field is valid only when action is REROUTE.
	ServiceIpLists []string  `pulumi:"serviceIpLists"`
	Source         PbrSource `pulumi:"source"`
	// The reference to a vpc. Should not be used with {vpc_reference_uuid}
	VpcName *string `pulumi:"vpcName"`
	// The reference to a vpc . Should not be used with {vpc_name} .
	VpcReferenceUuid *string `pulumi:"vpcReferenceUuid"`
}

// The set of arguments for constructing a Pbr resource.
type PbrArgs struct {
	// Routing policy action. Must be one of {DENY, PERMIT, REROUTE} .
	Action pulumi.StringInput
	// The version of the API.
	ApiVersion  pulumi.StringPtrInput
	Destination PbrDestinationInput
	// Additionally create Policy in reverse direction. Should be used with {TCP, UDP with start and end port ranges and ICMP with icmp code and type}. Supported with 2022.x.
	IsBidirectional pulumi.BoolPtrInput
	// name of policy
	Name pulumi.StringPtrInput
	// priority of policy
	Priority           pulumi.IntInput
	ProtocolParameters PbrProtocolParametersPtrInput
	// Protocol type of policy based routing. Must be one of {TCP, UDP, ICMP, PROTOCOL_NUMBER, ALL} .
	ProtocolType pulumi.StringInput
	// IP addresses of network services. This field is valid only when action is REROUTE.
	ServiceIpLists pulumi.StringArrayInput
	Source         PbrSourceInput
	// The reference to a vpc. Should not be used with {vpc_reference_uuid}
	VpcName pulumi.StringPtrInput
	// The reference to a vpc . Should not be used with {vpc_name} .
	VpcReferenceUuid pulumi.StringPtrInput
}

func (PbrArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*pbrArgs)(nil)).Elem()
}

type PbrInput interface {
	pulumi.Input

	ToPbrOutput() PbrOutput
	ToPbrOutputWithContext(ctx context.Context) PbrOutput
}

func (*Pbr) ElementType() reflect.Type {
	return reflect.TypeOf((**Pbr)(nil)).Elem()
}

func (i *Pbr) ToPbrOutput() PbrOutput {
	return i.ToPbrOutputWithContext(context.Background())
}

func (i *Pbr) ToPbrOutputWithContext(ctx context.Context) PbrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PbrOutput)
}

// PbrArrayInput is an input type that accepts PbrArray and PbrArrayOutput values.
// You can construct a concrete instance of `PbrArrayInput` via:
//
//	PbrArray{ PbrArgs{...} }
type PbrArrayInput interface {
	pulumi.Input

	ToPbrArrayOutput() PbrArrayOutput
	ToPbrArrayOutputWithContext(context.Context) PbrArrayOutput
}

type PbrArray []PbrInput

func (PbrArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Pbr)(nil)).Elem()
}

func (i PbrArray) ToPbrArrayOutput() PbrArrayOutput {
	return i.ToPbrArrayOutputWithContext(context.Background())
}

func (i PbrArray) ToPbrArrayOutputWithContext(ctx context.Context) PbrArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PbrArrayOutput)
}

// PbrMapInput is an input type that accepts PbrMap and PbrMapOutput values.
// You can construct a concrete instance of `PbrMapInput` via:
//
//	PbrMap{ "key": PbrArgs{...} }
type PbrMapInput interface {
	pulumi.Input

	ToPbrMapOutput() PbrMapOutput
	ToPbrMapOutputWithContext(context.Context) PbrMapOutput
}

type PbrMap map[string]PbrInput

func (PbrMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Pbr)(nil)).Elem()
}

func (i PbrMap) ToPbrMapOutput() PbrMapOutput {
	return i.ToPbrMapOutputWithContext(context.Background())
}

func (i PbrMap) ToPbrMapOutputWithContext(ctx context.Context) PbrMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PbrMapOutput)
}

type PbrOutput struct{ *pulumi.OutputState }

func (PbrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Pbr)(nil)).Elem()
}

func (o PbrOutput) ToPbrOutput() PbrOutput {
	return o
}

func (o PbrOutput) ToPbrOutputWithContext(ctx context.Context) PbrOutput {
	return o
}

// Routing policy action. Must be one of {DENY, PERMIT, REROUTE} .
func (o PbrOutput) Action() pulumi.StringOutput {
	return o.ApplyT(func(v *Pbr) pulumi.StringOutput { return v.Action }).(pulumi.StringOutput)
}

// The version of the API.
func (o PbrOutput) ApiVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *Pbr) pulumi.StringOutput { return v.ApiVersion }).(pulumi.StringOutput)
}

func (o PbrOutput) Destination() PbrDestinationOutput {
	return o.ApplyT(func(v *Pbr) PbrDestinationOutput { return v.Destination }).(PbrDestinationOutput)
}

// Additionally create Policy in reverse direction. Should be used with {TCP, UDP with start and end port ranges and ICMP with icmp code and type}. Supported with 2022.x.
func (o PbrOutput) IsBidirectional() pulumi.BoolOutput {
	return o.ApplyT(func(v *Pbr) pulumi.BoolOutput { return v.IsBidirectional }).(pulumi.BoolOutput)
}

// The routing policies kind metadata.
func (o PbrOutput) Metadata() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Pbr) pulumi.StringMapOutput { return v.Metadata }).(pulumi.StringMapOutput)
}

// name of policy
func (o PbrOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Pbr) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// priority of policy
func (o PbrOutput) Priority() pulumi.IntOutput {
	return o.ApplyT(func(v *Pbr) pulumi.IntOutput { return v.Priority }).(pulumi.IntOutput)
}

func (o PbrOutput) ProtocolParameters() PbrProtocolParametersPtrOutput {
	return o.ApplyT(func(v *Pbr) PbrProtocolParametersPtrOutput { return v.ProtocolParameters }).(PbrProtocolParametersPtrOutput)
}

// Protocol type of policy based routing. Must be one of {TCP, UDP, ICMP, PROTOCOL_NUMBER, ALL} .
func (o PbrOutput) ProtocolType() pulumi.StringOutput {
	return o.ApplyT(func(v *Pbr) pulumi.StringOutput { return v.ProtocolType }).(pulumi.StringOutput)
}

// IP addresses of network services. This field is valid only when action is REROUTE.
func (o PbrOutput) ServiceIpLists() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Pbr) pulumi.StringArrayOutput { return v.ServiceIpLists }).(pulumi.StringArrayOutput)
}

func (o PbrOutput) Source() PbrSourceOutput {
	return o.ApplyT(func(v *Pbr) PbrSourceOutput { return v.Source }).(PbrSourceOutput)
}

// The reference to a vpc. Should not be used with {vpc_reference_uuid}
func (o PbrOutput) VpcName() pulumi.StringOutput {
	return o.ApplyT(func(v *Pbr) pulumi.StringOutput { return v.VpcName }).(pulumi.StringOutput)
}

// The reference to a vpc . Should not be used with {vpc_name} .
func (o PbrOutput) VpcReferenceUuid() pulumi.StringOutput {
	return o.ApplyT(func(v *Pbr) pulumi.StringOutput { return v.VpcReferenceUuid }).(pulumi.StringOutput)
}

type PbrArrayOutput struct{ *pulumi.OutputState }

func (PbrArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Pbr)(nil)).Elem()
}

func (o PbrArrayOutput) ToPbrArrayOutput() PbrArrayOutput {
	return o
}

func (o PbrArrayOutput) ToPbrArrayOutputWithContext(ctx context.Context) PbrArrayOutput {
	return o
}

func (o PbrArrayOutput) Index(i pulumi.IntInput) PbrOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Pbr {
		return vs[0].([]*Pbr)[vs[1].(int)]
	}).(PbrOutput)
}

type PbrMapOutput struct{ *pulumi.OutputState }

func (PbrMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Pbr)(nil)).Elem()
}

func (o PbrMapOutput) ToPbrMapOutput() PbrMapOutput {
	return o
}

func (o PbrMapOutput) ToPbrMapOutputWithContext(ctx context.Context) PbrMapOutput {
	return o
}

func (o PbrMapOutput) MapIndex(k pulumi.StringInput) PbrOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Pbr {
		return vs[0].(map[string]*Pbr)[vs[1].(string)]
	}).(PbrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PbrInput)(nil)).Elem(), &Pbr{})
	pulumi.RegisterInputType(reflect.TypeOf((*PbrArrayInput)(nil)).Elem(), PbrArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PbrMapInput)(nil)).Elem(), PbrMap{})
	pulumi.RegisterOutputType(PbrOutput{})
	pulumi.RegisterOutputType(PbrArrayOutput{})
	pulumi.RegisterOutputType(PbrMapOutput{})
}
