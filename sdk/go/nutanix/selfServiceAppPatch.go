// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package nutanix

import (
	"context"
	"reflect"

	"errors"
	"github.com/pierskarsenbarg/pulumi-nutanix/sdk/go/nutanix/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Run the specified patch on the application by running patch action to update vm configuration, add nics, add disks, add/delete categories.
//
// ## Example 1: Update VM Configuration
//
// This will run set patch config action in application.
//
// ```go
// package main
//
// import (
//
//	"github.com/pierskarsenbarg/pulumi-nutanix/sdk/go/nutanix"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Provision Application
//			testSelfServiceAppProvision, err := nutanix.NewSelfServiceAppProvision(ctx, "testSelfServiceAppProvision", &nutanix.SelfServiceAppProvisionArgs{
//				BpName:         pulumi.String("NAME OF BLUEPRINT"),
//				AppName:        pulumi.String("NAME OF APPLICATION"),
//				AppDescription: pulumi.String("DESCRIPTION OF APPLICATION"),
//			})
//			if err != nil {
//				return err
//			}
//			// Run patch config (update config)
//			_, err = nutanix.NewSelfServiceAppPatch(ctx, "testSelfServiceAppPatch", &nutanix.SelfServiceAppPatchArgs{
//				AppUuid:    testSelfServiceAppProvision.ID(),
//				PatchName:  pulumi.String("NAME OF PATCH ACTION"),
//				ConfigName: pulumi.String("NAME OF PATCH CONFIG"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Example 2: Update VM Configuration with runtime editable
//
// ```go
// package main
//
// import (
//
//	"github.com/pierskarsenbarg/pulumi-nutanix/sdk/go/nutanix"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Provision Application
//			testSelfServiceAppProvision, err := nutanix.NewSelfServiceAppProvision(ctx, "testSelfServiceAppProvision", &nutanix.SelfServiceAppProvisionArgs{
//				BpName:         pulumi.String("NAME OF BLUEPRINT"),
//				AppName:        pulumi.String("NAME OF APPLICATION"),
//				AppDescription: pulumi.String("DESCRIPTION OF APPLICATION"),
//			})
//			if err != nil {
//				return err
//			}
//			// Run patch config (update config)
//			_, err = nutanix.NewSelfServiceAppPatch(ctx, "testSelfServiceAppPatch", &nutanix.SelfServiceAppPatchArgs{
//				AppUuid:    testSelfServiceAppProvision.ID(),
//				PatchName:  pulumi.String("NAME OF PATCH ACTION"),
//				ConfigName: pulumi.String("NAME OF PATCH CONFIG"),
//				VmConfigs: nutanix.SelfServiceAppPatchVmConfigArray{
//					&nutanix.SelfServiceAppPatchVmConfigArgs{
//						MemorySizeMib:     pulumi.Int("SIZE IN MiB"),
//						NumSockets:        pulumi.Int("vCPU count"),
//						NumVcpusPerSocket: pulumi.Int("NUMBER OF CORES VCPU"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Example 3: Add Category
//
// ```go
// package main
//
// import (
//
//	"github.com/pierskarsenbarg/pulumi-nutanix/sdk/go/nutanix"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Provision Application
//			testSelfServiceAppProvision, err := nutanix.NewSelfServiceAppProvision(ctx, "testSelfServiceAppProvision", &nutanix.SelfServiceAppProvisionArgs{
//				BpName:         pulumi.String("NAME OF BLUEPRINT"),
//				AppName:        pulumi.String("NAME OF APPLICATION"),
//				AppDescription: pulumi.String("DESCRIPTION OF APPLICATION"),
//			})
//			if err != nil {
//				return err
//			}
//			// Run patch config (update config)
//			_, err = nutanix.NewSelfServiceAppPatch(ctx, "testSelfServiceAppPatch", &nutanix.SelfServiceAppPatchArgs{
//				AppUuid:    testSelfServiceAppProvision.ID(),
//				PatchName:  pulumi.String("NAME OF PATCH ACTION"),
//				ConfigName: pulumi.String("NAME OF PATCH CONFIG"),
//				Categories: nutanix.SelfServiceAppPatchCategoryArray{
//					&nutanix.SelfServiceAppPatchCategoryArgs{
//						Value:     pulumi.String("CATEGORY TO BE ADDED (KEY:VALUE PAIR)"),
//						Operation: pulumi.String("add"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Example 4: Delete Category
//
// ```go
// package main
//
// import (
//
//	"github.com/pierskarsenbarg/pulumi-nutanix/sdk/go/nutanix"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Provision Application
//			testSelfServiceAppProvision, err := nutanix.NewSelfServiceAppProvision(ctx, "testSelfServiceAppProvision", &nutanix.SelfServiceAppProvisionArgs{
//				BpName:         pulumi.String("NAME OF BLUEPRINT"),
//				AppName:        pulumi.String("NAME OF APPLICATION"),
//				AppDescription: pulumi.String("DESCRIPTION OF APPLICATION"),
//			})
//			if err != nil {
//				return err
//			}
//			// Run patch config (update config)
//			_, err = nutanix.NewSelfServiceAppPatch(ctx, "testSelfServiceAppPatch", &nutanix.SelfServiceAppPatchArgs{
//				AppUuid:    testSelfServiceAppProvision.ID(),
//				PatchName:  pulumi.String("NAME OF PATCH ACTION"),
//				ConfigName: pulumi.String("NAME OF PATCH CONFIG"),
//				Categories: nutanix.SelfServiceAppPatchCategoryArray{
//					&nutanix.SelfServiceAppPatchCategoryArgs{
//						Value:     pulumi.String("CATEGORY TO BE ADDED (KEY:VALUE PAIR)"),
//						Operation: pulumi.String("delete"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Example 5: Add Disk
//
// ```go
// package main
//
// import (
//
//	"github.com/pierskarsenbarg/pulumi-nutanix/sdk/go/nutanix"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Provision Application
//			testSelfServiceAppProvision, err := nutanix.NewSelfServiceAppProvision(ctx, "testSelfServiceAppProvision", &nutanix.SelfServiceAppProvisionArgs{
//				BpName:         pulumi.String("NAME OF BLUEPRINT"),
//				AppName:        pulumi.String("NAME OF APPLICATION"),
//				AppDescription: pulumi.String("DESCRIPTION OF APPLICATION"),
//			})
//			if err != nil {
//				return err
//			}
//			// Run patch config (update config)
//			_, err = nutanix.NewSelfServiceAppPatch(ctx, "testSelfServiceAppPatch", &nutanix.SelfServiceAppPatchArgs{
//				AppUuid:    testSelfServiceAppProvision.ID(),
//				PatchName:  pulumi.String("NAME OF PATCH ACTION"),
//				ConfigName: pulumi.String("NAME OF PATCH CONFIG"),
//				Disks: nutanix.SelfServiceAppPatchDiskArray{
//					&nutanix.SelfServiceAppPatchDiskArgs{
//						DiskSizeMib: pulumi.Int("SIZE OF DISK IN MiB"),
//						Operation:   pulumi.String("add"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Example 6: Add Nic
//
// ```go
// package main
//
// import (
//
//	"github.com/pierskarsenbarg/pulumi-nutanix/sdk/go/nutanix"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Provision Application
//			testSelfServiceAppProvision, err := nutanix.NewSelfServiceAppProvision(ctx, "testSelfServiceAppProvision", &nutanix.SelfServiceAppProvisionArgs{
//				BpName:         pulumi.String("NAME OF BLUEPRINT"),
//				AppName:        pulumi.String("NAME OF APPLICATION"),
//				AppDescription: pulumi.String("DESCRIPTION OF APPLICATION"),
//			})
//			if err != nil {
//				return err
//			}
//			// Run patch config (update config)
//			_, err = nutanix.NewSelfServiceAppPatch(ctx, "testSelfServiceAppPatch", &nutanix.SelfServiceAppPatchArgs{
//				AppUuid:    testSelfServiceAppProvision.ID(),
//				PatchName:  pulumi.String("NAME OF PATCH ACTION"),
//				ConfigName: pulumi.String("NAME OF PATCH CONFIG"),
//				Nics: nutanix.SelfServiceAppPatchNicArray{
//					&nutanix.SelfServiceAppPatchNicArgs{
//						Index:      pulumi.Int("DUMMY INDEX VALUE"),
//						Operation:  pulumi.String("add"),
//						SubnetUuid: pulumi.String("VALID SUBNET UUID IN PROJECT ATTACHED TO APP"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type SelfServiceAppPatch struct {
	pulumi.CustomResourceState

	// - (Required) The UUID of the application.
	AppUuid    pulumi.StringOutput                    `pulumi:"appUuid"`
	Categories SelfServiceAppPatchCategoryArrayOutput `pulumi:"categories"`
	// - (Required) The name of the patch configuration. (<b>Same as patchName for SINGLE VM)</b>
	ConfigName pulumi.StringOutput                `pulumi:"configName"`
	Disks      SelfServiceAppPatchDiskArrayOutput `pulumi:"disks"`
	Nics       SelfServiceAppPatchNicArrayOutput  `pulumi:"nics"`
	// - (Required) The name of the patch to be applied. This is used to identify the action name which needs to be executed to update an application.
	PatchName pulumi.StringOutput `pulumi:"patchName"`
	// - (Computed) The UUID of the runlog that records the patch operation's execution details.
	RunlogUuid pulumi.StringOutput                    `pulumi:"runlogUuid"`
	VmConfigs  SelfServiceAppPatchVmConfigArrayOutput `pulumi:"vmConfigs"`
}

// NewSelfServiceAppPatch registers a new resource with the given unique name, arguments, and options.
func NewSelfServiceAppPatch(ctx *pulumi.Context,
	name string, args *SelfServiceAppPatchArgs, opts ...pulumi.ResourceOption) (*SelfServiceAppPatch, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AppUuid == nil {
		return nil, errors.New("invalid value for required argument 'AppUuid'")
	}
	if args.ConfigName == nil {
		return nil, errors.New("invalid value for required argument 'ConfigName'")
	}
	if args.PatchName == nil {
		return nil, errors.New("invalid value for required argument 'PatchName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SelfServiceAppPatch
	err := ctx.RegisterResource("nutanix:index/selfServiceAppPatch:SelfServiceAppPatch", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSelfServiceAppPatch gets an existing SelfServiceAppPatch resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSelfServiceAppPatch(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SelfServiceAppPatchState, opts ...pulumi.ResourceOption) (*SelfServiceAppPatch, error) {
	var resource SelfServiceAppPatch
	err := ctx.ReadResource("nutanix:index/selfServiceAppPatch:SelfServiceAppPatch", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SelfServiceAppPatch resources.
type selfServiceAppPatchState struct {
	// - (Required) The UUID of the application.
	AppUuid    *string                       `pulumi:"appUuid"`
	Categories []SelfServiceAppPatchCategory `pulumi:"categories"`
	// - (Required) The name of the patch configuration. (<b>Same as patchName for SINGLE VM)</b>
	ConfigName *string                   `pulumi:"configName"`
	Disks      []SelfServiceAppPatchDisk `pulumi:"disks"`
	Nics       []SelfServiceAppPatchNic  `pulumi:"nics"`
	// - (Required) The name of the patch to be applied. This is used to identify the action name which needs to be executed to update an application.
	PatchName *string `pulumi:"patchName"`
	// - (Computed) The UUID of the runlog that records the patch operation's execution details.
	RunlogUuid *string                       `pulumi:"runlogUuid"`
	VmConfigs  []SelfServiceAppPatchVmConfig `pulumi:"vmConfigs"`
}

type SelfServiceAppPatchState struct {
	// - (Required) The UUID of the application.
	AppUuid    pulumi.StringPtrInput
	Categories SelfServiceAppPatchCategoryArrayInput
	// - (Required) The name of the patch configuration. (<b>Same as patchName for SINGLE VM)</b>
	ConfigName pulumi.StringPtrInput
	Disks      SelfServiceAppPatchDiskArrayInput
	Nics       SelfServiceAppPatchNicArrayInput
	// - (Required) The name of the patch to be applied. This is used to identify the action name which needs to be executed to update an application.
	PatchName pulumi.StringPtrInput
	// - (Computed) The UUID of the runlog that records the patch operation's execution details.
	RunlogUuid pulumi.StringPtrInput
	VmConfigs  SelfServiceAppPatchVmConfigArrayInput
}

func (SelfServiceAppPatchState) ElementType() reflect.Type {
	return reflect.TypeOf((*selfServiceAppPatchState)(nil)).Elem()
}

type selfServiceAppPatchArgs struct {
	// - (Required) The UUID of the application.
	AppUuid    string                        `pulumi:"appUuid"`
	Categories []SelfServiceAppPatchCategory `pulumi:"categories"`
	// - (Required) The name of the patch configuration. (<b>Same as patchName for SINGLE VM)</b>
	ConfigName string                    `pulumi:"configName"`
	Disks      []SelfServiceAppPatchDisk `pulumi:"disks"`
	Nics       []SelfServiceAppPatchNic  `pulumi:"nics"`
	// - (Required) The name of the patch to be applied. This is used to identify the action name which needs to be executed to update an application.
	PatchName string `pulumi:"patchName"`
	// - (Computed) The UUID of the runlog that records the patch operation's execution details.
	RunlogUuid *string                       `pulumi:"runlogUuid"`
	VmConfigs  []SelfServiceAppPatchVmConfig `pulumi:"vmConfigs"`
}

// The set of arguments for constructing a SelfServiceAppPatch resource.
type SelfServiceAppPatchArgs struct {
	// - (Required) The UUID of the application.
	AppUuid    pulumi.StringInput
	Categories SelfServiceAppPatchCategoryArrayInput
	// - (Required) The name of the patch configuration. (<b>Same as patchName for SINGLE VM)</b>
	ConfigName pulumi.StringInput
	Disks      SelfServiceAppPatchDiskArrayInput
	Nics       SelfServiceAppPatchNicArrayInput
	// - (Required) The name of the patch to be applied. This is used to identify the action name which needs to be executed to update an application.
	PatchName pulumi.StringInput
	// - (Computed) The UUID of the runlog that records the patch operation's execution details.
	RunlogUuid pulumi.StringPtrInput
	VmConfigs  SelfServiceAppPatchVmConfigArrayInput
}

func (SelfServiceAppPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*selfServiceAppPatchArgs)(nil)).Elem()
}

type SelfServiceAppPatchInput interface {
	pulumi.Input

	ToSelfServiceAppPatchOutput() SelfServiceAppPatchOutput
	ToSelfServiceAppPatchOutputWithContext(ctx context.Context) SelfServiceAppPatchOutput
}

func (*SelfServiceAppPatch) ElementType() reflect.Type {
	return reflect.TypeOf((**SelfServiceAppPatch)(nil)).Elem()
}

func (i *SelfServiceAppPatch) ToSelfServiceAppPatchOutput() SelfServiceAppPatchOutput {
	return i.ToSelfServiceAppPatchOutputWithContext(context.Background())
}

func (i *SelfServiceAppPatch) ToSelfServiceAppPatchOutputWithContext(ctx context.Context) SelfServiceAppPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SelfServiceAppPatchOutput)
}

// SelfServiceAppPatchArrayInput is an input type that accepts SelfServiceAppPatchArray and SelfServiceAppPatchArrayOutput values.
// You can construct a concrete instance of `SelfServiceAppPatchArrayInput` via:
//
//	SelfServiceAppPatchArray{ SelfServiceAppPatchArgs{...} }
type SelfServiceAppPatchArrayInput interface {
	pulumi.Input

	ToSelfServiceAppPatchArrayOutput() SelfServiceAppPatchArrayOutput
	ToSelfServiceAppPatchArrayOutputWithContext(context.Context) SelfServiceAppPatchArrayOutput
}

type SelfServiceAppPatchArray []SelfServiceAppPatchInput

func (SelfServiceAppPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SelfServiceAppPatch)(nil)).Elem()
}

func (i SelfServiceAppPatchArray) ToSelfServiceAppPatchArrayOutput() SelfServiceAppPatchArrayOutput {
	return i.ToSelfServiceAppPatchArrayOutputWithContext(context.Background())
}

func (i SelfServiceAppPatchArray) ToSelfServiceAppPatchArrayOutputWithContext(ctx context.Context) SelfServiceAppPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SelfServiceAppPatchArrayOutput)
}

// SelfServiceAppPatchMapInput is an input type that accepts SelfServiceAppPatchMap and SelfServiceAppPatchMapOutput values.
// You can construct a concrete instance of `SelfServiceAppPatchMapInput` via:
//
//	SelfServiceAppPatchMap{ "key": SelfServiceAppPatchArgs{...} }
type SelfServiceAppPatchMapInput interface {
	pulumi.Input

	ToSelfServiceAppPatchMapOutput() SelfServiceAppPatchMapOutput
	ToSelfServiceAppPatchMapOutputWithContext(context.Context) SelfServiceAppPatchMapOutput
}

type SelfServiceAppPatchMap map[string]SelfServiceAppPatchInput

func (SelfServiceAppPatchMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SelfServiceAppPatch)(nil)).Elem()
}

func (i SelfServiceAppPatchMap) ToSelfServiceAppPatchMapOutput() SelfServiceAppPatchMapOutput {
	return i.ToSelfServiceAppPatchMapOutputWithContext(context.Background())
}

func (i SelfServiceAppPatchMap) ToSelfServiceAppPatchMapOutputWithContext(ctx context.Context) SelfServiceAppPatchMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SelfServiceAppPatchMapOutput)
}

type SelfServiceAppPatchOutput struct{ *pulumi.OutputState }

func (SelfServiceAppPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SelfServiceAppPatch)(nil)).Elem()
}

func (o SelfServiceAppPatchOutput) ToSelfServiceAppPatchOutput() SelfServiceAppPatchOutput {
	return o
}

func (o SelfServiceAppPatchOutput) ToSelfServiceAppPatchOutputWithContext(ctx context.Context) SelfServiceAppPatchOutput {
	return o
}

// - (Required) The UUID of the application.
func (o SelfServiceAppPatchOutput) AppUuid() pulumi.StringOutput {
	return o.ApplyT(func(v *SelfServiceAppPatch) pulumi.StringOutput { return v.AppUuid }).(pulumi.StringOutput)
}

func (o SelfServiceAppPatchOutput) Categories() SelfServiceAppPatchCategoryArrayOutput {
	return o.ApplyT(func(v *SelfServiceAppPatch) SelfServiceAppPatchCategoryArrayOutput { return v.Categories }).(SelfServiceAppPatchCategoryArrayOutput)
}

// - (Required) The name of the patch configuration. (<b>Same as patchName for SINGLE VM)</b>
func (o SelfServiceAppPatchOutput) ConfigName() pulumi.StringOutput {
	return o.ApplyT(func(v *SelfServiceAppPatch) pulumi.StringOutput { return v.ConfigName }).(pulumi.StringOutput)
}

func (o SelfServiceAppPatchOutput) Disks() SelfServiceAppPatchDiskArrayOutput {
	return o.ApplyT(func(v *SelfServiceAppPatch) SelfServiceAppPatchDiskArrayOutput { return v.Disks }).(SelfServiceAppPatchDiskArrayOutput)
}

func (o SelfServiceAppPatchOutput) Nics() SelfServiceAppPatchNicArrayOutput {
	return o.ApplyT(func(v *SelfServiceAppPatch) SelfServiceAppPatchNicArrayOutput { return v.Nics }).(SelfServiceAppPatchNicArrayOutput)
}

// - (Required) The name of the patch to be applied. This is used to identify the action name which needs to be executed to update an application.
func (o SelfServiceAppPatchOutput) PatchName() pulumi.StringOutput {
	return o.ApplyT(func(v *SelfServiceAppPatch) pulumi.StringOutput { return v.PatchName }).(pulumi.StringOutput)
}

// - (Computed) The UUID of the runlog that records the patch operation's execution details.
func (o SelfServiceAppPatchOutput) RunlogUuid() pulumi.StringOutput {
	return o.ApplyT(func(v *SelfServiceAppPatch) pulumi.StringOutput { return v.RunlogUuid }).(pulumi.StringOutput)
}

func (o SelfServiceAppPatchOutput) VmConfigs() SelfServiceAppPatchVmConfigArrayOutput {
	return o.ApplyT(func(v *SelfServiceAppPatch) SelfServiceAppPatchVmConfigArrayOutput { return v.VmConfigs }).(SelfServiceAppPatchVmConfigArrayOutput)
}

type SelfServiceAppPatchArrayOutput struct{ *pulumi.OutputState }

func (SelfServiceAppPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SelfServiceAppPatch)(nil)).Elem()
}

func (o SelfServiceAppPatchArrayOutput) ToSelfServiceAppPatchArrayOutput() SelfServiceAppPatchArrayOutput {
	return o
}

func (o SelfServiceAppPatchArrayOutput) ToSelfServiceAppPatchArrayOutputWithContext(ctx context.Context) SelfServiceAppPatchArrayOutput {
	return o
}

func (o SelfServiceAppPatchArrayOutput) Index(i pulumi.IntInput) SelfServiceAppPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SelfServiceAppPatch {
		return vs[0].([]*SelfServiceAppPatch)[vs[1].(int)]
	}).(SelfServiceAppPatchOutput)
}

type SelfServiceAppPatchMapOutput struct{ *pulumi.OutputState }

func (SelfServiceAppPatchMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SelfServiceAppPatch)(nil)).Elem()
}

func (o SelfServiceAppPatchMapOutput) ToSelfServiceAppPatchMapOutput() SelfServiceAppPatchMapOutput {
	return o
}

func (o SelfServiceAppPatchMapOutput) ToSelfServiceAppPatchMapOutputWithContext(ctx context.Context) SelfServiceAppPatchMapOutput {
	return o
}

func (o SelfServiceAppPatchMapOutput) MapIndex(k pulumi.StringInput) SelfServiceAppPatchOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SelfServiceAppPatch {
		return vs[0].(map[string]*SelfServiceAppPatch)[vs[1].(string)]
	}).(SelfServiceAppPatchOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SelfServiceAppPatchInput)(nil)).Elem(), &SelfServiceAppPatch{})
	pulumi.RegisterInputType(reflect.TypeOf((*SelfServiceAppPatchArrayInput)(nil)).Elem(), SelfServiceAppPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SelfServiceAppPatchMapInput)(nil)).Elem(), SelfServiceAppPatchMap{})
	pulumi.RegisterOutputType(SelfServiceAppPatchOutput{})
	pulumi.RegisterOutputType(SelfServiceAppPatchArrayOutput{})
	pulumi.RegisterOutputType(SelfServiceAppPatchMapOutput{})
}
