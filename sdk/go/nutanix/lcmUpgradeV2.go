// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package nutanix

import (
	"context"
	"reflect"

	"github.com/pierskarsenbarg/pulumi-nutanix/sdk/go/nutanix/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Perform upgrade operation to a specific target version for discovered LCM entity/entities.
//
// ## Example
//
// ```go
// package main
//
// import (
//
//	"github.com/pierskarsenbarg/pulumi-nutanix/sdk/go/nutanix"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// upgrade the entity
//			_, err := nutanix.NewLcmUpgradeV2(ctx, "upgrade", &nutanix.LcmUpgradeV2Args{
//				EntityUpdateSpecs: nutanix.LcmUpgradeV2EntityUpdateSpecArray{
//					&nutanix.LcmUpgradeV2EntityUpdateSpecArgs{
//						EntityUuid: pulumi.String("0c5c9e53-3551-4c5d-b13c-e41c04cbfaf7"),
//						ToVersion:  pulumi.String("4.0.0"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type LcmUpgradeV2 struct {
	pulumi.CustomResourceState

	// List of automated system operations to perform, to avoid precheck failure and let the system restore state after an update is complete. The allowed flag is: - 'powerOffUvms': This allows the system to automatically power off user VMs which cannot be migrated to other hosts and power them on when the update is done. This option can avoid pinned VM precheck failure on the host which needs to enter maintenance mode during the update and allow the update to go through. Items Enum: `POWER_OFF_UVMS`
	AutoHandleFlags pulumi.StringArrayOutput `pulumi:"autoHandleFlags"`
	// List of entity update objects for getting recommendations.
	EntityUpdateSpecs LcmUpgradeV2EntityUpdateSpecArrayOutput `pulumi:"entityUpdateSpecs"`
	// Cluster management server configuration used while updating clusters with ESX or Hyper-V.
	ManagementServer LcmUpgradeV2ManagementServerPtrOutput `pulumi:"managementServer"`
	// Number of seconds LCM waits for the VMs to come up after exiting host maintenance mode. Value in Range [ 60 .. 86400]
	MaxWaitTimeInSecs pulumi.IntPtrOutput `pulumi:"maxWaitTimeInSecs"`
	// List of prechecks to skip. The allowed value is 'powerOffUvms' that skips the pinned VM prechecks. Items Enum: `POWER_OFF_UVMS`
	SkippedPrecheckFlags pulumi.StringArrayOutput `pulumi:"skippedPrecheckFlags"`
	// Cluster uuid on which the resource is present or operation is being performed.
	XClusterId pulumi.StringPtrOutput `pulumi:"xClusterId"`
}

// NewLcmUpgradeV2 registers a new resource with the given unique name, arguments, and options.
func NewLcmUpgradeV2(ctx *pulumi.Context,
	name string, args *LcmUpgradeV2Args, opts ...pulumi.ResourceOption) (*LcmUpgradeV2, error) {
	if args == nil {
		args = &LcmUpgradeV2Args{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource LcmUpgradeV2
	err := ctx.RegisterResource("nutanix:index/lcmUpgradeV2:LcmUpgradeV2", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLcmUpgradeV2 gets an existing LcmUpgradeV2 resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLcmUpgradeV2(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LcmUpgradeV2State, opts ...pulumi.ResourceOption) (*LcmUpgradeV2, error) {
	var resource LcmUpgradeV2
	err := ctx.ReadResource("nutanix:index/lcmUpgradeV2:LcmUpgradeV2", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LcmUpgradeV2 resources.
type lcmUpgradeV2State struct {
	// List of automated system operations to perform, to avoid precheck failure and let the system restore state after an update is complete. The allowed flag is: - 'powerOffUvms': This allows the system to automatically power off user VMs which cannot be migrated to other hosts and power them on when the update is done. This option can avoid pinned VM precheck failure on the host which needs to enter maintenance mode during the update and allow the update to go through. Items Enum: `POWER_OFF_UVMS`
	AutoHandleFlags []string `pulumi:"autoHandleFlags"`
	// List of entity update objects for getting recommendations.
	EntityUpdateSpecs []LcmUpgradeV2EntityUpdateSpec `pulumi:"entityUpdateSpecs"`
	// Cluster management server configuration used while updating clusters with ESX or Hyper-V.
	ManagementServer *LcmUpgradeV2ManagementServer `pulumi:"managementServer"`
	// Number of seconds LCM waits for the VMs to come up after exiting host maintenance mode. Value in Range [ 60 .. 86400]
	MaxWaitTimeInSecs *int `pulumi:"maxWaitTimeInSecs"`
	// List of prechecks to skip. The allowed value is 'powerOffUvms' that skips the pinned VM prechecks. Items Enum: `POWER_OFF_UVMS`
	SkippedPrecheckFlags []string `pulumi:"skippedPrecheckFlags"`
	// Cluster uuid on which the resource is present or operation is being performed.
	XClusterId *string `pulumi:"xClusterId"`
}

type LcmUpgradeV2State struct {
	// List of automated system operations to perform, to avoid precheck failure and let the system restore state after an update is complete. The allowed flag is: - 'powerOffUvms': This allows the system to automatically power off user VMs which cannot be migrated to other hosts and power them on when the update is done. This option can avoid pinned VM precheck failure on the host which needs to enter maintenance mode during the update and allow the update to go through. Items Enum: `POWER_OFF_UVMS`
	AutoHandleFlags pulumi.StringArrayInput
	// List of entity update objects for getting recommendations.
	EntityUpdateSpecs LcmUpgradeV2EntityUpdateSpecArrayInput
	// Cluster management server configuration used while updating clusters with ESX or Hyper-V.
	ManagementServer LcmUpgradeV2ManagementServerPtrInput
	// Number of seconds LCM waits for the VMs to come up after exiting host maintenance mode. Value in Range [ 60 .. 86400]
	MaxWaitTimeInSecs pulumi.IntPtrInput
	// List of prechecks to skip. The allowed value is 'powerOffUvms' that skips the pinned VM prechecks. Items Enum: `POWER_OFF_UVMS`
	SkippedPrecheckFlags pulumi.StringArrayInput
	// Cluster uuid on which the resource is present or operation is being performed.
	XClusterId pulumi.StringPtrInput
}

func (LcmUpgradeV2State) ElementType() reflect.Type {
	return reflect.TypeOf((*lcmUpgradeV2State)(nil)).Elem()
}

type lcmUpgradeV2Args struct {
	// List of automated system operations to perform, to avoid precheck failure and let the system restore state after an update is complete. The allowed flag is: - 'powerOffUvms': This allows the system to automatically power off user VMs which cannot be migrated to other hosts and power them on when the update is done. This option can avoid pinned VM precheck failure on the host which needs to enter maintenance mode during the update and allow the update to go through. Items Enum: `POWER_OFF_UVMS`
	AutoHandleFlags []string `pulumi:"autoHandleFlags"`
	// List of entity update objects for getting recommendations.
	EntityUpdateSpecs []LcmUpgradeV2EntityUpdateSpec `pulumi:"entityUpdateSpecs"`
	// Cluster management server configuration used while updating clusters with ESX or Hyper-V.
	ManagementServer *LcmUpgradeV2ManagementServer `pulumi:"managementServer"`
	// Number of seconds LCM waits for the VMs to come up after exiting host maintenance mode. Value in Range [ 60 .. 86400]
	MaxWaitTimeInSecs *int `pulumi:"maxWaitTimeInSecs"`
	// List of prechecks to skip. The allowed value is 'powerOffUvms' that skips the pinned VM prechecks. Items Enum: `POWER_OFF_UVMS`
	SkippedPrecheckFlags []string `pulumi:"skippedPrecheckFlags"`
	// Cluster uuid on which the resource is present or operation is being performed.
	XClusterId *string `pulumi:"xClusterId"`
}

// The set of arguments for constructing a LcmUpgradeV2 resource.
type LcmUpgradeV2Args struct {
	// List of automated system operations to perform, to avoid precheck failure and let the system restore state after an update is complete. The allowed flag is: - 'powerOffUvms': This allows the system to automatically power off user VMs which cannot be migrated to other hosts and power them on when the update is done. This option can avoid pinned VM precheck failure on the host which needs to enter maintenance mode during the update and allow the update to go through. Items Enum: `POWER_OFF_UVMS`
	AutoHandleFlags pulumi.StringArrayInput
	// List of entity update objects for getting recommendations.
	EntityUpdateSpecs LcmUpgradeV2EntityUpdateSpecArrayInput
	// Cluster management server configuration used while updating clusters with ESX or Hyper-V.
	ManagementServer LcmUpgradeV2ManagementServerPtrInput
	// Number of seconds LCM waits for the VMs to come up after exiting host maintenance mode. Value in Range [ 60 .. 86400]
	MaxWaitTimeInSecs pulumi.IntPtrInput
	// List of prechecks to skip. The allowed value is 'powerOffUvms' that skips the pinned VM prechecks. Items Enum: `POWER_OFF_UVMS`
	SkippedPrecheckFlags pulumi.StringArrayInput
	// Cluster uuid on which the resource is present or operation is being performed.
	XClusterId pulumi.StringPtrInput
}

func (LcmUpgradeV2Args) ElementType() reflect.Type {
	return reflect.TypeOf((*lcmUpgradeV2Args)(nil)).Elem()
}

type LcmUpgradeV2Input interface {
	pulumi.Input

	ToLcmUpgradeV2Output() LcmUpgradeV2Output
	ToLcmUpgradeV2OutputWithContext(ctx context.Context) LcmUpgradeV2Output
}

func (*LcmUpgradeV2) ElementType() reflect.Type {
	return reflect.TypeOf((**LcmUpgradeV2)(nil)).Elem()
}

func (i *LcmUpgradeV2) ToLcmUpgradeV2Output() LcmUpgradeV2Output {
	return i.ToLcmUpgradeV2OutputWithContext(context.Background())
}

func (i *LcmUpgradeV2) ToLcmUpgradeV2OutputWithContext(ctx context.Context) LcmUpgradeV2Output {
	return pulumi.ToOutputWithContext(ctx, i).(LcmUpgradeV2Output)
}

// LcmUpgradeV2ArrayInput is an input type that accepts LcmUpgradeV2Array and LcmUpgradeV2ArrayOutput values.
// You can construct a concrete instance of `LcmUpgradeV2ArrayInput` via:
//
//	LcmUpgradeV2Array{ LcmUpgradeV2Args{...} }
type LcmUpgradeV2ArrayInput interface {
	pulumi.Input

	ToLcmUpgradeV2ArrayOutput() LcmUpgradeV2ArrayOutput
	ToLcmUpgradeV2ArrayOutputWithContext(context.Context) LcmUpgradeV2ArrayOutput
}

type LcmUpgradeV2Array []LcmUpgradeV2Input

func (LcmUpgradeV2Array) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LcmUpgradeV2)(nil)).Elem()
}

func (i LcmUpgradeV2Array) ToLcmUpgradeV2ArrayOutput() LcmUpgradeV2ArrayOutput {
	return i.ToLcmUpgradeV2ArrayOutputWithContext(context.Background())
}

func (i LcmUpgradeV2Array) ToLcmUpgradeV2ArrayOutputWithContext(ctx context.Context) LcmUpgradeV2ArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LcmUpgradeV2ArrayOutput)
}

// LcmUpgradeV2MapInput is an input type that accepts LcmUpgradeV2Map and LcmUpgradeV2MapOutput values.
// You can construct a concrete instance of `LcmUpgradeV2MapInput` via:
//
//	LcmUpgradeV2Map{ "key": LcmUpgradeV2Args{...} }
type LcmUpgradeV2MapInput interface {
	pulumi.Input

	ToLcmUpgradeV2MapOutput() LcmUpgradeV2MapOutput
	ToLcmUpgradeV2MapOutputWithContext(context.Context) LcmUpgradeV2MapOutput
}

type LcmUpgradeV2Map map[string]LcmUpgradeV2Input

func (LcmUpgradeV2Map) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LcmUpgradeV2)(nil)).Elem()
}

func (i LcmUpgradeV2Map) ToLcmUpgradeV2MapOutput() LcmUpgradeV2MapOutput {
	return i.ToLcmUpgradeV2MapOutputWithContext(context.Background())
}

func (i LcmUpgradeV2Map) ToLcmUpgradeV2MapOutputWithContext(ctx context.Context) LcmUpgradeV2MapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LcmUpgradeV2MapOutput)
}

type LcmUpgradeV2Output struct{ *pulumi.OutputState }

func (LcmUpgradeV2Output) ElementType() reflect.Type {
	return reflect.TypeOf((**LcmUpgradeV2)(nil)).Elem()
}

func (o LcmUpgradeV2Output) ToLcmUpgradeV2Output() LcmUpgradeV2Output {
	return o
}

func (o LcmUpgradeV2Output) ToLcmUpgradeV2OutputWithContext(ctx context.Context) LcmUpgradeV2Output {
	return o
}

// List of automated system operations to perform, to avoid precheck failure and let the system restore state after an update is complete. The allowed flag is: - 'powerOffUvms': This allows the system to automatically power off user VMs which cannot be migrated to other hosts and power them on when the update is done. This option can avoid pinned VM precheck failure on the host which needs to enter maintenance mode during the update and allow the update to go through. Items Enum: `POWER_OFF_UVMS`
func (o LcmUpgradeV2Output) AutoHandleFlags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LcmUpgradeV2) pulumi.StringArrayOutput { return v.AutoHandleFlags }).(pulumi.StringArrayOutput)
}

// List of entity update objects for getting recommendations.
func (o LcmUpgradeV2Output) EntityUpdateSpecs() LcmUpgradeV2EntityUpdateSpecArrayOutput {
	return o.ApplyT(func(v *LcmUpgradeV2) LcmUpgradeV2EntityUpdateSpecArrayOutput { return v.EntityUpdateSpecs }).(LcmUpgradeV2EntityUpdateSpecArrayOutput)
}

// Cluster management server configuration used while updating clusters with ESX or Hyper-V.
func (o LcmUpgradeV2Output) ManagementServer() LcmUpgradeV2ManagementServerPtrOutput {
	return o.ApplyT(func(v *LcmUpgradeV2) LcmUpgradeV2ManagementServerPtrOutput { return v.ManagementServer }).(LcmUpgradeV2ManagementServerPtrOutput)
}

// Number of seconds LCM waits for the VMs to come up after exiting host maintenance mode. Value in Range [ 60 .. 86400]
func (o LcmUpgradeV2Output) MaxWaitTimeInSecs() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *LcmUpgradeV2) pulumi.IntPtrOutput { return v.MaxWaitTimeInSecs }).(pulumi.IntPtrOutput)
}

// List of prechecks to skip. The allowed value is 'powerOffUvms' that skips the pinned VM prechecks. Items Enum: `POWER_OFF_UVMS`
func (o LcmUpgradeV2Output) SkippedPrecheckFlags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LcmUpgradeV2) pulumi.StringArrayOutput { return v.SkippedPrecheckFlags }).(pulumi.StringArrayOutput)
}

// Cluster uuid on which the resource is present or operation is being performed.
func (o LcmUpgradeV2Output) XClusterId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LcmUpgradeV2) pulumi.StringPtrOutput { return v.XClusterId }).(pulumi.StringPtrOutput)
}

type LcmUpgradeV2ArrayOutput struct{ *pulumi.OutputState }

func (LcmUpgradeV2ArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LcmUpgradeV2)(nil)).Elem()
}

func (o LcmUpgradeV2ArrayOutput) ToLcmUpgradeV2ArrayOutput() LcmUpgradeV2ArrayOutput {
	return o
}

func (o LcmUpgradeV2ArrayOutput) ToLcmUpgradeV2ArrayOutputWithContext(ctx context.Context) LcmUpgradeV2ArrayOutput {
	return o
}

func (o LcmUpgradeV2ArrayOutput) Index(i pulumi.IntInput) LcmUpgradeV2Output {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *LcmUpgradeV2 {
		return vs[0].([]*LcmUpgradeV2)[vs[1].(int)]
	}).(LcmUpgradeV2Output)
}

type LcmUpgradeV2MapOutput struct{ *pulumi.OutputState }

func (LcmUpgradeV2MapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LcmUpgradeV2)(nil)).Elem()
}

func (o LcmUpgradeV2MapOutput) ToLcmUpgradeV2MapOutput() LcmUpgradeV2MapOutput {
	return o
}

func (o LcmUpgradeV2MapOutput) ToLcmUpgradeV2MapOutputWithContext(ctx context.Context) LcmUpgradeV2MapOutput {
	return o
}

func (o LcmUpgradeV2MapOutput) MapIndex(k pulumi.StringInput) LcmUpgradeV2Output {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *LcmUpgradeV2 {
		return vs[0].(map[string]*LcmUpgradeV2)[vs[1].(string)]
	}).(LcmUpgradeV2Output)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LcmUpgradeV2Input)(nil)).Elem(), &LcmUpgradeV2{})
	pulumi.RegisterInputType(reflect.TypeOf((*LcmUpgradeV2ArrayInput)(nil)).Elem(), LcmUpgradeV2Array{})
	pulumi.RegisterInputType(reflect.TypeOf((*LcmUpgradeV2MapInput)(nil)).Elem(), LcmUpgradeV2Map{})
	pulumi.RegisterOutputType(LcmUpgradeV2Output{})
	pulumi.RegisterOutputType(LcmUpgradeV2ArrayOutput{})
	pulumi.RegisterOutputType(LcmUpgradeV2MapOutput{})
}
