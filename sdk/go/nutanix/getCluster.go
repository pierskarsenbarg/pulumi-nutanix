// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package nutanix

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Describes Clusters
func GetCluster(ctx *pulumi.Context, args *GetClusterArgs, opts ...pulumi.InvokeOption) (*GetClusterResult, error) {
	opts = pkgInvokeDefaultOpts(opts)
	var rv GetClusterResult
	err := ctx.Invoke("nutanix:index/getCluster:getCluster", args, &rv, opts...)
	if err != nil {
		return nil, err
	}
	return &rv, nil
}

// A collection of arguments for invoking getCluster.
type GetClusterArgs struct {
	Categories []GetClusterCategory `pulumi:"categories"`
	ClusterId  *string              `pulumi:"clusterId"`
	Name       *string              `pulumi:"name"`
}

// A collection of values returned by getCluster.
type GetClusterResult struct {
	AnalysisVmEfficiencyMap map[string]string `pulumi:"analysisVmEfficiencyMap"`
	// The API version.
	// * `description`: - A description for image.
	// * `metadata`: - The image kind metadata.
	// * `state`: - The state of the cluster entity.
	// * `gpuDriverVersion`: - GPU driver version.
	// * `clientAuth`: - Client authentication config.
	// * `authorizedPiblicKeyList`: - List of valid ssh keys for the cluster.
	// * `softwareMapNcc`: - Map of software on the cluster with software type as the key.
	// * `softwareMapNos`: - Map of software on the cluster with software type as the key.
	// * `encryptionStatus`: - Cluster encryption status.
	// * `sslKeyType`: - SSL key type. Key types with RSA_2048, ECDSA_256 and ECDSA_384 are supported for key generation and importing.
	// * `sslKeySigningInfo`: - Customer information used in Certificate Signing Request for creating digital certificates.
	// * `sslKeyExpireDatetime`: - UTC date and time in RFC-3339 format when the key expires
	// * `serviceList`: - Array of enabled cluster services. For example, a cluster can function as both AOS and cloud data gateway. - 'AOS': Regular Prism Element - 'PRISM_CENTRAL': Prism Central - 'CLOUD_DATA_GATEWAY': Cloud backup and DR gateway - 'AFS': Cluster for file server - 'WITNESS' : Witness cluster - 'XI_PORTAL': Xi cluster.
	// * `supportedInformationVerbosity`: - Verbosity level settings for populating support information. - 'Nothing': Send nothing - 'Basic': Send basic information - skip core dump and hypervisor stats information - 'BasicPlusCoreDump': Send basic and core dump information - 'All': Send all information (Default value: BASIC_PLUS_CORE_DUMP)
	// * `certificationSigningInfo`: - Customer information used in Certificate Signing Request for creating digital certificates.
	// * `operationMode`: - Cluster operation mode. - 'NORMAL': Cluster is operating normally. - 'READ_ONLY': Cluster is operating in read only mode. - 'STAND_ALONE': Only one node is operational in the cluster. This is valid only for single node or two node clusters. - 'SWITCH_TO_TWO_NODE': Cluster is moving from single node to two node cluster. - 'OVERRIDE': Valid only for single node cluster. If the user wants to run vms on a single node cluster in read only mode, he can set the cluster peration mode to override. Writes will be allowed in override mode.
	// * `caCertificateList`: - Zone name used in value of TZ environment variable.
	// * `enabledFeatureList`: - Array of enabled features.
	// * `isAvailable`: - Indicates if cluster is available to contact. (Readonly)
	// * `build`: - Cluster build details.
	// * `timezone`: - Zone name used in value of TZ environment variable.
	// * `clusterArch`: - Cluster architecture. (Readonly, Options: Options : X86_64 , PPC64LE)
	// * `managementServerList`: - List of cluster management servers. (Readonly)
	// * `masqueradingPort`: - Port used together with masqueradingIp to connect to the cluster.
	// * `masqueradingIp`: - The cluster NAT'd or proxy IP which maps to the cluster local IP.
	// * `externalIp`: - The local IP of cluster visible externally.
	// * `httpProxyList`: - List of proxies to connect to the service centers.
	// * `smtpServerType`: - SMTP Server type.
	// * `smtpServerEmailAddress`: - SMTP Server Email Address.
	// * `smtpServerCredentials`: - SMTP Server Credentials.
	// * `smtpServerProxyTypeList`: - SMTP Server Proxy Type List
	// * `smtpServerAddress`: - SMTP Server Address.
	// * `ntpServerIpList`: - The list of IP addresses or FQDNs of the NTP servers.
	// * `externalSubnet`: - External subnet for cross server communication. The format is IP/netmask. (default 172.16.0.0/255.240.0.0)
	// * `externalDataServicesIp`: - The cluster IP address that provides external entities access to various cluster data services.
	// * `internalSubnet`: - The internal subnet is local to every server - its not visible outside.iSCSI requests generated internally within the appliance (by user VMs or VMFS) are sent to the internal subnet. The format is IP/netmask.
	// * `domainServerNameserver`: -  The IP of the nameserver that can resolve the domain name. Must set when joining the domain.
	// * `domainServerName`: - Joined domain name. In 'put' request, empty name will unjoin the cluster from current domain.
	// * `domainServerCredentials`: - Cluster domain credentials.
	// * `nfsSubnetWhitelist`: - Comma separated list of subnets (of the form 'a.b.c.d/l.m.n.o') that are allowed to send NFS requests to this container. If not specified, the global NFS whitelist will be looked up for access permission. The internal subnet is always automatically considered part of the whitelist, even if the field below does not explicitly specify it. Similarly, all the hypervisor IPs are considered part of the whitelist. Finally, to permit debugging, all of the SVMs local IPs are considered to be implicitly part of the whitelist.
	// * `nameServerIpList`: - The list of IP addresses of the name servers.
	// * `httpProxyWhitelist`: - HTTP proxy whitelist.
	// * `analysisVmEfficiencyMap`: - Map of cluster efficiency which includes numbers of inefficient vms. The value is populated by analytics on PC. (Readonly)
	ApiVersion               string                              `pulumi:"apiVersion"`
	AuthorizedPublicKeyLists []GetClusterAuthorizedPublicKeyList `pulumi:"authorizedPublicKeyLists"`
	Build                    map[string]string                   `pulumi:"build"`
	CaCertificateLists       []GetClusterCaCertificateList       `pulumi:"caCertificateLists"`
	Categories               []GetClusterCategory                `pulumi:"categories"`
	CertificationSigningInfo map[string]string                   `pulumi:"certificationSigningInfo"`
	ClientAuth               map[string]string                   `pulumi:"clientAuth"`
	ClusterArch              string                              `pulumi:"clusterArch"`
	ClusterId                string                              `pulumi:"clusterId"`
	DomainServerCredentials  map[string]string                   `pulumi:"domainServerCredentials"`
	DomainServerName         string                              `pulumi:"domainServerName"`
	DomainServerNameserver   string                              `pulumi:"domainServerNameserver"`
	EnabledFeatureLists      []string                            `pulumi:"enabledFeatureLists"`
	EncryptionStatus         string                              `pulumi:"encryptionStatus"`
	ExternalDataServicesIp   string                              `pulumi:"externalDataServicesIp"`
	ExternalIp               string                              `pulumi:"externalIp"`
	ExternalSubnet           string                              `pulumi:"externalSubnet"`
	GpuDriverVersion         string                              `pulumi:"gpuDriverVersion"`
	HttpProxyLists           []GetClusterHttpProxyList           `pulumi:"httpProxyLists"`
	HttpProxyWhitelists      []GetClusterHttpProxyWhitelist      `pulumi:"httpProxyWhitelists"`
	// The provider-assigned unique ID for this managed resource.
	Id                            string                           `pulumi:"id"`
	InternalSubnet                string                           `pulumi:"internalSubnet"`
	IsAvailable                   bool                             `pulumi:"isAvailable"`
	ManagementServerLists         []GetClusterManagementServerList `pulumi:"managementServerLists"`
	MasqueradingIp                string                           `pulumi:"masqueradingIp"`
	MasqueradingPort              int                              `pulumi:"masqueradingPort"`
	Metadata                      map[string]string                `pulumi:"metadata"`
	Name                          string                           `pulumi:"name"`
	NameServerIpLists             []string                         `pulumi:"nameServerIpLists"`
	NfsSubnetWhitelists           []string                         `pulumi:"nfsSubnetWhitelists"`
	Nodes                         []GetClusterNode                 `pulumi:"nodes"`
	NtpServerIpLists              []string                         `pulumi:"ntpServerIpLists"`
	OperationMode                 string                           `pulumi:"operationMode"`
	OwnerReference                map[string]string                `pulumi:"ownerReference"`
	ProjectReference              map[string]string                `pulumi:"projectReference"`
	ServiceLists                  []string                         `pulumi:"serviceLists"`
	SmtpServerAddress             map[string]string                `pulumi:"smtpServerAddress"`
	SmtpServerCredentials         map[string]string                `pulumi:"smtpServerCredentials"`
	SmtpServerEmailAddress        string                           `pulumi:"smtpServerEmailAddress"`
	SmtpServerProxyTypeLists      []string                         `pulumi:"smtpServerProxyTypeLists"`
	SmtpServerType                string                           `pulumi:"smtpServerType"`
	SoftwareMapNcc                map[string]interface{}           `pulumi:"softwareMapNcc"`
	SoftwareMapNos                map[string]interface{}           `pulumi:"softwareMapNos"`
	SslKeyExpireDatetime          string                           `pulumi:"sslKeyExpireDatetime"`
	SslKeyName                    string                           `pulumi:"sslKeyName"`
	SslKeySigningInfo             map[string]string                `pulumi:"sslKeySigningInfo"`
	SslKeyType                    string                           `pulumi:"sslKeyType"`
	State                         string                           `pulumi:"state"`
	SupportedInformationVerbosity string                           `pulumi:"supportedInformationVerbosity"`
	Timezone                      string                           `pulumi:"timezone"`
}

func GetClusterOutput(ctx *pulumi.Context, args GetClusterOutputArgs, opts ...pulumi.InvokeOption) GetClusterResultOutput {
	return pulumi.ToOutputWithContext(context.Background(), args).
		ApplyT(func(v interface{}) (GetClusterResult, error) {
			args := v.(GetClusterArgs)
			r, err := GetCluster(ctx, &args, opts...)
			var s GetClusterResult
			if r != nil {
				s = *r
			}
			return s, err
		}).(GetClusterResultOutput)
}

// A collection of arguments for invoking getCluster.
type GetClusterOutputArgs struct {
	Categories GetClusterCategoryArrayInput `pulumi:"categories"`
	ClusterId  pulumi.StringPtrInput        `pulumi:"clusterId"`
	Name       pulumi.StringPtrInput        `pulumi:"name"`
}

func (GetClusterOutputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetClusterArgs)(nil)).Elem()
}

// A collection of values returned by getCluster.
type GetClusterResultOutput struct{ *pulumi.OutputState }

func (GetClusterResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetClusterResult)(nil)).Elem()
}

func (o GetClusterResultOutput) ToGetClusterResultOutput() GetClusterResultOutput {
	return o
}

func (o GetClusterResultOutput) ToGetClusterResultOutputWithContext(ctx context.Context) GetClusterResultOutput {
	return o
}

func (o GetClusterResultOutput) AnalysisVmEfficiencyMap() pulumi.StringMapOutput {
	return o.ApplyT(func(v GetClusterResult) map[string]string { return v.AnalysisVmEfficiencyMap }).(pulumi.StringMapOutput)
}

// The API version.
// * `description`: - A description for image.
// * `metadata`: - The image kind metadata.
// * `state`: - The state of the cluster entity.
// * `gpuDriverVersion`: - GPU driver version.
// * `clientAuth`: - Client authentication config.
// * `authorizedPiblicKeyList`: - List of valid ssh keys for the cluster.
// * `softwareMapNcc`: - Map of software on the cluster with software type as the key.
// * `softwareMapNos`: - Map of software on the cluster with software type as the key.
// * `encryptionStatus`: - Cluster encryption status.
// * `sslKeyType`: - SSL key type. Key types with RSA_2048, ECDSA_256 and ECDSA_384 are supported for key generation and importing.
// * `sslKeySigningInfo`: - Customer information used in Certificate Signing Request for creating digital certificates.
// * `sslKeyExpireDatetime`: - UTC date and time in RFC-3339 format when the key expires
// * `serviceList`: - Array of enabled cluster services. For example, a cluster can function as both AOS and cloud data gateway. - 'AOS': Regular Prism Element - 'PRISM_CENTRAL': Prism Central - 'CLOUD_DATA_GATEWAY': Cloud backup and DR gateway - 'AFS': Cluster for file server - 'WITNESS' : Witness cluster - 'XI_PORTAL': Xi cluster.
// * `supportedInformationVerbosity`: - Verbosity level settings for populating support information. - 'Nothing': Send nothing - 'Basic': Send basic information - skip core dump and hypervisor stats information - 'BasicPlusCoreDump': Send basic and core dump information - 'All': Send all information (Default value: BASIC_PLUS_CORE_DUMP)
// * `certificationSigningInfo`: - Customer information used in Certificate Signing Request for creating digital certificates.
// * `operationMode`: - Cluster operation mode. - 'NORMAL': Cluster is operating normally. - 'READ_ONLY': Cluster is operating in read only mode. - 'STAND_ALONE': Only one node is operational in the cluster. This is valid only for single node or two node clusters. - 'SWITCH_TO_TWO_NODE': Cluster is moving from single node to two node cluster. - 'OVERRIDE': Valid only for single node cluster. If the user wants to run vms on a single node cluster in read only mode, he can set the cluster peration mode to override. Writes will be allowed in override mode.
// * `caCertificateList`: - Zone name used in value of TZ environment variable.
// * `enabledFeatureList`: - Array of enabled features.
// * `isAvailable`: - Indicates if cluster is available to contact. (Readonly)
// * `build`: - Cluster build details.
// * `timezone`: - Zone name used in value of TZ environment variable.
// * `clusterArch`: - Cluster architecture. (Readonly, Options: Options : X86_64 , PPC64LE)
// * `managementServerList`: - List of cluster management servers. (Readonly)
// * `masqueradingPort`: - Port used together with masqueradingIp to connect to the cluster.
// * `masqueradingIp`: - The cluster NAT'd or proxy IP which maps to the cluster local IP.
// * `externalIp`: - The local IP of cluster visible externally.
// * `httpProxyList`: - List of proxies to connect to the service centers.
// * `smtpServerType`: - SMTP Server type.
// * `smtpServerEmailAddress`: - SMTP Server Email Address.
// * `smtpServerCredentials`: - SMTP Server Credentials.
// * `smtpServerProxyTypeList`: - SMTP Server Proxy Type List
// * `smtpServerAddress`: - SMTP Server Address.
// * `ntpServerIpList`: - The list of IP addresses or FQDNs of the NTP servers.
// * `externalSubnet`: - External subnet for cross server communication. The format is IP/netmask. (default 172.16.0.0/255.240.0.0)
// * `externalDataServicesIp`: - The cluster IP address that provides external entities access to various cluster data services.
// * `internalSubnet`: - The internal subnet is local to every server - its not visible outside.iSCSI requests generated internally within the appliance (by user VMs or VMFS) are sent to the internal subnet. The format is IP/netmask.
// * `domainServerNameserver`: -  The IP of the nameserver that can resolve the domain name. Must set when joining the domain.
// * `domainServerName`: - Joined domain name. In 'put' request, empty name will unjoin the cluster from current domain.
// * `domainServerCredentials`: - Cluster domain credentials.
// * `nfsSubnetWhitelist`: - Comma separated list of subnets (of the form 'a.b.c.d/l.m.n.o') that are allowed to send NFS requests to this container. If not specified, the global NFS whitelist will be looked up for access permission. The internal subnet is always automatically considered part of the whitelist, even if the field below does not explicitly specify it. Similarly, all the hypervisor IPs are considered part of the whitelist. Finally, to permit debugging, all of the SVMs local IPs are considered to be implicitly part of the whitelist.
// * `nameServerIpList`: - The list of IP addresses of the name servers.
// * `httpProxyWhitelist`: - HTTP proxy whitelist.
// * `analysisVmEfficiencyMap`: - Map of cluster efficiency which includes numbers of inefficient vms. The value is populated by analytics on PC. (Readonly)
func (o GetClusterResultOutput) ApiVersion() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.ApiVersion }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) AuthorizedPublicKeyLists() GetClusterAuthorizedPublicKeyListArrayOutput {
	return o.ApplyT(func(v GetClusterResult) []GetClusterAuthorizedPublicKeyList { return v.AuthorizedPublicKeyLists }).(GetClusterAuthorizedPublicKeyListArrayOutput)
}

func (o GetClusterResultOutput) Build() pulumi.StringMapOutput {
	return o.ApplyT(func(v GetClusterResult) map[string]string { return v.Build }).(pulumi.StringMapOutput)
}

func (o GetClusterResultOutput) CaCertificateLists() GetClusterCaCertificateListArrayOutput {
	return o.ApplyT(func(v GetClusterResult) []GetClusterCaCertificateList { return v.CaCertificateLists }).(GetClusterCaCertificateListArrayOutput)
}

func (o GetClusterResultOutput) Categories() GetClusterCategoryArrayOutput {
	return o.ApplyT(func(v GetClusterResult) []GetClusterCategory { return v.Categories }).(GetClusterCategoryArrayOutput)
}

func (o GetClusterResultOutput) CertificationSigningInfo() pulumi.StringMapOutput {
	return o.ApplyT(func(v GetClusterResult) map[string]string { return v.CertificationSigningInfo }).(pulumi.StringMapOutput)
}

func (o GetClusterResultOutput) ClientAuth() pulumi.StringMapOutput {
	return o.ApplyT(func(v GetClusterResult) map[string]string { return v.ClientAuth }).(pulumi.StringMapOutput)
}

func (o GetClusterResultOutput) ClusterArch() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.ClusterArch }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) ClusterId() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.ClusterId }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) DomainServerCredentials() pulumi.StringMapOutput {
	return o.ApplyT(func(v GetClusterResult) map[string]string { return v.DomainServerCredentials }).(pulumi.StringMapOutput)
}

func (o GetClusterResultOutput) DomainServerName() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.DomainServerName }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) DomainServerNameserver() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.DomainServerNameserver }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) EnabledFeatureLists() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetClusterResult) []string { return v.EnabledFeatureLists }).(pulumi.StringArrayOutput)
}

func (o GetClusterResultOutput) EncryptionStatus() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.EncryptionStatus }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) ExternalDataServicesIp() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.ExternalDataServicesIp }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) ExternalIp() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.ExternalIp }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) ExternalSubnet() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.ExternalSubnet }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) GpuDriverVersion() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.GpuDriverVersion }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) HttpProxyLists() GetClusterHttpProxyListArrayOutput {
	return o.ApplyT(func(v GetClusterResult) []GetClusterHttpProxyList { return v.HttpProxyLists }).(GetClusterHttpProxyListArrayOutput)
}

func (o GetClusterResultOutput) HttpProxyWhitelists() GetClusterHttpProxyWhitelistArrayOutput {
	return o.ApplyT(func(v GetClusterResult) []GetClusterHttpProxyWhitelist { return v.HttpProxyWhitelists }).(GetClusterHttpProxyWhitelistArrayOutput)
}

// The provider-assigned unique ID for this managed resource.
func (o GetClusterResultOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.Id }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) InternalSubnet() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.InternalSubnet }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) IsAvailable() pulumi.BoolOutput {
	return o.ApplyT(func(v GetClusterResult) bool { return v.IsAvailable }).(pulumi.BoolOutput)
}

func (o GetClusterResultOutput) ManagementServerLists() GetClusterManagementServerListArrayOutput {
	return o.ApplyT(func(v GetClusterResult) []GetClusterManagementServerList { return v.ManagementServerLists }).(GetClusterManagementServerListArrayOutput)
}

func (o GetClusterResultOutput) MasqueradingIp() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.MasqueradingIp }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) MasqueradingPort() pulumi.IntOutput {
	return o.ApplyT(func(v GetClusterResult) int { return v.MasqueradingPort }).(pulumi.IntOutput)
}

func (o GetClusterResultOutput) Metadata() pulumi.StringMapOutput {
	return o.ApplyT(func(v GetClusterResult) map[string]string { return v.Metadata }).(pulumi.StringMapOutput)
}

func (o GetClusterResultOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.Name }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) NameServerIpLists() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetClusterResult) []string { return v.NameServerIpLists }).(pulumi.StringArrayOutput)
}

func (o GetClusterResultOutput) NfsSubnetWhitelists() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetClusterResult) []string { return v.NfsSubnetWhitelists }).(pulumi.StringArrayOutput)
}

func (o GetClusterResultOutput) Nodes() GetClusterNodeArrayOutput {
	return o.ApplyT(func(v GetClusterResult) []GetClusterNode { return v.Nodes }).(GetClusterNodeArrayOutput)
}

func (o GetClusterResultOutput) NtpServerIpLists() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetClusterResult) []string { return v.NtpServerIpLists }).(pulumi.StringArrayOutput)
}

func (o GetClusterResultOutput) OperationMode() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.OperationMode }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) OwnerReference() pulumi.StringMapOutput {
	return o.ApplyT(func(v GetClusterResult) map[string]string { return v.OwnerReference }).(pulumi.StringMapOutput)
}

func (o GetClusterResultOutput) ProjectReference() pulumi.StringMapOutput {
	return o.ApplyT(func(v GetClusterResult) map[string]string { return v.ProjectReference }).(pulumi.StringMapOutput)
}

func (o GetClusterResultOutput) ServiceLists() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetClusterResult) []string { return v.ServiceLists }).(pulumi.StringArrayOutput)
}

func (o GetClusterResultOutput) SmtpServerAddress() pulumi.StringMapOutput {
	return o.ApplyT(func(v GetClusterResult) map[string]string { return v.SmtpServerAddress }).(pulumi.StringMapOutput)
}

func (o GetClusterResultOutput) SmtpServerCredentials() pulumi.StringMapOutput {
	return o.ApplyT(func(v GetClusterResult) map[string]string { return v.SmtpServerCredentials }).(pulumi.StringMapOutput)
}

func (o GetClusterResultOutput) SmtpServerEmailAddress() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.SmtpServerEmailAddress }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) SmtpServerProxyTypeLists() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetClusterResult) []string { return v.SmtpServerProxyTypeLists }).(pulumi.StringArrayOutput)
}

func (o GetClusterResultOutput) SmtpServerType() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.SmtpServerType }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) SoftwareMapNcc() pulumi.MapOutput {
	return o.ApplyT(func(v GetClusterResult) map[string]interface{} { return v.SoftwareMapNcc }).(pulumi.MapOutput)
}

func (o GetClusterResultOutput) SoftwareMapNos() pulumi.MapOutput {
	return o.ApplyT(func(v GetClusterResult) map[string]interface{} { return v.SoftwareMapNos }).(pulumi.MapOutput)
}

func (o GetClusterResultOutput) SslKeyExpireDatetime() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.SslKeyExpireDatetime }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) SslKeyName() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.SslKeyName }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) SslKeySigningInfo() pulumi.StringMapOutput {
	return o.ApplyT(func(v GetClusterResult) map[string]string { return v.SslKeySigningInfo }).(pulumi.StringMapOutput)
}

func (o GetClusterResultOutput) SslKeyType() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.SslKeyType }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.State }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) SupportedInformationVerbosity() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.SupportedInformationVerbosity }).(pulumi.StringOutput)
}

func (o GetClusterResultOutput) Timezone() pulumi.StringOutput {
	return o.ApplyT(func(v GetClusterResult) string { return v.Timezone }).(pulumi.StringOutput)
}

func init() {
	pulumi.RegisterOutputType(GetClusterResultOutput{})
}
