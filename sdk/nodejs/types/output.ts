// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AccessControlPolicyCategory {
    /**
     * - (Optional) Name of the Access Control Policy.
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface AccessControlPolicyContextFilterList {
    /**
     * A list of Entity filter expressions.
     */
    entityFilterExpressionLists: outputs.AccessControlPolicyContextFilterListEntityFilterExpressionList[];
    /**
     * - (Optional) Filter the scope of an Access Control Policy.
     */
    scopeFilterExpressionLists: outputs.AccessControlPolicyContextFilterListScopeFilterExpressionList[];
}

export interface AccessControlPolicyContextFilterListEntityFilterExpressionList {
    /**
     * - (Optional)  The LHS of the filter expression - the entity type.
     */
    leftHandSideEntityType: string;
    /**
     * - (Required) The operator in the filter expression.
     */
    operator: string;
    /**
     * - (Required) The right hand side (RHS) of an scope expression.
     */
    rightHandSide: outputs.AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSide;
}

export interface AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSide {
    /**
     * - (Optional) The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategories;
    /**
     * - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
     */
    collection: string;
    /**
     * - (Optional) The explicit list of UUIDs for the given kind.
     */
    uuidLists: string[];
}

export interface AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategories {
    /**
     * - (Optional) Name of the Access Control Policy.
     */
    name: string;
    /**
     * - value of the key.
     */
    values: string[];
}

export interface AccessControlPolicyContextFilterListScopeFilterExpressionList {
    /**
     * - (Optional)  The LHS of the filter expression - the scope type.
     */
    leftHandSide: string;
    /**
     * - (Required) The operator of the filter expression.
     */
    operator: string;
    /**
     * - (Required) The right hand side (RHS) of an scope expression.
     */
    rightHandSide: outputs.AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSide;
}

export interface AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSide {
    /**
     * - (Optional) The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategories;
    /**
     * - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
     */
    collection: string;
    /**
     * - (Optional) The explicit list of UUIDs for the given kind.
     */
    uuidLists: string[];
}

export interface AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategories {
    /**
     * - (Optional) Name of the Access Control Policy.
     */
    name: string;
    /**
     * - value of the key.
     */
    values: string[];
}

export interface AccessControlPolicyOwnerReference {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind?: string;
    /**
     * - (Optional) Name of the Access Control Policy.
     */
    name?: string;
    /**
     * - the UUID(Required).
     */
    uuid?: string;
}

export interface AccessControlPolicyRoleReference {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Optional) Name of the Access Control Policy.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface AccessControlPolicyUserGroupReferenceList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Optional) Name of the Access Control Policy.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface AccessControlPolicyUserReferenceList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Optional) Name of the Access Control Policy.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface AddressGroupIpAddressBlockList {
    /**
     * - (Required) IP of the address block
     */
    ip: string;
    /**
     * - (Required) Prefix length of address block in int
     *
     * See detailed information in [Nutanix Address Groups](https://www.nutanix.dev/api_references/prism-central-v3/#/5ccef53a546a4-create-a-new-address-group).
     */
    prefixLength: number;
}

export interface FoundationCentralImageClusterClusterStatus {
    aggregatePercentComplete: number;
    clusterCreationStarted: boolean;
    clusterProgressDetails: outputs.FoundationCentralImageClusterClusterStatusClusterProgressDetail[];
    currentFoundationIp: string;
    foundationSessionId: string;
    imagingStopped: boolean;
    intentPickedUp: boolean;
    nodeProgressDetails: outputs.FoundationCentralImageClusterClusterStatusNodeProgressDetail[];
}

export interface FoundationCentralImageClusterClusterStatusClusterProgressDetail {
    /**
     * Name of the cluster.
     */
    clusterName: string;
    messageLists: string[];
    percentComplete: number;
    status: string;
}

export interface FoundationCentralImageClusterClusterStatusNodeProgressDetail {
    /**
     * UUID of the node.
     */
    imagedNodeUuid: string;
    imagingStopped: boolean;
    intentPickedUp: boolean;
    messageLists: string[];
    percentComplete: number;
    status: string;
}

export interface FoundationCentralImageClusterCommonNetworkSettings {
    /**
     * List of dns servers for the cvms in the cluster.
     */
    cvmDnsServers: string[];
    /**
     * List of ntp servers for the cvms in the cluster.
     */
    cvmNtpServers: string[];
    /**
     * List of dns servers for the hypervisors in the cluster.
     */
    hypervisorDnsServers: string[];
    /**
     * List of ntp servers for the hypervisors in the cluster.
     */
    hypervisorNtpServers: string[];
}

export interface FoundationCentralImageClusterFoundationInitConfig {
    blocks: outputs.FoundationCentralImageClusterFoundationInitConfigBlock[];
    clusters: outputs.FoundationCentralImageClusterFoundationInitConfigCluster[];
    /**
     * Gateway of the cvm.
     */
    cvmGateway: string;
    /**
     * Netmask of the cvm.
     */
    cvmNetmask: string;
    dnsServers: string;
    /**
     * Product key for hyperv isos. Required only if the hypervisor type is hyperv and product key is mandatory (ex: for volume license).
     */
    hypervProductKey: string;
    /**
     * SKU of hyperv to be installed if hypervisorType is hyperv.
     */
    hypervSku: string;
    /**
     * Gateway of the hypervisor.
     */
    hypervisorGateway: string;
    hypervisorIsoUrl: {[key: string]: string};
    hypervisorIsos: outputs.FoundationCentralImageClusterFoundationInitConfigHypervisorIso[];
    /**
     * Netmask of the hypervisor.
     */
    hypervisorNetmask: string;
    /**
     * Gateway of the ipmi.
     */
    ipmiGateway: string;
    /**
     * Netmask of the ipmi.
     */
    ipmiNetmask: string;
    nosPackageUrls: outputs.FoundationCentralImageClusterFoundationInitConfigNosPackageUrl[];
}

export interface FoundationCentralImageClusterFoundationInitConfigBlock {
    blockId: string;
    nodes: outputs.FoundationCentralImageClusterFoundationInitConfigBlockNode[];
}

export interface FoundationCentralImageClusterFoundationInitConfigBlockNode {
    /**
     * IP address to be set for the cvm on the node.
     */
    cvmIp: string;
    /**
     * Vlan tag of the cvm, if the cvm is on a vlan.
     */
    cvmVlanId: number;
    fcImagedNodeUuid: string;
    /**
     * Hardware attributes override json for the node.
     */
    hardwareAttributesOverride: {[key: string]: string};
    hypervisor: string;
    /**
     * Name to be set for the hypervisor host.
     */
    hypervisorHostname: string;
    /**
     * IP address to be set for the hypervisor on the node.
     */
    hypervisorIp: string;
    /**
     * True, if the node should be imaged, False, otherwise.
     */
    imageNow: boolean;
    /**
     * IP address to be set for the ipmi of the node.
     */
    ipmiIp: string;
    ipv6Address: string;
    nodePosition: string;
    nodeSerial: string;
}

export interface FoundationCentralImageClusterFoundationInitConfigCluster {
    /**
     * External management ip of the cluster.
     */
    clusterExternalIp: string;
    clusterInitNow: boolean;
    clusterInitSuccessful: boolean;
    clusterMembers: string[];
    /**
     * Name of the cluster.
     */
    clusterName: string;
    /**
     * List of dns servers for the cvms in the cluster.
     */
    cvmDnsServers: string;
    /**
     * List of ntp servers for the cvms in the cluster.
     */
    cvmNtpServers: string;
    /**
     * Redundancy factor of the cluster.
     */
    redundancyFactor: number;
    /**
     * Timezone to be set on the cluster.
     */
    timezone: string;
}

export interface FoundationCentralImageClusterFoundationInitConfigHypervisorIso {
    /**
     * Type of hypervisor to be installed. Must be one of {kvm, esx, hyperv}.
     */
    hypervisorType: string;
    /**
     * sha256sum of the hypervisor iso.
     */
    sha256sum: string;
    /**
     * URL to download hypervisor iso. Required only if imaging is needed.
     */
    url: string;
}

export interface FoundationCentralImageClusterFoundationInitConfigNosPackageUrl {
    /**
     * sha256sum of the hypervisor iso.
     */
    sha256sum: string;
    /**
     * URL to download hypervisor iso. Required only if imaging is needed.
     */
    url: string;
}

export interface FoundationCentralImageClusterHypervisorIsoDetails {
    /**
     * Product key for hyperv isos. Required only if the hypervisor type is hyperv and product key is mandatory (ex: for volume license).
     */
    hypervProductKey: string;
    /**
     * SKU of hyperv to be installed if hypervisorType is hyperv.
     */
    hypervSku: string;
    /**
     * sha256sum of the hypervisor iso.
     */
    sha256sum: string;
    /**
     * URL to download hypervisor iso. Required only if imaging is needed.
     */
    url?: string;
}

export interface FoundationCentralImageClusterNodeList {
    /**
     * Gateway of the cvm.
     */
    cvmGateway: string;
    /**
     * IP address to be set for the cvm on the node.
     */
    cvmIp: string;
    /**
     * Netmask of the cvm.
     */
    cvmNetmask?: string;
    /**
     * Amount of memory to be assigned for the cvm.
     */
    cvmRamGb?: number;
    /**
     * Vlan tag of the cvm, if the cvm is on a vlan.
     */
    cvmVlanId: number;
    /**
     * Hardware attributes override json for the node.
     */
    hardwareAttributesOverride: {[key: string]: any};
    /**
     * Gateway of the hypervisor.
     */
    hypervisorGateway: string;
    /**
     * Name to be set for the hypervisor host.
     */
    hypervisorHostname: string;
    /**
     * IP address to be set for the hypervisor on the node.
     */
    hypervisorIp: string;
    /**
     * Netmask of the hypervisor.
     */
    hypervisorNetmask: string;
    /**
     * Type of hypervisor to be installed. Must be one of {kvm, esx, hyperv}.
     */
    hypervisorType?: string;
    /**
     * True, if the node should be imaged, False, otherwise.
     */
    imageNow: boolean;
    /**
     * UUID of the node.
     */
    imagedNodeUuid: string;
    /**
     * Gateway of the ipmi.
     */
    ipmiGateway: string;
    /**
     * IP address to be set for the ipmi of the node.
     */
    ipmiIp: string;
    /**
     * Netmask of the ipmi.
     */
    ipmiNetmask?: string;
    /**
     * Passthrough RDMA nic to CVM if possible, default to false.
     */
    rdmaPassthrough?: boolean;
    /**
     * Decides whether to use the existing network settings for the node. If True, the existing network settings of the node will be used during cluster creation. If False, then client must provide new network settings. If all nodes are booted in phoenix, this field is, by default, considered to be False.
     */
    useExistingNetworkSettings?: boolean;
}

export interface FoundationImageNodesBlock {
    /**
     * - Block ID.
     */
    blockId?: string;
    nodes: outputs.FoundationImageNodesBlockNode[];
}

export interface FoundationImageNodesBlockNode {
    /**
     * - (Required if node is lacp configured) slow or fast if lacp if being used at the switch
     */
    bondLacpRate?: string;
    /**
     * - (Required if node is capable) dynamic if using LACP, static for LAG
     */
    bondMode?: string;
    /**
     * - MAC Addresses of NICs in a team/bond
     */
    bondUplinks?: string;
    /**
     * - ID of cluster.
     */
    clusterId?: string;
    /**
     * - Current CVM vlan tag. 0 Value with remove vlan tag.
     */
    currentCvmVlanTag?: number;
    /**
     * - CVM current network interface.
     */
    currentNetworkInterface?: string;
    /**
     * - RAM capacity of CVM in GB.
     */
    cvmGbRam?: number;
    cvmIp?: string;
    /**
     * - Number of CVM vcpus.
     */
    cvmNumVcpus?: number;
    /**
     * - use "vmInstaller" to enable CVM imaging from standalone.
     */
    deviceHint?: string;
    /**
     * - serial of boot device to be excluded (used by NX G6 platforms)
     */
    exludeBootSerial?: string;
    hypervisor?: string;
    /**
     * - (Required) Hypervisor Hostname.
     */
    hypervisorHostname: string;
    /**
     * - (Required) Hypervisor IP address.
     */
    hypervisorIp: string;
    /**
     * - Imaging delay.
     */
    imageDelay?: number;
    /**
     * - (Optional, Default = true) If the node should be imaged now.
     */
    imageNow?: boolean;
    imageSuccessful?: boolean;
    /**
     * - Whether IPMI should be configured.
     */
    ipmiConfigureNow?: boolean;
    /**
     * - (Required incase using IPMI based imaging either here or outside blocks) IPMI gateway for this node
     */
    ipmiGateway?: string;
    /**
     * - (Required) IPMI IP address.
     */
    ipmiIp?: string;
    /**
     * - IPMI MAC address.
     */
    ipmiMac?: string;
    /**
     * - (Required incase using IPMI based imaging either here or outside blocks) IPMI netmask for this node
     */
    ipmiNetmask?: string;
    /**
     * - (Required incase using IPMI based imaging either here or outside blocks) IPMI username
     */
    ipmiPassword?: string;
    /**
     * - (Required incase using IPMI based imaging either here or outside blocks) IPMI password
     */
    ipmiUser?: string;
    /**
     * - (Required when deviceHint = "vmInstaller" for imaging using node's existing cvm for imaging) IPV6 address.
     */
    ipv6Address?: string;
    /**
     * - (Required when deviceHint = "vmInstaller" for imaging using node's existing cvm for imaging) ipv6 interface.
     */
    ipv6Interface?: string;
    /**
     * - relocate bootbank files to make space for phoenix files.
     */
    mitigateLowBootSpace?: boolean;
    /**
     * - (Required) Position of the node in the block.
     */
    nodePosition: string;
    /**
     * - serial number of the node.
     */
    nodeSerial?: string;
    /**
     * - mac address of nic to be used for rdma
     */
    rdmaMacAddr?: string;
    /**
     * - (Required if node is capable) passthru RDMA nic to CVM if possible, default to false
     */
    rdmaPassthrough?: boolean;
    /**
     * - UCSM Managed mode.
     */
    ucsmManagedMode?: string;
    /**
     * - UCSM node serial.
     */
    ucsmNodeSerial?: string;
    /**
     * - Object of UCSM parameters.
     * * `ucsm_params.native_vlan` :- If the vlan is native.
     * * `ucsm_params.keep_ucsm_settings` :- Whether UCSM settings should be kept.
     * * `ucsm_params.mac_pool` :- Mac address pool.
     * * `ucsm_params.vlan_name` :- Name of vlan.
     */
    ucsmParams?: outputs.FoundationImageNodesBlockNodeUcsmParams;
    vswitches?: outputs.FoundationImageNodesBlockNodeVswitch[];
}

export interface FoundationImageNodesBlockNodeUcsmParams {
    keepUcsmSettings?: boolean;
    macPool?: string;
    nativeVlan?: boolean;
    vlanName?: string;
}

export interface FoundationImageNodesBlockNodeVswitch {
    /**
     * - (Required if node is capable) dynamic if using LACP, static for LAG
     */
    bondMode?: string;
    lacp?: string;
    mtu?: number;
    name?: string;
    otherConfigs?: string[];
    uplinks?: string[];
}

export interface FoundationImageNodesCluster {
    /**
     * - Backplane netmask.
     */
    backplaneNetmask?: string;
    /**
     * - Backplane subnet address.
     */
    backplaneSubnet?: string;
    /**
     * - Backplane vlan.
     */
    backplaneVlan?: string;
    /**
     * - External IP of the cluster.
     */
    clusterExternalIp?: string;
    /**
     * - (Optional, Default = true) If cluster should be created.
     */
    clusterInitNow?: boolean;
    /**
     * - If cluster initialization was successful.
     */
    clusterInitSuccessful?: boolean;
    /**
     * - (Required) Members in the cluster.
     */
    clusterMembers: string[];
    /**
     * - (Required) Name of the cluster.
     */
    clusterName: string;
    /**
     * - DNS servers of CVM.
     */
    cvmDnsServers?: string;
    /**
     * - NTP servers of CVM.
     */
    cvmNtpServers?: string;
    /**
     * - If network segmentation should be enabled.
     */
    enableNs?: boolean;
    /**
     * - NTP servers of hypervisor.
     */
    hypervisorNtpServers?: string;
    /**
     * - (Required) Cluster Redundancy Factor.
     */
    redundancyFactor: number;
    /**
     * - If it is a single node cluster.
     */
    singleNodeCluster?: boolean;
    /**
     * - Set timezone for every CVM
     */
    timezone?: string;
}

export interface FoundationImageNodesClusterUrl {
    /**
     * - (Required) Name of the cluster.
     */
    clusterName: string;
    clusterUrl: string;
}

export interface FoundationImageNodesEosMetadata {
    /**
     * - arrya of account names
     */
    accountNames?: string[];
    /**
     * - Id of the Eos config uploaded in foundation GUI.
     */
    configId?: string;
    /**
     * - Email address of the user who downloaded Eos config.
     */
    email?: string;
}

export interface FoundationImageNodesFcSettings {
    /**
     * - Foundation Central metadata which will be transferred to the newly imaged node.
     * * `fc_metadata.fc_ip` :- IP address of foundation central.
     * * `fc_metadata.api_key` :- apiKey which the node uses to register itself with foundation central.
     */
    fcMetadata: outputs.FoundationImageNodesFcSettingsFcMetadata;
    /**
     * - If this attribute is set to True, FC workflow will be invoked.
     */
    foundationCentral: boolean;
}

export interface FoundationImageNodesFcSettingsFcMetadata {
    apiKey: string;
    fcIp: string;
}

export interface FoundationImageNodesHypervisorIso {
    /**
     * - Details of hypervisor ISO of type esx.
     */
    esx?: outputs.FoundationImageNodesHypervisorIsoEsx;
    /**
     * - Details of hypervisor ISO of type hyperv.
     */
    hyperv?: outputs.FoundationImageNodesHypervisorIsoHyperv;
    /**
     * - Details of hypervisor ISO of type kvm.
     */
    kvm?: outputs.FoundationImageNodesHypervisorIsoKvm;
    /**
     * - Details of hypervisor ISO of type xen.
     */
    xen?: outputs.FoundationImageNodesHypervisorIsoXen;
}

export interface FoundationImageNodesHypervisorIsoEsx {
    /**
     * - (Required) Filename of hypervisor ISO.
     */
    checksum: string;
    /**
     * - (Required) Checksum for ISO file.
     */
    filename: string;
}

export interface FoundationImageNodesHypervisorIsoHyperv {
    /**
     * - (Required) Filename of hypervisor ISO.
     */
    checksum: string;
    /**
     * - (Required) Checksum for ISO file.
     */
    filename: string;
}

export interface FoundationImageNodesHypervisorIsoKvm {
    /**
     * - (Required) Filename of hypervisor ISO.
     */
    checksum: string;
    /**
     * - (Required) Checksum for ISO file.
     */
    filename: string;
}

export interface FoundationImageNodesHypervisorIsoXen {
    /**
     * - (Required) Filename of hypervisor ISO.
     */
    checksum: string;
    /**
     * - (Required) Checksum for ISO file.
     */
    filename: string;
}

export interface FoundationImageNodesTests {
    /**
     * - Whether NCC checks should run.
     */
    runNcc?: boolean;
    /**
     * - Whether system checks should run.
     */
    runSyscheck?: boolean;
}

export interface FoundationIpmiConfigBlock {
    /**
     * - (Optional) Block Id
     */
    blockId?: string;
    /**
     * - (Required) array of nodes for ipmi config.
     */
    nodes: outputs.FoundationIpmiConfigBlockNode[];
}

export interface FoundationIpmiConfigBlockNode {
    /**
     * - (Required) Whether IPMI should be configured. Should be kept true to configure
     */
    ipmiConfigureNow: boolean;
    /**
     * - Whether IPMI was successfully configured.
     */
    ipmiConfigureSuccessful: boolean;
    /**
     * - IPMI IP address.
     */
    ipmiIp: string;
    /**
     * - (Required) IPMI mac address.
     */
    ipmiMac: string;
    /**
     * - IPMI configuration status message if any.
     */
    ipmiMessage: string;
}

export interface GetAccessControlPoliciesEntity {
    accessControlPolicyId: string;
    /**
     * The version of the API.
     */
    apiVersion: string;
    /**
     * - The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.GetAccessControlPoliciesEntityCategory[];
    contextFilterLists: outputs.GetAccessControlPoliciesEntityContextFilterList[];
    /**
     * - The description of the Access Control Policy.
     */
    description: string;
    /**
     * - The Access Control Policy kind metadata.
     */
    metadata: {[key: string]: string};
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - The reference to a user.
     */
    ownerReference: {[key: string]: string};
    /**
     * - The reference to a project.
     */
    projectReference: {[key: string]: string};
    /**
     * - The reference to a role.
     */
    roleReferences: outputs.GetAccessControlPoliciesEntityRoleReference[];
    /**
     * - The state of the Access Control Policy.
     */
    state: string;
    /**
     * - The User group(s) being assigned a given role.
     */
    userGroupReferenceLists: outputs.GetAccessControlPoliciesEntityUserGroupReferenceList[];
    /**
     * - The User(s) being assigned a given role.
     */
    userReferenceLists: outputs.GetAccessControlPoliciesEntityUserReferenceList[];
}

export interface GetAccessControlPoliciesEntityCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetAccessControlPoliciesEntityContextFilterList {
    /**
     * A list of Entity filter expressions.
     */
    entityFilterExpressionLists: outputs.GetAccessControlPoliciesEntityContextFilterListEntityFilterExpressionList[];
    /**
     * - The device ID which is used to uniquely identify this particular disk.
     */
    scopeFilterExpressionLists: outputs.GetAccessControlPoliciesEntityContextFilterListScopeFilterExpressionList[];
}

export interface GetAccessControlPoliciesEntityContextFilterListEntityFilterExpressionList {
    /**
     * -  The LHS of the filter expression - the entity type.
     */
    leftHandSideEntityType: string;
    /**
     * - The operator in the filter expression.
     */
    operator: string;
    /**
     * - The right hand side (RHS) of an scope expression.
     */
    rightHandSides: outputs.GetAccessControlPoliciesEntityContextFilterListEntityFilterExpressionListRightHandSide[];
}

export interface GetAccessControlPoliciesEntityContextFilterListEntityFilterExpressionListRightHandSide {
    /**
     * - The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.GetAccessControlPoliciesEntityContextFilterListEntityFilterExpressionListRightHandSideCategory[];
    /**
     * -  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
     */
    collection: string;
    /**
     * - The explicit list of UUIDs for the given kind.
     */
    uuidLists: string[];
}

export interface GetAccessControlPoliciesEntityContextFilterListEntityFilterExpressionListRightHandSideCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    values: string[];
}

export interface GetAccessControlPoliciesEntityContextFilterListScopeFilterExpressionList {
    /**
     * -  The LHS of the filter expression - the scope type.
     */
    leftHandSide: string;
    /**
     * - The operator in the filter expression.
     */
    operator: string;
    /**
     * - The right hand side (RHS) of an scope expression.
     */
    rightHandSides: outputs.GetAccessControlPoliciesEntityContextFilterListScopeFilterExpressionListRightHandSide[];
}

export interface GetAccessControlPoliciesEntityContextFilterListScopeFilterExpressionListRightHandSide {
    /**
     * - The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.GetAccessControlPoliciesEntityContextFilterListScopeFilterExpressionListRightHandSideCategory[];
    /**
     * -  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
     */
    collection: string;
    /**
     * - The explicit list of UUIDs for the given kind.
     */
    uuidLists: string[];
}

export interface GetAccessControlPoliciesEntityContextFilterListScopeFilterExpressionListRightHandSideCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    values: string[];
}

export interface GetAccessControlPoliciesEntityRoleReference {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetAccessControlPoliciesEntityUserGroupReferenceList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetAccessControlPoliciesEntityUserReferenceList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetAccessControlPoliciesMetadata {
    filter: string;
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetAccessControlPolicyCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetAccessControlPolicyContextFilterList {
    /**
     * A list of Entity filter expressions.
     */
    entityFilterExpressionLists: outputs.GetAccessControlPolicyContextFilterListEntityFilterExpressionList[];
    /**
     * - The device ID which is used to uniquely identify this particular disk.
     */
    scopeFilterExpressionLists: outputs.GetAccessControlPolicyContextFilterListScopeFilterExpressionList[];
}

export interface GetAccessControlPolicyContextFilterListEntityFilterExpressionList {
    /**
     * -  The LHS of the filter expression - the entity type.
     */
    leftHandSideEntityType: string;
    /**
     * - The operator in the filter expression.
     */
    operator: string;
    /**
     * - The right hand side (RHS) of an scope expression.
     */
    rightHandSides: outputs.GetAccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSide[];
}

export interface GetAccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSide {
    /**
     * - The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.GetAccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategory[];
    /**
     * -  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
     */
    collection: string;
    /**
     * - The explicit list of UUIDs for the given kind.
     */
    uuidLists: string[];
}

export interface GetAccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    values: string[];
}

export interface GetAccessControlPolicyContextFilterListScopeFilterExpressionList {
    /**
     * -  The LHS of the filter expression - the scope type.
     */
    leftHandSide: string;
    /**
     * - The operator in the filter expression.
     */
    operator: string;
    /**
     * - The right hand side (RHS) of an scope expression.
     */
    rightHandSides: outputs.GetAccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSide[];
}

export interface GetAccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSide {
    /**
     * - The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.GetAccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategory[];
    /**
     * -  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
     */
    collection: string;
    /**
     * - The explicit list of UUIDs for the given kind.
     */
    uuidLists: string[];
}

export interface GetAccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    values: string[];
}

export interface GetAccessControlPolicyRoleReference {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetAccessControlPolicyUserGroupReferenceList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetAccessControlPolicyUserReferenceList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetAddressGroupIpAddressBlockList {
    /**
     * - (ReadOnly) IP of the address block
     */
    ip: string;
    /**
     * - (ReadOnly) Prefix length of address block in int
     */
    prefixLength: number;
}

export interface GetAddressGroupsEntity {
    /**
     * Information about address_group
     */
    addressGroups: outputs.GetAddressGroupsEntityAddressGroup[];
    /**
     * List of associated policies to address group
     */
    associatedPoliciesLists: outputs.GetAddressGroupsEntityAssociatedPoliciesList[];
    /**
     * - (ReadOnly) UUID of associated policy
     */
    uuid: string;
}

export interface GetAddressGroupsEntityAddressGroup {
    /**
     * - (ReadOnly) Address Group string
     */
    addressGroupString: string;
    /**
     * - (ReadOnly) Description of the address group
     */
    description: string;
    /**
     * - (ReadOnly) list of IP address blocks with their prefix length
     */
    ipAddressBlockLists: outputs.GetAddressGroupsEntityAddressGroupIpAddressBlockList[];
    /**
     * - (ReadOnly) Name of associated policy
     */
    name: string;
}

export interface GetAddressGroupsEntityAddressGroupIpAddressBlockList {
    /**
     * - (ReadOnly) IP of the address block
     */
    ip: string;
    /**
     * - (ReadOnly) Prefix length of address block in int
     */
    prefixLength: number;
}

export interface GetAddressGroupsEntityAssociatedPoliciesList {
    kind: string;
    /**
     * - (ReadOnly) Name of associated policy
     */
    name: string;
    /**
     * - (ReadOnly) UUID of associated policy
     */
    uuid: string;
}

export interface GetAddressGroupsMetadata {
    /**
     * (Optional) Filter in FIQL Syntax
     */
    filter: string;
    kind: string;
    /**
     * (Optional) Integer
     */
    length: number;
    /**
     * (Optional) Integer
     */
    offset: number;
    /**
     * (Optional) attribute to sort
     */
    sortAttribute: string;
    /**
     * (Optional) order of sorting
     */
    sortOrder: string;
}

export interface GetAssertHelperCheck {
    condition: boolean;
    errorMessage: string;
}

export interface GetClusterAuthorizedPublicKeyList {
    key: string;
    /**
     * Represents the name of cluster
     */
    name: string;
}

export interface GetClusterCaCertificateList {
    caName: string;
    certificate: string;
}

export interface GetClusterCategory {
    /**
     * - the key name.
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetClusterHttpProxyList {
    address: {[key: string]: string};
    credentials: {[key: string]: string};
    proxyTypeLists: string[];
}

export interface GetClusterHttpProxyWhitelist {
    target: string;
    targetType: string;
}

export interface GetClusterManagementServerList {
    drsEnabled: boolean;
    ip: string;
    statusLists: string[];
    type: string;
}

export interface GetClusterNode {
    ip: string;
    type: string;
    version: string;
}

export interface GetClustersEntity {
    /**
     * - Map of cluster efficiency which includes numbers of inefficient vms. The value is populated by analytics on PC. (Readonly)
     */
    analysisVmEfficiencyMap: {[key: string]: string};
    /**
     * The API version.
     */
    apiVersion: string;
    authorizedPublicKeyLists: outputs.GetClustersEntityAuthorizedPublicKeyList[];
    /**
     * - Cluster build details.
     */
    build: {[key: string]: string};
    /**
     * - Zone name used in value of TZ environment variable.
     */
    caCertificateLists: outputs.GetClustersEntityCaCertificateList[];
    /**
     * - Categories for the image.
     */
    categories: outputs.GetClustersEntityCategory[];
    /**
     * - Customer information used in Certificate Signing Request for creating digital certificates.
     */
    certificationSigningInfo: {[key: string]: string};
    /**
     * - Client authentication config.
     */
    clientAuth: {[key: string]: string};
    /**
     * - Cluster architecture. (Readonly, Options: Options : X86_64 , PPC64LE)
     */
    clusterArch: string;
    /**
     * - Cluster domain credentials.
     */
    domainServerCredentials: {[key: string]: string};
    /**
     * - Joined domain name. In 'put' request, empty name will unjoin the cluster from current domain.
     */
    domainServerName: string;
    /**
     * -  The IP of the nameserver that can resolve the domain name. Must set when joining the domain.
     */
    domainServerNameserver: string;
    /**
     * - Array of enabled features.
     */
    enabledFeatureLists: string[];
    /**
     * - Cluster encryption status.
     */
    encryptionStatus: string;
    /**
     * - The cluster IP address that provides external entities access to various cluster data services.
     */
    externalDataServicesIp: string;
    /**
     * - The local IP of cluster visible externally.
     */
    externalIp: string;
    /**
     * - External subnet for cross server communication. The format is IP/netmask. (default 172.16.0.0/255.240.0.0)
     */
    externalSubnet: string;
    /**
     * - GPU driver version.
     */
    gpuDriverVersion: string;
    /**
     * - List of proxies to connect to the service centers.
     */
    httpProxyLists: outputs.GetClustersEntityHttpProxyList[];
    /**
     * - HTTP proxy whitelist.
     */
    httpProxyWhitelists: outputs.GetClustersEntityHttpProxyWhitelist[];
    /**
     * - The internal subnet is local to every server - its not visible outside.iSCSI requests generated internally within the appliance (by user VMs or VMFS) are sent to the internal subnet. The format is IP/netmask.
     */
    internalSubnet: string;
    /**
     * - Indicates if cluster is available to contact. (Readonly)
     */
    isAvailable: boolean;
    /**
     * - List of cluster management servers. (Readonly)
     */
    managementServerLists: outputs.GetClustersEntityManagementServerList[];
    /**
     * - The cluster NAT'd or proxy IP which maps to the cluster local IP.
     */
    masqueradingIp: string;
    /**
     * - Port used together with masqueradingIp to connect to the cluster.
     */
    masqueradingPort: number;
    /**
     * - The image kind metadata.
     */
    metadata: {[key: string]: string};
    /**
     * -  The name for the image.
     */
    name: string;
    /**
     * - The list of IP addresses of the name servers.
     */
    nameServerIpLists: string[];
    /**
     * - Comma separated list of subnets (of the form 'a.b.c.d/l.m.n.o') that are allowed to send NFS requests to this container. If not specified, the global NFS whitelist will be looked up for access permission. The internal subnet is always automatically considered part of the whitelist, even if the field below does not explicitly specify it. Similarly, all the hypervisor IPs are considered part of the whitelist. Finally, to permit debugging, all of the SVMs local IPs are considered to be implicitly part of the whitelist.
     */
    nfsSubnetWhitelists: string[];
    nodes: outputs.GetClustersEntityNode[];
    /**
     * - The list of IP addresses or FQDNs of the NTP servers.
     */
    ntpServerIpLists: string[];
    /**
     * - Cluster operation mode. - 'NORMAL': Cluster is operating normally. - 'READ_ONLY': Cluster is operating in read only mode. - 'STAND_ALONE': Only one node is operational in the cluster. This is valid only for single node or two node clusters. - 'SWITCH_TO_TWO_NODE': Cluster is moving from single node to two node cluster. - 'OVERRIDE': Valid only for single node cluster. If the user wants to run vms on a single node cluster in read only mode, he can set the cluster peration mode to override. Writes will be allowed in override mode.
     */
    operationMode: string;
    /**
     * - The reference to a user.
     */
    ownerReference: {[key: string]: string};
    /**
     * - The reference to a project.
     */
    projectReference: {[key: string]: string};
    /**
     * - Array of enabled cluster services. For example, a cluster can function as both AOS and cloud data gateway. - 'AOS': Regular Prism Element - 'PRISM_CENTRAL': Prism Central - 'CLOUD_DATA_GATEWAY': Cloud backup and DR gateway - 'AFS': Cluster for file server - 'WITNESS' : Witness cluster - 'XI_PORTAL': Xi cluster.
     */
    serviceLists: string[];
    /**
     * - SMTP Server Address.
     */
    smtpServerAddress: {[key: string]: string};
    /**
     * - SMTP Server Credentials.
     */
    smtpServerCredentials: {[key: string]: string};
    /**
     * - SMTP Server Email Address.
     */
    smtpServerEmailAddress: string;
    /**
     * - SMTP Server Proxy Type List
     */
    smtpServerProxyTypeLists: string[];
    /**
     * - SMTP Server type.
     */
    smtpServerType: string;
    /**
     * - Map of software on the cluster with software type as the key.
     */
    softwareMapNcc: {[key: string]: any};
    /**
     * - Map of software on the cluster with software type as the key.
     */
    softwareMapNos: {[key: string]: any};
    /**
     * - UTC date and time in RFC-3339 format when the key expires
     */
    sslKeyExpireDatetime: string;
    sslKeyName: string;
    /**
     * - Customer information used in Certificate Signing Request for creating digital certificates.
     */
    sslKeySigningInfo: {[key: string]: string};
    /**
     * - SSL key type. Key types with RSA_2048, ECDSA_256 and ECDSA_384 are supported for key generation and importing.
     */
    sslKeyType: string;
    /**
     * - The state of the cluster entity.
     */
    state: string;
    /**
     * - Verbosity level settings for populating support information. - 'Nothing': Send nothing - 'Basic': Send basic information - skip core dump and hypervisor stats information - 'BasicPlusCoreDump': Send basic and core dump information - 'All': Send all information (Default value: BASIC_PLUS_CORE_DUMP)
     */
    supportedInformationVerbosity: string;
    /**
     * - Zone name used in value of TZ environment variable.
     */
    timezone: string;
}

export interface GetClustersEntityAuthorizedPublicKeyList {
    key: string;
    /**
     * -  The name for the image.
     */
    name: string;
}

export interface GetClustersEntityCaCertificateList {
    caName: string;
    certificate: string;
}

export interface GetClustersEntityCategory {
    /**
     * - the key name.
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetClustersEntityHttpProxyList {
    address: {[key: string]: string};
    credentials: {[key: string]: string};
    proxyTypeLists: string[];
}

export interface GetClustersEntityHttpProxyWhitelist {
    target: string;
    targetType: string;
}

export interface GetClustersEntityManagementServerList {
    drsEnabled: boolean;
    ip: string;
    statusLists: string[];
    type: string;
}

export interface GetClustersEntityNode {
    ip: string;
    type: string;
    version: string;
}

export interface GetFloatingIpSpec {
    /**
     * Floating IP allocation status.
     */
    resources: outputs.GetFloatingIpSpecResource[];
}

export interface GetFloatingIpSpecResource {
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a vm_nic
     */
    vmNicReference: {[key: string]: string};
    /**
     * The reference to a vpc
     */
    vpcReference: {[key: string]: string};
}

export interface GetFloatingIpStatus {
    /**
     * Execution Context of Floating IP.
     */
    executionContexts: outputs.GetFloatingIpStatusExecutionContext[];
    /**
     * - the name.
     */
    name: string;
    /**
     * Floating IP allocation status.
     */
    resources: outputs.GetFloatingIpStatusResource[];
    /**
     * The state of the floating_ip.
     */
    state: string;
}

export interface GetFloatingIpStatusExecutionContext {
    taskUuids: string[];
}

export interface GetFloatingIpStatusResource {
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * Private IP with which the floating IP is associated.
     */
    floatingIp: string;
    /**
     * The reference to a vm_nic
     */
    vmNicReference: {[key: string]: string};
    /**
     * The reference to a vpc
     */
    vpcReference: {[key: string]: string};
}

export interface GetFloatingIpsEntity {
    /**
     * - The floatingIp kind metadata.
     */
    metadata: {[key: string]: string};
    /**
     * Floating IP spec
     */
    specs: outputs.GetFloatingIpsEntitySpec[];
    /**
     * Floating IP output status
     */
    statuses: outputs.GetFloatingIpsEntityStatus[];
}

export interface GetFloatingIpsEntitySpec {
    /**
     * Floating IP allocation status.
     */
    resources: outputs.GetFloatingIpsEntitySpecResource[];
}

export interface GetFloatingIpsEntitySpecResource {
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a vm_nic
     */
    vmNicReference: {[key: string]: string};
    /**
     * The reference to a vpc
     */
    vpcReference: {[key: string]: string};
}

export interface GetFloatingIpsEntityStatus {
    /**
     * Execution Context of Floating IP.
     */
    executionContexts: outputs.GetFloatingIpsEntityStatusExecutionContext[];
    /**
     * - the name.
     */
    name: string;
    /**
     * Floating IP allocation status.
     */
    resources: outputs.GetFloatingIpsEntityStatusResource[];
    /**
     * The state of the floating_ip.
     */
    state: string;
}

export interface GetFloatingIpsEntityStatusExecutionContext {
    taskUuids: string[];
}

export interface GetFloatingIpsEntityStatusResource {
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * Private IP with which the floating IP is associated.
     */
    floatingIp: string;
    /**
     * The reference to a vm_nic
     */
    vmNicReference: {[key: string]: string};
    /**
     * The reference to a vpc
     */
    vpcReference: {[key: string]: string};
}

export interface GetFloatingIpsMetadata {
    filter: string;
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
    totalMatches: number;
}

export interface GetFoundationCentralClusterDetailsClusterStatus {
    /**
     * Overall progress percentage including imaging and cluster creation.
     */
    aggregatePercentComplete: number;
    /**
     * Denotes whether cluster creation has started in a phoenix workflow. For foundation workflows, this field will be same as intent_picked_up.
     */
    clusterCreationStarted: boolean;
    /**
     * Denotes the progress status of cluster creation.
     */
    clusterProgressDetails: outputs.GetFoundationCentralClusterDetailsClusterStatusClusterProgressDetail[];
    /**
     * Current IP address of the coordinating foundation node.
     */
    currentFoundationIp: string;
    /**
     * Foundation session id for cluster creation.
     */
    foundationSessionId: string;
    /**
     * Describes whether imaging has stopped. True indicates that process has stopped. False indicates that process is still going on. This field will only be used by phoenix nodes to update FC.
     */
    imagingStopped: boolean;
    /**
     * Denotes whether the remote nodes has picked up the cluster creation intent.
     */
    intentPickedUp: boolean;
    /**
     * List of progress details of each node.
     */
    nodeProgressDetails: outputs.GetFoundationCentralClusterDetailsClusterStatusNodeProgressDetail[];
}

export interface GetFoundationCentralClusterDetailsClusterStatusClusterProgressDetail {
    /**
     * Cluster name.
     */
    clusterName: string;
    /**
     * List of messages for the client based on process state.
     */
    messageLists: string[];
    /**
     * Percent completion of cluster creation process.
     */
    percentComplete: number;
    /**
     * Current status of cluster creation process.
     */
    status: string;
}

export interface GetFoundationCentralClusterDetailsClusterStatusNodeProgressDetail {
    /**
     * UUID of the node.
     */
    imagedNodeUuid: string;
    /**
     * Describes whether imaging has stopped. True indicates that process has stopped. False indicates that process is still going on. This field will only be used by phoenix nodes to update FC.
     */
    imagingStopped: boolean;
    /**
     * Denotes whether the remote nodes has picked up the cluster creation intent.
     */
    intentPickedUp: boolean;
    /**
     * List of messages for the client based on process state.
     */
    messageLists: string[];
    /**
     * Percent completion of cluster creation process.
     */
    percentComplete: number;
    /**
     * Current status of cluster creation process.
     */
    status: string;
}

export interface GetFoundationCentralClusterDetailsCommonNetworkSettings {
    /**
     * List of dns servers for the cvms in the cluster.
     */
    cvmDnsServers: string[];
    /**
     * List of ntp servers for the cvms in the cluster.
     */
    cvmNtpServers: string[];
    /**
     * List of dns servers for the hypervisors in the cluster.
     */
    hypervisorDnsServers: string[];
    /**
     * List of ntp servers for the hypervisors in the cluster.
     */
    hypervisorNtpServers: string[];
}

export interface GetFoundationCentralClusterDetailsFoundationInitConfig {
    blocks: outputs.GetFoundationCentralClusterDetailsFoundationInitConfigBlock[];
    clusters: outputs.GetFoundationCentralClusterDetailsFoundationInitConfigCluster[];
    cvmGateway: string;
    cvmNetmask: string;
    dnsServers: string;
    hypervProductKey: string;
    hypervSku: string;
    hypervisorGateway: string;
    hypervisorIsoUrl: {[key: string]: string};
    hypervisorIsos: outputs.GetFoundationCentralClusterDetailsFoundationInitConfigHypervisorIso[];
    hypervisorNetmask: string;
    ipmiGateway: string;
    ipmiNetmask: string;
    nosPackageUrls: outputs.GetFoundationCentralClusterDetailsFoundationInitConfigNosPackageUrl[];
}

export interface GetFoundationCentralClusterDetailsFoundationInitConfigBlock {
    blockId: string;
    nodes: outputs.GetFoundationCentralClusterDetailsFoundationInitConfigBlockNode[];
}

export interface GetFoundationCentralClusterDetailsFoundationInitConfigBlockNode {
    cvmIp: string;
    cvmVlanId: number;
    fcImagedNodeUuid: string;
    hardwareAttributesOverride: {[key: string]: string};
    hypervisor: string;
    hypervisorHostname: string;
    hypervisorIp: string;
    imageNow: boolean;
    ipmiIp: string;
    ipv6Address: string;
    nodePosition: string;
    nodeSerial: string;
}

export interface GetFoundationCentralClusterDetailsFoundationInitConfigCluster {
    /**
     * External management ip of the cluster.
     */
    clusterExternalIp: string;
    clusterInitNow: boolean;
    clusterInitSuccessful: boolean;
    clusterMembers: string[];
    /**
     * Cluster name.
     */
    clusterName: string;
    /**
     * List of dns servers for the cvms in the cluster.
     */
    cvmDnsServers: string;
    /**
     * List of ntp servers for the cvms in the cluster.
     */
    cvmNtpServers: string;
    /**
     * Redundancy factor of the cluster.
     */
    redundancyFactor: number;
    timezone: string;
}

export interface GetFoundationCentralClusterDetailsFoundationInitConfigHypervisorIso {
    hypervisorType: string;
    sha256sum: string;
    url: string;
}

export interface GetFoundationCentralClusterDetailsFoundationInitConfigNosPackageUrl {
    sha256sum: string;
    url: string;
}

export interface GetFoundationCentralImagedClustersListFilters {
    /**
     * True if the cluster creation request is archived, False otherwise
     */
    archived?: boolean;
}

export interface GetFoundationCentralImagedClustersListImagedCluster {
    /**
     * True if the cluster creation request is archived, False otherwise
     */
    archived: boolean;
    /**
     * External management ip of the cluster.
     */
    clusterExternalIp: string;
    /**
     * Cluster name.
     */
    clusterName: string;
    /**
     * Number of nodes in the cluster.
     */
    clusterSize: number;
    /**
     * Details of cluster creation process.
     */
    clusterStatus: outputs.GetFoundationCentralImagedClustersListImagedClusterClusterStatus;
    /**
     * Common network settings across the nodes in the cluster.
     */
    commonNetworkSettings: outputs.GetFoundationCentralImagedClustersListImagedClusterCommonNetworkSettings;
    /**
     * Time when the cluster creation request was received in Foundation Central.
     */
    createdTimestamp: string;
    /**
     * Current time of Foundation Central.
     */
    currentTime: string;
    /**
     * True if the cluster is destroyed, False otherwise
     */
    destroyed: boolean;
    /**
     * Json config used by Foundation to create the cluster.
     */
    foundationInitConfigs: outputs.GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfig[];
    /**
     * UUID of the first node coordinating cluster creation.
     */
    foundationInitNodeUuid: string;
    /**
     * UUID of the cluster.
     */
    imagedClusterUuid: string;
    /**
     * List of UUIDs of imaged nodes.
     */
    imagedNodeUuidLists: string[];
    /**
     * Redundancy factor of the cluster.
     */
    redundancyFactor?: number;
    /**
     * Number of storage only nodes in the cluster. AHV iso for storage node will be taken from aos package.
     */
    storageNodeCount: number;
    /**
     * If imaging and cluster creation is coordinated by Foundation, value will be FOUNDATION_WF. If the nodes are in phoenix, value will be PHOENIX_WF.
     */
    workflowType: string;
}

export interface GetFoundationCentralImagedClustersListImagedClusterClusterStatus {
    /**
     * Overall progress percentage including imaging and cluster creation.
     */
    aggregatePercentComplete: number;
    /**
     * Denotes whether cluster creation has started in a phoenix workflow. For foundation workflows, this field will be same as intent_picked_up.
     */
    clusterCreationStarted: boolean;
    /**
     * Denotes the progress status of cluster creation.
     */
    clusterProgressDetails: outputs.GetFoundationCentralImagedClustersListImagedClusterClusterStatusClusterProgressDetail[];
    /**
     * Current IP address of the coordinating foundation node.
     */
    currentFoundationIp: string;
    /**
     * Foundation session id for cluster creation.
     */
    foundationSessionId: string;
    /**
     * Describes whether imaging has stopped. True indicates that process has stopped. False indicates that process is still going on. This field will only be used by phoenix nodes to update FC.
     */
    imagingStopped: boolean;
    /**
     * Denotes whether the remote nodes has picked up the cluster creation intent.
     */
    intentPickedUp: boolean;
    /**
     * List of progress details of each node.
     */
    nodeProgressDetails: outputs.GetFoundationCentralImagedClustersListImagedClusterClusterStatusNodeProgressDetail[];
}

export interface GetFoundationCentralImagedClustersListImagedClusterClusterStatusClusterProgressDetail {
    /**
     * Cluster name.
     */
    clusterName: string;
    /**
     * List of messages for the client based on process state.
     */
    messageLists: string[];
    /**
     * Percent completion of cluster creation process.
     */
    percentComplete: number;
    /**
     * Current status of cluster creation process.
     */
    status: string;
}

export interface GetFoundationCentralImagedClustersListImagedClusterClusterStatusNodeProgressDetail {
    /**
     * UUID of the node.
     */
    imagedNodeUuid: string;
    /**
     * Describes whether imaging has stopped. True indicates that process has stopped. False indicates that process is still going on. This field will only be used by phoenix nodes to update FC.
     */
    imagingStopped: boolean;
    /**
     * Denotes whether the remote nodes has picked up the cluster creation intent.
     */
    intentPickedUp: boolean;
    /**
     * List of messages for the client based on process state.
     */
    messageLists: string[];
    /**
     * Percent completion of cluster creation process.
     */
    percentComplete: number;
    /**
     * Current status of cluster creation process.
     */
    status: string;
}

export interface GetFoundationCentralImagedClustersListImagedClusterCommonNetworkSettings {
    /**
     * List of dns servers for the cvms in the cluster.
     */
    cvmDnsServers: string[];
    /**
     * List of ntp servers for the cvms in the cluster.
     */
    cvmNtpServers: string[];
    /**
     * List of dns servers for the hypervisors in the cluster.
     */
    hypervisorDnsServers: string[];
    /**
     * List of ntp servers for the hypervisors in the cluster.
     */
    hypervisorNtpServers: string[];
}

export interface GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfig {
    blocks: outputs.GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigBlock[];
    clusters: outputs.GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigCluster[];
    cvmGateway: string;
    cvmNetmask: string;
    dnsServers: string;
    hypervProductKey: string;
    hypervSku: string;
    hypervisorGateway: string;
    hypervisorIsoUrl: {[key: string]: string};
    hypervisorIsos: outputs.GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigHypervisorIso[];
    hypervisorNetmask: string;
    ipmiGateway: string;
    ipmiNetmask: string;
    nosPackageUrls: outputs.GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigNosPackageUrl[];
}

export interface GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigBlock {
    blockId: string;
    nodes: outputs.GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigBlockNode[];
}

export interface GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigBlockNode {
    cvmIp: string;
    cvmVlanId: number;
    fcImagedNodeUuid: string;
    hardwareAttributesOverride: {[key: string]: string};
    hypervisor: string;
    hypervisorHostname: string;
    hypervisorIp: string;
    imageNow: boolean;
    ipmiIp: string;
    ipv6Address: string;
    nodePosition: string;
    nodeSerial: string;
}

export interface GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigCluster {
    /**
     * External management ip of the cluster.
     */
    clusterExternalIp: string;
    clusterInitNow: boolean;
    clusterInitSuccessful: boolean;
    clusterMembers: string[];
    /**
     * Cluster name.
     */
    clusterName: string;
    /**
     * List of dns servers for the cvms in the cluster.
     */
    cvmDnsServers: string;
    /**
     * List of ntp servers for the cvms in the cluster.
     */
    cvmNtpServers: string;
    /**
     * Redundancy factor of the cluster.
     */
    redundancyFactor: number;
    timezone: string;
}

export interface GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigHypervisorIso {
    hypervisorType: string;
    sha256sum: string;
    url: string;
}

export interface GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigNosPackageUrl {
    sha256sum: string;
    url: string;
}

export interface GetFoundationCentralImagedClustersListMetadata {
    /**
     * The number of records retrieved.
     */
    length: number;
    /**
     * Offset from the start of the object list.
     */
    offset: number;
    /**
     * Total matches found.
     */
    totalMatches: number;
}

export interface GetFoundationCentralImagedNodesListFilters {
    /**
     * Specifies whether the node is discovering, available or unavailable for cluster creation.
     */
    nodeState?: string;
}

export interface GetFoundationCentralImagedNodesListImagedNode {
    /**
     * AOS version currently installed on the node.
     */
    aosVersion: string;
    /**
     * API key used to register the node.
     */
    apiKeyUuid: string;
    /**
     * Specifies whether the node is available for cluster creation.
     */
    available: boolean;
    /**
     * Serial number of the block to which the node belongs.
     */
    blockSerial: string;
    /**
     * Time when the node was discovered in Foundation Central.
     */
    createdTimestamp: string;
    /**
     * Current time of Foundation Central.
     */
    currentTime: string;
    /**
     * gateway of the cvm.
     */
    cvmGateway: string;
    /**
     * IP address of the cvm.
     */
    cvmIp: string;
    /**
     * IPv6 address of the cvm.
     */
    cvmIpv6: string;
    /**
     * netmask of the cvm.
     */
    cvmNetmask: string;
    /**
     * Denotes whether the CVM is up or not on this node.
     */
    cvmUp: boolean;
    /**
     * Node UUID from the node's cvm.
     */
    cvmUuid: string;
    /**
     * Vlan tag of the cvm, if the cvm is on a vlan.
     */
    cvmVlanId: number;
    /**
     * Foundation version installed on the node.
     */
    foundationVersion: string;
    /**
     * Hardware attributes json of the node.
     */
    hardwareAttributes: {[key: string]: any};
    /**
     * gateway of the hypervisor.
     */
    hypervisorGateway: string;
    /**
     * Name of the hypervisor host.
     */
    hypervisorHostname: string;
    /**
     * IP address of the hypervisor.
     */
    hypervisorIp: string;
    /**
     * netmask of the hypervisor.
     */
    hypervisorNetmask: string;
    /**
     * Hypervisor type currently installed on the node. Must be one of {kvm, esx, hyperv}.
     */
    hypervisorType: string;
    /**
     * Version of the hypervisor currently installed on the node.
     */
    hypervisorVersion: string;
    /**
     * UUID of the cluster to which the node belongs, if any.
     */
    imagedClusterUuid: string;
    /**
     * UUID of the node.
     */
    imagedNodeUuid: string;
    /**
     * gateway of the ipmi.
     */
    ipmiGateway: string;
    /**
     * IP address of the ipmi.
     */
    ipmiIp: string;
    /**
     * netmask of the ipmi.
     */
    ipmiNetmask: string;
    /**
     * Name of the cvm interface having ipv6 address.
     */
    ipv6Interface: string;
    /**
     * List of timestamps when the node has sent heartbeats to Foundation Central.
     */
    latestHbTsLists: string[];
    /**
     * Model of the node.
     */
    model: string;
    /**
     * Position of the node in the block.
     */
    nodePosition: string;
    /**
     * Serial number of the node.
     */
    nodeSerial: string;
    /**
     * Specifies whether the node is discovering, available or unavailable for cluster creation.
     */
    nodeState: string;
    /**
     * Specifies the type of node - on-prem, AWS, GCP etc.
     */
    nodeType: string;
    /**
     * Version of the node used for CAS.
     */
    objectVersion: number;
    supportedFeatures: string[];
}

export interface GetFoundationCentralImagedNodesListMetadata {
    /**
     * The number of records retrieved.
     */
    length: number;
    /**
     * Offset from the start of the object list.
     */
    offset: number;
    /**
     * Total matches found.
     */
    totalMatches: number;
}

export interface GetFoundationCentralListApiKeysApiKey {
    /**
     * Alias of the api key.
     */
    alias: string;
    /**
     * Api key in string format.
     */
    apiKey: string;
    /**
     * Time when the api key was created.
     */
    createdTimestamp: string;
    /**
     * Current time of Foundation Central.
     */
    currentTime: string;
    /**
     * UUID of the api key.
     */
    keyUuid: string;
}

export interface GetFoundationCentralListApiKeysMetadata {
    /**
     * The number of records retrieved.
     */
    length: number;
    /**
     * Offset from the start of the object list.
     */
    offset: number;
    /**
     * Total matches found.
     */
    totalMatches: number;
}

export interface GetFoundationDiscoverNodesEntity {
    /**
     * Chassis serial number.
     */
    blockId: string;
    /**
     * ID number of the block.
     */
    chassisN: number;
    /**
     * Model name of the node.
     */
    model: string;
    /**
     * Node level properties.
     */
    nodes: outputs.GetFoundationDiscoverNodesEntityNode[];
}

export interface GetFoundationDiscoverNodesEntityNode {
    /**
     * ID of the cluster the node is part of.
     */
    clusterId: string;
    /**
     * Whether the node is configured.
     */
    configured: boolean;
    /**
     * vlan tag of cvm.
     */
    currentCvmVlanTag: string;
    /**
     * Current network interface of the node.
     */
    currentNetworkInterface: string;
    /**
     * Version of foundation.
     */
    foundationVersion: string;
    /**
     * Type of hypervisor installed on the node.
     */
    hypervisor: string;
    /**
     * Version of hypervisor installed.
     */
    hypervisorVersion: string;
    /**
     * IPV6 address of the node.
     */
    ipv6Address: string;
    /**
     * Model name of the node.
     */
    model: string;
    /**
     * Position of the node in the block.
     */
    nodePosition: string;
    /**
     * Node serial of the node.
     */
    nodeSerial: string;
    /**
     * UUID of the node.
     */
    nodeUuid: string;
    /**
     * Version of NOS installed on the node.
     */
    nosVersion: string;
    /**
     * IP address of CVM.
     */
    svmIp: string;
}

export interface GetFoundationHypervisorIsosEsx {
    /**
     * Name of installer.
     */
    filename: string;
    /**
     * Whether front-end should treat hyp as supported.
     */
    supported: boolean;
}

export interface GetFoundationHypervisorIsosHyperv {
    /**
     * Name of installer.
     */
    filename: string;
    /**
     * Whether front-end should treat hyp as supported.
     */
    supported: boolean;
}

export interface GetFoundationHypervisorIsosKvm {
    /**
     * Name of installer.
     */
    filename: string;
    /**
     * Whether front-end should treat hyp as supported.
     */
    supported: boolean;
}

export interface GetFoundationHypervisorIsosLinux {
    /**
     * Name of installer.
     */
    filename: string;
    /**
     * Whether front-end should treat hyp as supported.
     */
    supported: boolean;
}

export interface GetFoundationHypervisorIsosXen {
    /**
     * Name of installer.
     */
    filename: string;
    /**
     * Whether front-end should treat hyp as supported.
     */
    supported: boolean;
}

export interface GetFoundationNodeNetworkDetailsNode {
    /**
     * Gateway of CVM.
     */
    cvmGateway: string;
    /**
     * CVM IP address.
     */
    cvmIp: string;
    /**
     * Netmask of CVM.
     */
    cvmNetmask: string;
    /**
     * CVM vlan tag.
     */
    cvmVlanId: string;
    /**
     * Only exists when failed to fetch node_info, with the reason of failure. all other fields will be empty.
     */
    error: string;
    /**
     * Gateway of the hypervisor.
     */
    hypervisorGateway: string;
    /**
     * Hypervisor hostname.
     */
    hypervisorHostname: string;
    /**
     * Hypervisor IP address.
     */
    hypervisorIp: string;
    /**
     * Netmask of the hypervisor.
     */
    hypervisorNetmask: string;
    /**
     * IPMI gateway.
     */
    ipmiGateway: string;
    /**
     * IPMI IP address.
     */
    ipmiIp: string;
    /**
     * IPMI netmask.
     */
    ipmiNetmask: string;
    /**
     * IPV6 address of the CVM.
     */
    ipv6Address: string;
    /**
     * Node serial.
     */
    nodeSerial: string;
}

export interface GetHostCategory {
    /**
     * - the key name.
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetHostGpuList {
    assignable: boolean;
    consumerReference: {[key: string]: string};
    deviceId: number;
    fraction: number;
    frameBufferSizeMib: number;
    guestDriverVersion: string;
    index: number;
    licenseLists: string[];
    maxResolution: string;
    mode: string;
    /**
     * - the name.
     */
    name: string;
    numVgpusAllocated: number;
    numVirtualDisplayHeads: number;
    numaNode: number;
    pciAddress: string;
    status: string;
    /**
     * - the uuid.
     */
    uuid: string;
    vendor: string;
}

export interface GetHostHostDisksReferenceList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the uuid.
     */
    uuid: string;
}

export interface GetHostsEntity {
    /**
     * The API version.
     */
    apiVersion: string;
    /**
     * - Host block config info.
     */
    block: {[key: string]: string};
    /**
     * - Categories for the image.
     */
    categories: outputs.GetHostsEntityCategory[];
    /**
     * - Reference to a kind. Either one of (kind, uuid) or url needs to be specified.
     */
    clusterReference: {[key: string]: string};
    /**
     * - Host controller vm information.
     */
    controllerVm: {[key: string]: string};
    /**
     * - Host CPU capacity.
     */
    cpuCapacityHz: number;
    /**
     * - Host CPU model.
     */
    cpuModel: string;
    /**
     * - Hyper-V failover cluster.
     */
    failoverCluster: {[key: string]: string};
    /**
     * - Host GPU driver version.
     */
    gpuDriverVersion: string;
    /**
     * - List of GPUs on the host.
     */
    gpuLists: outputs.GetHostsEntityGpuList[];
    /**
     * - The reference to a disk.
     */
    hostDisksReferenceLists: outputs.GetHostsEntityHostDisksReferenceList[];
    /**
     * - Host NICs.
     */
    hostNicsIdLists: string[];
    /**
     * - Host type.
     */
    hostType: string;
    /**
     * - Host Hypervisor information.
     */
    hypervisor: {[key: string]: string};
    /**
     * - Host IPMI info.
     */
    ipmi: {[key: string]: string};
    /**
     * - Host memory capacity in MiB.
     */
    memoryCapacityMib: number;
    metadata: {[key: string]: string};
    /**
     * - Host monitoring status.
     */
    monitoringState: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - Number of CPU cores on Host.
     */
    numCpuCores: number;
    /**
     * - Number of CPU sockets.
     */
    numCpuSockets: number;
    /**
     * - The reference to a user.
     */
    ownerReference: {[key: string]: string};
    /**
     * - The reference to a project.
     */
    projectReference: {[key: string]: string};
    /**
     * - The reference to a rackable_unit.
     */
    rackableUnitReference: {[key: string]: string};
    /**
     * - Node serial number.
     */
    serialNumber: string;
    /**
     * - The name of the node to be renamed to during domain-join. If not given,a new name will be automatically assigned.
     */
    windowsDomain: {[key: string]: string};
}

export interface GetHostsEntityCategory {
    /**
     * - the name.
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetHostsEntityGpuList {
    assignable: boolean;
    consumerReference: {[key: string]: string};
    deviceId: number;
    fraction: number;
    frameBufferSizeMib: number;
    guestDriverVersion: string;
    index: number;
    licenseLists: string[];
    maxResolution: string;
    mode: string;
    /**
     * - the name.
     */
    name: string;
    numVgpusAllocated: number;
    numVirtualDisplayHeads: number;
    numaNode: number;
    pciAddress: string;
    status: string;
    /**
     * - the uuid.
     */
    uuid: string;
    vendor: string;
}

export interface GetHostsEntityHostDisksReferenceList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the uuid.
     */
    uuid: string;
}

export interface GetImageCategory {
    /**
     * - the name.
     */
    name: string;
    value: string;
}

export interface GetImageClusterReference {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetImageCurrentClusterReferenceList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetKarbonClusterEtcdNodePool {
    /**
     * - VM configuration in AHV.
     */
    ahvConfigs: outputs.GetKarbonClusterEtcdNodePoolAhvConfig[];
    /**
     * - Unique name of the node pool.
     */
    name: string;
    /**
     * - The version of the node OS image.
     */
    nodeOsVersion: string;
    /**
     * - List of the deployed nodes in the node pool.
     */
    nodes: outputs.GetKarbonClusterEtcdNodePoolNode[];
    /**
     * - Number of nodes in the node pool.
     */
    numInstances: number;
}

export interface GetKarbonClusterEtcdNodePoolAhvConfig {
    /**
     * - The number of VCPUs allocated for each VM on the PE cluster.
     */
    cpu: number;
    /**
     * - Size of local storage for each VM on the PE cluster in MiB.
     */
    diskMib: number;
    /**
     * - Memory allocated for each VM on the PE cluster in MiB.
     */
    memoryMib: number;
    /**
     * - The UUID of the network for the VMs deployed with this resource configuration.
     */
    networkUuid: string;
    /**
     * - The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
     */
    prismElementClusterUuid: string;
}

export interface GetKarbonClusterEtcdNodePoolNode {
    /**
     * - Hostname of the deployed node.
     */
    hostname: string;
    /**
     * - IP of the deployed node.
     */
    ipv4Address: string;
}

export interface GetKarbonClusterMasterNodePool {
    /**
     * - VM configuration in AHV.
     */
    ahvConfigs: outputs.GetKarbonClusterMasterNodePoolAhvConfig[];
    /**
     * - Unique name of the node pool.
     */
    name: string;
    /**
     * - The version of the node OS image.
     */
    nodeOsVersion: string;
    /**
     * - List of the deployed nodes in the node pool.
     */
    nodes: outputs.GetKarbonClusterMasterNodePoolNode[];
    /**
     * - Number of nodes in the node pool.
     */
    numInstances: number;
}

export interface GetKarbonClusterMasterNodePoolAhvConfig {
    /**
     * - The number of VCPUs allocated for each VM on the PE cluster.
     */
    cpu: number;
    /**
     * - Size of local storage for each VM on the PE cluster in MiB.
     */
    diskMib: number;
    /**
     * - Memory allocated for each VM on the PE cluster in MiB.
     */
    memoryMib: number;
    /**
     * - The UUID of the network for the VMs deployed with this resource configuration.
     */
    networkUuid: string;
    /**
     * - The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
     */
    prismElementClusterUuid: string;
}

export interface GetKarbonClusterMasterNodePoolNode {
    /**
     * - Hostname of the deployed node.
     */
    hostname: string;
    /**
     * - IP of the deployed node.
     */
    ipv4Address: string;
}

export interface GetKarbonClusterWorkerNodePool {
    /**
     * - VM configuration in AHV.
     */
    ahvConfigs: outputs.GetKarbonClusterWorkerNodePoolAhvConfig[];
    /**
     * - Unique name of the node pool.
     */
    name: string;
    /**
     * - The version of the node OS image.
     */
    nodeOsVersion: string;
    /**
     * - List of the deployed nodes in the node pool.
     */
    nodes: outputs.GetKarbonClusterWorkerNodePoolNode[];
    /**
     * - Number of nodes in the node pool.
     */
    numInstances: number;
}

export interface GetKarbonClusterWorkerNodePoolAhvConfig {
    /**
     * - The number of VCPUs allocated for each VM on the PE cluster.
     */
    cpu: number;
    /**
     * - Size of local storage for each VM on the PE cluster in MiB.
     */
    diskMib: number;
    /**
     * - Memory allocated for each VM on the PE cluster in MiB.
     */
    memoryMib: number;
    /**
     * - The UUID of the network for the VMs deployed with this resource configuration.
     */
    networkUuid: string;
    /**
     * - The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
     */
    prismElementClusterUuid: string;
}

export interface GetKarbonClusterWorkerNodePoolNode {
    /**
     * - Hostname of the deployed node.
     */
    hostname: string;
    /**
     * - IP of the deployed node.
     */
    ipv4Address: string;
}

export interface GetKarbonClustersCluster {
    deploymentType: string;
    /**
     * - Configuration of the node pools that the nodes in the etcd cluster belong to. The etcd nodes require a minimum of 8,192 MiB memory and 409,60 MiB disk space.
     */
    etcdNodePools: outputs.GetKarbonClustersClusterEtcdNodePool[];
    kubeapiServerIpv4Address: string;
    /**
     * - .
     */
    masterNodePools: outputs.GetKarbonClustersClusterMasterNodePool[];
    /**
     * - Unique name of the node pool.
     */
    name: string;
    status: string;
    uuid: string;
    /**
     * - K8s version of the cluster.
     */
    version: string;
    workerNodePools: outputs.GetKarbonClustersClusterWorkerNodePool[];
}

export interface GetKarbonClustersClusterEtcdNodePool {
    /**
     * - .
     */
    ahvConfigs: outputs.GetKarbonClustersClusterEtcdNodePoolAhvConfig[];
    /**
     * - Unique name of the node pool.
     */
    name: string;
    /**
     * - The version of the node OS image.
     */
    nodeOsVersion: string;
    nodes: outputs.GetKarbonClustersClusterEtcdNodePoolNode[];
    /**
     * - Number of nodes in the node pool.
     */
    numInstances: number;
}

export interface GetKarbonClustersClusterEtcdNodePoolAhvConfig {
    /**
     * - The number of VCPUs allocated for each VM on the PE cluster.
     */
    cpu: number;
    /**
     * - Size of local storage for each VM on the PE cluster in MiB.
     */
    diskMib: number;
    /**
     * - Memory allocated for each VM on the PE cluster in MiB.
     */
    memoryMib: number;
    /**
     * - The UUID of the network for the VMs deployed with this resource configuration.
     */
    networkUuid: string;
    /**
     * - The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
     */
    prismElementClusterUuid: string;
}

export interface GetKarbonClustersClusterEtcdNodePoolNode {
    hostname: string;
    ipv4Address: string;
}

export interface GetKarbonClustersClusterMasterNodePool {
    /**
     * - .
     */
    ahvConfigs: outputs.GetKarbonClustersClusterMasterNodePoolAhvConfig[];
    /**
     * - Unique name of the node pool.
     */
    name: string;
    /**
     * - The version of the node OS image.
     */
    nodeOsVersion: string;
    nodes: outputs.GetKarbonClustersClusterMasterNodePoolNode[];
    /**
     * - Number of nodes in the node pool.
     */
    numInstances: number;
}

export interface GetKarbonClustersClusterMasterNodePoolAhvConfig {
    /**
     * - The number of VCPUs allocated for each VM on the PE cluster.
     */
    cpu: number;
    /**
     * - Size of local storage for each VM on the PE cluster in MiB.
     */
    diskMib: number;
    /**
     * - Memory allocated for each VM on the PE cluster in MiB.
     */
    memoryMib: number;
    /**
     * - The UUID of the network for the VMs deployed with this resource configuration.
     */
    networkUuid: string;
    /**
     * - The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
     */
    prismElementClusterUuid: string;
}

export interface GetKarbonClustersClusterMasterNodePoolNode {
    hostname: string;
    ipv4Address: string;
}

export interface GetKarbonClustersClusterWorkerNodePool {
    /**
     * - .
     */
    ahvConfigs: outputs.GetKarbonClustersClusterWorkerNodePoolAhvConfig[];
    /**
     * - Unique name of the node pool.
     */
    name: string;
    /**
     * - The version of the node OS image.
     */
    nodeOsVersion: string;
    nodes: outputs.GetKarbonClustersClusterWorkerNodePoolNode[];
    /**
     * - Number of nodes in the node pool.
     */
    numInstances: number;
}

export interface GetKarbonClustersClusterWorkerNodePoolAhvConfig {
    /**
     * - The number of VCPUs allocated for each VM on the PE cluster.
     */
    cpu: number;
    /**
     * - Size of local storage for each VM on the PE cluster in MiB.
     */
    diskMib: number;
    /**
     * - Memory allocated for each VM on the PE cluster in MiB.
     */
    memoryMib: number;
    /**
     * - The UUID of the network for the VMs deployed with this resource configuration.
     */
    networkUuid: string;
    /**
     * - The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
     */
    prismElementClusterUuid: string;
}

export interface GetKarbonClustersClusterWorkerNodePoolNode {
    hostname: string;
    ipv4Address: string;
}

export interface GetKarbonPrivateRegistriesPrivateRegistry {
    /**
     * - Endpoint of the private in format `url:port`.
     */
    endpoint: string;
    /**
     * - Name of the private registry.
     */
    name: string;
    /**
     * - UUID of the private registry.
     */
    uuid: string;
}

export interface GetNdbCloneDatabaseNode {
    accessLevel: {[key: string]: string};
    databaseId: string;
    /**
     * database status
     */
    databaseStatus: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    dbserver: {[key: string]: string};
    dbserverId: string;
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned id
     */
    id: string;
    /**
     * cloned info
     */
    infos: outputs.GetNdbCloneDatabaseNodeInfo[];
    /**
     * cloned name
     */
    name: string;
    primary: boolean;
    /**
     * properties of clone
     */
    properties: outputs.GetNdbCloneDatabaseNodeProperty[];
    protectionDomainId: string;
    protectionDomains: outputs.GetNdbCloneDatabaseNodeProtectionDomain[];
    softwareInstallationId: string;
    /**
     * status of clone
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.GetNdbCloneDatabaseNodeTag[];
}

export interface GetNdbCloneDatabaseNodeInfo {
    /**
     * cloned info
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface GetNdbCloneDatabaseNodeProperty {
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned name
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbCloneDatabaseNodeProtectionDomain {
    assocEntities: string[];
    cloudId: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * cloned description
     */
    description: string;
    eraCreated: boolean;
    /**
     * cloned id
     */
    id: string;
    /**
     * cloned name
     */
    name: string;
    ownerId: string;
    primaryHost: string;
    /**
     * properties of clone
     */
    properties: outputs.GetNdbCloneDatabaseNodeProtectionDomainProperty[];
    /**
     * status of clone
     */
    status: string;
    /**
     * type
     */
    type: string;
}

export interface GetNdbCloneDatabaseNodeProtectionDomainProperty {
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned name
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbCloneDatabaseNodeTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbCloneFilter {
    /**
     * Get entity(s) if it satisfies query criteria irrespective of status (retrieve even deleted). Default is false
     */
    anyStatus?: string;
    /**
     * Load entities with complete details. Default is false
     */
    detailed?: string;
    /**
     * Load cluster info. Default is false
     */
    loadDbserverCluster?: string;
    /**
     * Default is UTC
     */
    timezone?: string;
}

export interface GetNdbCloneInfo {
    bpgConfigs: outputs.GetNdbCloneInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface GetNdbCloneInfoBpgConfig {
    bpgDbParams: outputs.GetNdbCloneInfoBpgConfigBpgDbParam[];
    storages: outputs.GetNdbCloneInfoBpgConfigStorage[];
    vmProperties: outputs.GetNdbCloneInfoBpgConfigVmProperty[];
}

export interface GetNdbCloneInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface GetNdbCloneInfoBpgConfigStorage {
    archiveStorages: outputs.GetNdbCloneInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.GetNdbCloneInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.GetNdbCloneInfoBpgConfigStorageLogDisk[];
}

export interface GetNdbCloneInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface GetNdbCloneInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface GetNdbCloneInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface GetNdbCloneInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface GetNdbCloneLcmConfig {
    expiryDetails: outputs.GetNdbCloneLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.GetNdbCloneLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.GetNdbCloneLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.GetNdbCloneLcmConfigRefreshDetail[];
}

export interface GetNdbCloneLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface GetNdbCloneLcmConfigPostDeleteCommand {
    command: string;
}

export interface GetNdbCloneLcmConfigPreDeleteCommand {
    command: string;
}

export interface GetNdbCloneLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface GetNdbCloneLinkedDatabase {
    /**
     * database name
     */
    databaseName: string;
    /**
     * database status
     */
    databaseStatus: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned id
     */
    id: string;
    /**
     * cloned info
     */
    infos: outputs.GetNdbCloneLinkedDatabaseInfo[];
    /**
     * Metric of clone
     */
    metric: {[key: string]: string};
    /**
     * cloned name
     */
    name: string;
    /**
     * parent database id
     */
    parentDatabaseId: string;
    parentLinkedDatabaseId: string;
    snapshotId: string;
    /**
     * status of clone
     */
    status: string;
    /**
     * Default is UTC
     */
    timezone: string;
}

export interface GetNdbCloneLinkedDatabaseInfo {
    /**
     * cloned info
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface GetNdbCloneProperty {
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned name
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbCloneTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbCloneTimeMachine {
    accessLevel: string;
    /**
     * clone or not
     */
    clone: boolean;
    clones: string;
    /**
     * clustered or not
     */
    clustered: boolean;
    database: string;
    databaseId: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * cloned description
     */
    description: string;
    eaStatus: string;
    /**
     * cloned id
     */
    id: string;
    /**
     * Metric of clone
     */
    metric: string;
    /**
     * cloned name
     */
    name: string;
    /**
     * properties of clone
     */
    properties: outputs.GetNdbCloneTimeMachineProperty[];
    scheduleId: string;
    schedules: outputs.GetNdbCloneTimeMachineSchedule[];
    scope: string;
    slaId: string;
    slaUpdateInProgress: boolean;
    slaUpdateMetadata: string;
    slas: outputs.GetNdbCloneTimeMachineSla[];
    sourceNxClusters: string[];
    /**
     * status of clone
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.GetNdbCloneTimeMachineTag[];
    /**
     * type
     */
    type: string;
}

export interface GetNdbCloneTimeMachineProperty {
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned name
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbCloneTimeMachineSchedule {
    continuousSchedules: outputs.GetNdbCloneTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.GetNdbCloneTimeMachineScheduleDailySchedule[];
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * cloned description
     */
    description: string;
    globalPolicy: boolean;
    /**
     * cloned id
     */
    id: string;
    monthlySchedules: outputs.GetNdbCloneTimeMachineScheduleMonthlySchedule[];
    /**
     * cloned name
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.GetNdbCloneTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.GetNdbCloneTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    /**
     * time zone
     */
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.GetNdbCloneTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.GetNdbCloneTimeMachineScheduleYearlySchedule[];
}

export interface GetNdbCloneTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface GetNdbCloneTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface GetNdbCloneTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface GetNdbCloneTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface GetNdbCloneTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface GetNdbCloneTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface GetNdbCloneTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface GetNdbCloneTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned id
     */
    id: string;
    monthlyRetention: number;
    /**
     * cloned name
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface GetNdbCloneTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbClonesClone {
    /**
     * clone or not
     */
    clone: boolean;
    /**
     * clustered or not
     */
    clustered: boolean;
    /**
     * database cluster type
     */
    databaseClusterType: string;
    /**
     * database name
     */
    databaseName: string;
    /**
     * database nodes associated with database instance
     */
    databaseNodes: outputs.GetNdbClonesCloneDatabaseNode[];
    /**
     * database status
     */
    databaseStatus: string;
    /**
     * database for a cloned instance
     */
    databases: {[key: string]: string};
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * dbserver logical cluster
     */
    dbserverLogicalCluster: {[key: string]: string};
    /**
     * dbserver logical cluster id
     */
    dbserverLogicalClusterId: string;
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned id
     */
    id: string;
    /**
     * cloned info
     */
    infos: outputs.GetNdbClonesCloneInfo[];
    /**
     * LCM Config
     */
    lcmConfigs: outputs.GetNdbClonesCloneLcmConfig[];
    /**
     * linked databases within database instance
     */
    linkedDatabases: outputs.GetNdbClonesCloneLinkedDatabase[];
    /**
     * Metric of clone
     */
    metric: {[key: string]: string};
    /**
     * cloned name
     */
    name: string;
    /**
     * parent database id
     */
    parentDatabaseId: string;
    /**
     * parent source database id
     */
    parentSourceDatabaseId: string;
    /**
     * parent time machine id
     */
    parentTimeMachineId: string;
    /**
     * properties of clone
     */
    properties: outputs.GetNdbClonesCloneProperty[];
    /**
     * status of clone
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.GetNdbClonesCloneTag[];
    /**
     * time machine id
     */
    timeMachineId: string;
    /**
     * Time machine info
     */
    timeMachines: outputs.GetNdbClonesCloneTimeMachine[];
    /**
     * time zone
     */
    timeZone: string;
    /**
     * type
     */
    type: string;
}

export interface GetNdbClonesCloneDatabaseNode {
    accessLevel: {[key: string]: string};
    databaseId: string;
    /**
     * database status
     */
    databaseStatus: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    dbserver: {[key: string]: string};
    dbserverId: string;
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned id
     */
    id: string;
    /**
     * cloned info
     */
    infos: outputs.GetNdbClonesCloneDatabaseNodeInfo[];
    /**
     * cloned name
     */
    name: string;
    primary: boolean;
    /**
     * properties of clone
     */
    properties: outputs.GetNdbClonesCloneDatabaseNodeProperty[];
    protectionDomainId: string;
    protectionDomains: outputs.GetNdbClonesCloneDatabaseNodeProtectionDomain[];
    softwareInstallationId: string;
    /**
     * status of clone
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.GetNdbClonesCloneDatabaseNodeTag[];
}

export interface GetNdbClonesCloneDatabaseNodeInfo {
    /**
     * cloned info
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface GetNdbClonesCloneDatabaseNodeProperty {
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned name
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbClonesCloneDatabaseNodeProtectionDomain {
    assocEntities: string[];
    cloudId: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * cloned description
     */
    description: string;
    eraCreated: boolean;
    /**
     * cloned id
     */
    id: string;
    /**
     * cloned name
     */
    name: string;
    ownerId: string;
    primaryHost: string;
    /**
     * properties of clone
     */
    properties: outputs.GetNdbClonesCloneDatabaseNodeProtectionDomainProperty[];
    /**
     * status of clone
     */
    status: string;
    /**
     * type
     */
    type: string;
}

export interface GetNdbClonesCloneDatabaseNodeProtectionDomainProperty {
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned name
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbClonesCloneDatabaseNodeTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbClonesCloneInfo {
    bpgConfigs: outputs.GetNdbClonesCloneInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface GetNdbClonesCloneInfoBpgConfig {
    bpgDbParams: outputs.GetNdbClonesCloneInfoBpgConfigBpgDbParam[];
    storages: outputs.GetNdbClonesCloneInfoBpgConfigStorage[];
    vmProperties: outputs.GetNdbClonesCloneInfoBpgConfigVmProperty[];
}

export interface GetNdbClonesCloneInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface GetNdbClonesCloneInfoBpgConfigStorage {
    archiveStorages: outputs.GetNdbClonesCloneInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.GetNdbClonesCloneInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.GetNdbClonesCloneInfoBpgConfigStorageLogDisk[];
}

export interface GetNdbClonesCloneInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface GetNdbClonesCloneInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface GetNdbClonesCloneInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface GetNdbClonesCloneInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface GetNdbClonesCloneLcmConfig {
    expiryDetails: outputs.GetNdbClonesCloneLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.GetNdbClonesCloneLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.GetNdbClonesCloneLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.GetNdbClonesCloneLcmConfigRefreshDetail[];
}

export interface GetNdbClonesCloneLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface GetNdbClonesCloneLcmConfigPostDeleteCommand {
    command: string;
}

export interface GetNdbClonesCloneLcmConfigPreDeleteCommand {
    command: string;
}

export interface GetNdbClonesCloneLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface GetNdbClonesCloneLinkedDatabase {
    /**
     * database name
     */
    databaseName: string;
    /**
     * database status
     */
    databaseStatus: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned id
     */
    id: string;
    /**
     * cloned info
     */
    infos: outputs.GetNdbClonesCloneLinkedDatabaseInfo[];
    /**
     * Metric of clone
     */
    metric: {[key: string]: string};
    /**
     * cloned name
     */
    name: string;
    /**
     * parent database id
     */
    parentDatabaseId: string;
    parentLinkedDatabaseId: string;
    snapshotId: string;
    /**
     * status of clone
     */
    status: string;
    /**
     * Default is UTC
     */
    timezone: string;
}

export interface GetNdbClonesCloneLinkedDatabaseInfo {
    /**
     * cloned info
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface GetNdbClonesCloneProperty {
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned name
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbClonesCloneTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbClonesCloneTimeMachine {
    accessLevel: string;
    /**
     * clone or not
     */
    clone: boolean;
    /**
     * List of clones based on filters
     */
    clones: string;
    /**
     * clustered or not
     */
    clustered: boolean;
    database: string;
    databaseId: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * cloned description
     */
    description: string;
    eaStatus: string;
    /**
     * cloned id
     */
    id: string;
    /**
     * Metric of clone
     */
    metric: string;
    /**
     * cloned name
     */
    name: string;
    /**
     * properties of clone
     */
    properties: outputs.GetNdbClonesCloneTimeMachineProperty[];
    scheduleId: string;
    schedules: outputs.GetNdbClonesCloneTimeMachineSchedule[];
    scope: string;
    slaId: string;
    slaUpdateInProgress: boolean;
    slaUpdateMetadata: string;
    slas: outputs.GetNdbClonesCloneTimeMachineSla[];
    sourceNxClusters: string[];
    /**
     * status of clone
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.GetNdbClonesCloneTimeMachineTag[];
    /**
     * type
     */
    type: string;
}

export interface GetNdbClonesCloneTimeMachineProperty {
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned name
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbClonesCloneTimeMachineSchedule {
    continuousSchedules: outputs.GetNdbClonesCloneTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.GetNdbClonesCloneTimeMachineScheduleDailySchedule[];
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * cloned description
     */
    description: string;
    globalPolicy: boolean;
    /**
     * cloned id
     */
    id: string;
    monthlySchedules: outputs.GetNdbClonesCloneTimeMachineScheduleMonthlySchedule[];
    /**
     * cloned name
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.GetNdbClonesCloneTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.GetNdbClonesCloneTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    /**
     * time zone
     */
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.GetNdbClonesCloneTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.GetNdbClonesCloneTimeMachineScheduleYearlySchedule[];
}

export interface GetNdbClonesCloneTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface GetNdbClonesCloneTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface GetNdbClonesCloneTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface GetNdbClonesCloneTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface GetNdbClonesCloneTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface GetNdbClonesCloneTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface GetNdbClonesCloneTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface GetNdbClonesCloneTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned id
     */
    id: string;
    monthlyRetention: number;
    /**
     * cloned name
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface GetNdbClonesCloneTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbClonesFilter {
    /**
     * Get entity(s) if it satisfies query criteria irrespective of status (retrieve even deleted). Default is false
     */
    anyStatus?: string;
    /**
     * Load entities with complete details. Default is false
     */
    detailed?: string;
    /**
     * Load cluster info. Default is false
     */
    loadDbserverCluster?: string;
    /**
     * Sorted by dbserver cluster. Default is false
     */
    orderByDbserverCluster?: string;
    /**
     * Sorted by dbserver logical cluster.  Default is false
     */
    orderByDbserverLogicalCluster?: string;
    /**
     * Default is UTC
     */
    timezone?: string;
}

export interface GetNdbClusterEntityCount {
    dbServers: number;
    engineCounts: outputs.GetNdbClusterEntityCountEngineCount[];
}

export interface GetNdbClusterEntityCountEngineCount {
    mariadbDatabases: outputs.GetNdbClusterEntityCountEngineCountMariadbDatabase[];
    mongodbDatabases: outputs.GetNdbClusterEntityCountEngineCountMongodbDatabase[];
    mysqlDatabases: outputs.GetNdbClusterEntityCountEngineCountMysqlDatabase[];
    oracleDatabases: outputs.GetNdbClusterEntityCountEngineCountOracleDatabase[];
    postgresDatabases: outputs.GetNdbClusterEntityCountEngineCountPostgresDatabase[];
    saphanaDatabases: outputs.GetNdbClusterEntityCountEngineCountSaphanaDatabase[];
    sqlserverDatabases: outputs.GetNdbClusterEntityCountEngineCountSqlserverDatabase[];
}

export interface GetNdbClusterEntityCountEngineCountMariadbDatabase {
    profiles: outputs.GetNdbClusterEntityCountEngineCountMariadbDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClusterEntityCountEngineCountMariadbDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClusterEntityCountEngineCountMongodbDatabase {
    profiles: outputs.GetNdbClusterEntityCountEngineCountMongodbDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClusterEntityCountEngineCountMongodbDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClusterEntityCountEngineCountMysqlDatabase {
    profiles: outputs.GetNdbClusterEntityCountEngineCountMysqlDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClusterEntityCountEngineCountMysqlDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClusterEntityCountEngineCountOracleDatabase {
    profiles: outputs.GetNdbClusterEntityCountEngineCountOracleDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClusterEntityCountEngineCountOracleDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClusterEntityCountEngineCountPostgresDatabase {
    profiles: outputs.GetNdbClusterEntityCountEngineCountPostgresDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClusterEntityCountEngineCountPostgresDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClusterEntityCountEngineCountSaphanaDatabase {
    profiles: outputs.GetNdbClusterEntityCountEngineCountSaphanaDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClusterEntityCountEngineCountSaphanaDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClusterEntityCountEngineCountSqlserverDatabase {
    profiles: outputs.GetNdbClusterEntityCountEngineCountSqlserverDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClusterEntityCountEngineCountSqlserverDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClusterProperty {
    /**
     * - description
     */
    description: string;
    /**
     * - name of cluster
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbClusterResourceConfig {
    memoryThresholdPercentage: number;
    storageThresholdPercentage: number;
}

export interface GetNdbClustersCluster {
    cloudInfo: string;
    cloudType: string;
    dateCreated: string;
    dateModified: string;
    description: string;
    entityCounts: outputs.GetNdbClustersClusterEntityCount[];
    fqdns: string;
    healthy: boolean;
    hypervisorType: string;
    hypervisorVersion: string;
    id: string;
    ipAddresses: string[];
    managementServerInfo: string;
    name: string;
    nxClusterUuid: string;
    ownerId: string;
    password: string;
    properties: outputs.GetNdbClustersClusterProperty[];
    referenceCount: number;
    resourceConfigs: outputs.GetNdbClustersClusterResourceConfig[];
    status: string;
    uniqueName: string;
    username: string;
    version: string;
}

export interface GetNdbClustersClusterEntityCount {
    dbServers: number;
    engineCounts: outputs.GetNdbClustersClusterEntityCountEngineCount[];
}

export interface GetNdbClustersClusterEntityCountEngineCount {
    mariadbDatabases: outputs.GetNdbClustersClusterEntityCountEngineCountMariadbDatabase[];
    mongodbDatabases: outputs.GetNdbClustersClusterEntityCountEngineCountMongodbDatabase[];
    mysqlDatabases: outputs.GetNdbClustersClusterEntityCountEngineCountMysqlDatabase[];
    oracleDatabases: outputs.GetNdbClustersClusterEntityCountEngineCountOracleDatabase[];
    postgresDatabases: outputs.GetNdbClustersClusterEntityCountEngineCountPostgresDatabase[];
    saphanaDatabases: outputs.GetNdbClustersClusterEntityCountEngineCountSaphanaDatabase[];
    sqlserverDatabases: outputs.GetNdbClustersClusterEntityCountEngineCountSqlserverDatabase[];
}

export interface GetNdbClustersClusterEntityCountEngineCountMariadbDatabase {
    profiles: outputs.GetNdbClustersClusterEntityCountEngineCountMariadbDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountMariadbDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountMongodbDatabase {
    profiles: outputs.GetNdbClustersClusterEntityCountEngineCountMongodbDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountMongodbDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountMysqlDatabase {
    profiles: outputs.GetNdbClustersClusterEntityCountEngineCountMysqlDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountMysqlDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountOracleDatabase {
    profiles: outputs.GetNdbClustersClusterEntityCountEngineCountOracleDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountOracleDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountPostgresDatabase {
    profiles: outputs.GetNdbClustersClusterEntityCountEngineCountPostgresDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountPostgresDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountSaphanaDatabase {
    profiles: outputs.GetNdbClustersClusterEntityCountEngineCountSaphanaDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountSaphanaDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountSqlserverDatabase {
    profiles: outputs.GetNdbClustersClusterEntityCountEngineCountSqlserverDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountSqlserverDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClustersClusterProperty {
    description: string;
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbClustersClusterResourceConfig {
    memoryThresholdPercentage: number;
    storageThresholdPercentage: number;
}

export interface GetNdbDatabaseDatabaseNode {
    accessLevel: {[key: string]: string};
    /**
     * ID of database instance
     */
    databaseId: string;
    databaseStatus: string;
    /**
     * - creation date
     */
    dateCreated: string;
    /**
     * - date modified
     */
    dateModified: string;
    dbserver: {[key: string]: string};
    dbserverId: string;
    /**
     * - description
     */
    description: string;
    /**
     * - id of database instance
     */
    id: string;
    /**
     * - info regarding disks, vm, storage, etc.
     */
    infos: outputs.GetNdbDatabaseDatabaseNodeInfo[];
    /**
     * - name of database instance
     */
    name: string;
    primary: boolean;
    /**
     * - properties
     */
    properties: outputs.GetNdbDatabaseDatabaseNodeProperty[];
    protectionDomainId: string;
    protectionDomains: outputs.GetNdbDatabaseDatabaseNodeProtectionDomain[];
    softwareInstallationId: string;
    /**
     * - status of database instance
     */
    status: string;
    /**
     * - tags attached
     */
    tags: outputs.GetNdbDatabaseDatabaseNodeTag[];
}

export interface GetNdbDatabaseDatabaseNodeInfo {
    /**
     * - info regarding disks, vm, storage, etc.
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface GetNdbDatabaseDatabaseNodeProperty {
    /**
     * - description
     */
    description: string;
    /**
     * - name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbDatabaseDatabaseNodeProtectionDomain {
    assocEntities: string[];
    cloudId: string;
    /**
     * - creation date
     */
    dateCreated: string;
    /**
     * - date modified
     */
    dateModified: string;
    /**
     * - description
     */
    description: string;
    eraCreated: boolean;
    /**
     * - id of database instance
     */
    id: string;
    /**
     * - name of database instance
     */
    name: string;
    ownerId: string;
    primaryHost: string;
    /**
     * - properties
     */
    properties: outputs.GetNdbDatabaseDatabaseNodeProtectionDomainProperty[];
    /**
     * - status of database instance
     */
    status: string;
    /**
     * - database engine type
     */
    type: string;
}

export interface GetNdbDatabaseDatabaseNodeProtectionDomainProperty {
    /**
     * - description
     */
    description: string;
    /**
     * - name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbDatabaseDatabaseNodeTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbDatabaseInfo {
    bpgConfigs: outputs.GetNdbDatabaseInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface GetNdbDatabaseInfoBpgConfig {
    bpgDbParams: outputs.GetNdbDatabaseInfoBpgConfigBpgDbParam[];
    storages: outputs.GetNdbDatabaseInfoBpgConfigStorage[];
    vmProperties: outputs.GetNdbDatabaseInfoBpgConfigVmProperty[];
}

export interface GetNdbDatabaseInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface GetNdbDatabaseInfoBpgConfigStorage {
    archiveStorages: outputs.GetNdbDatabaseInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.GetNdbDatabaseInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.GetNdbDatabaseInfoBpgConfigStorageLogDisk[];
}

export interface GetNdbDatabaseInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface GetNdbDatabaseInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface GetNdbDatabaseInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface GetNdbDatabaseInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface GetNdbDatabaseLcmConfig {
    expiryDetails: outputs.GetNdbDatabaseLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.GetNdbDatabaseLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.GetNdbDatabaseLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.GetNdbDatabaseLcmConfigRefreshDetail[];
}

export interface GetNdbDatabaseLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface GetNdbDatabaseLcmConfigPostDeleteCommand {
    command: string;
}

export interface GetNdbDatabaseLcmConfigPreDeleteCommand {
    command: string;
}

export interface GetNdbDatabaseLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface GetNdbDatabaseLinkedDatabase {
    /**
     * - database instance name
     */
    databaseName: string;
    databaseStatus: string;
    /**
     * - creation date
     */
    dateCreated: string;
    /**
     * - date modified
     */
    dateModified: string;
    /**
     * - description
     */
    description: string;
    /**
     * - id of database instance
     */
    id: string;
    /**
     * - info regarding disks, vm, storage, etc.
     */
    infos: outputs.GetNdbDatabaseLinkedDatabaseInfo[];
    /**
     * - metrics
     */
    metric: {[key: string]: string};
    /**
     * - name of database instance
     */
    name: string;
    /**
     * - parent database ID
     */
    parentDatabaseId: string;
    parentLinkedDatabaseId: string;
    snapshotId: string;
    /**
     * - status of database instance
     */
    status: string;
    timezone: string;
}

export interface GetNdbDatabaseLinkedDatabaseInfo {
    /**
     * - info regarding disks, vm, storage, etc.
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface GetNdbDatabaseProperty {
    /**
     * - description
     */
    description: string;
    /**
     * - name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbDatabaseTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbDatabaseTimeMachine {
    accessLevel: string;
    /**
     * - if cloned
     */
    clone: boolean;
    clones: string;
    /**
     * - if clustered or not
     */
    clustered: boolean;
    database: string;
    /**
     * ID of database instance
     */
    databaseId: string;
    /**
     * - creation date
     */
    dateCreated: string;
    /**
     * - date modified
     */
    dateModified: string;
    /**
     * - description
     */
    description: string;
    eaStatus: string;
    /**
     * - id of database instance
     */
    id: string;
    /**
     * - metrics
     */
    metric: string;
    /**
     * - name of database instance
     */
    name: string;
    /**
     * - properties
     */
    properties: outputs.GetNdbDatabaseTimeMachineProperty[];
    scheduleId: string;
    schedules: outputs.GetNdbDatabaseTimeMachineSchedule[];
    scope: string;
    slaId: string;
    slaUpdateInProgress: boolean;
    slaUpdateMetadata: string;
    slas: outputs.GetNdbDatabaseTimeMachineSla[];
    sourceNxClusters: string[];
    /**
     * - status of database instance
     */
    status: string;
    /**
     * - tags attached
     */
    tags: outputs.GetNdbDatabaseTimeMachineTag[];
    /**
     * - database engine type
     */
    type: string;
}

export interface GetNdbDatabaseTimeMachineProperty {
    /**
     * - description
     */
    description: string;
    /**
     * - name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbDatabaseTimeMachineSchedule {
    continuousSchedules: outputs.GetNdbDatabaseTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.GetNdbDatabaseTimeMachineScheduleDailySchedule[];
    /**
     * - creation date
     */
    dateCreated: string;
    /**
     * - date modified
     */
    dateModified: string;
    /**
     * - description
     */
    description: string;
    globalPolicy: boolean;
    /**
     * - id of database instance
     */
    id: string;
    monthlySchedules: outputs.GetNdbDatabaseTimeMachineScheduleMonthlySchedule[];
    /**
     * - name of database instance
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.GetNdbDatabaseTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.GetNdbDatabaseTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    /**
     * - timezone
     */
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.GetNdbDatabaseTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.GetNdbDatabaseTimeMachineScheduleYearlySchedule[];
}

export interface GetNdbDatabaseTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface GetNdbDatabaseTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface GetNdbDatabaseTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface GetNdbDatabaseTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface GetNdbDatabaseTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface GetNdbDatabaseTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface GetNdbDatabaseTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface GetNdbDatabaseTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    /**
     * - creation date
     */
    dateCreated: string;
    /**
     * - date modified
     */
    dateModified: string;
    /**
     * - description
     */
    description: string;
    /**
     * - id of database instance
     */
    id: string;
    monthlyRetention: number;
    /**
     * - name of database instance
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface GetNdbDatabaseTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbDatabasesDatabaseInstance {
    clone: boolean;
    clustered: boolean;
    databaseClusterType: string;
    databaseName: string;
    databaseNodes: outputs.GetNdbDatabasesDatabaseInstanceDatabaseNode[];
    databases: {[key: string]: string};
    dateCreated: string;
    dateModified: string;
    dbserverLogicalCluster: {[key: string]: string};
    dbserverLogicalClusterId: string;
    description: string;
    id: string;
    infos: outputs.GetNdbDatabasesDatabaseInstanceInfo[];
    lcmConfigs: outputs.GetNdbDatabasesDatabaseInstanceLcmConfig[];
    linkedDatabases: outputs.GetNdbDatabasesDatabaseInstanceLinkedDatabase[];
    metadatas: outputs.GetNdbDatabasesDatabaseInstanceMetadata[];
    metric: {[key: string]: string};
    name: string;
    parentDatabaseId: string;
    /**
     * List of all the properties
     */
    properties: outputs.GetNdbDatabasesDatabaseInstanceProperty[];
    status: string;
    tags: outputs.GetNdbDatabasesDatabaseInstanceTag[];
    timeMachineId: string;
    timeMachines: outputs.GetNdbDatabasesDatabaseInstanceTimeMachine[];
    timeZone: string;
    type: string;
}

export interface GetNdbDatabasesDatabaseInstanceDatabaseNode {
    accessLevel: {[key: string]: string};
    databaseId: string;
    databaseStatus: string;
    dateCreated: string;
    dateModified: string;
    dbserver: {[key: string]: string};
    dbserverId: string;
    description: string;
    id: string;
    infos: outputs.GetNdbDatabasesDatabaseInstanceDatabaseNodeInfo[];
    name: string;
    primary: boolean;
    /**
     * List of all the properties
     */
    properties: outputs.GetNdbDatabasesDatabaseInstanceDatabaseNodeProperty[];
    protectionDomainId: string;
    protectionDomains: outputs.GetNdbDatabasesDatabaseInstanceDatabaseNodeProtectionDomain[];
    softwareInstallationId: string;
    status: string;
    tags: outputs.GetNdbDatabasesDatabaseInstanceDatabaseNodeTag[];
}

export interface GetNdbDatabasesDatabaseInstanceDatabaseNodeInfo {
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface GetNdbDatabasesDatabaseInstanceDatabaseNodeProperty {
    description: string;
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbDatabasesDatabaseInstanceDatabaseNodeProtectionDomain {
    assocEntities: string[];
    cloudId: string;
    dateCreated: string;
    dateModified: string;
    description: string;
    eraCreated: boolean;
    id: string;
    name: string;
    ownerId: string;
    primaryHost: string;
    /**
     * List of all the properties
     */
    properties: outputs.GetNdbDatabasesDatabaseInstanceDatabaseNodeProtectionDomainProperty[];
    status: string;
    type: string;
}

export interface GetNdbDatabasesDatabaseInstanceDatabaseNodeProtectionDomainProperty {
    description: string;
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbDatabasesDatabaseInstanceDatabaseNodeTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbDatabasesDatabaseInstanceInfo {
    bpgConfigs: outputs.GetNdbDatabasesDatabaseInstanceInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface GetNdbDatabasesDatabaseInstanceInfoBpgConfig {
    bpgDbParams: outputs.GetNdbDatabasesDatabaseInstanceInfoBpgConfigBpgDbParam[];
    storages: outputs.GetNdbDatabasesDatabaseInstanceInfoBpgConfigStorage[];
    vmProperties: outputs.GetNdbDatabasesDatabaseInstanceInfoBpgConfigVmProperty[];
}

export interface GetNdbDatabasesDatabaseInstanceInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface GetNdbDatabasesDatabaseInstanceInfoBpgConfigStorage {
    archiveStorages: outputs.GetNdbDatabasesDatabaseInstanceInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.GetNdbDatabasesDatabaseInstanceInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.GetNdbDatabasesDatabaseInstanceInfoBpgConfigStorageLogDisk[];
}

export interface GetNdbDatabasesDatabaseInstanceInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface GetNdbDatabasesDatabaseInstanceInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface GetNdbDatabasesDatabaseInstanceInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface GetNdbDatabasesDatabaseInstanceInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface GetNdbDatabasesDatabaseInstanceLcmConfig {
    expiryDetails: outputs.GetNdbDatabasesDatabaseInstanceLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.GetNdbDatabasesDatabaseInstanceLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.GetNdbDatabasesDatabaseInstanceLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.GetNdbDatabasesDatabaseInstanceLcmConfigRefreshDetail[];
}

export interface GetNdbDatabasesDatabaseInstanceLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface GetNdbDatabasesDatabaseInstanceLcmConfigPostDeleteCommand {
    command: string;
}

export interface GetNdbDatabasesDatabaseInstanceLcmConfigPreDeleteCommand {
    command: string;
}

export interface GetNdbDatabasesDatabaseInstanceLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface GetNdbDatabasesDatabaseInstanceLinkedDatabase {
    databaseName: string;
    databaseStatus: string;
    dateCreated: string;
    dateModified: string;
    description: string;
    id: string;
    infos: outputs.GetNdbDatabasesDatabaseInstanceLinkedDatabaseInfo[];
    metric: {[key: string]: string};
    name: string;
    parentDatabaseId: string;
    parentLinkedDatabaseId: string;
    snapshotId: string;
    status: string;
    timezone: string;
}

export interface GetNdbDatabasesDatabaseInstanceLinkedDatabaseInfo {
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface GetNdbDatabasesDatabaseInstanceMetadata {
    baseSizeComputed: boolean;
    capabilityResetTime: string;
    createdDbservers: string[];
    deregisterInfos: outputs.GetNdbDatabasesDatabaseInstanceMetadataDeregisterInfo[];
    deregisteredWithDeleteTimeMachine: boolean;
    info: {[key: string]: string};
    lastLogCatchupForRestoreOperationId: string;
    lastRefreshTimestamp: string;
    lastRequestedRefreshTimestamp: string;
    logCatchupForRestoreDispatched: boolean;
    originalDatabaseName: string;
    pitrBased: boolean;
    provisionOperationId: string;
    refreshBlockerInfo: string;
    registeredDbservers: string[];
    secureInfo: {[key: string]: string};
    sourceSnapshotId: string;
    stateBeforeRefresh: string;
    stateBeforeRestore: string;
    stateBeforeScaling: string;
    tmActivateOperationId: string;
}

export interface GetNdbDatabasesDatabaseInstanceMetadataDeregisterInfo {
    message: string;
    operations: string[];
}

export interface GetNdbDatabasesDatabaseInstanceProperty {
    description: string;
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbDatabasesDatabaseInstanceTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachine {
    accessLevel: string;
    clone: boolean;
    clones: string;
    clustered: boolean;
    database: string;
    databaseId: string;
    dateCreated: string;
    dateModified: string;
    description: string;
    eaStatus: string;
    id: string;
    metric: string;
    name: string;
    /**
     * List of all the properties
     */
    properties: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineProperty[];
    scheduleId: string;
    schedules: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineSchedule[];
    scope: string;
    slaId: string;
    slaUpdateInProgress: boolean;
    slaUpdateMetadata: string;
    slas: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineSla[];
    sourceNxClusters: string[];
    status: string;
    tags: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineTag[];
    type: string;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineProperty {
    description: string;
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineSchedule {
    continuousSchedules: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineScheduleDailySchedule[];
    dateCreated: string;
    dateModified: string;
    description: string;
    globalPolicy: boolean;
    id: string;
    monthlySchedules: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineScheduleMonthlySchedule[];
    name: string;
    ownerId: string;
    quartelySchedules: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineScheduleYearlySchedule[];
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    dateCreated: string;
    dateModified: string;
    description: string;
    id: string;
    monthlyRetention: number;
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbDbserverProperty {
    /**
     * name of database server vm
     */
    name: string;
    value: string;
}

export interface GetNdbDbserverTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbDbserverVmInfo {
    deregisterInfos: outputs.GetNdbDbserverVmInfoDeregisterInfo[];
    distribution: {[key: string]: string};
    infos: outputs.GetNdbDbserverVmInfoInfo[];
    networkInfos: outputs.GetNdbDbserverVmInfoNetworkInfo[];
    osType: string;
    osVersion: string;
    secureInfo: {[key: string]: string};
}

export interface GetNdbDbserverVmInfoDeregisterInfo {
    message: string;
    operations: string[];
}

export interface GetNdbDbserverVmInfoInfo {
    bpgConfigs: outputs.GetNdbDbserverVmInfoInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface GetNdbDbserverVmInfoInfoBpgConfig {
    bpgDbParams: outputs.GetNdbDbserverVmInfoInfoBpgConfigBpgDbParam[];
    storages: outputs.GetNdbDbserverVmInfoInfoBpgConfigStorage[];
    vmProperties: outputs.GetNdbDbserverVmInfoInfoBpgConfigVmProperty[];
}

export interface GetNdbDbserverVmInfoInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface GetNdbDbserverVmInfoInfoBpgConfigStorage {
    archiveStorages: outputs.GetNdbDbserverVmInfoInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.GetNdbDbserverVmInfoInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.GetNdbDbserverVmInfoInfoBpgConfigStorageLogDisk[];
}

export interface GetNdbDbserverVmInfoInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface GetNdbDbserverVmInfoInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface GetNdbDbserverVmInfoInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface GetNdbDbserverVmInfoInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface GetNdbDbserverVmInfoNetworkInfo {
    accessInfos: outputs.GetNdbDbserverVmInfoNetworkInfoAccessInfo[];
    defaultGatewayDevice: boolean;
    deviceName: string;
    eraConfigured: boolean;
    flags: string;
    gateway: string;
    hostname: string;
    /**
     * IP addresses of the dbserver vm
     */
    ipAddresses: string[];
    macAddress: string;
    mtu: string;
    subnetMask: string;
    vlanName: string;
    vlanType: string;
    vlanUuid: string;
}

export interface GetNdbDbserverVmInfoNetworkInfoAccessInfo {
    accessType: string;
    destinationSubnet: string;
}

export interface GetNdbDbserversDbserver {
    /**
     * access key id of dbserver vm
     */
    accessKeyId: string;
    /**
     * access level
     */
    accessLevel: string;
    /**
     * associated time machines ids
     */
    associatedTimeMachineIds: string[];
    /**
     * client id
     */
    clientId: string;
    /**
     * clustered or not
     */
    clustered: boolean;
    /**
     * database type
     */
    databaseType: string;
    /**
     * date created of db server vm
     */
    dateCreated: string;
    /**
     * date modified of db server vm
     */
    dateModified: string;
    /**
     * dbserver invalid ea state
     */
    dbserverInvalidEaState: boolean;
    /**
     * description of db server vm
     */
    description: string;
    /**
     * era drive id
     */
    eraDriveId: string;
    /**
     * era version
     */
    eraVersion: string;
    fqdns: string;
    id: string;
    /**
     * IP addresses of the dbserver vm
     */
    ipAddresses: string[];
    /**
     * is server down or not
     */
    isServerDriven: boolean;
    /**
     * Mac addresses of dbserver vm
     */
    macAddresses: string[];
    /**
     * name of dbserver vm
     */
    name: string;
    /**
     * properties of db server vm
     */
    properties: outputs.GetNdbDbserversDbserverProperty[];
    /**
     * protection domain id
     */
    protectionDomainId: string;
    /**
     * query count
     */
    queryCount: number;
    /**
     * Status of Dbserver . Active or not.
     */
    status: string;
    /**
     * tags for db server vm
     */
    tags: outputs.GetNdbDbserversDbserverTag[];
    /**
     * Type of entity. i.e. Dbserver
     */
    type: string;
    /**
     * valid diagnostic bundle state
     */
    validDiagnosticBundleState: boolean;
    /**
     * clusetr uuid for dbserver vm
     */
    vmClusterUuid: string;
    /**
     * info of dbserver vm
     */
    vmInfos: outputs.GetNdbDbserversDbserverVmInfo[];
    /**
     * timezone of dbserver vm
     */
    vmTimezone: string;
    /**
     * window db server
     */
    windowsDbServer: boolean;
    /**
     * working directory of db server vm
     */
    workingDirectory: string;
}

export interface GetNdbDbserversDbserverProperty {
    /**
     * name of dbserver vm
     */
    name: string;
    value: string;
}

export interface GetNdbDbserversDbserverTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbDbserversDbserverVmInfo {
    deregisterInfos: outputs.GetNdbDbserversDbserverVmInfoDeregisterInfo[];
    distribution: {[key: string]: string};
    infos: outputs.GetNdbDbserversDbserverVmInfoInfo[];
    networkInfos: outputs.GetNdbDbserversDbserverVmInfoNetworkInfo[];
    osType: string;
    osVersion: string;
    secureInfo: {[key: string]: string};
}

export interface GetNdbDbserversDbserverVmInfoDeregisterInfo {
    message: string;
    operations: string[];
}

export interface GetNdbDbserversDbserverVmInfoInfo {
    bpgConfigs: outputs.GetNdbDbserversDbserverVmInfoInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface GetNdbDbserversDbserverVmInfoInfoBpgConfig {
    bpgDbParams: outputs.GetNdbDbserversDbserverVmInfoInfoBpgConfigBpgDbParam[];
    storages: outputs.GetNdbDbserversDbserverVmInfoInfoBpgConfigStorage[];
    vmProperties: outputs.GetNdbDbserversDbserverVmInfoInfoBpgConfigVmProperty[];
}

export interface GetNdbDbserversDbserverVmInfoInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface GetNdbDbserversDbserverVmInfoInfoBpgConfigStorage {
    archiveStorages: outputs.GetNdbDbserversDbserverVmInfoInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.GetNdbDbserversDbserverVmInfoInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.GetNdbDbserversDbserverVmInfoInfoBpgConfigStorageLogDisk[];
}

export interface GetNdbDbserversDbserverVmInfoInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface GetNdbDbserversDbserverVmInfoInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface GetNdbDbserversDbserverVmInfoInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface GetNdbDbserversDbserverVmInfoInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface GetNdbDbserversDbserverVmInfoNetworkInfo {
    accessInfos: outputs.GetNdbDbserversDbserverVmInfoNetworkInfoAccessInfo[];
    defaultGatewayDevice: boolean;
    deviceName: string;
    eraConfigured: boolean;
    flags: string;
    gateway: string;
    hostname: string;
    /**
     * IP addresses of the dbserver vm
     */
    ipAddresses: string[];
    macAddress: string;
    mtu: string;
    subnetMask: string;
    vlanName: string;
    vlanType: string;
    vlanUuid: string;
}

export interface GetNdbDbserversDbserverVmInfoNetworkInfoAccessInfo {
    accessType: string;
    destinationSubnet: string;
}

export interface GetNdbMaintenanceWindowEntityTaskAssoc {
    /**
     * access level
     */
    accessLevel: string;
    /**
     * created date of maintenance window
     */
    dateCreated: string;
    /**
     * modified date of maintenance window
     */
    dateModified: string;
    /**
     * description of maintenance window
     */
    description: string;
    entity: string;
    entityId: string;
    entityType: string;
    /**
     * Maintenance window id.
     */
    id: string;
    maintenanceWindowId: string;
    maintenanceWindowOwnerId: string;
    /**
     * name of maintenance window
     */
    name: string;
    /**
     * owner id of maintenance window
     */
    ownerId: string;
    payloads: outputs.GetNdbMaintenanceWindowEntityTaskAssocPayload[];
    /**
     * properties of maintenance window
     */
    properties: outputs.GetNdbMaintenanceWindowEntityTaskAssocProperty[];
    /**
     * status of maintennace window
     */
    status: string;
    /**
     * tags of maintenance window
     */
    tags: outputs.GetNdbMaintenanceWindowEntityTaskAssocTag[];
    taskType: string;
}

export interface GetNdbMaintenanceWindowEntityTaskAssocPayload {
    prePostCommands: outputs.GetNdbMaintenanceWindowEntityTaskAssocPayloadPrePostCommand[];
}

export interface GetNdbMaintenanceWindowEntityTaskAssocPayloadPrePostCommand {
    postCommand: string;
    preCommand: string;
}

export interface GetNdbMaintenanceWindowEntityTaskAssocProperty {
    /**
     * name of maintenance window
     */
    name: string;
    value: string;
}

export interface GetNdbMaintenanceWindowEntityTaskAssocTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbMaintenanceWindowProperty {
    /**
     * name of maintenance window
     */
    name: string;
    value: string;
}

export interface GetNdbMaintenanceWindowSchedule {
    dayOfWeek: string;
    duration: number;
    hour: number;
    minute: number;
    recurrence: string;
    startTime?: string;
    threshold: string;
    /**
     * timezone
     */
    timezone: string;
    weekOfMonth: number;
}

export interface GetNdbMaintenanceWindowTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbMaintenanceWindowsMaintenanceWindow {
    /**
     * access level
     */
    accessLevel: string;
    /**
     * created date of maintenance window
     */
    dateCreated: string;
    /**
     * modified date of maintenance window
     */
    dateModified: string;
    /**
     * description of maintenance window
     */
    description: string;
    /**
     * entity task association for maintenance window
     */
    entityTaskAssocs: outputs.GetNdbMaintenanceWindowsMaintenanceWindowEntityTaskAssoc[];
    id: string;
    /**
     * name of maintenance window
     */
    name: string;
    /**
     * next run time for maintenance window to trigger
     */
    nextRunTime: string;
    /**
     * owner id of maintenance window
     */
    ownerId: string;
    /**
     * properties of maintenance window
     */
    properties: outputs.GetNdbMaintenanceWindowsMaintenanceWindowProperty[];
    /**
     * schedule of maintenance window
     */
    schedules: outputs.GetNdbMaintenanceWindowsMaintenanceWindowSchedule[];
    /**
     * status of maintennace window
     */
    status: string;
    /**
     * tags of maintenance window
     */
    tags: outputs.GetNdbMaintenanceWindowsMaintenanceWindowTag[];
    /**
     * timezone
     */
    timezone: string;
}

export interface GetNdbMaintenanceWindowsMaintenanceWindowEntityTaskAssoc {
    /**
     * access level
     */
    accessLevel: string;
    /**
     * created date of maintenance window
     */
    dateCreated: string;
    /**
     * modified date of maintenance window
     */
    dateModified: string;
    /**
     * description of maintenance window
     */
    description: string;
    entity: string;
    entityId: string;
    entityType: string;
    id: string;
    maintenanceWindowId: string;
    maintenanceWindowOwnerId: string;
    /**
     * name of maintenance window
     */
    name: string;
    /**
     * owner id of maintenance window
     */
    ownerId: string;
    payloads: outputs.GetNdbMaintenanceWindowsMaintenanceWindowEntityTaskAssocPayload[];
    /**
     * properties of maintenance window
     */
    properties: outputs.GetNdbMaintenanceWindowsMaintenanceWindowEntityTaskAssocProperty[];
    /**
     * status of maintennace window
     */
    status: string;
    /**
     * tags of maintenance window
     */
    tags: outputs.GetNdbMaintenanceWindowsMaintenanceWindowEntityTaskAssocTag[];
    taskType: string;
}

export interface GetNdbMaintenanceWindowsMaintenanceWindowEntityTaskAssocPayload {
    prePostCommands: outputs.GetNdbMaintenanceWindowsMaintenanceWindowEntityTaskAssocPayloadPrePostCommand[];
}

export interface GetNdbMaintenanceWindowsMaintenanceWindowEntityTaskAssocPayloadPrePostCommand {
    postCommand: string;
    preCommand: string;
}

export interface GetNdbMaintenanceWindowsMaintenanceWindowEntityTaskAssocProperty {
    /**
     * name of maintenance window
     */
    name: string;
    value: string;
}

export interface GetNdbMaintenanceWindowsMaintenanceWindowEntityTaskAssocTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbMaintenanceWindowsMaintenanceWindowProperty {
    /**
     * name of maintenance window
     */
    name: string;
    value: string;
}

export interface GetNdbMaintenanceWindowsMaintenanceWindowSchedule {
    dayOfWeek: string;
    duration: number;
    hour: number;
    minute: number;
    recurrence: string;
    startTime?: string;
    threshold: string;
    /**
     * timezone
     */
    timezone: string;
    weekOfMonth: number;
}

export interface GetNdbMaintenanceWindowsMaintenanceWindowTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbNetworkAvailableIpsAvailableIp {
    /**
     * cluster id
     */
    clusterId: string;
    /**
     * cluster name
     */
    clusterName: string;
    /**
     * network profile id
     */
    id: string;
    /**
     * list of available ips in network
     */
    ipAddresses: string[];
    /**
     * managed by ndb or not
     */
    managed: boolean;
    /**
     * Network Name
     */
    name: string;
    /**
     * property name of vlan
     */
    propertyName: string;
    /**
     * type of network
     */
    type: string;
}

export interface GetNdbNetworkIpAddress {
    /**
     * dbserver id
     */
    dbserverId: string;
    /**
     * dbserver name
     */
    dbserverName: string;
    /**
     * ip of pool
     */
    ip: string;
    /**
     * ip status
     */
    status: string;
}

export interface GetNdbNetworkIpPool {
    /**
     * address of ips ranges
     */
    addresses: outputs.GetNdbNetworkIpPoolAddress[];
    /**
     * end ip
     */
    endIp: string;
    /**
     * start ip
     */
    startIp: string;
}

export interface GetNdbNetworkIpPoolAddress {
    /**
     * ip of pool
     */
    ip: string;
    /**
     * ip status
     */
    status: string;
}

export interface GetNdbNetworkPropertiesMap {
    /**
     * gateway of vlan
     */
    vlanGateway: string;
    /**
     * primary dns of vlan
     */
    vlanPrimaryDns: string;
    /**
     * secondary dns of vlan
     */
    vlanSecondaryDns: string;
    /**
     * subnet mask of vlan
     */
    vlanSubnetMask: string;
}

export interface GetNdbNetworkProperty {
    /**
     * name of network
     */
    name: string;
    secure: boolean;
    value: string;
}

export interface GetNdbNetworksNetwork {
    /**
     * cluster id where network is present
     */
    clusterId: string;
    /**
     * network id
     */
    id: string;
    /**
     * IP addresses of network
     */
    ipAddresses: outputs.GetNdbNetworksNetworkIpAddress[];
    /**
     * IP Pools of network
     */
    ipPools: outputs.GetNdbNetworksNetworkIpPool[];
    /**
     * network managed by NDB or not
     */
    managed: boolean;
    /**
     * network name
     */
    name: string;
    /**
     * properties of network
     */
    properties: outputs.GetNdbNetworksNetworkProperty[];
    /**
     * properties map of network
     */
    propertiesMaps: outputs.GetNdbNetworksNetworkPropertiesMap[];
    /**
     * stretched vlan id
     */
    stretchedVlanId: string;
    /**
     * type of network
     */
    type: string;
}

export interface GetNdbNetworksNetworkIpAddress {
    /**
     * dbserver id
     */
    dbserverId: string;
    /**
     * dbserver name
     */
    dbserverName: string;
    /**
     * ip of pool
     */
    ip: string;
    /**
     * ip status
     */
    status: string;
}

export interface GetNdbNetworksNetworkIpPool {
    /**
     * address of ips ranges
     */
    addresses: outputs.GetNdbNetworksNetworkIpPoolAddress[];
    /**
     * end ip
     */
    endIp: string;
    /**
     * start ip
     */
    startIp: string;
}

export interface GetNdbNetworksNetworkIpPoolAddress {
    /**
     * ip of pool
     */
    ip: string;
    /**
     * ip status
     */
    status: string;
}

export interface GetNdbNetworksNetworkPropertiesMap {
    /**
     * gateway of vlan
     */
    vlanGateway: string;
    /**
     * primary dns of vlan
     */
    vlanPrimaryDns: string;
    /**
     * secondary dns of vlan
     */
    vlanSecondaryDns: string;
    /**
     * subnet mask of vlan
     */
    vlanSubnetMask: string;
}

export interface GetNdbNetworksNetworkProperty {
    /**
     * network name
     */
    name: string;
    secure: boolean;
    value: string;
}

export interface GetNdbProfileClusterAvailability {
    dateCreated: string;
    dateModified: string;
    /**
     * - era cluster ID
     */
    nxClusterId: string;
    ownerId: string;
    /**
     * Profile ID for query
     */
    profileId: string;
    /**
     * - status of profile
     */
    status: string;
}

export interface GetNdbProfileVersion {
    /**
     * - database version
     */
    dbVersion: string;
    deprecated: boolean;
    /**
     * - description of profile
     */
    description: string;
    /**
     * - database engine type
     */
    engineType: string;
    /**
     * - id of profile
     */
    id: string;
    /**
     * - profile name
     */
    name: string;
    /**
     * - owner name
     */
    owner: string;
    /**
     * Profile ID for query
     */
    profileId: string;
    properties: outputs.GetNdbProfileVersionProperty[];
    propertiesMap: {[key: string]: string};
    published: boolean;
    /**
     * - status of profile
     */
    status: string;
    /**
     * - if system profile or not
     */
    systemProfile: boolean;
    /**
     * - topology
     */
    topology: string;
    type: string;
    version: string;
    versionClusterAssociations: outputs.GetNdbProfileVersionVersionClusterAssociation[];
}

export interface GetNdbProfileVersionProperty {
    /**
     * - profile name
     */
    name: string;
    secure: boolean;
    value: string;
}

export interface GetNdbProfileVersionVersionClusterAssociation {
    dateCreated: string;
    dateModified: string;
    /**
     * - era cluster ID
     */
    nxClusterId: string;
    optimizedForProvisioning: boolean;
    ownerId: string;
    profileVersionId: string;
    properties: outputs.GetNdbProfileVersionVersionClusterAssociationProperty[];
    /**
     * - status of profile
     */
    status: string;
}

export interface GetNdbProfileVersionVersionClusterAssociationProperty {
    /**
     * - profile name
     */
    name: string;
    secure: boolean;
    value: string;
}

export interface GetNdbProfilesProfile {
    assocDatabases: string[];
    assocDbServers: string[];
    clusterAvailabilities: outputs.GetNdbProfilesProfileClusterAvailability[];
    dbVersion: string;
    description: string;
    engineType: string;
    id: string;
    latestVersion: string;
    latestVersionId: string;
    name: string;
    nxClusterId: string;
    owner: string;
    status: string;
    systemProfile: boolean;
    topology: string;
    type: string;
    versions: outputs.GetNdbProfilesProfileVersion[];
}

export interface GetNdbProfilesProfileClusterAvailability {
    dateCreated: string;
    dateModified: string;
    nxClusterId: string;
    ownerId: string;
    profileId: string;
    status: string;
}

export interface GetNdbProfilesProfileVersion {
    dbVersion: string;
    deprecated: boolean;
    description: string;
    engineType: string;
    id: string;
    name: string;
    owner: string;
    profileId: string;
    properties: outputs.GetNdbProfilesProfileVersionProperty[];
    propertiesMap: {[key: string]: string};
    published: boolean;
    status: string;
    systemProfile: boolean;
    topology: string;
    type: string;
    version: string;
    versionClusterAssociations: outputs.GetNdbProfilesProfileVersionVersionClusterAssociation[];
}

export interface GetNdbProfilesProfileVersionProperty {
    name: string;
    secure: boolean;
    value: string;
}

export interface GetNdbProfilesProfileVersionVersionClusterAssociation {
    dateCreated: string;
    dateModified: string;
    nxClusterId: string;
    optimizedForProvisioning: boolean;
    ownerId: string;
    profileVersionId: string;
    properties: outputs.GetNdbProfilesProfileVersionVersionClusterAssociationProperty[];
    status: string;
}

export interface GetNdbProfilesProfileVersionVersionClusterAssociationProperty {
    name: string;
    secure: boolean;
    value: string;
}

export interface GetNdbSlasSla {
    /**
     * - continuous retention of logs limit
     */
    continuousRetention: number;
    /**
     * - Current active frequency
     */
    currentActiveFrequency: string;
    /**
     * - Daily snapshots retention limit
     */
    dailyRetention: number;
    /**
     * - creation date
     */
    dateCreated: string;
    /**
     * - last modified
     */
    dateModified: string;
    /**
     * - description of sla
     */
    description: string;
    /**
     * - ID of sla
     */
    id: string;
    /**
     * - Monthly snapshots retention limit
     */
    monthlyRetention: number;
    /**
     * - sla name
     */
    name: string;
    /**
     * - owner ID
     */
    ownerId: string;
    /**
     * - If point in time recovery enabled
     */
    pitrEnabled: boolean;
    /**
     * - Daily snapshots retention limit
     */
    quartelyRetention: number;
    /**
     * - Reference count
     */
    referenceCount: number;
    /**
     * - if system sla
     */
    systemSla: boolean;
    /**
     * - unique name
     */
    uniqueName: string;
    /**
     * - weeky snapshots retention limit
     */
    weeklyRetention: number;
    /**
     * - Yearly snapshots retention limit
     */
    yearlyRetention: number;
}

export interface GetNdbSnapshotFilter {
    /**
     * load child snapshots. Default is false
     */
    loadReplicatedChildSnapshots?: string;
    /**
     * Default is UTC
     */
    timezone?: string;
}

export interface GetNdbSnapshotLcmConfig {
    expiryDetails: outputs.GetNdbSnapshotLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.GetNdbSnapshotLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.GetNdbSnapshotLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.GetNdbSnapshotLcmConfigRefreshDetail[];
}

export interface GetNdbSnapshotLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface GetNdbSnapshotLcmConfigPostDeleteCommand {
    command: string;
}

export interface GetNdbSnapshotLcmConfigPreDeleteCommand {
    command: string;
}

export interface GetNdbSnapshotLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface GetNdbSnapshotProperty {
    /**
     * description of snapshot
     */
    description: string;
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbSnapshotTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbSnapshotsFilter {
    /**
     * Fetches all the snapshots for a given time machine
     */
    timeMachineId?: string;
}

export interface GetNdbSnapshotsSnapshot {
    appInfoVersion: string;
    applicableTypes: string[];
    databaseNodeId: string;
    databaseSnapshot: boolean;
    dateCreated: string;
    dateModified: string;
    dbserverId: string;
    dbserverIp: string;
    dbserverName: string;
    dbserverStorageMetadataVersion: number;
    description: string;
    fromTimestamp: string;
    id: string;
    lcmConfigs: outputs.GetNdbSnapshotsSnapshotLcmConfig[];
    name: string;
    nxClusterId: string;
    parentSnapshot: boolean;
    parentSnapshotId: string;
    processed: boolean;
    /**
     * List of all the properties
     */
    properties: outputs.GetNdbSnapshotsSnapshotProperty[];
    protectionDomainId: string;
    replicatedSnapshots: string[];
    santized: boolean;
    santizedFromSnapshotId: string;
    santizedSnapshots: string;
    snapshotFamily: string;
    snapshotSize: number;
    snapshotTimestamp: string;
    snapshotTimestampDate: number;
    snapshotUuid: string;
    softwareDatabaseSnapshot: boolean;
    softwareSnapshot: string;
    softwareSnapshotId: string;
    status: string;
    tags: outputs.GetNdbSnapshotsSnapshotTag[];
    /**
     * Fetches all the snapshots for a given time machine
     */
    timeMachineId: string;
    timezone: string;
    toTimestamp: string;
    type: string;
}

export interface GetNdbSnapshotsSnapshotLcmConfig {
    expiryDetails: outputs.GetNdbSnapshotsSnapshotLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.GetNdbSnapshotsSnapshotLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.GetNdbSnapshotsSnapshotLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.GetNdbSnapshotsSnapshotLcmConfigRefreshDetail[];
}

export interface GetNdbSnapshotsSnapshotLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface GetNdbSnapshotsSnapshotLcmConfigPostDeleteCommand {
    command: string;
}

export interface GetNdbSnapshotsSnapshotLcmConfigPreDeleteCommand {
    command: string;
}

export interface GetNdbSnapshotsSnapshotLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface GetNdbSnapshotsSnapshotProperty {
    description: string;
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbSnapshotsSnapshotTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbTagsTag {
    /**
     * date created of the tag
     */
    dateCreated: string;
    /**
     * modified date of tha tag
     */
    dateModified: string;
    /**
     * description for the tag
     */
    description: string;
    /**
     * entity for the tag to be associated with.
     */
    entityType: string;
    id: string;
    /**
     * name for the tag
     */
    name: string;
    /**
     * owner id of the tag
     */
    owner: string;
    /**
     * tag value for entities.
     */
    required: boolean;
    /**
     * Status of the tag
     */
    status: string;
    /**
     * value for the tag
     */
    values: number;
}

export interface GetNdbTimeMachineProperty {
    /**
     * time machine description
     */
    description: string;
    /**
     * time machine name
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbTimeMachineSchedule {
    continuousSchedules: outputs.GetNdbTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.GetNdbTimeMachineScheduleDailySchedule[];
    /**
     * date created
     */
    dateCreated: string;
    /**
     * date modified
     */
    dateModified: string;
    /**
     * time machine description
     */
    description: string;
    globalPolicy: boolean;
    /**
     * time machine id
     */
    id: string;
    monthlySchedules: outputs.GetNdbTimeMachineScheduleMonthlySchedule[];
    /**
     * time machine name
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.GetNdbTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.GetNdbTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.GetNdbTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.GetNdbTimeMachineScheduleYearlySchedule[];
}

export interface GetNdbTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface GetNdbTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface GetNdbTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface GetNdbTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface GetNdbTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface GetNdbTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface GetNdbTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface GetNdbTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    /**
     * date created
     */
    dateCreated: string;
    /**
     * date modified
     */
    dateModified: string;
    /**
     * time machine description
     */
    description: string;
    /**
     * time machine id
     */
    id: string;
    monthlyRetention: number;
    /**
     * time machine name
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface GetNdbTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbTimeMachinesTimeMachine {
    /**
     * access level to time machines
     */
    accessLevel: string;
    /**
     * clone time machine or not
     */
    clone: boolean;
    /**
     * clone info
     */
    clones: string;
    /**
     * clustered or not
     */
    clustered: boolean;
    /**
     * database info
     */
    database: string;
    /**
     * database id
     */
    databaseId: string;
    /**
     * date created
     */
    dateCreated: string;
    /**
     * date modified
     */
    dateModified: string;
    /**
     * time machine description
     */
    description: string;
    /**
     * ea status of time machine
     */
    eaStatus: string;
    /**
     * time machine id
     */
    id: string;
    /**
     * Metric info
     */
    metric: string;
    /**
     * time machine name
     */
    name: string;
    /**
     * List of all the properties
     */
    properties: outputs.GetNdbTimeMachinesTimeMachineProperty[];
    /**
     * schedule id
     */
    scheduleId: string;
    /**
     * schedule info
     *
     *
     * See detailed information in [NDB Time Machines](https://www.nutanix.dev/api_references/ndb/#/e68ba687086ed-get-list-of-all-time-machines).
     */
    schedules: outputs.GetNdbTimeMachinesTimeMachineSchedule[];
    /**
     * scope
     */
    scope: string;
    /**
     * sla id
     */
    slaId: string;
    /**
     * sla update in progress
     */
    slaUpdateInProgress: boolean;
    /**
     * sla update metadata
     */
    slaUpdateMetadata: string;
    /**
     * sla info
     */
    slas: outputs.GetNdbTimeMachinesTimeMachineSla[];
    /**
     * source clusters
     */
    sourceNxClusters: string[];
    /**
     * status of time machine
     */
    status: string;
    /**
     * tags
     */
    tags: outputs.GetNdbTimeMachinesTimeMachineTag[];
    /**
     * type of time machine
     */
    type: string;
}

export interface GetNdbTimeMachinesTimeMachineProperty {
    /**
     * time machine description
     */
    description: string;
    /**
     * time machine name
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbTimeMachinesTimeMachineSchedule {
    continuousSchedules: outputs.GetNdbTimeMachinesTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.GetNdbTimeMachinesTimeMachineScheduleDailySchedule[];
    /**
     * date created
     */
    dateCreated: string;
    /**
     * date modified
     */
    dateModified: string;
    /**
     * time machine description
     */
    description: string;
    globalPolicy: boolean;
    /**
     * time machine id
     */
    id: string;
    monthlySchedules: outputs.GetNdbTimeMachinesTimeMachineScheduleMonthlySchedule[];
    /**
     * time machine name
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.GetNdbTimeMachinesTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.GetNdbTimeMachinesTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.GetNdbTimeMachinesTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.GetNdbTimeMachinesTimeMachineScheduleYearlySchedule[];
}

export interface GetNdbTimeMachinesTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface GetNdbTimeMachinesTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface GetNdbTimeMachinesTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface GetNdbTimeMachinesTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface GetNdbTimeMachinesTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface GetNdbTimeMachinesTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface GetNdbTimeMachinesTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface GetNdbTimeMachinesTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    /**
     * date created
     */
    dateCreated: string;
    /**
     * date modified
     */
    dateModified: string;
    /**
     * time machine description
     */
    description: string;
    /**
     * time machine id
     */
    id: string;
    monthlyRetention: number;
    /**
     * time machine name
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface GetNdbTimeMachinesTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbTmsCapabilityCapability {
    continuousRegions: outputs.GetNdbTmsCapabilityCapabilityContinuousRegion[];
    databaseIds: string[];
    databasesContinuousRegion: string;
    from: string;
    mode: string;
    snapshots: outputs.GetNdbTmsCapabilityCapabilitySnapshot[];
    timeUnit: string;
    timeUnitNumber: string;
    to: string;
}

export interface GetNdbTmsCapabilityCapabilityContinuousRegion {
    dbLogs: outputs.GetNdbTmsCapabilityCapabilityContinuousRegionDbLog[];
    fromTime: string;
    message: string;
    partialRanges: boolean;
    processedRanges: outputs.GetNdbTmsCapabilityCapabilityContinuousRegionProcessedRange[];
    snapshotIds: string[];
    snapshots: string;
    subRange: boolean;
    timeRangeAndDatabases: string;
    timezone: string;
    toTime: string;
    unknownTimeRanges: string;
    unprocessedRanges: outputs.GetNdbTmsCapabilityCapabilityContinuousRegionUnprocessedRange[];
}

export interface GetNdbTmsCapabilityCapabilityContinuousRegionDbLog {
    databaseId: string;
    databaseNodeId: string;
    dateCreated: string;
    dateModified: string;
    eraLogDriveId: string;
    fromTime: string;
    id: string;
    infos: outputs.GetNdbTmsCapabilityCapabilityContinuousRegionDbLogInfo[];
    logCopyOperationId: string;
    message: string;
    metadatas: outputs.GetNdbTmsCapabilityCapabilityContinuousRegionDbLogMetadata[];
    name: string;
    ownerId: string;
    size: number;
    status: string;
    toTime: string;
    unprocessed: boolean;
}

export interface GetNdbTmsCapabilityCapabilityContinuousRegionDbLogInfo {
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
    unknownTimeRange: boolean;
}

export interface GetNdbTmsCapabilityCapabilityContinuousRegionDbLogMetadata {
    createdDirectly: boolean;
    curationRetryCount: number;
    deregisterInfos: outputs.GetNdbTmsCapabilityCapabilityContinuousRegionDbLogMetadataDeregisterInfo[];
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
    updatedDirectly: boolean;
}

export interface GetNdbTmsCapabilityCapabilityContinuousRegionDbLogMetadataDeregisterInfo {
    message: string;
    operations: string[];
}

export interface GetNdbTmsCapabilityCapabilityContinuousRegionProcessedRange {
    first: string;
    second: string;
}

export interface GetNdbTmsCapabilityCapabilityContinuousRegionUnprocessedRange {
    first: string;
    second: string;
}

export interface GetNdbTmsCapabilityCapabilitySnapshot {
    appInfoVersion: string;
    applicableTypes: string[];
    databaseNodeId: string;
    databaseSnapshot: boolean;
    dateCreated: string;
    dateModified: string;
    dbserverId: string;
    dbserverIp: string;
    dbserverName: string;
    dbserverStorageMetadataVersion: number;
    description: string;
    fromTimestamp: string;
    id: string;
    lcmConfigs: outputs.GetNdbTmsCapabilityCapabilitySnapshotLcmConfig[];
    metadatas: outputs.GetNdbTmsCapabilityCapabilitySnapshotMetadata[];
    name: string;
    nxClusterId: string;
    ownerId: string;
    parentSnapshot: boolean;
    parentSnapshotId: string;
    processed: boolean;
    /**
     * List of all the properties
     */
    properties: outputs.GetNdbTmsCapabilityCapabilitySnapshotProperty[];
    protectionDomainId: string;
    replicatedSnapshots: string[];
    santized: boolean;
    santizedFromSnapshotId: string;
    santizedSnapshots: string;
    snapshotFamily: string;
    snapshotSize: number;
    snapshotTimestamp: string;
    snapshotTimestampDate: number;
    snapshotUuid: string;
    softwareDatabaseSnapshot: boolean;
    softwareSnapshot: string;
    softwareSnapshotId: string;
    status: string;
    tags: outputs.GetNdbTmsCapabilityCapabilitySnapshotTag[];
    timeMachineId: string;
    timezone: string;
    toTimestamp: string;
    type: string;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotLcmConfig {
    expiryDetails: outputs.GetNdbTmsCapabilityCapabilitySnapshotLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.GetNdbTmsCapabilityCapabilitySnapshotLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.GetNdbTmsCapabilityCapabilitySnapshotLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.GetNdbTmsCapabilityCapabilitySnapshotLcmConfigRefreshDetail[];
}

export interface GetNdbTmsCapabilityCapabilitySnapshotLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotLcmConfigPostDeleteCommand {
    command: string;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotLcmConfigPreDeleteCommand {
    command: string;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotMetadata {
    async: boolean;
    curationRetryCount: number;
    deregisterInfo: {[key: string]: string};
    fromTimestamp: string;
    infos: outputs.GetNdbTmsCapabilityCapabilitySnapshotMetadataInfo[];
    lastReplicationRetyrSourceSnapshotId: string;
    operationsUsingSnapshots: string[];
    replicationRetryCount: number;
    secureInfo: {[key: string]: string};
    standBy: boolean;
    toTimestamp: string;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotMetadataInfo {
    bpgConfigs: outputs.GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfig {
    bpgDbParams: outputs.GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigBpgDbParam[];
    storages: outputs.GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigStorage[];
    vmProperties: outputs.GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigVmProperty[];
}

export interface GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigStorage {
    archiveStorages: outputs.GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigStorageLogDisk[];
}

export interface GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotProperty {
    description: string;
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshot {
    appInfoVersion: string;
    applicableTypes: string[];
    databaseNodeId: string;
    databaseSnapshot: boolean;
    dateCreated: string;
    dateModified: string;
    dbserverId: string;
    dbserverIp: string;
    dbserverName: string;
    dbserverStorageMetadataVersion: number;
    description: string;
    fromTimestamp: string;
    id: string;
    lcmConfigs: outputs.GetNdbTmsCapabilityLastContinuousSnapshotLcmConfig[];
    metadatas: outputs.GetNdbTmsCapabilityLastContinuousSnapshotMetadata[];
    name: string;
    nxClusterId: string;
    ownerId: string;
    parentSnapshot: boolean;
    parentSnapshotId: string;
    processed: boolean;
    /**
     * List of all the properties
     */
    properties: outputs.GetNdbTmsCapabilityLastContinuousSnapshotProperty[];
    protectionDomainId: string;
    replicatedSnapshots: string[];
    santized: boolean;
    santizedFromSnapshotId: string;
    santizedSnapshots: string;
    snapshotFamily: string;
    snapshotSize: number;
    snapshotTimestamp: string;
    snapshotTimestampDate: number;
    snapshotUuid: string;
    softwareDatabaseSnapshot: boolean;
    softwareSnapshot: string;
    softwareSnapshotId: string;
    status: string;
    tags: outputs.GetNdbTmsCapabilityLastContinuousSnapshotTag[];
    timeMachineId: string;
    timezone: string;
    toTimestamp: string;
    type: string;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotLcmConfig {
    expiryDetails: outputs.GetNdbTmsCapabilityLastContinuousSnapshotLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.GetNdbTmsCapabilityLastContinuousSnapshotLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.GetNdbTmsCapabilityLastContinuousSnapshotLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.GetNdbTmsCapabilityLastContinuousSnapshotLcmConfigRefreshDetail[];
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotLcmConfigPostDeleteCommand {
    command: string;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotLcmConfigPreDeleteCommand {
    command: string;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotMetadata {
    async: boolean;
    curationRetryCount: number;
    deregisterInfo: {[key: string]: string};
    fromTimestamp: string;
    infos: outputs.GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfo[];
    lastReplicationRetrySourceSnapshotId: string;
    lastReplicationRetryTimestamp: string;
    operationsUsingSnapshots: string[];
    replicationRetryCount: number;
    secureInfo: {[key: string]: string};
    standBy: boolean;
    toTimestamp: string;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfo {
    bpgConfigs: outputs.GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfig {
    bpgDbParams: outputs.GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigBpgDbParam[];
    storages: outputs.GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigStorage[];
    vmProperties: outputs.GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigVmProperty[];
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigStorage {
    archiveStorages: outputs.GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigStorageLogDisk[];
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotProperty {
    description: string;
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbTmsCapabilityLastDbLog {
    databaseId: string;
    databaseNodeId: string;
    dateCreated: string;
    dateModified: string;
    eraLogDriveId: string;
    fromTime: string;
    id: string;
    logCopyOperationId: string;
    message: string;
    metadatas: outputs.GetNdbTmsCapabilityLastDbLogMetadata[];
    name: string;
    ownerId: string;
    size: number;
    status: string;
    toTime: string;
    unprocessed: boolean;
}

export interface GetNdbTmsCapabilityLastDbLogMetadata {
    createdDirectly: boolean;
    curationRetryCount: number;
    deregisterInfos: outputs.GetNdbTmsCapabilityLastDbLogMetadataDeregisterInfo[];
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
    updatedDirectly: boolean;
}

export interface GetNdbTmsCapabilityLastDbLogMetadataDeregisterInfo {
    message: string;
    operations: string[];
}

export interface GetNetworkSecurityRuleAdRuleInboundAllowList {
    addressGroupInclusionLists: outputs.GetNetworkSecurityRuleAdRuleInboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.GetNetworkSecurityRuleAdRuleInboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.GetNetworkSecurityRuleAdRuleInboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.GetNetworkSecurityRuleAdRuleInboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.GetNetworkSecurityRuleAdRuleInboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetNetworkSecurityRuleAdRuleInboundAllowListUdpPortRangeList[];
}

export interface GetNetworkSecurityRuleAdRuleInboundAllowListAddressGroupInclusionList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetNetworkSecurityRuleAdRuleInboundAllowListFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleAdRuleInboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetNetworkSecurityRuleAdRuleInboundAllowListServiceGroupList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetNetworkSecurityRuleAdRuleInboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAdRuleInboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAdRuleOutboundAllowList {
    addressGroupInclusionLists: outputs.GetNetworkSecurityRuleAdRuleOutboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.GetNetworkSecurityRuleAdRuleOutboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.GetNetworkSecurityRuleAdRuleOutboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.GetNetworkSecurityRuleAdRuleOutboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.GetNetworkSecurityRuleAdRuleOutboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetNetworkSecurityRuleAdRuleOutboundAllowListUdpPortRangeList[];
}

export interface GetNetworkSecurityRuleAdRuleOutboundAllowListAddressGroupInclusionList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetNetworkSecurityRuleAdRuleOutboundAllowListFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleAdRuleOutboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetNetworkSecurityRuleAdRuleOutboundAllowListServiceGroupList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetNetworkSecurityRuleAdRuleOutboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAdRuleOutboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAdRuleTargetGroupFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleAppRuleInboundAllowList {
    addressGroupInclusionLists: outputs.GetNetworkSecurityRuleAppRuleInboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.GetNetworkSecurityRuleAppRuleInboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.GetNetworkSecurityRuleAppRuleInboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.GetNetworkSecurityRuleAppRuleInboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.GetNetworkSecurityRuleAppRuleInboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetNetworkSecurityRuleAppRuleInboundAllowListUdpPortRangeList[];
}

export interface GetNetworkSecurityRuleAppRuleInboundAllowListAddressGroupInclusionList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetNetworkSecurityRuleAppRuleInboundAllowListFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleAppRuleInboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetNetworkSecurityRuleAppRuleInboundAllowListServiceGroupList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetNetworkSecurityRuleAppRuleInboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAppRuleInboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAppRuleOutboundAllowList {
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.GetNetworkSecurityRuleAppRuleOutboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.GetNetworkSecurityRuleAppRuleOutboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    tcpPortRangeLists: outputs.GetNetworkSecurityRuleAppRuleOutboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetNetworkSecurityRuleAppRuleOutboundAllowListUdpPortRangeList[];
}

export interface GetNetworkSecurityRuleAppRuleOutboundAllowListFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleAppRuleOutboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetNetworkSecurityRuleAppRuleOutboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAppRuleOutboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAppRuleTargetGroupFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleCategory {
    /**
     * - the name.
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetNetworkSecurityRuleIsolationRuleFirstEntityFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleIsolationRuleSecondEntityFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleQuarantineRuleInboundAllowList {
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.GetNetworkSecurityRuleQuarantineRuleInboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.GetNetworkSecurityRuleQuarantineRuleInboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    tcpPortRangeLists: outputs.GetNetworkSecurityRuleQuarantineRuleInboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetNetworkSecurityRuleQuarantineRuleInboundAllowListUdpPortRangeList[];
}

export interface GetNetworkSecurityRuleQuarantineRuleInboundAllowListFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleQuarantineRuleInboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetNetworkSecurityRuleQuarantineRuleInboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleQuarantineRuleInboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleQuarantineRuleOutboundAllowList {
    addressGroupInclusionLists: outputs.GetNetworkSecurityRuleQuarantineRuleOutboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.GetNetworkSecurityRuleQuarantineRuleOutboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.GetNetworkSecurityRuleQuarantineRuleOutboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.GetNetworkSecurityRuleQuarantineRuleOutboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.GetNetworkSecurityRuleQuarantineRuleOutboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetNetworkSecurityRuleQuarantineRuleOutboundAllowListUdpPortRangeList[];
}

export interface GetNetworkSecurityRuleQuarantineRuleOutboundAllowListAddressGroupInclusionList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetNetworkSecurityRuleQuarantineRuleOutboundAllowListFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleQuarantineRuleOutboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetNetworkSecurityRuleQuarantineRuleOutboundAllowListServiceGroupList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetNetworkSecurityRuleQuarantineRuleOutboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleQuarantineRuleOutboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleQuarantineRuleTargetGroupFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetPbrSpec {
    /**
     * - the name.
     */
    name: string;
    /**
     * PBR resources status
     */
    resources: outputs.GetPbrSpecResource[];
}

export interface GetPbrSpecResource {
    /**
     * Routing policy action
     */
    actions: outputs.GetPbrSpecResourceAction[];
    /**
     * destination address of an IP.
     */
    destinations: outputs.GetPbrSpecResourceDestination[];
    /**
     * Policy in reverse direction.
     */
    isBidirectional: boolean;
    /**
     * priority of routing policy
     */
    priority: number;
    /**
     * Routing policy IP protocol parameters
     */
    protocolParameters: outputs.GetPbrSpecResourceProtocolParameter[];
    /**
     * Protocol type of routing policy
     */
    protocolType: string;
    /**
     * source address of an IP.
     */
    sources: outputs.GetPbrSpecResourceSource[];
    /**
     * Reference to VPC
     */
    vpcReference: {[key: string]: string};
}

export interface GetPbrSpecResourceAction {
    /**
     * Routing policy action
     */
    action: string;
    serviceIpLists: string[];
}

export interface GetPbrSpecResourceDestination {
    addressType: string;
    /**
     * prefix length of provided subnet.
     */
    prefixLength?: number;
    /**
     * IP subnet provided as an address.
     */
    subnetIp?: string;
}

export interface GetPbrSpecResourceProtocolParameter {
    /**
     * ICMP parameters in routing policy.
     */
    icmps: outputs.GetPbrSpecResourceProtocolParameterIcmp[];
    /**
     * Protocol number in routing policy
     */
    protocolNumber: number;
    /**
     * TCP parameters in routing policy
     */
    tcps: outputs.GetPbrSpecResourceProtocolParameterTcp[];
    /**
     * UDP parameters in routing policy
     */
    udps: outputs.GetPbrSpecResourceProtocolParameterUdp[];
}

export interface GetPbrSpecResourceProtocolParameterIcmp {
    icmpCode: number;
    icmpType: number;
}

export interface GetPbrSpecResourceProtocolParameterTcp {
    destinationPortRangeLists: outputs.GetPbrSpecResourceProtocolParameterTcpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrSpecResourceProtocolParameterTcpSourcePortRangeList[];
}

export interface GetPbrSpecResourceProtocolParameterTcpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrSpecResourceProtocolParameterTcpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrSpecResourceProtocolParameterUdp {
    destinationPortRangeLists: outputs.GetPbrSpecResourceProtocolParameterUdpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrSpecResourceProtocolParameterUdpSourcePortRangeList[];
}

export interface GetPbrSpecResourceProtocolParameterUdpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrSpecResourceProtocolParameterUdpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrSpecResourceSource {
    addressType: string;
    /**
     * prefix length of provided subnet.
     */
    prefixLength?: number;
    /**
     * IP subnet provided as an address.
     */
    subnetIp?: string;
}

export interface GetPbrStatus {
    /**
     * Execution Context of PBR.
     */
    executionContexts: outputs.GetPbrStatusExecutionContext[];
    /**
     * - the name.
     */
    name: string;
    /**
     * PBR resources status
     */
    resources: outputs.GetPbrStatusResource[];
    /**
     * The state of the PBR
     */
    state: string;
}

export interface GetPbrStatusExecutionContext {
    taskUuids: string[];
}

export interface GetPbrStatusResource {
    /**
     * Routing policy action
     */
    actions: outputs.GetPbrStatusResourceAction[];
    /**
     * destination address of an IP.
     */
    destinations: outputs.GetPbrStatusResourceDestination[];
    /**
     * Policy in reverse direction.
     */
    isBidirectional: boolean;
    /**
     * priority of routing policy
     */
    priority: number;
    /**
     * Routing policy IP protocol parameters
     */
    protocolParameters: outputs.GetPbrStatusResourceProtocolParameter[];
    /**
     * Protocol type of routing policy
     */
    protocolType: string;
    routingPolicyCounters: outputs.GetPbrStatusResourceRoutingPolicyCounter[];
    /**
     * source address of an IP.
     */
    sources: outputs.GetPbrStatusResourceSource[];
    /**
     * Reference to VPC
     */
    vpcReference: {[key: string]: string};
}

export interface GetPbrStatusResourceAction {
    /**
     * Routing policy action
     */
    action: string;
    serviceIpLists: string[];
}

export interface GetPbrStatusResourceDestination {
    addressType: string;
    /**
     * prefix length of provided subnet.
     */
    prefixLength?: number;
    /**
     * IP subnet provided as an address.
     */
    subnetIp?: string;
}

export interface GetPbrStatusResourceProtocolParameter {
    /**
     * ICMP parameters in routing policy.
     */
    icmps: outputs.GetPbrStatusResourceProtocolParameterIcmp[];
    /**
     * Protocol number in routing policy
     */
    protocolNumber: number;
    /**
     * TCP parameters in routing policy
     */
    tcps: outputs.GetPbrStatusResourceProtocolParameterTcp[];
    /**
     * UDP parameters in routing policy
     */
    udps: outputs.GetPbrStatusResourceProtocolParameterUdp[];
}

export interface GetPbrStatusResourceProtocolParameterIcmp {
    icmpCode: number;
    icmpType: number;
}

export interface GetPbrStatusResourceProtocolParameterTcp {
    destinationPortRangeLists: outputs.GetPbrStatusResourceProtocolParameterTcpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrStatusResourceProtocolParameterTcpSourcePortRangeList[];
}

export interface GetPbrStatusResourceProtocolParameterTcpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrStatusResourceProtocolParameterTcpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrStatusResourceProtocolParameterUdp {
    destinationPortRangeLists: outputs.GetPbrStatusResourceProtocolParameterUdpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrStatusResourceProtocolParameterUdpSourcePortRangeList[];
}

export interface GetPbrStatusResourceProtocolParameterUdpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrStatusResourceProtocolParameterUdpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrStatusResourceRoutingPolicyCounter {
    byteCount: number;
    packetCount: number;
}

export interface GetPbrStatusResourceSource {
    addressType: string;
    /**
     * prefix length of provided subnet.
     */
    prefixLength?: number;
    /**
     * IP subnet provided as an address.
     */
    subnetIp?: string;
}

export interface GetPbrsEntity {
    /**
     * - The routing policies kind metadata.
     */
    metadata: {[key: string]: string};
    /**
     * PBR spec
     */
    specs: outputs.GetPbrsEntitySpec[];
    /**
     * PBR output status
     */
    statuses: outputs.GetPbrsEntityStatus[];
}

export interface GetPbrsEntitySpec {
    /**
     * - the name.
     */
    name: string;
    /**
     * PBR resources status
     */
    resources: outputs.GetPbrsEntitySpecResource[];
}

export interface GetPbrsEntitySpecResource {
    /**
     * Routing policy action
     */
    actions: outputs.GetPbrsEntitySpecResourceAction[];
    /**
     * destination address of an IP.
     */
    destinations: outputs.GetPbrsEntitySpecResourceDestination[];
    /**
     * Policy in reverse direction.
     */
    isBidirectional: boolean;
    /**
     * priority of routing policy
     */
    priority: number;
    /**
     * Routing policy IP protocol parameters
     */
    protocolParameters: outputs.GetPbrsEntitySpecResourceProtocolParameter[];
    /**
     * Protocol type of routing policy
     */
    protocolType: string;
    /**
     * source address of an IP.
     */
    sources: outputs.GetPbrsEntitySpecResourceSource[];
    /**
     * Reference to VPC
     */
    vpcReference: {[key: string]: string};
}

export interface GetPbrsEntitySpecResourceAction {
    /**
     * Routing policy action
     */
    action: string;
    serviceIpLists: string[];
}

export interface GetPbrsEntitySpecResourceDestination {
    addressType: string;
    /**
     * prefix length of provided subnet.
     */
    prefixLength?: number;
    /**
     * IP subnet provided as an address.
     */
    subnetIp?: string;
}

export interface GetPbrsEntitySpecResourceProtocolParameter {
    /**
     * ICMP parameters in routing policy.
     */
    icmps: outputs.GetPbrsEntitySpecResourceProtocolParameterIcmp[];
    /**
     * Protocol number in routing policy
     */
    protocolNumber: number;
    /**
     * TCP parameters in routing policy
     */
    tcps: outputs.GetPbrsEntitySpecResourceProtocolParameterTcp[];
    /**
     * UDP parameters in routing policy
     */
    udps: outputs.GetPbrsEntitySpecResourceProtocolParameterUdp[];
}

export interface GetPbrsEntitySpecResourceProtocolParameterIcmp {
    icmpCode: number;
    icmpType: number;
}

export interface GetPbrsEntitySpecResourceProtocolParameterTcp {
    destinationPortRangeLists: outputs.GetPbrsEntitySpecResourceProtocolParameterTcpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrsEntitySpecResourceProtocolParameterTcpSourcePortRangeList[];
}

export interface GetPbrsEntitySpecResourceProtocolParameterTcpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntitySpecResourceProtocolParameterTcpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntitySpecResourceProtocolParameterUdp {
    destinationPortRangeLists: outputs.GetPbrsEntitySpecResourceProtocolParameterUdpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrsEntitySpecResourceProtocolParameterUdpSourcePortRangeList[];
}

export interface GetPbrsEntitySpecResourceProtocolParameterUdpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntitySpecResourceProtocolParameterUdpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntitySpecResourceSource {
    addressType: string;
    /**
     * prefix length of provided subnet.
     */
    prefixLength?: number;
    /**
     * IP subnet provided as an address.
     */
    subnetIp?: string;
}

export interface GetPbrsEntityStatus {
    /**
     * Execution Context of PBR.
     */
    executionContexts: outputs.GetPbrsEntityStatusExecutionContext[];
    /**
     * - the name.
     */
    name: string;
    /**
     * PBR resources status
     */
    resources: outputs.GetPbrsEntityStatusResource[];
    /**
     * The state of the PBR
     */
    state: string;
}

export interface GetPbrsEntityStatusExecutionContext {
    taskUuids: string[];
}

export interface GetPbrsEntityStatusResource {
    /**
     * Routing policy action
     */
    actions: outputs.GetPbrsEntityStatusResourceAction[];
    /**
     * destination address of an IP.
     */
    destinations: outputs.GetPbrsEntityStatusResourceDestination[];
    /**
     * Policy in reverse direction.
     */
    isBidirectional: boolean;
    /**
     * priority of routing policy
     */
    priority: number;
    /**
     * Routing policy IP protocol parameters
     */
    protocolParameters: outputs.GetPbrsEntityStatusResourceProtocolParameter[];
    /**
     * Protocol type of routing policy
     */
    protocolType: string;
    routingPolicyCounters: outputs.GetPbrsEntityStatusResourceRoutingPolicyCounter[];
    /**
     * source address of an IP.
     */
    sources: outputs.GetPbrsEntityStatusResourceSource[];
    /**
     * Reference to VPC
     */
    vpcReference: {[key: string]: string};
}

export interface GetPbrsEntityStatusResourceAction {
    /**
     * Routing policy action
     */
    action: string;
    serviceIpLists: string[];
}

export interface GetPbrsEntityStatusResourceDestination {
    addressType: string;
    /**
     * prefix length of provided subnet.
     */
    prefixLength?: number;
    /**
     * IP subnet provided as an address.
     */
    subnetIp?: string;
}

export interface GetPbrsEntityStatusResourceProtocolParameter {
    /**
     * ICMP parameters in routing policy.
     */
    icmps: outputs.GetPbrsEntityStatusResourceProtocolParameterIcmp[];
    /**
     * Protocol number in routing policy
     */
    protocolNumber: number;
    /**
     * TCP parameters in routing policy
     */
    tcps: outputs.GetPbrsEntityStatusResourceProtocolParameterTcp[];
    /**
     * UDP parameters in routing policy
     */
    udps: outputs.GetPbrsEntityStatusResourceProtocolParameterUdp[];
}

export interface GetPbrsEntityStatusResourceProtocolParameterIcmp {
    icmpCode: number;
    icmpType: number;
}

export interface GetPbrsEntityStatusResourceProtocolParameterTcp {
    destinationPortRangeLists: outputs.GetPbrsEntityStatusResourceProtocolParameterTcpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrsEntityStatusResourceProtocolParameterTcpSourcePortRangeList[];
}

export interface GetPbrsEntityStatusResourceProtocolParameterTcpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntityStatusResourceProtocolParameterTcpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntityStatusResourceProtocolParameterUdp {
    destinationPortRangeLists: outputs.GetPbrsEntityStatusResourceProtocolParameterUdpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrsEntityStatusResourceProtocolParameterUdpSourcePortRangeList[];
}

export interface GetPbrsEntityStatusResourceProtocolParameterUdpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntityStatusResourceProtocolParameterUdpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntityStatusResourceRoutingPolicyCounter {
    byteCount: number;
    packetCount: number;
}

export interface GetPbrsEntityStatusResourceSource {
    addressType: string;
    /**
     * prefix length of provided subnet.
     */
    prefixLength?: number;
    /**
     * IP subnet provided as an address.
     */
    subnetIp?: string;
}

export interface GetPbrsMetadata {
    filter: string;
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
    totalMatches: number;
}

export interface GetPermissionCategory {
    /**
     * the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetPermissionField {
    /**
     * Allow or disallow the fields mentioned.
     */
    fieldMode: string;
    /**
     * The list of fields.
     */
    fieldNameLists: string[];
}

export interface GetPermissionsEntity {
    /**
     * version of the API
     */
    apiVersion: string;
    /**
     * The categories for this resource.
     */
    categories: outputs.GetPermissionsEntityCategory[];
    /**
     * A description for the permission.
     */
    description: string;
    /**
     * . The fields that can/cannot be accessed during the specified operation. fieldNameList will be a list of fields. e.g. if fieldMode = disallowed, fieldNameList = [“xyz”] then the list of allowed fields is ALL fields minus xyz. Seee Field for more info.
     */
    fields: outputs.GetPermissionsEntityField[];
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The permission kind metadata.
     */
    metadata: {[key: string]: string};
    /**
     * the name.
     */
    name: string;
    /**
     * The operation that is being performed on a given kind.
     */
    operation: string;
    /**
     * The reference to a user.
     */
    ownerReference: {[key: string]: string};
    /**
     * The reference to a project.
     */
    projectReference: {[key: string]: string};
    /**
     * The state of the permission.
     */
    state: string;
}

export interface GetPermissionsEntityCategory {
    /**
     * the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetPermissionsEntityField {
    /**
     * Allow or disallow the fields mentioned.
     */
    fieldMode: string;
    /**
     * The list of fields.
     */
    fieldNameLists: string[];
}

export interface GetPermissionsMetadata {
    filter: string;
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetProjectAccountReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectAcp {
    /**
     * The list of context filters. These are OR filters. The scope-expression-list defines the context, and the filter works in conjunction with the entity-expression-list.
     */
    contextFilterLists: outputs.GetProjectAcpContextFilterList[];
    /**
     * Description of ACP
     */
    description: string;
    metadata: {[key: string]: string};
    /**
     * the name.
     */
    name: string;
    /**
     * Reference to role.
     */
    roleReferences: outputs.GetProjectAcpRoleReference[];
    /**
     * List of Reference of users groups.
     */
    userGroupReferenceLists: outputs.GetProjectAcpUserGroupReferenceList[];
    /**
     * List of Reference of users.
     */
    userReferenceLists: outputs.GetProjectAcpUserReferenceList[];
}

export interface GetProjectAcpContextFilterList {
    /**
     * (Required) A list of Entity filter expressions.
     */
    entityFilterExpressionLists: outputs.GetProjectAcpContextFilterListEntityFilterExpressionList[];
    /**
     * - (Optional) Filter the scope of an Access Control Policy.
     */
    scopeFilterExpressionLists?: outputs.GetProjectAcpContextFilterListScopeFilterExpressionList[];
}

export interface GetProjectAcpContextFilterListEntityFilterExpressionList {
    /**
     * - (Optional)  The LHS of the filter expression - the entity type.
     */
    leftHandSideEntityType: string;
    /**
     * - (Required) The operator in the filter expression.
     */
    operator: string;
    /**
     * - (Required) The right hand side (RHS) of an scope expression.
     */
    rightHandSides: outputs.GetProjectAcpContextFilterListEntityFilterExpressionListRightHandSide[];
}

export interface GetProjectAcpContextFilterListEntityFilterExpressionListRightHandSide {
    /**
     * - (Optional) The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.GetProjectAcpContextFilterListEntityFilterExpressionListRightHandSideCategory[];
    /**
     * - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
     */
    collection: string;
    /**
     * - (Optional) The explicit list of UUIDs for the given kind.
     */
    uuidLists: string[];
}

export interface GetProjectAcpContextFilterListEntityFilterExpressionListRightHandSideCategory {
    /**
     * the name.
     */
    name: string;
    /**
     * value of the key.
     */
    values: string[];
}

export interface GetProjectAcpContextFilterListScopeFilterExpressionList {
    /**
     * - (Optional)  The LHS of the filter expression - the scope type.
     */
    leftHandSide: string;
    /**
     * - (Required) The operator in the filter expression.
     */
    operator: string;
    /**
     * - (Required) The right hand side (RHS) of an scope expression.
     */
    rightHandSides: outputs.GetProjectAcpContextFilterListScopeFilterExpressionListRightHandSide[];
}

export interface GetProjectAcpContextFilterListScopeFilterExpressionListRightHandSide {
    /**
     * - (Optional) The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.GetProjectAcpContextFilterListScopeFilterExpressionListRightHandSideCategory[];
    /**
     * - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
     */
    collection: string;
    /**
     * - (Optional) The explicit list of UUIDs for the given kind.
     */
    uuidLists: string[];
}

export interface GetProjectAcpContextFilterListScopeFilterExpressionListRightHandSideCategory {
    /**
     * the name.
     */
    name: string;
    /**
     * value of the key.
     */
    values: string[];
}

export interface GetProjectAcpRoleReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectAcpUserGroupReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectAcpUserReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectCategory {
    /**
     * the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetProjectClusterReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectDefaultEnvironmentReference {
    /**
     * (Optional) The kind name. Default value is `environment`
     */
    kind: string;
    /**
     * (Optional/Computed) The name of a environment.
     */
    name: string;
    /**
     * (Required) The UUID of a environment
     */
    uuid: string;
}

export interface GetProjectEnvironmentReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectExternalNetworkList {
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectExternalUserGroupReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectResourceDomain {
    /**
     * Array of the utilization/limit for resource types
     * * `resource_domain.resources.#.limit` The resource consumption limit (unspecified is unlimited)
     * * `resource_domain.resources.#.resource_type` The type of resource (for example storage, CPUs)
     * * `resource_domain.resources.#.units` - The units of the resource type
     * * `resource_domain.resources.#.value` - The amount of resource consumed
     */
    resources: outputs.GetProjectResourceDomainResource[];
}

export interface GetProjectResourceDomainResource {
    limit: number;
    resourceType: string;
    units: string;
    /**
     * value of the key.
     */
    value: number;
}

export interface GetProjectSubnetReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectTunnelReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectUserReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectVpcReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectsEntity {
    /**
     * List of accounts associated with the project.
     * * `account_reference_list.#.kind` - The kind name. Default value is `account`
     * * `account_reference_list.#.uuid` - The UUID of an account.
     * * `account_reference_list.#.name` - The name of an account.
     */
    accountReferenceLists: outputs.GetProjectsEntityAccountReferenceList[];
    /**
     * version of the API
     */
    apiVersion: string;
    categories: outputs.GetProjectsEntityCategory[];
    /**
     * Reference to a subnet.
     */
    defaultSubnetReference: {[key: string]: string};
    /**
     * A description for project.
     */
    description: string;
    /**
     * List of environments associated with the project.
     * * `environment_reference_list.#.kind` - The kind name. Default value is `environment`
     * * `environment_reference_list.#.uuid` - The UUID of an environment.
     * * `environment_reference_list.#.name` - The name of an environment.
     */
    environmentReferenceLists: outputs.GetProjectsEntityEnvironmentReferenceList[];
    /**
     * List of external networks associated with the project.
     * * `external_network_list.#.uuid` - The UUID of a network.
     * * `external_network_list.#.name` - The name of a network.
     */
    externalNetworkLists: outputs.GetProjectsEntityExternalNetworkList[];
    /**
     * List of directory service user groups. These groups are not managed by Nutanix.
     * * `external_user_group_reference_list.#.kind` - The kind name. Default value is `userGroup`
     * * `external_user_group_reference_list.#.uuid` - The UUID of a userGroup
     * * `external_user_group_reference_list.#.name` - The name of a user_group
     */
    externalUserGroupReferenceLists: outputs.GetProjectsEntityExternalUserGroupReferenceList[];
    isDefault: boolean;
    metadata: {[key: string]: string};
    /**
     * (Optional) the name.
     */
    name: string;
    ownerReference: {[key: string]: string};
    projectReference: {[key: string]: string};
    /**
     * The status for a resource domain (limits and values)
     */
    resourceDomains: outputs.GetProjectsEntityResourceDomain[];
    state: string;
    /**
     * List of subnets for the project.
     * * `subnet_reference_list.#.kind` - The kind name. Default value is `subnet`
     * * `subnet_reference_list.#.uuid` - The UUID of a subnet
     * * `subnet_reference_list.#.name` - The name of a subnet.
     */
    subnetReferenceLists: outputs.GetProjectsEntitySubnetReferenceList[];
    /**
     * List of users in the project.
     * * `user_reference_list.#.kind` - The kind name. Default value is `user`
     * * `user_reference_list.#.uuid` - The UUID of a user
     * * `user_reference_list.#.name` - The name of a user.
     */
    userReferenceLists: outputs.GetProjectsEntityUserReferenceList[];
}

export interface GetProjectsEntityAccountReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectsEntityCategory {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetProjectsEntityEnvironmentReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectsEntityExternalNetworkList {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectsEntityExternalUserGroupReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectsEntityResourceDomain {
    /**
     * Array of the utilization/limit for resource types
     * * `resource_domain.resources.#.limit` The resource consumption limit (unspecified is unlimited)
     * * `resource_domain.resources.#.resource_type` The type of resource (for example storage, CPUs)
     * * `resource_domain.resources.#.units` - The units of the resource type
     * * `resource_domain.resources.#.value` - The amount of resource consumed
     */
    resources: outputs.GetProjectsEntityResourceDomainResource[];
}

export interface GetProjectsEntityResourceDomainResource {
    limit: number;
    resourceType: string;
    units: string;
    /**
     * value of the key.
     */
    value: number;
}

export interface GetProjectsEntitySubnetReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectsEntityUserReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProtectionRuleAvailabilityZoneConnectivityList {
    /**
     * (Optional/Computed) Index of the availability zone.
     */
    destinationAvailabilityZoneIndex: number;
    /**
     * (Optional/Computed) Snapshot schedules for the pair of the availability zones.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.recovery_point_objective_secs` - (Required) "A recovery point objective (RPO) is the maximum acceptable amount of data loss.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.local_snapshot_retention_policy` - (Optional/Computed) This describes the snapshot retention policy for this availability zone.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.local_snapshot_retention_policy.0.num_snapshots` - (Optional/Computed) Number of snapshots need to be retained.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.local_snapshot_retention_policy.0.rollup_retention_policy_multiple` - (Optional/Computed) Multiplier to 'snapshot_interval_type'.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.local_snapshot_retention_policy.0.rollup_retention_policy_snapshot_interval_type` - (Optional/Computed)
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.auto_suspend_timeout_secs` - (Optional/Computed) Auto suspend timeout in case of connection failure between the sites.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.snapshot_type` - (Optional/Computed) Crash consistent or Application Consistent snapshot.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.remote_snapshot_retention_policy` - (Optional/Computed) This describes the snapshot retention policy for this availability zone.
     */
    snapshotScheduleLists: outputs.GetProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleList[];
    /**
     * (Optional/Computed) Index of the availability zone.
     */
    sourceAvailabilityZoneIndex: number;
}

export interface GetProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleList {
    autoSuspendTimeoutSecs: number;
    localSnapshotRetentionPolicies: outputs.GetProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicy[];
    recoveryPointObjectiveSecs: number;
    remoteSnapshotRetentionPolicies: outputs.GetProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicy[];
    snapshotType: string;
}

export interface GetProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicy {
    numSnapshots: number;
    rollupRetentionPolicyMultiple: number;
    rollupRetentionPolicySnapshotIntervalType: string;
}

export interface GetProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicy {
    numSnapshots: number;
    rollupRetentionPolicyMultiple: number;
    rollupRetentionPolicySnapshotIntervalType: string;
}

export interface GetProtectionRuleCategory {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetProtectionRuleCategoryFilter {
    /**
     * (Optional/Computed) List of kinds associated with this filter.
     */
    kindLists: string[];
    /**
     * (Optional/Computed) A list of category key and list of values.
     */
    params: outputs.GetProtectionRuleCategoryFilterParam[];
    /**
     * (Optional/Computed) The type of the filter being used.
     */
    type: string;
}

export interface GetProtectionRuleCategoryFilterParam {
    /**
     * (Optional) the name.
     */
    name: string;
    values: string[];
}

export interface GetProtectionRuleOrderedAvailabilityZoneList {
    availabilityZoneUrl: string;
    clusterUuid: string;
}

export interface GetProtectionRuleOwnerReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProtectionRuleProjectReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProtectionRulesEntity {
    /**
     * version of the API
     */
    apiVersion: string;
    /**
     * (Required) This encodes the datapipes between various availability zones and\nthe backup policy of the pipes.
     */
    availabilityZoneConnectivityLists: outputs.GetProtectionRulesEntityAvailabilityZoneConnectivityList[];
    categories: outputs.GetProtectionRulesEntityCategory[];
    /**
     * (Optional/Computed)
     */
    categoryFilters: outputs.GetProtectionRulesEntityCategoryFilter[];
    /**
     * A description for protection rule.
     */
    description: string;
    metadata: {[key: string]: string};
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) A list of availability zones, each of which, receives a replica\nof the data for the entities protected by this protection rule.
     * * `ordered_availability_zone_list.#.cluster_uuid` - (Optional/Computed) UUID of specific cluster to which we will be replicating.
     * * `ordered_availability_zone_list.#.availability_zone_url` - (Optional/Computed) The FQDN or IP address of the availability zone.
     */
    orderedAvailabilityZoneLists: outputs.GetProtectionRulesEntityOrderedAvailabilityZoneList[];
    ownerReferences: outputs.GetProtectionRulesEntityOwnerReference[];
    projectReferences: outputs.GetProtectionRulesEntityProjectReference[];
    startTime: string;
    state: string;
}

export interface GetProtectionRulesEntityAvailabilityZoneConnectivityList {
    /**
     * (Optional/Computed) Index of the availability zone.
     */
    destinationAvailabilityZoneIndex: number;
    /**
     * (Optional/Computed) Snapshot schedules for the pair of the availability zones.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.recovery_point_objective_secs` - (Required) "A recovery point objective (RPO) is the maximum acceptable amount of data loss.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.local_snapshot_retention_policy` - (Optional/Computed) This describes the snapshot retention policy for this availability zone.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.local_snapshot_retention_policy.0.num_snapshots` - (Optional/Computed) Number of snapshots need to be retained.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.local_snapshot_retention_policy.0.rollup_retention_policy_multiple` - (Optional/Computed) Multiplier to 'snapshot_interval_type'.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.local_snapshot_retention_policy.0.rollup_retention_policy_snapshot_interval_type` - (Optional/Computed)
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.auto_suspend_timeout_secs` - (Optional/Computed) Auto suspend timeout in case of connection failure between the sites.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.snapshot_type` - (Optional/Computed) Crash consistent or Application Consistent snapshot.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.remote_snapshot_retention_policy` - (Optional/Computed) This describes the snapshot retention policy for this availability zone.
     */
    snapshotScheduleLists: outputs.GetProtectionRulesEntityAvailabilityZoneConnectivityListSnapshotScheduleList[];
    /**
     * (Optional/Computed) Index of the availability zone.
     */
    sourceAvailabilityZoneIndex: number;
}

export interface GetProtectionRulesEntityAvailabilityZoneConnectivityListSnapshotScheduleList {
    autoSuspendTimeoutSecs: number;
    localSnapshotRetentionPolicies: outputs.GetProtectionRulesEntityAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicy[];
    recoveryPointObjectiveSecs: number;
    remoteSnapshotRetentionPolicies: outputs.GetProtectionRulesEntityAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicy[];
    snapshotType: string;
}

export interface GetProtectionRulesEntityAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicy {
    numSnapshots: number;
    rollupRetentionPolicyMultiple: number;
    rollupRetentionPolicySnapshotIntervalType: string;
}

export interface GetProtectionRulesEntityAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicy {
    numSnapshots: number;
    rollupRetentionPolicyMultiple: number;
    rollupRetentionPolicySnapshotIntervalType: string;
}

export interface GetProtectionRulesEntityCategory {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetProtectionRulesEntityCategoryFilter {
    /**
     * (Optional/Computed) List of kinds associated with this filter.
     */
    kindLists: string[];
    /**
     * (Optional/Computed) A list of category key and list of values.
     */
    params: outputs.GetProtectionRulesEntityCategoryFilterParam[];
    /**
     * (Optional/Computed) The type of the filter being used.
     */
    type: string;
}

export interface GetProtectionRulesEntityCategoryFilterParam {
    /**
     * (Optional) the name.
     */
    name: string;
    values: string[];
}

export interface GetProtectionRulesEntityOrderedAvailabilityZoneList {
    availabilityZoneUrl: string;
    clusterUuid: string;
}

export interface GetProtectionRulesEntityOwnerReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProtectionRulesEntityProjectReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanCategory {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetRecoveryPlanOwnerReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameter {
    /**
     * (Optional/Computed) Floating IP assignment for VMs upon recovery in an Availability Zone. This is applicable only for the public cloud Availability Zones.
     * * `parameters.0.floating_ip_assignment_list.#.availability_zone_url` - (Required) URL of the Availability Zone.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list` - (Required) IP assignment for VMs upon recovery in the specified Availability Zone.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.test_floating_ip_config` - (Optional/Computed) Configuration for assigning floating IP to a VM on the execution of the Recovery Plan.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.test_floating_ip_config.ip` - (Optional/Computed) IP to be assigned to VM, in case of failover.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.test_floating_ip_config.should_allocate_dynamically` - (Optional/Computed) Whether to allocate the floating IPs for the VMs dynamically.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.recovery_floating_ip_config` - (Optional/Computed) Configuration for assigning floating IP to a VM on the execution of the Recovery Plan.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.recovery_floating_ip_config.ip` - (Optional/Computed) IP to be assigned to VM, in case of failover.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.recovery_floating_ip_config.should_allocate_dynamically` - (Optional/Computed) Whether to allocate the floating IPs for the VMs dynamically.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_reference` - (Required) Reference to a vm.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_reference.kind` - (Required) The kind name.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_reference.uuid` - (Required) The uuid.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_nic_information` - (Required) Information about vnic to which floating IP has to be assigned.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_nic_information.ip` - (Optional/Computed) IP address associated with vnic for which floating IP has to be assigned on failover.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_nic_information.uuid` - (Required) Uuid of the vnic of the VM to which floating IP has to be assigned.
     */
    floatingIpAssignmentLists: outputs.GetRecoveryPlanParameterFloatingIpAssignmentList[];
    /**
     * (Required) Network mappings to be used for the Recovery Plan. This will be represented by array of network mappings across the Availability Zones.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list` - (Required) Mapping of networks across the Availability Zones.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.availability_zone_url` - (Optional/Computed) URL of the Availability Zone.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network` - (Optional/Computed) Network configuration to be used for performing network mapping and IP preservation/mapping on Recovery Plan execution.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.virtual_network_reference` - (Optional/Computed) The reference to a virtual_network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.virtual_network_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.virtual_network_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.virtual_network_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.use_vpc_reference` - (Optional/Computed) The reference to a VPC.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.vpc_reference` - (Optional/Computed) The reference to a VPC.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.vpc_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.vpc_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.vpc_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.subnet_list` - (Optional/Computed) List of subnets for the network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.subnet_list.#.gateway_ip` - (Required) Gateway IP address for the subnet.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.subnet_list.#.external_connectivity_state` - (Optional/Computed) External connectivity state of the subnet. This is applicable only for the subnet to be created in public cloud Availability Zone.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.subnet_list.#.prefix_length` - (Required) Prefix length for the subnet.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.name` - (Required) Name of the network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network` - (Optional/Computed) Network configuration to be used for performing network mapping and IP preservation/mapping on Recovery Plan execution.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.virtual_network_reference` - (Optional/Computed) The reference to a virtual_network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.virtual_network_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.virtual_network_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.virtual_network_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.subnet_list` - (Optional/Computed) List of subnets for the network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.subnet_list.#.gateway_ip` - (Required) Gateway IP address for the subnet.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.subnet_list.#.external_connectivity_state` - (Optional/Computed) External connectivity state of the subnet. This is applicable only for the subnet to be created in public cloud Availability Zone.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.subnet_list.#.prefix_length` - (Required) Prefix length for the subnet.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.name` - (Required) Name of the network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list` - (Optional/Computed) Static IP configuration for the VMs to be applied post recovery in the recovery network for migrate/ failover action on the Recovery Plan.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.vm_reference` - (Optional/Computed) The reference to a vm.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.vm_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.vm_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.vm_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.ip_config_list` - (Optional/Computed) List of IP configurations for a VM.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.ip_config_list.#.ip_address` - (Required) IP address.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list` - (Optional/Computed) Static IP configuration for the VMs to be applied post recovery in the test network for test failover action on the Recovery Plan.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.vm_reference` - (Optional/Computed) The reference to a vm.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.vm_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.vm_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.vm_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.ip_config_list` - (Optional/Computed) List of IP configurations for a VM.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.ip_config_list.#.ip_address` - (Required) IP address.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.cluster_reference_list` - (Optional/Computed) The clusters where the recovery and test networks reside. This is required to specify network mapping across clusters for a Recovery Plan created to handle failover within the same Availability Zone.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.cluster_reference_list.0.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.cluster_reference_list.0.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.name` - (Optional/Computed) The name.
     */
    networkMappingLists: outputs.GetRecoveryPlanParameterNetworkMappingList[];
}

export interface GetRecoveryPlanParameterFloatingIpAssignmentList {
    availabilityZoneUrl: string;
    vmIpAssignmentLists: outputs.GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentList[];
}

export interface GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentList {
    recoveryFloatingIpConfigs: outputs.GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfig[];
    testFloatingIpConfigs: outputs.GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfig[];
    vmNicInformations: outputs.GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListVmNicInformation[];
    vmReferences: outputs.GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListVmReference[];
}

export interface GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfig {
    ip: string;
    shouldAllocateDynamically: boolean;
}

export interface GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfig {
    ip: string;
    shouldAllocateDynamically: boolean;
}

export interface GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListVmNicInformation {
    ip: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterNetworkMappingList {
    areNetworksStretched: boolean;
    availabilityZoneNetworkMappingLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingList[];
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingList {
    availabilityZoneUrl: string;
    clusterReferenceLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceList[];
    recoveryIpAssignmentLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentList[];
    recoveryNetworks: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetwork[];
    testIpAssignmentLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentList[];
    testNetworks: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetwork[];
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentList {
    ipConfigLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigList[];
    vmReference: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReference;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigList {
    ipAddress: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetwork {
    /**
     * (Optional) the name.
     */
    name: string;
    subnetLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetList[];
    useVpcReference: boolean;
    virtualNetworkReferences: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReference[];
    vpcReferences: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReference[];
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetList {
    externalConnectivityState: string;
    gatewayIp: string;
    prefixLength: number;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentList {
    ipConfigLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigList[];
    vmReference: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReference;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigList {
    ipAddress: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetwork {
    /**
     * (Optional) the name.
     */
    name: string;
    subnetLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetList[];
    useVpcReference: boolean;
    virtualNetworkReferences: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReference[];
    vpcReferences: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReference[];
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetList {
    externalConnectivityState: string;
    gatewayIp: string;
    prefixLength: number;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanProjectReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanStageList {
    /**
     * (Optional/Computed) Amount of time in seconds to delay the execution of next stage after execution of current stage.
     */
    delayTimeSecs: number;
    /**
     * (Optional/Computed) UUID of stage.
     */
    stageUuid: string;
    /**
     * (Required) A stage specifies the work to be performed when the Recovery Plan is executed.
     */
    stageWorks: outputs.GetRecoveryPlanStageListStageWork[];
}

export interface GetRecoveryPlanStageListStageWork {
    /**
     * (Optional/Computed) Information about entities to be recovered.
     */
    recoverEntities: outputs.GetRecoveryPlanStageListStageWorkRecoverEntity[];
}

export interface GetRecoveryPlanStageListStageWorkRecoverEntity {
    /**
     * (Optional/Computed) Information about entities to be recovered as part of this stage. For VM, entity information will include set of scripts to be executed after recovery of VM. Only one of categories or anyEntityReference has to be provided.
     * * `stage_list.stage_work.0.recover_entities.0.entity_info_list.#.any_entity_reference_kind` - (Optional/Computed) Reference to a kind.
     * * `stage_list.stage_work.0.recover_entities.0.entity_info_list.#.any_entity_reference_uuid` - (Optional/Computed) Reference to a uuid.
     * * `stage_list.stage_work.0.recover_entities.0.entity_info_list.#.any_entity_reference_name` - (Optional/Computed) Reference to a name.
     * * `stage_list.stage_work.0.recover_entities.0.entity_info_list.#.categories` - (Optional/Computed)  Categories for filtering entities.
     */
    entityInfoLists: outputs.GetRecoveryPlanStageListStageWorkRecoverEntityEntityInfoList[];
}

export interface GetRecoveryPlanStageListStageWorkRecoverEntityEntityInfoList {
    anyEntityReferenceKind: string;
    anyEntityReferenceName: string;
    anyEntityReferenceUuid: string;
    categories: outputs.GetRecoveryPlanStageListStageWorkRecoverEntityEntityInfoListCategory[];
    scriptLists: outputs.GetRecoveryPlanStageListStageWorkRecoverEntityEntityInfoListScriptList[];
}

export interface GetRecoveryPlanStageListStageWorkRecoverEntityEntityInfoListCategory {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetRecoveryPlanStageListStageWorkRecoverEntityEntityInfoListScriptList {
    enableScriptExec: boolean;
    timeout: string;
}

export interface GetRecoveryPlansEntity {
    /**
     * version of the API
     */
    apiVersion: string;
    categories: outputs.GetRecoveryPlansEntityCategory[];
    /**
     * A description for recovery plan.
     */
    description: string;
    metadata: {[key: string]: string};
    /**
     * (Optional) the name.
     */
    name: string;
    ownerReferences: outputs.GetRecoveryPlansEntityOwnerReference[];
    /**
     * (Required) Parameters for the Recovery Plan.
     */
    parameters: outputs.GetRecoveryPlansEntityParameter[];
    projectReferences: outputs.GetRecoveryPlansEntityProjectReference[];
    /**
     * (Required) Input for the stages of the Recovery Plan. Each stage will perform a predefined type of task.
     */
    stageLists: outputs.GetRecoveryPlansEntityStageList[];
    state: string;
}

export interface GetRecoveryPlansEntityCategory {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetRecoveryPlansEntityOwnerReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameter {
    /**
     * (Optional/Computed) Floating IP assignment for VMs upon recovery in an Availability Zone. This is applicable only for the public cloud Availability Zones.
     * * `parameters.0.floating_ip_assignment_list.#.availability_zone_url` - (Required) URL of the Availability Zone.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list` - (Required) IP assignment for VMs upon recovery in the specified Availability Zone.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.test_floating_ip_config` - (Optional/Computed) Configuration for assigning floating IP to a VM on the execution of the Recovery Plan.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.test_floating_ip_config.ip` - (Optional/Computed) IP to be assigned to VM, in case of failover.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.test_floating_ip_config.should_allocate_dynamically` - (Optional/Computed) Whether to allocate the floating IPs for the VMs dynamically.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.recovery_floating_ip_config` - (Optional/Computed) Configuration for assigning floating IP to a VM on the execution of the Recovery Plan.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.recovery_floating_ip_config.ip` - (Optional/Computed) IP to be assigned to VM, in case of failover.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.recovery_floating_ip_config.should_allocate_dynamically` - (Optional/Computed) Whether to allocate the floating IPs for the VMs dynamically.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_reference` - (Required) Reference to a vm.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_reference.kind` - (Required) The kind name.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_reference.uuid` - (Required) The uuid.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_nic_information` - (Required) Information about vnic to which floating IP has to be assigned.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_nic_information.ip` - (Optional/Computed) IP address associated with vnic for which floating IP has to be assigned on failover.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_nic_information.uuid` - (Required) Uuid of the vnic of the VM to which floating IP has to be assigned.
     */
    floatingIpAssignmentLists: outputs.GetRecoveryPlansEntityParameterFloatingIpAssignmentList[];
    /**
     * (Required) Network mappings to be used for the Recovery Plan. This will be represented by array of network mappings across the Availability Zones.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list` - (Required) Mapping of networks across the Availability Zones.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.availability_zone_url` - (Optional/Computed) URL of the Availability Zone.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network` - (Optional/Computed) Network configuration to be used for performing network mapping and IP preservation/mapping on Recovery Plan execution.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.virtual_network_reference` - (Optional/Computed) The reference to a virtual_network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.virtual_network_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.virtual_network_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.virtual_network_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.use_vpc_reference` - (Optional/Computed) The reference to a VPC.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.vpc_reference` - (Optional/Computed) The reference to a VPC.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.vpc_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.vpc_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.vpc_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.subnet_list` - (Optional/Computed) List of subnets for the network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.subnet_list.#.gateway_ip` - (Required) Gateway IP address for the subnet.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.subnet_list.#.external_connectivity_state` - (Optional/Computed) External connectivity state of the subnet. This is applicable only for the subnet to be created in public cloud Availability Zone.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.subnet_list.#.prefix_length` - (Required) Prefix length for the subnet.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.name` - (Required) Name of the network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network` - (Optional/Computed) Network configuration to be used for performing network mapping and IP preservation/mapping on Recovery Plan execution.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.virtual_network_reference` - (Optional/Computed) The reference to a virtual_network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.virtual_network_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.virtual_network_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.virtual_network_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.subnet_list` - (Optional/Computed) List of subnets for the network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.subnet_list.#.gateway_ip` - (Required) Gateway IP address for the subnet.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.subnet_list.#.external_connectivity_state` - (Optional/Computed) External connectivity state of the subnet. This is applicable only for the subnet to be created in public cloud Availability Zone.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.subnet_list.#.prefix_length` - (Required) Prefix length for the subnet.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.name` - (Required) Name of the network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list` - (Optional/Computed) Static IP configuration for the VMs to be applied post recovery in the recovery network for migrate/ failover action on the Recovery Plan.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.vm_reference` - (Optional/Computed) The reference to a vm.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.vm_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.vm_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.vm_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.ip_config_list` - (Optional/Computed) List of IP configurations for a VM.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.ip_config_list.#.ip_address` - (Required) IP address.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list` - (Optional/Computed) Static IP configuration for the VMs to be applied post recovery in the test network for test failover action on the Recovery Plan.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.vm_reference` - (Optional/Computed) The reference to a vm.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.vm_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.vm_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.vm_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.ip_config_list` - (Optional/Computed) List of IP configurations for a VM.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.ip_config_list.#.ip_address` - (Required) IP address.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.cluster_reference_list` - (Optional/Computed) The clusters where the recovery and test networks reside. This is required to specify network mapping across clusters for a Recovery Plan created to handle failover within the same Availability Zone.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.cluster_reference_list.0.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.cluster_reference_list.0.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.name` - (Optional/Computed) The name.
     */
    networkMappingLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingList[];
}

export interface GetRecoveryPlansEntityParameterFloatingIpAssignmentList {
    availabilityZoneUrl: string;
    vmIpAssignmentLists: outputs.GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentList[];
}

export interface GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentList {
    recoveryFloatingIpConfigs: outputs.GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfig[];
    testFloatingIpConfigs: outputs.GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfig[];
    vmNicInformations: outputs.GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListVmNicInformation[];
    vmReferences: outputs.GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListVmReference[];
}

export interface GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfig {
    ip: string;
    shouldAllocateDynamically: boolean;
}

export interface GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfig {
    ip: string;
    shouldAllocateDynamically: boolean;
}

export interface GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListVmNicInformation {
    ip: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingList {
    areNetworksStretched: boolean;
    availabilityZoneNetworkMappingLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingList[];
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingList {
    availabilityZoneUrl: string;
    clusterReferenceLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceList[];
    recoveryIpAssignmentLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentList[];
    recoveryNetworks: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetwork[];
    testIpAssignmentLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentList[];
    testNetworks: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetwork[];
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentList {
    ipConfigLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigList[];
    vmReference: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReference;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigList {
    ipAddress: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetwork {
    /**
     * (Optional) the name.
     */
    name: string;
    subnetLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetList[];
    useVpcReference: boolean;
    virtualNetworkReferences: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReference[];
    vpcReferences: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReference[];
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetList {
    externalConnectivityState: string;
    gatewayIp: string;
    prefixLength: number;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentList {
    ipConfigLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigList[];
    vmReference: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReference;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigList {
    ipAddress: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetwork {
    /**
     * (Optional) the name.
     */
    name: string;
    subnetLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetList[];
    useVpcReference: boolean;
    virtualNetworkReferences: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReference[];
    vpcReferences: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReference[];
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetList {
    externalConnectivityState: string;
    gatewayIp: string;
    prefixLength: number;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityProjectReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityStageList {
    /**
     * (Optional/Computed) Amount of time in seconds to delay the execution of next stage after execution of current stage.
     */
    delayTimeSecs: number;
    /**
     * (Optional/Computed) UUID of stage.
     */
    stageUuid: string;
    /**
     * (Required) A stage specifies the work to be performed when the Recovery Plan is executed.
     */
    stageWorks: outputs.GetRecoveryPlansEntityStageListStageWork[];
}

export interface GetRecoveryPlansEntityStageListStageWork {
    /**
     * (Optional/Computed) Information about entities to be recovered.
     */
    recoverEntities: outputs.GetRecoveryPlansEntityStageListStageWorkRecoverEntity[];
}

export interface GetRecoveryPlansEntityStageListStageWorkRecoverEntity {
    /**
     * (Optional/Computed) Information about entities to be recovered as part of this stage. For VM, entity information will include set of scripts to be executed after recovery of VM. Only one of categories or anyEntityReference has to be provided.
     * * `stage_list.stage_work.0.recover_entities.0.entity_info_list.#.any_entity_reference_kind` - (Optional/Computed) Reference to a kind.
     * * `stage_list.stage_work.0.recover_entities.0.entity_info_list.#.any_entity_reference_uuid` - (Optional/Computed) Reference to a uuid.
     * * `stage_list.stage_work.0.recover_entities.0.entity_info_list.#.any_entity_reference_name` - (Optional/Computed) Reference to a name.
     * * `stage_list.stage_work.0.recover_entities.0.entity_info_list.#.categories` - (Optional/Computed)  Categories for filtering entities.
     */
    entityInfoLists: outputs.GetRecoveryPlansEntityStageListStageWorkRecoverEntityEntityInfoList[];
}

export interface GetRecoveryPlansEntityStageListStageWorkRecoverEntityEntityInfoList {
    anyEntityReferenceKind: string;
    anyEntityReferenceName: string;
    anyEntityReferenceUuid: string;
    categories: outputs.GetRecoveryPlansEntityStageListStageWorkRecoverEntityEntityInfoListCategory[];
    scriptLists: outputs.GetRecoveryPlansEntityStageListStageWorkRecoverEntityEntityInfoListScriptList[];
}

export interface GetRecoveryPlansEntityStageListStageWorkRecoverEntityEntityInfoListCategory {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetRecoveryPlansEntityStageListStageWorkRecoverEntityEntityInfoListScriptList {
    enableScriptExec: boolean;
    timeout: string;
}

export interface GetRoleCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetRolePermissionReferenceList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetRolesEntity {
    /**
     * The version of the API.
     */
    apiVersion: string;
    /**
     * - Categories for the role.
     */
    categories: outputs.GetRolesEntityCategory[];
    /**
     * - The description of the role.
     */
    description: string;
    /**
     * - The role kind metadata.
     */
    metadata: {[key: string]: string};
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - The reference to a user.
     */
    ownerReference: {[key: string]: string};
    /**
     * - (Required) List of permission references.
     */
    permissionReferenceLists: outputs.GetRolesEntityPermissionReferenceList[];
    /**
     * - The reference to a project.
     */
    projectReference: {[key: string]: string};
    roleId: string;
    /**
     * - The state of the role.
     */
    state: string;
}

export interface GetRolesEntityCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetRolesEntityPermissionReferenceList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetRolesMetadata {
    filter: string;
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetServiceGroupServiceList {
    icmpTypeCodeLists: outputs.GetServiceGroupServiceListIcmpTypeCodeList[];
    protocol: string;
    tcpPortRangeLists: outputs.GetServiceGroupServiceListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetServiceGroupServiceListUdpPortRangeList[];
}

export interface GetServiceGroupServiceListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetServiceGroupServiceListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetServiceGroupServiceListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetServiceGroupsEntity {
    associatedPoliciesLists: outputs.GetServiceGroupsEntityAssociatedPoliciesList[];
    serviceGroups: outputs.GetServiceGroupsEntityServiceGroup[];
    uuid: string;
}

export interface GetServiceGroupsEntityAssociatedPoliciesList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetServiceGroupsEntityServiceGroup {
    description: string;
    /**
     * specifying whether it is a system defined service group
     */
    isSystemDefined: boolean;
    name: string;
    serviceLists: outputs.GetServiceGroupsEntityServiceGroupServiceList[];
}

export interface GetServiceGroupsEntityServiceGroupServiceList {
    icmpTypeCodeLists: outputs.GetServiceGroupsEntityServiceGroupServiceListIcmpTypeCodeList[];
    protocol: string;
    tcpPortRangeLists: outputs.GetServiceGroupsEntityServiceGroupServiceListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetServiceGroupsEntityServiceGroupServiceListUdpPortRangeList[];
}

export interface GetServiceGroupsEntityServiceGroupServiceListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetServiceGroupsEntityServiceGroupServiceListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetServiceGroupsEntityServiceGroupServiceListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetServiceGroupsMetadata {
    filter: string;
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetStaticRoutesSpec {
    /**
     * - the name.
     */
    name: string;
    /**
     * VPC route table resources status
     */
    resources: outputs.GetStaticRoutesSpecResource[];
}

export interface GetStaticRoutesSpecResource {
    /**
     * default routes (present in spec resource)
     */
    defaultRouteNexthops: outputs.GetStaticRoutesSpecResourceDefaultRouteNexthop[];
    /**
     * list of static routes
     */
    staticRoutesLists: outputs.GetStaticRoutesSpecResourceStaticRoutesList[];
}

export interface GetStaticRoutesSpecResourceDefaultRouteNexthop {
    /**
     * The reference to a direct_connect_virtual_interface
     */
    directConnectVirtualInterfaceReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    localSubnetReference: {[key: string]: string};
    /**
     * The reference to a vpn_connection
     */
    vpnConnectionReference: {[key: string]: string};
}

export interface GetStaticRoutesSpecResourceStaticRoutesList {
    /**
     * destination ip address with prefix.
     */
    destination: string;
    /**
     * Targeted link to use as the nexthop in a route.
     */
    nexthops: outputs.GetStaticRoutesSpecResourceStaticRoutesListNexthop[];
}

export interface GetStaticRoutesSpecResourceStaticRoutesListNexthop {
    /**
     * The reference to a direct_connect_virtual_interface
     */
    directConnectVirtualInterfaceReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    localSubnetReference: {[key: string]: string};
    /**
     * The reference to a vpn_connection
     */
    vpnConnectionReference: {[key: string]: string};
}

export interface GetStaticRoutesStatus {
    /**
     * Execution Context of VPC.
     */
    executionContexts: outputs.GetStaticRoutesStatusExecutionContext[];
    /**
     * VPC route table resources status
     */
    resources: outputs.GetStaticRoutesStatusResource[];
    /**
     * The state of the vpc_route_table.
     */
    state: string;
}

export interface GetStaticRoutesStatusExecutionContext {
    taskUuids: string[];
}

export interface GetStaticRoutesStatusResource {
    /**
     * default route. (present in status resource only )
     */
    defaultRoutes: outputs.GetStaticRoutesStatusResourceDefaultRoute[];
    /**
     * list of dynamic routes (present in status resource only)
     */
    dynamicRoutesLists: outputs.GetStaticRoutesStatusResourceDynamicRoutesList[];
    /**
     * list of local routes (present in status resource only )
     */
    localRoutesLists: outputs.GetStaticRoutesStatusResourceLocalRoutesList[];
    /**
     * list of static routes
     */
    staticRoutesLists: outputs.GetStaticRoutesStatusResourceStaticRoutesList[];
}

export interface GetStaticRoutesStatusResourceDefaultRoute {
    /**
     * destination ip address with prefix.
     */
    destination: string;
    /**
     * Whether this route is currently active. Present in Status Resources.
     */
    isActive: boolean;
    /**
     * Targeted link to use as the nexthop in a route.
     */
    nexthops: outputs.GetStaticRoutesStatusResourceDefaultRouteNexthop[];
    /**
     * The preference value assigned to this route. A higher value means greater preference. Present in Status Resource.
     */
    priority: number;
}

export interface GetStaticRoutesStatusResourceDefaultRouteNexthop {
    /**
     * The reference to a direct_connect_virtual_interface
     */
    directConnectVirtualInterfaceReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    localSubnetReference: {[key: string]: string};
    nexthopIpAddress: string;
    /**
     * The reference to a vpn_connection
     */
    vpnConnectionReference: {[key: string]: string};
}

export interface GetStaticRoutesStatusResourceDynamicRoutesList {
    /**
     * destination ip address with prefix.
     */
    destination: string;
    /**
     * Whether this route is currently active. Present in Status Resources.
     */
    isActive: boolean;
    /**
     * Targeted link to use as the nexthop in a route.
     */
    nexthops: outputs.GetStaticRoutesStatusResourceDynamicRoutesListNexthop[];
    /**
     * The preference value assigned to this route. A higher value means greater preference. Present in Status Resource.
     */
    priority: number;
}

export interface GetStaticRoutesStatusResourceDynamicRoutesListNexthop {
    /**
     * The reference to a direct_connect_virtual_interface
     */
    directConnectVirtualInterfaceReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    localSubnetReference: {[key: string]: string};
    nexthopIpAddress: string;
    /**
     * The reference to a vpn_connection
     */
    vpnConnectionReference: {[key: string]: string};
}

export interface GetStaticRoutesStatusResourceLocalRoutesList {
    /**
     * destination ip address with prefix.
     */
    destination: string;
    /**
     * Whether this route is currently active. Present in Status Resources.
     */
    isActive: boolean;
    /**
     * Targeted link to use as the nexthop in a route.
     */
    nexthops: outputs.GetStaticRoutesStatusResourceLocalRoutesListNexthop[];
    /**
     * The preference value assigned to this route. A higher value means greater preference. Present in Status Resource.
     */
    priority: number;
}

export interface GetStaticRoutesStatusResourceLocalRoutesListNexthop {
    /**
     * The reference to a direct_connect_virtual_interface
     */
    directConnectVirtualInterfaceReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    localSubnetReference: {[key: string]: string};
    nexthopIpAddress: string;
    /**
     * The reference to a vpn_connection
     */
    vpnConnectionReference: {[key: string]: string};
}

export interface GetStaticRoutesStatusResourceStaticRoutesList {
    /**
     * destination ip address with prefix.
     */
    destination: string;
    /**
     * Whether this route is currently active. Present in Status Resources.
     */
    isActive: boolean;
    /**
     * Targeted link to use as the nexthop in a route.
     */
    nexthops: outputs.GetStaticRoutesStatusResourceStaticRoutesListNexthop[];
    /**
     * The preference value assigned to this route. A higher value means greater preference. Present in Status Resource.
     */
    priority: number;
}

export interface GetStaticRoutesStatusResourceStaticRoutesListNexthop {
    /**
     * The reference to a direct_connect_virtual_interface
     */
    directConnectVirtualInterfaceReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    localSubnetReference: {[key: string]: string};
    nexthopIpAddress: string;
    /**
     * The reference to a vpn_connection
     */
    vpnConnectionReference: {[key: string]: string};
}

export interface GetSubnetAdditionalFilter {
    /**
     * - the name(Optional).
     */
    name: string;
    values: string[];
}

export interface GetSubnetCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetSubnetMessageList {
    details: {[key: string]: any};
    message: string;
    reason: string;
}

export interface GetSubnetsEntity {
    /**
     * version of the API
     */
    apiVersion: string;
    /**
     * The reference to a availability_zone.
     */
    availabilityZoneReference: {[key: string]: string};
    /**
     * The API Version.
     */
    categories: outputs.GetSubnetsEntityCategory[];
    /**
     * The name of a cluster.
     */
    clusterName: string;
    /**
     * The reference to a cluster.
     */
    clusterReference: {[key: string]: string};
    clusterUuid: string;
    /**
     * Default gateway IP address.
     */
    defaultGatewayIp: string;
    /**
     * A description for subnet.
     */
    description: string;
    dhcpDomainNameServerLists: string[];
    /**
     * DHCP domain search list for a subnet.
     */
    dhcpDomainSearchLists: string[];
    /**
     * Spec for defining DHCP options.
     */
    dhcpOptions: {[key: string]: string};
    /**
     * Host address.
     */
    dhcpServerAddress: {[key: string]: string};
    /**
     * Port Number.
     */
    dhcpServerAddressPort: number;
    enableNat: boolean;
    ipConfigPoolListRanges: string[];
    isExternal: boolean;
    messageLists: outputs.GetSubnetsEntityMessageList[];
    /**
     * The subnet kind metadata.
     */
    metadata: {[key: string]: string};
    /**
     * the name.
     */
    name: string;
    /**
     * The reference to a network_function_chain.
     */
    networkFunctionChainReference: {[key: string]: string};
    /**
     * The reference to a user.
     */
    ownerReference: {[key: string]: string};
    /**
     * -. IP prefix length of the Subnet.
     */
    prefixLength: number;
    /**
     * The reference to a project.
     */
    projectReference: {[key: string]: string};
    /**
     * The state of the subnet.
     */
    state: string;
    subnetId: string;
    /**
     * Subnet IP address.
     */
    subnetIp: string;
    subnetName: string;
    /**
     * The type of the subnet.
     */
    subnetType: string;
    /**
     * VLAN assigned to the subnet.
     */
    vlanId: number;
    vpcReference: {[key: string]: string};
    /**
     * The name of the vswitch.
     */
    vswitchName: string;
}

export interface GetSubnetsEntityCategory {
    /**
     * the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetSubnetsEntityMessageList {
    details: {[key: string]: any};
    message: string;
    reason: string;
}

export interface GetSubnetsMetadata {
    filter: string;
    /**
     * The kind name (Default value: project.
     */
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetUserAccessControlPolicyReferenceList {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - (Optional) The name for the user
     */
    name: string;
    /**
     * - (Optional) The UUID for the user.
     */
    uuid: string;
}

export interface GetUserCategory {
    /**
     * - (Optional) The name for the user
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetUserDirectoryServiceUser {
    defaultUserPrincipalName: string;
    /**
     * - (Optional) The reference to a directory service. See #reference for to look the supported attributes.
     */
    directoryServiceReferences: outputs.GetUserDirectoryServiceUserDirectoryServiceReference[];
    /**
     * - (Optional) The UserPrincipalName of the user from the directory service.
     */
    userPrincipalName: string;
}

export interface GetUserDirectoryServiceUserDirectoryServiceReference {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - (Optional) The name for the user
     */
    name: string;
    /**
     * - (Optional) The UUID for the user.
     */
    uuid: string;
}

export interface GetUserGroupAccessControlPolicyReferenceList {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetUserGroupCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetUserGroupDirectoryServiceUserGroup {
    defaultUserPrincipalName: string;
    /**
     * - The reference to a directory service. See #reference for to look the supported attributes.
     */
    directoryServiceReferences: outputs.GetUserGroupDirectoryServiceUserGroupDirectoryServiceReference[];
    /**
     * - The Distinguished name for the user group
     */
    distinguishedName: string;
}

export interface GetUserGroupDirectoryServiceUserGroupDirectoryServiceReference {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetUserGroupProjectReferenceList {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetUserGroupsEntity {
    /**
     * - List of ACP references. See #reference for more details.
     */
    accessControlPolicyReferenceLists: outputs.GetUserGroupsEntityAccessControlPolicyReferenceList[];
    /**
     * The version of the API.
     */
    apiVersion: string;
    /**
     * - The Categories for the user group.
     */
    categories: outputs.GetUserGroupsEntityCategory[];
    /**
     * - A Directory Service User Group.
     */
    directoryServiceUserGroups: outputs.GetUserGroupsEntityDirectoryServiceUserGroup[];
    /**
     * - The display name of the user group.
     */
    displayName: string;
    /**
     * - The user group kind metadata.
     */
    metadata: {[key: string]: string};
    /**
     * - The reference to a user.
     */
    ownerReference: {[key: string]: string};
    /**
     * - The reference to a project.
     */
    projectReference?: {[key: string]: string};
    /**
     * - A list of projects the user is part of. See #reference for more details.
     */
    projectReferenceLists: outputs.GetUserGroupsEntityProjectReferenceList[];
    /**
     * - The state of the entity.
     */
    state: string;
    /**
     * - The type of the user group.
     */
    userGroupType: string;
}

export interface GetUserGroupsEntityAccessControlPolicyReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetUserGroupsEntityCategory {
    /**
     * - the key name.
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetUserGroupsEntityDirectoryServiceUserGroup {
    defaultUserPrincipalName: string;
    /**
     * - The reference to a directory service. See #reference for to look the supported attributes.
     */
    directoryServiceReferences: outputs.GetUserGroupsEntityDirectoryServiceUserGroupDirectoryServiceReference[];
    /**
     * - The Distinguished name for the user group
     */
    distinguishedName: string;
}

export interface GetUserGroupsEntityDirectoryServiceUserGroupDirectoryServiceReference {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     *
     * For `accessControlPolicyReferenceList` and `projectReferenceList` are the same as reference but used as list.
     *
     * See detailed information in [Nutanix Users](https://www.nutanix.dev/api_references/prism-central-v3/#/6016c890e9122-get-a-list-of-existing-user-groups).
     */
    uuid: string;
}

export interface GetUserGroupsEntityProjectReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetUserGroupsMetadata {
    filter: string;
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetUserIdentityProviderUser {
    /**
     * - (Optional) The reference to a identity provider. See #reference for to look the supported attributes.
     */
    identityProviderReferences: outputs.GetUserIdentityProviderUserIdentityProviderReference[];
    /**
     * - (Optional) The username from identity provider. Name ID for SAML Identity Provider.
     */
    username: string;
}

export interface GetUserIdentityProviderUserIdentityProviderReference {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - (Optional) The name for the user
     */
    name: string;
    /**
     * - (Optional) The UUID for the user.
     */
    uuid: string;
}

export interface GetUserProjectReferenceList {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - (Optional) The name for the user
     */
    name: string;
    /**
     * - (Optional) The UUID for the user.
     */
    uuid: string;
}

export interface GetUsersEntity {
    /**
     * - List of ACP references. See #reference for more details.
     */
    accessControlPolicyReferenceLists: outputs.GetUsersEntityAccessControlPolicyReferenceList[];
    /**
     * The version of the API.
     */
    apiVersion: string;
    /**
     * - (Optional) Categories for the user.
     */
    categories: outputs.GetUsersEntityCategory[];
    /**
     * - (Optional) The directory service user configuration. See below for more information.
     */
    directoryServiceUsers: outputs.GetUsersEntityDirectoryServiceUser[];
    /**
     * - The display name of the user (common name) provided by the directory service.
     */
    displayName: string;
    /**
     * - (Optional) (Optional) The identity provider user configuration. See below for more information.
     */
    identityProviderUsers: outputs.GetUsersEntityIdentityProviderUser[];
    /**
     * - The user kind metadata.
     */
    metadata: {[key: string]: string};
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - (Optional) The reference to a user.
     */
    ownerReference: {[key: string]: string};
    /**
     * - (Optional) The reference to a project.
     */
    projectReference?: {[key: string]: string};
    /**
     * - A list of projects the user is part of. See #reference for more details.
     */
    projectReferenceLists: outputs.GetUsersEntityProjectReferenceList[];
    /**
     * - The state of the entity.
     */
    state: string;
    /**
     * - The name of the user.
     */
    userType: string;
}

export interface GetUsersEntityAccessControlPolicyReferenceList {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetUsersEntityCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetUsersEntityDirectoryServiceUser {
    defaultUserPrincipalName: string;
    /**
     * - (Optional) The reference to a directory service. See #reference for to look the supported attributes.
     */
    directoryServiceReferences: outputs.GetUsersEntityDirectoryServiceUserDirectoryServiceReference[];
    /**
     * - (Optional) The UserPrincipalName of the user from the directory service.
     */
    userPrincipalName: string;
}

export interface GetUsersEntityDirectoryServiceUserDirectoryServiceReference {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetUsersEntityIdentityProviderUser {
    /**
     * - (Optional) The reference to a identity provider. See #reference for to look the supported attributes.
     */
    identityProviderReferences: outputs.GetUsersEntityIdentityProviderUserIdentityProviderReference[];
    /**
     * - (Optional) The username from identity provider. Name ID for SAML Identity Provider.
     */
    username: string;
}

export interface GetUsersEntityIdentityProviderUserIdentityProviderReference {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetUsersEntityProjectReferenceList {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetUsersMetadata {
    filter: string;
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetVirtualMachineCategory {
    /**
     * - the name.
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetVirtualMachineDiskList {
    /**
     * Reference to a data source.
     */
    dataSourceReference: {[key: string]: string};
    /**
     * Properties to a device.
     */
    deviceProperties: outputs.GetVirtualMachineDiskListDeviceProperty[];
    /**
     * Size of the disk in Bytes.
     */
    diskSizeBytes: number;
    /**
     * Size of the disk in MiB. Must match the size specified in 'disk_size_bytes' - rounded up to the nearest MiB - when that field is present.
     */
    diskSizeMib: number;
    storageConfigs: outputs.GetVirtualMachineDiskListStorageConfig[];
    /**
     * - the UUID.
     */
    uuid: string;
    /**
     * Reference to a volume group.
     */
    volumeGroupReference: {[key: string]: string};
}

export interface GetVirtualMachineDiskListDeviceProperty {
    /**
     * - A Disk type (default: DISK).
     */
    deviceType: string;
    /**
     * - Address of disk to boot from.
     */
    diskAddress: {[key: string]: string};
}

export interface GetVirtualMachineDiskListStorageConfig {
    /**
     * - State of the storage policy to pin virtual disks to the hot tier. When specified as a VM attribute, the storage policy applies to all virtual disks of the VM unless overridden by the same attribute specified for a virtual disk.
     */
    flashMode: string;
    /**
     * - Reference to a kind. Either one of (kind, uuid) or url needs to be specified.
     * * `storage_container_reference.#.url`: - GET query on the URL will provide information on the source.
     * * `storage_container_reference.#.kind`: - kind of the container reference
     * * `storage_container_reference.#.name`: - name of the container reference
     * * `storage_container_reference.#.uuid`: - uiid of the container reference
     */
    storageContainerReferences: outputs.GetVirtualMachineDiskListStorageConfigStorageContainerReference[];
}

export interface GetVirtualMachineDiskListStorageConfigStorageContainerReference {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    url: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetVirtualMachineGpuList {
    /**
     * - (Computed) The device ID of the GPU.
     */
    deviceId: number;
    /**
     * Fraction of the physical GPU assigned.
     */
    fraction: number;
    /**
     * - GPU frame buffer size in MiB.
     */
    frameBufferSizeMib: number;
    /**
     * - Last determined guest driver version.
     */
    guestDriverVersion: string;
    /**
     * - The mode of this GPU.
     */
    mode: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - Number of supported virtual display heads.
     */
    numVirtualDisplayHeads: number;
    /**
     * GPU {segment:bus:device:function} (sbdf) address if assigned.
     */
    pciAddress: string;
    /**
     * - the UUID.
     */
    uuid: string;
    /**
     * - The vendor of the GPU.
     * * `UUID`: - UUID of the GPU.
     */
    vendor: string;
}

export interface GetVirtualMachineMessageList {
    details: {[key: string]: any};
    message: string;
    reason: string;
}

export interface GetVirtualMachineNicList {
    /**
     * -  The Floating IP associated with the vnic.
     */
    floatingIp: string;
    /**
     * - IP endpoints for the adapter. Currently, IPv4 addresses are supported.
     */
    ipEndpointLists: outputs.GetVirtualMachineNicListIpEndpointList[];
    /**
     * - Indicates whether the serial port connection is connected or not (`true` or `false`).
     */
    isConnected: string;
    /**
     * - The MAC address for the adapter.
     */
    macAddress: string;
    /**
     * - The model of this NIC. (Options : VIRTIO , E1000).
     */
    model: string;
    /**
     * - The reference to a network_function_chain.
     */
    networkFunctionChainReference: {[key: string]: string};
    /**
     * - The type of this Network function NIC. Defaults to INGRESS. (Options : INGRESS , EGRESS , TAP).
     */
    networkFunctionNicType: string;
    /**
     * - The type of this NIC. Defaults to NORMAL_NIC. (Options : NORMAL_NIC , DIRECT_NIC , NETWORK_FUNCTION_NIC).
     */
    nicType: string;
    /**
     * - The number of tx/rx queue pairs for this NIC.
     */
    numQueues: number;
    /**
     * - The name of the subnet reference to.
     */
    subnetName: string;
    /**
     * - The reference to a subnet.
     */
    subnetUuid: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetVirtualMachineNicListIpEndpointList {
    /**
     * - Address string.
     */
    ip: string;
    /**
     * - Address type. It can only be "ASSIGNED" in the spec. If no type is specified in the spec, the default type is set to "ASSIGNED". (Options : ASSIGNED , LEARNED)
     */
    type: string;
}

export interface GetVirtualMachineSerialPortList {
    /**
     * - Index of the serial port (int).
     */
    index: number;
    /**
     * - Indicates whether the serial port connection is connected or not (`true` or `false`).
     */
    isConnected: boolean;
}

export interface GetVpcSpec {
    /**
     * - the name.
     */
    name: string;
    /**
     * VPC resources status
     */
    resources: outputs.GetVpcSpecResource[];
}

export interface GetVpcSpecResource {
    /**
     * List of domain name server IPs.
     */
    commonDomainNameServerIpLists: outputs.GetVpcSpecResourceCommonDomainNameServerIpList[];
    /**
     * List of external subnets attached to this VPC.
     */
    externalSubnetLists: outputs.GetVpcSpecResourceExternalSubnetList[];
    /**
     * List of external routable ip and prefix .
     */
    externallyRoutablePrefixLists: outputs.GetVpcSpecResourceExternallyRoutablePrefixList[];
}

export interface GetVpcSpecResourceCommonDomainNameServerIpList {
    /**
     * ip address of domain name server.
     */
    ip: string;
}

export interface GetVpcSpecResourceExternalSubnetList {
    /**
     * Reference to a subnet.
     */
    externalSubnetReference: {[key: string]: string};
}

export interface GetVpcSpecResourceExternallyRoutablePrefixList {
    /**
     * ip address of domain name server.
     */
    ip: string;
    /**
     * prefix length of routable ip .
     */
    prefixLength: number;
}

export interface GetVpcStatus {
    /**
     * Execution Context of VPC.
     */
    executionContexts: outputs.GetVpcStatusExecutionContext[];
    /**
     * - the name.
     */
    name: string;
    /**
     * VPC resources status
     */
    resources: outputs.GetVpcStatusResource[];
    /**
     * The state of the VPC
     */
    state: string;
}

export interface GetVpcStatusExecutionContext {
    taskUuids: string[];
}

export interface GetVpcStatusResource {
    /**
     * List of domain name server IPs.
     */
    commonDomainNameServerIpLists: outputs.GetVpcStatusResourceCommonDomainNameServerIpList[];
    /**
     * List of external subnets attached to this VPC.
     */
    externalSubnetLists: outputs.GetVpcStatusResourceExternalSubnetList[];
    /**
     * List of external routable ip and prefix .
     */
    externallyRoutablePrefixLists: outputs.GetVpcStatusResourceExternallyRoutablePrefixList[];
}

export interface GetVpcStatusResourceCommonDomainNameServerIpList {
    /**
     * ip address of domain name server.
     */
    ip: string;
}

export interface GetVpcStatusResourceExternalSubnetList {
    /**
     * Active Gateway Node. Only present in VPC Status Resources.
     */
    activeGatewayNodes: outputs.GetVpcStatusResourceExternalSubnetListActiveGatewayNode[];
    /**
     * List of external subnets attached to this VPC. Only present in VPC Status Resources .
     */
    externalIpLists: string[];
    /**
     * Reference to a subnet.
     */
    externalSubnetReference: {[key: string]: string};
}

export interface GetVpcStatusResourceExternalSubnetListActiveGatewayNode {
    /**
     * Reference to host.
     */
    hostReference: {[key: string]: string};
    /**
     * ip address.
     */
    ipAddress: string;
}

export interface GetVpcStatusResourceExternallyRoutablePrefixList {
    /**
     * ip address of domain name server.
     */
    ip: string;
    /**
     * prefix length of routable ip .
     */
    prefixLength: number;
}

export interface GetVpcsEntity {
    /**
     * - The vpc kind metadata.
     */
    metadata: {[key: string]: string};
    /**
     * VPC input spec
     */
    specs: outputs.GetVpcsEntitySpec[];
    /**
     * VPC output status
     */
    statuses: outputs.GetVpcsEntityStatus[];
}

export interface GetVpcsEntitySpec {
    /**
     * - the name.
     */
    name: string;
    /**
     * VPC resources status
     */
    resources: outputs.GetVpcsEntitySpecResource[];
}

export interface GetVpcsEntitySpecResource {
    /**
     * List of domain name server IPs.
     */
    commonDomainNameServerIpLists: outputs.GetVpcsEntitySpecResourceCommonDomainNameServerIpList[];
    /**
     * List of external subnets attached to this VPC.
     */
    externalSubnetLists: outputs.GetVpcsEntitySpecResourceExternalSubnetList[];
    /**
     * List of external routable ip and prefix .
     */
    externallyRoutablePrefixLists: outputs.GetVpcsEntitySpecResourceExternallyRoutablePrefixList[];
}

export interface GetVpcsEntitySpecResourceCommonDomainNameServerIpList {
    /**
     * ip address of domain name server.
     */
    ip: string;
}

export interface GetVpcsEntitySpecResourceExternalSubnetList {
    /**
     * Reference to a subnet.
     */
    externalSubnetReference: {[key: string]: string};
}

export interface GetVpcsEntitySpecResourceExternallyRoutablePrefixList {
    /**
     * ip address of domain name server.
     */
    ip: string;
    /**
     * prefix length of routable ip .
     */
    prefixLength: number;
}

export interface GetVpcsEntityStatus {
    /**
     * Execution Context of VPC.
     */
    executionContexts: outputs.GetVpcsEntityStatusExecutionContext[];
    /**
     * - the name.
     */
    name: string;
    /**
     * VPC resources status
     */
    resources: outputs.GetVpcsEntityStatusResource[];
    /**
     * The state of the VPC
     */
    state: string;
}

export interface GetVpcsEntityStatusExecutionContext {
    taskUuids: string[];
}

export interface GetVpcsEntityStatusResource {
    /**
     * List of domain name server IPs.
     */
    commonDomainNameServerIpLists: outputs.GetVpcsEntityStatusResourceCommonDomainNameServerIpList[];
    /**
     * List of external subnets attached to this VPC.
     */
    externalSubnetLists: outputs.GetVpcsEntityStatusResourceExternalSubnetList[];
    /**
     * List of external routable ip and prefix .
     */
    externallyRoutablePrefixLists: outputs.GetVpcsEntityStatusResourceExternallyRoutablePrefixList[];
}

export interface GetVpcsEntityStatusResourceCommonDomainNameServerIpList {
    /**
     * ip address of domain name server.
     */
    ip: string;
}

export interface GetVpcsEntityStatusResourceExternalSubnetList {
    /**
     * Active Gateway Node. Only present in VPC Status Resources.
     */
    activeGatewayNodes: outputs.GetVpcsEntityStatusResourceExternalSubnetListActiveGatewayNode[];
    /**
     * List of external subnets attached to this VPC. Only present in VPC Status Resources .
     */
    externalIpLists: string[];
    /**
     * Reference to a subnet.
     */
    externalSubnetReference: {[key: string]: string};
}

export interface GetVpcsEntityStatusResourceExternalSubnetListActiveGatewayNode {
    /**
     * Reference to host.
     */
    hostReference: {[key: string]: string};
    /**
     * ip address.
     */
    ipAddress: string;
}

export interface GetVpcsEntityStatusResourceExternallyRoutablePrefixList {
    /**
     * ip address of domain name server.
     */
    ip: string;
    /**
     * prefix length of routable ip .
     */
    prefixLength: number;
}

export interface GetVpcsMetadata {
    filter: string;
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
    totalMatches: number;
}

export interface ImageCategory {
    /**
     * - (Required) The name for the image.
     */
    name: string;
    value: string;
}

export interface ImageClusterReference {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Required) The name for the image.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface ImageCurrentClusterReferenceList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Required) The name for the image.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface KarbonClusterActivePassiveConfig {
    externalIpv4Address: string;
}

export interface KarbonClusterCniConfig {
    /**
     * - (Optional) Configuration of the calico CNI provider.
     * * `calico_config.ip_pool_config`: - (Optional) List of IP pools to be configured/managed by calico.
     * * `calico_config.ip_pool_config.cidr`: - (Optional) IP range to use for this pool, it should fall within pod cidr.
     */
    calicoConfig?: outputs.KarbonClusterCniConfigCalicoConfig;
    /**
     * - (Optional) Configuration of the flannel container network interface (CNI) provider.
     */
    flannelConfigs?: outputs.KarbonClusterCniConfigFlannelConfig[];
    /**
     * - (Optional) The size of the subnet from the podIpv4Cidr assigned to each host. A value of 24 would allow up to 255 pods per node.
     */
    nodeCidrMaskSize?: number;
    /**
     * - (Optional) CIDR for pods in the cluster.
     */
    podIpv4Cidr?: string;
    /**
     * - (Optional) Classless inter-domain routing (CIDR) for k8s services in the cluster.
     */
    serviceIpv4Cidr?: string;
}

export interface KarbonClusterCniConfigCalicoConfig {
    ipPoolConfigs?: outputs.KarbonClusterCniConfigCalicoConfigIpPoolConfig[];
}

export interface KarbonClusterCniConfigCalicoConfigIpPoolConfig {
    cidr?: string;
}

export interface KarbonClusterCniConfigFlannelConfig {
}

export interface KarbonClusterEtcdNodePool {
    /**
     * - (Optional) VM configuration in AHV. **Note:** Updates to this attribute forces new resource creation.
     * * `ahv_config.cpu`: - (Required) The number of VCPUs allocated for each VM on the PE cluster.
     * * `ahv_config.disk_mib`: - (Optional) Size of local storage for each VM on the PE cluster in MiB.
     * * `ahv_config.memory_mib`: - (Optional) Memory allocated for each VM on the PE cluster in MiB.
     * * `ahv_config.network_uuid`: - (Required) The UUID of the network for the VMs deployed with this resource configuration.
     * * `ahv_config.prism_element_cluster_uuid`: - (Required) The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
     */
    ahvConfig?: outputs.KarbonClusterEtcdNodePoolAhvConfig;
    /**
     * - (Optional) Unique name of the node pool. **Note:** Updates to this attribute forces new resource creation.
     */
    name?: string;
    /**
     * - (Required) The version of the node OS image. **Note:** Updates to this attribute forces new resource creation.
     */
    nodeOsVersion: string;
    /**
     * - List of the deployed nodes in the node pool.
     * * `nodes.hostname`: - Hostname of the deployed node.
     * * `nodes.ipv4_address`: - IP of the deployed node.
     */
    nodes: outputs.KarbonClusterEtcdNodePoolNode[];
    /**
     * - (Required) Number of nodes in the node pool. **Note:** Updates to etcd or master node pool forces new resource creation.
     */
    numInstances: number;
}

export interface KarbonClusterEtcdNodePoolAhvConfig {
    cpu?: number;
    diskMib?: number;
    memoryMib?: number;
    networkUuid: string;
    prismElementClusterUuid: string;
}

export interface KarbonClusterEtcdNodePoolNode {
    hostname: string;
    ipv4Address: string;
}

export interface KarbonClusterExternalLbConfig {
    externalIpv4Address: string;
    masterNodesConfigs: outputs.KarbonClusterExternalLbConfigMasterNodesConfig[];
}

export interface KarbonClusterExternalLbConfigMasterNodesConfig {
    ipv4Address: string;
    nodePoolName?: string;
}

export interface KarbonClusterMasterNodePool {
    /**
     * - (Optional) VM configuration in AHV. **Note:** Updates to this attribute forces new resource creation.
     * * `ahv_config.cpu`: - (Required) The number of VCPUs allocated for each VM on the PE cluster.
     * * `ahv_config.disk_mib`: - (Optional) Size of local storage for each VM on the PE cluster in MiB.
     * * `ahv_config.memory_mib`: - (Optional) Memory allocated for each VM on the PE cluster in MiB.
     * * `ahv_config.network_uuid`: - (Required) The UUID of the network for the VMs deployed with this resource configuration.
     * * `ahv_config.prism_element_cluster_uuid`: - (Required) The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
     */
    ahvConfig?: outputs.KarbonClusterMasterNodePoolAhvConfig;
    /**
     * - (Optional) Unique name of the node pool. **Note:** Updates to this attribute forces new resource creation.
     */
    name?: string;
    /**
     * - (Required) The version of the node OS image. **Note:** Updates to this attribute forces new resource creation.
     */
    nodeOsVersion: string;
    /**
     * - List of the deployed nodes in the node pool.
     * * `nodes.hostname`: - Hostname of the deployed node.
     * * `nodes.ipv4_address`: - IP of the deployed node.
     */
    nodes: outputs.KarbonClusterMasterNodePoolNode[];
    /**
     * - (Required) Number of nodes in the node pool. **Note:** Updates to etcd or master node pool forces new resource creation.
     */
    numInstances: number;
}

export interface KarbonClusterMasterNodePoolAhvConfig {
    cpu?: number;
    diskMib?: number;
    memoryMib?: number;
    networkUuid: string;
    prismElementClusterUuid: string;
}

export interface KarbonClusterMasterNodePoolNode {
    hostname: string;
    ipv4Address: string;
}

export interface KarbonClusterPrivateRegistry {
    registryName: string;
}

export interface KarbonClusterSingleMasterConfig {
}

export interface KarbonClusterStorageClassConfig {
    /**
     * - (Required) The name of the storage class.
     */
    name?: string;
    /**
     * Reclaim policy for persistent volumes provisioned using the specified storage class.
     * * `volumes_config.#.file_system` - (Optional) Karbon uses either the ext4 or xfs file-system on the volume disk.
     * * `volumes_config.#.flash_mode` - (Optional) Pins the persistent volumes to the flash tier in case of a `true` value.
     * * `volumes_config.#.password` - (Required) The password of the Prism Element user that the API calls use to provision volumes.
     * * `volumes_config.#.prism_element_cluster_uuid` - (Required) The universally unique identifier (UUID) of the Prism Element cluster.
     * * `volumes_config.#.storage_container` - (Required) Name of the storage container the storage container uses to provision volumes.
     * * `volumes_config.#.username` - (Required) Username of the Prism Element user that the API calls use to provision volumes.
     *
     * **Note:** Updates to this attribute forces new resource creation.
     */
    reclaimPolicy?: string;
    volumesConfig: outputs.KarbonClusterStorageClassConfigVolumesConfig;
}

export interface KarbonClusterStorageClassConfigVolumesConfig {
    fileSystem?: string;
    flashMode?: boolean;
    password: string;
    prismElementClusterUuid: string;
    storageContainer: string;
    username: string;
}

export interface KarbonClusterWorkerNodePool {
    /**
     * - (Optional) VM configuration in AHV. **Note:** Updates to this attribute forces new resource creation.
     * * `ahv_config.cpu`: - (Required) The number of VCPUs allocated for each VM on the PE cluster.
     * * `ahv_config.disk_mib`: - (Optional) Size of local storage for each VM on the PE cluster in MiB.
     * * `ahv_config.memory_mib`: - (Optional) Memory allocated for each VM on the PE cluster in MiB.
     * * `ahv_config.network_uuid`: - (Required) The UUID of the network for the VMs deployed with this resource configuration.
     * * `ahv_config.prism_element_cluster_uuid`: - (Required) The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
     */
    ahvConfig?: outputs.KarbonClusterWorkerNodePoolAhvConfig;
    /**
     * - (Optional) Unique name of the node pool. **Note:** Updates to this attribute forces new resource creation.
     */
    name?: string;
    /**
     * - (Required) The version of the node OS image. **Note:** Updates to this attribute forces new resource creation.
     */
    nodeOsVersion: string;
    /**
     * - List of the deployed nodes in the node pool.
     * * `nodes.hostname`: - Hostname of the deployed node.
     * * `nodes.ipv4_address`: - IP of the deployed node.
     */
    nodes: outputs.KarbonClusterWorkerNodePoolNode[];
    /**
     * - (Required) Number of nodes in the node pool. **Note:** Updates to etcd or master node pool forces new resource creation.
     */
    numInstances: number;
}

export interface KarbonClusterWorkerNodePoolAhvConfig {
    cpu?: number;
    diskMib?: number;
    memoryMib?: number;
    networkUuid: string;
    prismElementClusterUuid: string;
}

export interface KarbonClusterWorkerNodePoolNode {
    hostname: string;
    ipv4Address: string;
}

export interface KarbonWorkerNodepoolAhvConfig {
    /**
     * - (Required) The number of VCPUs allocated for each VM on the PE cluster.
     */
    cpu?: number;
    /**
     * - (Optional) Size of local storage for each VM on the PE cluster in MiB.
     */
    diskMib?: number;
    /**
     * VM network UUID for isolating iscsi data traffic.
     */
    iscsiNetworkUuid: string;
    /**
     * - (Optional) Memory allocated for each VM on the PE cluster in MiB.
     */
    memoryMib?: number;
    /**
     * - (Required) The UUID of the network for the VMs deployed with this resource configuration.
     */
    networkUuid: string;
    /**
     * - (Optional) The unique universal identifier (UUID) of the Prism Element
     */
    prismElementClusterUuid: string;
}

export interface KarbonWorkerNodepoolNode {
    /**
     * hostname of node
     */
    hostname: string;
    /**
     * ipv4 address of node
     */
    ipv4Address: string;
}

export interface NdbCloneActionargument {
    /**
     * - (Required) name of argument
     */
    name: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbCloneDatabaseNode {
    accessLevel: {[key: string]: string};
    databaseId: string;
    databaseStatus: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    dbserver: {[key: string]: string};
    /**
     * Specify if you want to create a database server. This value can be set to true or false as required.
     */
    dbserverId: string;
    /**
     * database instance description
     */
    description: string;
    id: string;
    /**
     * info of clone
     */
    infos: outputs.NdbCloneDatabaseNodeInfo[];
    /**
     * database instance name
     */
    name: string;
    primary: boolean;
    /**
     * List of all the properties
     */
    properties: outputs.NdbCloneDatabaseNodeProperty[];
    protectionDomainId: string;
    protectionDomains: outputs.NdbCloneDatabaseNodeProtectionDomain[];
    softwareInstallationId: string;
    /**
     * status of clone
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.NdbCloneDatabaseNodeTag[];
}

export interface NdbCloneDatabaseNodeInfo {
    /**
     * info of clone
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbCloneDatabaseNodeProperty {
    /**
     * database instance description
     */
    description: string;
    /**
     * database instance name
     */
    name: string;
    refId: string;
    secure: boolean;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbCloneDatabaseNodeProtectionDomain {
    assocEntities: string[];
    cloudId: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * database instance description
     */
    description: string;
    eraCreated: boolean;
    id: string;
    /**
     * database instance name
     */
    name: string;
    ownerId: string;
    primaryHost: string;
    /**
     * List of all the properties
     */
    properties: outputs.NdbCloneDatabaseNodeProtectionDomainProperty[];
    /**
     * status of clone
     */
    status: string;
    /**
     * type of clone
     */
    type: string;
}

export interface NdbCloneDatabaseNodeProtectionDomainProperty {
    /**
     * database instance description
     */
    description: string;
    /**
     * database instance name
     */
    name: string;
    refId: string;
    secure: boolean;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbCloneDatabaseNodeTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbCloneInfo {
    bpgConfigs: outputs.NdbCloneInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface NdbCloneInfoBpgConfig {
    bpgDbParams: outputs.NdbCloneInfoBpgConfigBpgDbParam[];
    storages: outputs.NdbCloneInfoBpgConfigStorage[];
    vmProperties: outputs.NdbCloneInfoBpgConfigVmProperty[];
}

export interface NdbCloneInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface NdbCloneInfoBpgConfigStorage {
    archiveStorages: outputs.NdbCloneInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.NdbCloneInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.NdbCloneInfoBpgConfigStorageLogDisk[];
}

export interface NdbCloneInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface NdbCloneInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface NdbCloneInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface NdbCloneInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface NdbCloneLcmConfig {
    databaseLcmConfigs?: outputs.NdbCloneLcmConfigDatabaseLcmConfig[];
}

export interface NdbCloneLcmConfigDatabaseLcmConfig {
    expiryDetails?: outputs.NdbCloneLcmConfigDatabaseLcmConfigExpiryDetail[];
    refreshDetails?: outputs.NdbCloneLcmConfigDatabaseLcmConfigRefreshDetail[];
}

export interface NdbCloneLcmConfigDatabaseLcmConfigExpiryDetail {
    deleteDatabase?: boolean;
    expireInDays?: number;
    expiryDateTimezone: string;
}

export interface NdbCloneLcmConfigDatabaseLcmConfigRefreshDetail {
    refreshDateTimezone?: string;
    refreshInDays?: number;
    refreshTime?: string;
}

export interface NdbCloneLinkedDatabase {
    /**
     * database name
     */
    databaseName: string;
    databaseStatus: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * database instance description
     */
    description: string;
    id: string;
    /**
     * info of clone
     */
    infos: outputs.NdbCloneLinkedDatabaseInfo[];
    /**
     * Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
     */
    metric: {[key: string]: string};
    /**
     * database instance name
     */
    name: string;
    parentDatabaseId: string;
    parentLinkedDatabaseId: string;
    /**
     * snapshot id from where clone is created
     */
    snapshotId: string;
    /**
     * status of clone
     */
    status: string;
    timezone: string;
}

export interface NdbCloneLinkedDatabaseInfo {
    /**
     * info of clone
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbCloneNode {
    /**
     * specify compute profile id
     */
    computeProfileId?: string;
    /**
     * dberver id
     */
    dbserverId?: string;
    /**
     * specify network profile id
     */
    networkProfileId?: string;
    /**
     * dbserver time zone
     */
    newDbServerTimeZone?: string;
    /**
     * cluster id
     */
    nxClusterId?: string;
    /**
     * properties of vm
     */
    properties?: outputs.NdbCloneNodeProperty[];
    /**
     * name for the database server VM.
     */
    vmName?: string;
}

export interface NdbCloneNodeProperty {
    /**
     * database instance name
     */
    name?: string;
    /**
     * - (Required) value for argument
     */
    value?: string;
}

export interface NdbClonePostgresqlInfo {
    /**
     * password of the postgres superuser.
     */
    dbPassword: string;
    /**
     * description for the dbserver.
     */
    dbserverDescription?: string;
    /**
     * OS command that you want to run after the instance is created.
     */
    postCloneCmd?: string;
    /**
     * OS command that you want to run before the instance is created.
     */
    preCloneCmd?: string;
    /**
     * name for the database server VM.
     */
    vmName: string;
}

export interface NdbCloneProperty {
    /**
     * database instance name
     */
    name: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbCloneTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbCloneTimeMachine {
    accessLevel: string;
    /**
     * cloned or not
     */
    clone: boolean;
    clones: string;
    /**
     * clone will be clustered or not
     */
    clustered: boolean;
    database: string;
    databaseId: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * database instance description
     */
    description: string;
    eaStatus: string;
    id: string;
    /**
     * Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
     */
    metric: string;
    /**
     * database instance name
     */
    name: string;
    /**
     * List of all the properties
     */
    properties: outputs.NdbCloneTimeMachineProperty[];
    scheduleId: string;
    schedules: outputs.NdbCloneTimeMachineSchedule[];
    scope: string;
    slaId: string;
    slaUpdateInProgress: boolean;
    slaUpdateMetadata: string;
    slas: outputs.NdbCloneTimeMachineSla[];
    sourceNxClusters: string[];
    /**
     * status of clone
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.NdbCloneTimeMachineTag[];
    /**
     * type of clone
     */
    type: string;
}

export interface NdbCloneTimeMachineProperty {
    /**
     * database instance description
     */
    description: string;
    /**
     * database instance name
     */
    name: string;
    refId: string;
    secure: boolean;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbCloneTimeMachineSchedule {
    continuousSchedules: outputs.NdbCloneTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.NdbCloneTimeMachineScheduleDailySchedule[];
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * database instance description
     */
    description: string;
    globalPolicy: boolean;
    id: string;
    monthlySchedules: outputs.NdbCloneTimeMachineScheduleMonthlySchedule[];
    /**
     * database instance name
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.NdbCloneTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.NdbCloneTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    /**
     * timezone
     */
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.NdbCloneTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.NdbCloneTimeMachineScheduleYearlySchedule[];
}

export interface NdbCloneTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface NdbCloneTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface NdbCloneTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface NdbCloneTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface NdbCloneTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface NdbCloneTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface NdbCloneTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface NdbCloneTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * database instance description
     */
    description: string;
    id: string;
    monthlyRetention: number;
    /**
     * database instance name
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface NdbCloneTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbClusterAgentNetworkInfo {
    /**
     * string of DNS servers(comma separted).
     */
    dns?: string;
    /**
     * string of NTP servers(comma separted).
     */
    ntp?: string;
}

export interface NdbClusterEntityCount {
    dbServers: number;
    engineCounts: outputs.NdbClusterEntityCountEngineCount[];
}

export interface NdbClusterEntityCountEngineCount {
    mariadbDatabases: outputs.NdbClusterEntityCountEngineCountMariadbDatabase[];
    mongodbDatabases: outputs.NdbClusterEntityCountEngineCountMongodbDatabase[];
    mysqlDatabases: outputs.NdbClusterEntityCountEngineCountMysqlDatabase[];
    oracleDatabases: outputs.NdbClusterEntityCountEngineCountOracleDatabase[];
    postgresDatabases: outputs.NdbClusterEntityCountEngineCountPostgresDatabase[];
    saphanaDatabases: outputs.NdbClusterEntityCountEngineCountSaphanaDatabase[];
    sqlserverDatabases: outputs.NdbClusterEntityCountEngineCountSqlserverDatabase[];
}

export interface NdbClusterEntityCountEngineCountMariadbDatabase {
    profiles: outputs.NdbClusterEntityCountEngineCountMariadbDatabaseProfile[];
    timeMachines: number;
}

export interface NdbClusterEntityCountEngineCountMariadbDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface NdbClusterEntityCountEngineCountMongodbDatabase {
    profiles: outputs.NdbClusterEntityCountEngineCountMongodbDatabaseProfile[];
    timeMachines: number;
}

export interface NdbClusterEntityCountEngineCountMongodbDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface NdbClusterEntityCountEngineCountMysqlDatabase {
    profiles: outputs.NdbClusterEntityCountEngineCountMysqlDatabaseProfile[];
    timeMachines: number;
}

export interface NdbClusterEntityCountEngineCountMysqlDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface NdbClusterEntityCountEngineCountOracleDatabase {
    profiles: outputs.NdbClusterEntityCountEngineCountOracleDatabaseProfile[];
    timeMachines: number;
}

export interface NdbClusterEntityCountEngineCountOracleDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface NdbClusterEntityCountEngineCountPostgresDatabase {
    profiles: outputs.NdbClusterEntityCountEngineCountPostgresDatabaseProfile[];
    timeMachines: number;
}

export interface NdbClusterEntityCountEngineCountPostgresDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface NdbClusterEntityCountEngineCountSaphanaDatabase {
    profiles: outputs.NdbClusterEntityCountEngineCountSaphanaDatabaseProfile[];
    timeMachines: number;
}

export interface NdbClusterEntityCountEngineCountSaphanaDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface NdbClusterEntityCountEngineCountSqlserverDatabase {
    profiles: outputs.NdbClusterEntityCountEngineCountSqlserverDatabaseProfile[];
    timeMachines: number;
}

export interface NdbClusterEntityCountEngineCountSqlserverDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface NdbClusterNetworksInfo {
    /**
     * VLAN access types for which you want to configure network segmentation. Supports [PRISM, DSIP, DBSERVER ]. 
     * Prism Element: Select this VLAN access type to configure a VLAN that the NDB agent VM can use to communicate with Prism.
     * Prism iSCSI Data Service. Select this VLAN access type to configure a VLAN that the agent VM can use to make connection requests to the iSCSI data services IP.
     * DBServer Access from NDB server. Select this VLAN access type to configure a VLAN that is used for communications between the NDB agent VM and the database server VM on the newly registered NDB server cluster.
     */
    accessTypes?: string[];
    /**
     * network segmentation to segment the network traffic
     */
    networkInfos?: outputs.NdbClusterNetworksInfoNetworkInfo[];
    /**
     * type of vlan. Supported [DHCP, Static, IPAM]
     */
    type?: string;
}

export interface NdbClusterNetworksInfoNetworkInfo {
    /**
     * gateway of agent network
     */
    gateway?: string;
    /**
     * static ip of agent network
     */
    staticIp?: string;
    /**
     * subnet mask of agent network
     */
    subnetMask?: string;
    /**
     * vlan name
     */
    vlanName?: string;
}

export interface NdbClusterProperty {
    /**
     * description of cluster
     */
    description: string;
    /**
     * name of the cluster to be registered
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbClusterResourceConfig {
    memoryThresholdPercentage: number;
    storageThresholdPercentage: number;
}

export interface NdbDatabaseActionargument {
    /**
     * - (Required) name of argument
     */
    name: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbDatabaseClusterInfo {
    clusterIpInfos: outputs.NdbDatabaseClusterInfoClusterIpInfo[];
}

export interface NdbDatabaseClusterInfoClusterIpInfo {
    /**
     * - (Optional) IP infos for custom network profile.
     */
    ipInfos?: outputs.NdbDatabaseClusterInfoClusterIpInfoIpInfo[];
    /**
     * - (Optional) cluster id.
     */
    nxClusterId: string;
}

export interface NdbDatabaseClusterInfoClusterIpInfoIpInfo {
    ipAddresses?: string[];
    ipType?: string;
}

export interface NdbDatabaseDatabaseNode {
    accessLevel: {[key: string]: string};
    databaseId: string;
    databaseStatus: string;
    dateCreated: string;
    dateModified: string;
    dbserver: {[key: string]: string};
    dbserverId: string;
    /**
     * - (Optional) The description
     */
    description: string;
    id: string;
    infos: outputs.NdbDatabaseDatabaseNodeInfo[];
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    primary: boolean;
    /**
     * List of all the properties
     */
    properties: outputs.NdbDatabaseDatabaseNodeProperty[];
    protectionDomainId: string;
    protectionDomains: outputs.NdbDatabaseDatabaseNodeProtectionDomain[];
    softwareInstallationId: string;
    status: string;
    /**
     * - (Optional) tags
     */
    tags: outputs.NdbDatabaseDatabaseNodeTag[];
}

export interface NdbDatabaseDatabaseNodeInfo {
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbDatabaseDatabaseNodeProperty {
    /**
     * - (Optional) The description
     */
    description: string;
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    refId: string;
    secure: boolean;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbDatabaseDatabaseNodeProtectionDomain {
    assocEntities: string[];
    cloudId: string;
    dateCreated: string;
    dateModified: string;
    /**
     * - (Optional) The description
     */
    description: string;
    eraCreated: boolean;
    id: string;
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    ownerId: string;
    primaryHost: string;
    /**
     * List of all the properties
     */
    properties: outputs.NdbDatabaseDatabaseNodeProtectionDomainProperty[];
    status: string;
    type: string;
}

export interface NdbDatabaseDatabaseNodeProtectionDomainProperty {
    /**
     * - (Optional) The description
     */
    description: string;
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    refId: string;
    secure: boolean;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbDatabaseDatabaseNodeTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbDatabaseInfo {
    bpgConfigs: outputs.NdbDatabaseInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface NdbDatabaseInfoBpgConfig {
    bpgDbParams: outputs.NdbDatabaseInfoBpgConfigBpgDbParam[];
    storages: outputs.NdbDatabaseInfoBpgConfigStorage[];
    vmProperties: outputs.NdbDatabaseInfoBpgConfigVmProperty[];
}

export interface NdbDatabaseInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface NdbDatabaseInfoBpgConfigStorage {
    archiveStorages: outputs.NdbDatabaseInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.NdbDatabaseInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.NdbDatabaseInfoBpgConfigStorageLogDisk[];
}

export interface NdbDatabaseInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface NdbDatabaseInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface NdbDatabaseInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface NdbDatabaseInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface NdbDatabaseLcmConfig {
    expiryDetails: outputs.NdbDatabaseLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.NdbDatabaseLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.NdbDatabaseLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.NdbDatabaseLcmConfigRefreshDetail[];
}

export interface NdbDatabaseLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    /**
     * - (Optional) Delete the database's Time Machine (snapshots/logs) from the NDB. Default value is true
     */
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface NdbDatabaseLcmConfigPostDeleteCommand {
    command: string;
}

export interface NdbDatabaseLcmConfigPreDeleteCommand {
    command: string;
}

export interface NdbDatabaseLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface NdbDatabaseLinkedDatabase {
    databaseName: string;
    databaseStatus: string;
    dateCreated: string;
    dateModified: string;
    /**
     * - (Optional) The description
     */
    description: string;
    id: string;
    infos: outputs.NdbDatabaseLinkedDatabaseInfo[];
    metric: {[key: string]: string};
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    parentDatabaseId: string;
    parentLinkedDatabaseId: string;
    snapshotId: string;
    status: string;
    timezone: string;
}

export interface NdbDatabaseLinkedDatabaseInfo {
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbDatabaseMaintenanceTasks {
    maintenanceWindowId?: string;
    tasks?: outputs.NdbDatabaseMaintenanceTasksTask[];
}

export interface NdbDatabaseMaintenanceTasksTask {
    postCommand?: string;
    preCommand?: string;
    taskType?: string;
}

export interface NdbDatabaseNode {
    /**
     * - (Optional) compute profile id
     */
    computeprofileid?: string;
    /**
     * - (Optional) Database server ID required for existing VM
     */
    dbserverid?: string;
    /**
     * - (Optional) IP infos for custom network profile.
     */
    ipInfos?: outputs.NdbDatabaseNodeIpInfo[];
    /**
     * - (Required) network profile ID
     */
    networkprofileid?: string;
    /**
     * - (Optional) cluster id.
     */
    nxClusterId?: string;
    /**
     * - (Optional) list of additional properties
     */
    properties?: outputs.NdbDatabaseNodeProperty[];
    /**
     * - (Required) name of vm
     */
    vmname: string;
}

export interface NdbDatabaseNodeIpInfo {
    ipAddresses?: string[];
    ipType?: string;
}

export interface NdbDatabaseNodeProperty {
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbDatabasePostgresqlInfo {
    /**
     * - (Optional) allocate huge page. Default: false
     */
    allocatePgHugepage?: boolean;
    /**
     * - (Optional) auth methods. Default: md5
     */
    authMethod?: string;
    /**
     * - (Optional) enable auto tuning of staging drive. Default: false
     */
    autoTuneStagingDrive?: boolean;
    /**
     * - (Optional) if clustered database. Default: false
     */
    clusterDatabase?: boolean;
    /**
     * - (Required) name of initial database to be created
     */
    databaseNames: string;
    /**
     * - (Required) initial database size
     */
    databaseSize: string;
    /**
     * - (Required) database instance password
     */
    dbPassword: string;
    /**
     * - (Optional) High Availability instance
     */
    haInstance?: outputs.NdbDatabasePostgresqlInfoHaInstance;
    /**
     * - (Required) listener port for database instance
     */
    listenerPort: string;
    /**
     * - (Optional) post instance create script
     */
    postCreateScript?: string;
    /**
     * - (Optional) pre instance create script
     */
    preCreateScript?: string;
}

export interface NdbDatabasePostgresqlInfoHaInstance {
    /**
     * - (Optional) archive wal expire days. Default is set to -1
     */
    archiveWalExpireDays?: number;
    /**
     * - (Optional) backup policy for instance. Default is "primaryOnly"
     */
    backupPolicy?: string;
    clusterDescription?: string;
    /**
     * - (Required) cluster name
     */
    clusterName: string;
    /**
     * - (Optional) HA proxy node. Default is set to false
     */
    deployHaproxy?: boolean;
    /**
     * - (Optional) enable peer auth . Default is set to false.
     */
    enablePeerAuth?: boolean;
    /**
     * - (Optional) enable synchronous mode. Default is set to true
     */
    enableSynchronousMode?: boolean;
    /**
     * - (Optional) failover mode of nodes.
     */
    failoverMode?: string;
    /**
     * - (Optional) node type of instance. Default is set to database
     */
    nodeType?: string;
    /**
     * - (Required) patroni cluster name
     */
    patroniClusterName: string;
    /**
     * - (Optional) provisional virtual ip. Default is set to true
     */
    provisionVirtualIp?: boolean;
    /**
     * -  (Required) proxy read port
     */
    proxyReadPort: string;
    /**
     * - (Required) proxy write port
     */
    proxyWritePort: string;
}

export interface NdbDatabaseProperty {
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbDatabaseRestoreDatabaseNode {
    accessLevel: {[key: string]: string};
    /**
     * database id
     */
    databaseId: string;
    databaseStatus: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    dbserver: {[key: string]: string};
    dbserverId: string;
    /**
     * description of database instance
     */
    description: string;
    id: string;
    /**
     * info of instance
     */
    infos: outputs.NdbDatabaseRestoreDatabaseNodeInfo[];
    /**
     * Name of database instance
     */
    name: string;
    primary: boolean;
    /**
     * properties of database created
     */
    properties: outputs.NdbDatabaseRestoreDatabaseNodeProperty[];
    protectionDomainId: string;
    protectionDomains: outputs.NdbDatabaseRestoreDatabaseNodeProtectionDomain[];
    softwareInstallationId: string;
    /**
     * status of instance
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.NdbDatabaseRestoreDatabaseNodeTag[];
}

export interface NdbDatabaseRestoreDatabaseNodeInfo {
    /**
     * info of instance
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbDatabaseRestoreDatabaseNodeProperty {
    /**
     * description of database instance
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbDatabaseRestoreDatabaseNodeProtectionDomain {
    assocEntities: string[];
    cloudId: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    eraCreated: boolean;
    id: string;
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    primaryHost: string;
    /**
     * properties of database created
     */
    properties: outputs.NdbDatabaseRestoreDatabaseNodeProtectionDomainProperty[];
    /**
     * status of instance
     */
    status: string;
    /**
     * type of database
     */
    type: string;
}

export interface NdbDatabaseRestoreDatabaseNodeProtectionDomainProperty {
    /**
     * description of database instance
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbDatabaseRestoreDatabaseNodeTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbDatabaseRestoreInfo {
    bpgConfigs: outputs.NdbDatabaseRestoreInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface NdbDatabaseRestoreInfoBpgConfig {
    bpgDbParams: outputs.NdbDatabaseRestoreInfoBpgConfigBpgDbParam[];
    storages: outputs.NdbDatabaseRestoreInfoBpgConfigStorage[];
    vmProperties: outputs.NdbDatabaseRestoreInfoBpgConfigVmProperty[];
}

export interface NdbDatabaseRestoreInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface NdbDatabaseRestoreInfoBpgConfigStorage {
    archiveStorages: outputs.NdbDatabaseRestoreInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.NdbDatabaseRestoreInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.NdbDatabaseRestoreInfoBpgConfigStorageLogDisk[];
}

export interface NdbDatabaseRestoreInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface NdbDatabaseRestoreInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface NdbDatabaseRestoreInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface NdbDatabaseRestoreInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface NdbDatabaseRestoreLcmConfig {
    expiryDetails: outputs.NdbDatabaseRestoreLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.NdbDatabaseRestoreLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.NdbDatabaseRestoreLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.NdbDatabaseRestoreLcmConfigRefreshDetail[];
}

export interface NdbDatabaseRestoreLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface NdbDatabaseRestoreLcmConfigPostDeleteCommand {
    command: string;
}

export interface NdbDatabaseRestoreLcmConfigPreDeleteCommand {
    command: string;
}

export interface NdbDatabaseRestoreLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface NdbDatabaseRestoreLinkedDatabase {
    /**
     * name of database
     */
    databaseName: string;
    databaseStatus: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    id: string;
    /**
     * info of instance
     */
    infos: outputs.NdbDatabaseRestoreLinkedDatabaseInfo[];
    /**
     * Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
     */
    metric: {[key: string]: string};
    /**
     * Name of database instance
     */
    name: string;
    /**
     * parent database id
     */
    parentDatabaseId: string;
    parentLinkedDatabaseId: string;
    /**
     * snapshot id from you want to use for restoring the instance
     */
    snapshotId: string;
    /**
     * status of instance
     */
    status: string;
    timezone: string;
}

export interface NdbDatabaseRestoreLinkedDatabaseInfo {
    /**
     * info of instance
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbDatabaseRestoreProperty {
    /**
     * Name of database instance
     */
    name: string;
    value: string;
}

export interface NdbDatabaseRestoreTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbDatabaseRestoreTimeMachine {
    accessLevel: string;
    /**
     * whether instance is cloned or not
     */
    clone: boolean;
    clones: string;
    clustered: boolean;
    database: string;
    /**
     * database id
     */
    databaseId: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    eaStatus: string;
    id: string;
    /**
     * Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
     */
    metric: string;
    /**
     * Name of database instance
     */
    name: string;
    /**
     * properties of database created
     */
    properties: outputs.NdbDatabaseRestoreTimeMachineProperty[];
    scheduleId: string;
    schedules: outputs.NdbDatabaseRestoreTimeMachineSchedule[];
    scope: string;
    slaId: string;
    slaUpdateInProgress: boolean;
    slaUpdateMetadata: string;
    slas: outputs.NdbDatabaseRestoreTimeMachineSla[];
    sourceNxClusters: string[];
    /**
     * status of instance
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.NdbDatabaseRestoreTimeMachineTag[];
    /**
     * type of database
     */
    type: string;
}

export interface NdbDatabaseRestoreTimeMachineProperty {
    /**
     * description of database instance
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbDatabaseRestoreTimeMachineSchedule {
    continuousSchedules: outputs.NdbDatabaseRestoreTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.NdbDatabaseRestoreTimeMachineScheduleDailySchedule[];
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    globalPolicy: boolean;
    id: string;
    monthlySchedules: outputs.NdbDatabaseRestoreTimeMachineScheduleMonthlySchedule[];
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.NdbDatabaseRestoreTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.NdbDatabaseRestoreTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    /**
     * timezone on which instance is created xw
     */
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.NdbDatabaseRestoreTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.NdbDatabaseRestoreTimeMachineScheduleYearlySchedule[];
}

export interface NdbDatabaseRestoreTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface NdbDatabaseRestoreTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface NdbDatabaseRestoreTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface NdbDatabaseRestoreTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface NdbDatabaseRestoreTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface NdbDatabaseRestoreTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface NdbDatabaseRestoreTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface NdbDatabaseRestoreTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    id: string;
    monthlyRetention: number;
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface NdbDatabaseRestoreTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbDatabaseScaleDatabaseNode {
    accessLevel: {[key: string]: string};
    databaseId: string;
    databaseStatus: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    dbserver: {[key: string]: string};
    dbserverId: string;
    /**
     * description of database instance
     */
    description: string;
    id: string;
    /**
     * info of instance
     */
    infos: outputs.NdbDatabaseScaleDatabaseNodeInfo[];
    /**
     * Name of database instance
     */
    name: string;
    primary: boolean;
    /**
     * properties of database created
     */
    properties: outputs.NdbDatabaseScaleDatabaseNodeProperty[];
    protectionDomainId: string;
    protectionDomains: outputs.NdbDatabaseScaleDatabaseNodeProtectionDomain[];
    softwareInstallationId: string;
    /**
     * status of instance
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.NdbDatabaseScaleDatabaseNodeTag[];
}

export interface NdbDatabaseScaleDatabaseNodeInfo {
    /**
     * info of instance
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbDatabaseScaleDatabaseNodeProperty {
    /**
     * description of database instance
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbDatabaseScaleDatabaseNodeProtectionDomain {
    assocEntities: string[];
    cloudId: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    eraCreated: boolean;
    id: string;
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    primaryHost: string;
    /**
     * properties of database created
     */
    properties: outputs.NdbDatabaseScaleDatabaseNodeProtectionDomainProperty[];
    /**
     * status of instance
     */
    status: string;
    /**
     * type of database
     */
    type: string;
}

export interface NdbDatabaseScaleDatabaseNodeProtectionDomainProperty {
    /**
     * description of database instance
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbDatabaseScaleDatabaseNodeTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbDatabaseScaleInfo {
    bpgConfigs: outputs.NdbDatabaseScaleInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface NdbDatabaseScaleInfoBpgConfig {
    bpgDbParams: outputs.NdbDatabaseScaleInfoBpgConfigBpgDbParam[];
    storages: outputs.NdbDatabaseScaleInfoBpgConfigStorage[];
    vmProperties: outputs.NdbDatabaseScaleInfoBpgConfigVmProperty[];
}

export interface NdbDatabaseScaleInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface NdbDatabaseScaleInfoBpgConfigStorage {
    archiveStorages: outputs.NdbDatabaseScaleInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.NdbDatabaseScaleInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.NdbDatabaseScaleInfoBpgConfigStorageLogDisk[];
}

export interface NdbDatabaseScaleInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface NdbDatabaseScaleInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface NdbDatabaseScaleInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface NdbDatabaseScaleInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface NdbDatabaseScaleLcmConfig {
    expiryDetails: outputs.NdbDatabaseScaleLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.NdbDatabaseScaleLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.NdbDatabaseScaleLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.NdbDatabaseScaleLcmConfigRefreshDetail[];
}

export interface NdbDatabaseScaleLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface NdbDatabaseScaleLcmConfigPostDeleteCommand {
    command: string;
}

export interface NdbDatabaseScaleLcmConfigPreDeleteCommand {
    command: string;
}

export interface NdbDatabaseScaleLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface NdbDatabaseScaleLinkedDatabase {
    /**
     * name of database
     */
    databaseName: string;
    databaseStatus: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    id: string;
    /**
     * info of instance
     */
    infos: outputs.NdbDatabaseScaleLinkedDatabaseInfo[];
    /**
     * Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
     */
    metric: {[key: string]: string};
    /**
     * Name of database instance
     */
    name: string;
    /**
     * parent database id
     */
    parentDatabaseId: string;
    parentLinkedDatabaseId: string;
    snapshotId: string;
    /**
     * status of instance
     */
    status: string;
    timezone: string;
}

export interface NdbDatabaseScaleLinkedDatabaseInfo {
    /**
     * info of instance
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbDatabaseScaleProperty {
    /**
     * Name of database instance
     */
    name: string;
    value: string;
}

export interface NdbDatabaseScaleTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbDatabaseScaleTimeMachine {
    accessLevel: string;
    /**
     * whether instance is cloned or not
     */
    clone: boolean;
    clones: string;
    clustered: boolean;
    database: string;
    databaseId: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    eaStatus: string;
    id: string;
    /**
     * Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
     */
    metric: string;
    /**
     * Name of database instance
     */
    name: string;
    /**
     * properties of database created
     */
    properties: outputs.NdbDatabaseScaleTimeMachineProperty[];
    scheduleId: string;
    schedules: outputs.NdbDatabaseScaleTimeMachineSchedule[];
    scope: string;
    slaId: string;
    slaUpdateInProgress: boolean;
    slaUpdateMetadata: string;
    slas: outputs.NdbDatabaseScaleTimeMachineSla[];
    sourceNxClusters: string[];
    /**
     * status of instance
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.NdbDatabaseScaleTimeMachineTag[];
    /**
     * type of database
     */
    type: string;
}

export interface NdbDatabaseScaleTimeMachineProperty {
    /**
     * description of database instance
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbDatabaseScaleTimeMachineSchedule {
    continuousSchedules: outputs.NdbDatabaseScaleTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.NdbDatabaseScaleTimeMachineScheduleDailySchedule[];
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    globalPolicy: boolean;
    id: string;
    monthlySchedules: outputs.NdbDatabaseScaleTimeMachineScheduleMonthlySchedule[];
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.NdbDatabaseScaleTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.NdbDatabaseScaleTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    /**
     * timezone on which instance is created xw
     */
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.NdbDatabaseScaleTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.NdbDatabaseScaleTimeMachineScheduleYearlySchedule[];
}

export interface NdbDatabaseScaleTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface NdbDatabaseScaleTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface NdbDatabaseScaleTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface NdbDatabaseScaleTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface NdbDatabaseScaleTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface NdbDatabaseScaleTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface NdbDatabaseScaleTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface NdbDatabaseScaleTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    id: string;
    monthlyRetention: number;
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface NdbDatabaseScaleTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbDatabaseSnapshotLcmConfig {
    expiryDetails: outputs.NdbDatabaseSnapshotLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.NdbDatabaseSnapshotLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.NdbDatabaseSnapshotLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.NdbDatabaseSnapshotLcmConfigRefreshDetail[];
}

export interface NdbDatabaseSnapshotLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    /**
     * Default is set to Asia/Calcutta
     */
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface NdbDatabaseSnapshotLcmConfigPostDeleteCommand {
    command: string;
}

export interface NdbDatabaseSnapshotLcmConfigPreDeleteCommand {
    command: string;
}

export interface NdbDatabaseSnapshotLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface NdbDatabaseSnapshotProperty {
    /**
     * description of snapshot
     */
    description: string;
    /**
     * Snapshot name. Default value is era_manual_snapshot.
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbDatabaseSnapshotTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbDatabaseTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbDatabaseTimeMachine {
    accessLevel: string;
    clone: boolean;
    clones: string;
    /**
     * - (Optional) If clustered database. Default: false
     */
    clustered: boolean;
    database: string;
    databaseId: string;
    dateCreated: string;
    dateModified: string;
    /**
     * - (Optional) The description
     */
    description: string;
    eaStatus: string;
    id: string;
    metric: string;
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    /**
     * List of all the properties
     */
    properties: outputs.NdbDatabaseTimeMachineProperty[];
    scheduleId: string;
    /**
     * - (Optional) schedule for snapshots
     */
    schedules: outputs.NdbDatabaseTimeMachineSchedule[];
    scope: string;
    slaId: string;
    slaUpdateInProgress: boolean;
    slaUpdateMetadata: string;
    slas: outputs.NdbDatabaseTimeMachineSla[];
    sourceNxClusters: string[];
    status: string;
    /**
     * - (Optional) tags
     */
    tags: outputs.NdbDatabaseTimeMachineTag[];
    type: string;
}

export interface NdbDatabaseTimeMachineProperty {
    /**
     * - (Optional) The description
     */
    description: string;
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    refId: string;
    secure: boolean;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbDatabaseTimeMachineSchedule {
    continuousSchedules: outputs.NdbDatabaseTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.NdbDatabaseTimeMachineScheduleDailySchedule[];
    dateCreated: string;
    dateModified: string;
    /**
     * - (Optional) The description
     */
    description: string;
    globalPolicy: boolean;
    id: string;
    monthlySchedules: outputs.NdbDatabaseTimeMachineScheduleMonthlySchedule[];
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.NdbDatabaseTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.NdbDatabaseTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.NdbDatabaseTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.NdbDatabaseTimeMachineScheduleYearlySchedule[];
}

export interface NdbDatabaseTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface NdbDatabaseTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface NdbDatabaseTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface NdbDatabaseTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface NdbDatabaseTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    /**
     * - (Required) hours
     */
    hours: number;
    /**
     * - (Required) minutes
     */
    minutes: number;
    /**
     * - (Required) seconds
     */
    seconds: number;
}

export interface NdbDatabaseTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface NdbDatabaseTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    /**
     * - (Required) month for snapshot
     */
    month: string;
    monthValue: string;
}

export interface NdbDatabaseTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    dateCreated: string;
    dateModified: string;
    /**
     * - (Optional) The description
     */
    description: string;
    id: string;
    monthlyRetention: number;
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface NdbDatabaseTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbDatabaseTimemachineinfo {
    /**
     * - (Optional) enable auto tune log drive. Default: true
     */
    autotunelogdrive?: boolean;
    /**
     * - (Optional) description of time machine
     */
    description?: string;
    /**
     * - (Required) name of time machine
     */
    name: string;
    /**
     * - (Optional) schedule for snapshots
     */
    schedule: outputs.NdbDatabaseTimemachineinfoSchedule;
    /**
     * -  (optional) SLA details for HA instance
     */
    slaDetails?: outputs.NdbDatabaseTimemachineinfoSlaDetail[];
    /**
     * - (Optional) SLA ID for single instance
     */
    slaid?: string;
    /**
     * - (Optional) tags
     */
    tags: outputs.NdbDatabaseTimemachineinfoTag[];
}

export interface NdbDatabaseTimemachineinfoSchedule {
    /**
     * - (Optional) snapshot freq and log config
     */
    continuousschedule?: outputs.NdbDatabaseTimemachineinfoScheduleContinuousschedule;
    /**
     * - (Optional) monthly snapshot config
     */
    monthlyschedule?: outputs.NdbDatabaseTimemachineinfoScheduleMonthlyschedule;
    /**
     * - (Optional) quaterly snapshot config
     */
    quartelyschedule?: outputs.NdbDatabaseTimemachineinfoScheduleQuartelyschedule;
    /**
     * - (Optional) daily snapshot config
     */
    snapshottimeofday?: outputs.NdbDatabaseTimemachineinfoScheduleSnapshottimeofday;
    /**
     * - (Optional) weekly snapshot config
     */
    weeklyschedule?: outputs.NdbDatabaseTimemachineinfoScheduleWeeklyschedule;
    /**
     * - (Optional) yearly snapshot config
     */
    yearlyschedule?: outputs.NdbDatabaseTimemachineinfoScheduleYearlyschedule;
}

export interface NdbDatabaseTimemachineinfoScheduleContinuousschedule {
    /**
     * - (Required) to enable
     */
    enabled: boolean;
    /**
     * - (Required) log catchup interval for database
     */
    logbackupinterval: number;
    /**
     * - (Required) num of snapshots per day
     */
    snapshotsperday: number;
}

export interface NdbDatabaseTimemachineinfoScheduleMonthlyschedule {
    /**
     * - (Required) day of month to take snapshot
     */
    dayofmonth: number;
    /**
     * - (Required) to enable
     */
    enabled: boolean;
}

export interface NdbDatabaseTimemachineinfoScheduleQuartelyschedule {
    /**
     * - (Required) month's day for snapshot
     */
    dayofmonth: number;
    /**
     * - (Required) to enable
     */
    enabled: boolean;
    /**
     * - (Required) quarter start month
     */
    startmonth: string;
}

export interface NdbDatabaseTimemachineinfoScheduleSnapshottimeofday {
    /**
     * - (Required) hours
     */
    hours: number;
    /**
     * - (Required) minutes
     */
    minutes: number;
    /**
     * - (Required) seconds
     */
    seconds: number;
}

export interface NdbDatabaseTimemachineinfoScheduleWeeklyschedule {
    /**
     * - (Required) day of week to take snaphsot. Eg. "WEDNESDAY"
     */
    dayofweek: string;
    /**
     * - (Required) to enable
     */
    enabled: boolean;
}

export interface NdbDatabaseTimemachineinfoScheduleYearlyschedule {
    /**
     * - (Required) day of month to take snapshot
     */
    dayofmonth: number;
    /**
     * - (Required) to enable
     */
    enabled: boolean;
    /**
     * - (Required) month for snapshot
     */
    month: string;
}

export interface NdbDatabaseTimemachineinfoSlaDetail {
    /**
     * - (Required) primary sla details
     * * `primary_sla.sla_id` :- (Required) sla id
     * * `primary_sla.nx_cluster_ids` -: (Optioanl) cluster ids
     */
    primarySlas?: outputs.NdbDatabaseTimemachineinfoSlaDetailPrimarySla[];
}

export interface NdbDatabaseTimemachineinfoSlaDetailPrimarySla {
    nxClusterIds?: string[];
    /**
     * description of SLA ID.
     */
    slaId: string;
}

export interface NdbDatabaseTimemachineinfoTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbDbserverVmCredential {
    label?: string;
    password: string;
    username: string;
}

export interface NdbDbserverVmMaintenanceTasks {
    /**
     * Associate an existing maintenance window id. NDB starts OS patching or database patching as per the schedule defined in the maintenance window.
     */
    maintenanceWindowId?: string;
    /**
     * Tasks for the maintenance.
     * * `tasks.task_type`: use this option if you want NDB to perform database patching or OS patching automatically. Supports [ OS_PATCHING, DB_PATCHING ].
     * * `tasks.pre_command`: add pre (operating system and database patching) commands.
     * * `tasks.post_command`:add post (operating system and database patching) commands.
     */
    tasks?: outputs.NdbDbserverVmMaintenanceTasksTask[];
}

export interface NdbDbserverVmMaintenanceTasksTask {
    postCommand?: string;
    preCommand?: string;
    taskType?: string;
}

export interface NdbDbserverVmPostgresDatabase {
    /**
     * use SSH public keys to access the database server VM.
     */
    clientPublicKey?: string;
    /**
     * name for the database server VM.
     */
    vmName: string;
}

export interface NdbDbserverVmProperty {
    /**
     * name of the dbserver vm
     */
    name: string;
    value: string;
}

export interface NdbDbserverVmTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbLinkedDatabasesInfo {
    infos: outputs.NdbLinkedDatabasesInfoInfo[];
    secureInfo: {[key: string]: string};
}

export interface NdbLinkedDatabasesInfoInfo {
    createdBy: string;
}

export interface NdbMaintenanceTaskEntityTaskAssociation {
    /**
     * access level of tasks
     */
    accessLevel: string;
    /**
     * created date of task
     */
    dateCreated: string;
    /**
     * modified date of task
     */
    dateModified: string;
    /**
     * description of maintenance window
     */
    description: string;
    entity: string;
    /**
     * entity id
     */
    entityId: string;
    /**
     * type of the entity. i.e. DBSERVER
     */
    entityType: string;
    /**
     * id of maintenance window
     */
    id: string;
    /**
     * maintenance window id which has to be associated
     */
    maintenanceWindowId: string;
    /**
     * maintenance window owner id
     */
    maintenanceWindowOwnerId: string;
    /**
     * name of of maintenance window
     */
    name: string;
    /**
     * owner id of task
     */
    ownerId: string;
    /**
     * list of pre post commands of OS or DB task
     */
    payloads: outputs.NdbMaintenanceTaskEntityTaskAssociationPayload[];
    /**
     * properties of task
     */
    properties: outputs.NdbMaintenanceTaskEntityTaskAssociationProperty[];
    /**
     * status of task
     */
    status: string;
    /**
     * tags of task
     */
    tags: outputs.NdbMaintenanceTaskEntityTaskAssociationTag[];
    /**
     * type of the task. OS or DB
     */
    taskType: string;
}

export interface NdbMaintenanceTaskEntityTaskAssociationPayload {
    /**
     * Pre Post command of Task
     */
    prePostCommands: outputs.NdbMaintenanceTaskEntityTaskAssociationPayloadPrePostCommand[];
}

export interface NdbMaintenanceTaskEntityTaskAssociationPayloadPrePostCommand {
    /**
     * post command of task
     */
    postCommand: string;
    /**
     * pre command of task
     */
    preCommand: string;
}

export interface NdbMaintenanceTaskEntityTaskAssociationProperty {
    /**
     * name of of maintenance window
     */
    name: string;
    value: string;
}

export interface NdbMaintenanceTaskEntityTaskAssociationTag {
    /**
     * entity id
     */
    entityId: string;
    /**
     * type of the entity. i.e. DBSERVER
     */
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbMaintenanceTaskTask {
    /**
     * command that you want to run after patching the OS/DB
     */
    postCommand?: string;
    /**
     * command that you want to run before patching the OS/DB
     */
    preCommand?: string;
    /**
     * type of task. Supports [ "OS_PATCHING", "DB_PATCHING" ]
     */
    taskType?: string;
}

export interface NdbMaintenanceWindowEntityTaskAssoc {
    /**
     * access level
     */
    accessLevel: string;
    /**
     * created date of maintenance window
     */
    dateCreated: string;
    /**
     * modified date of maintenance window
     */
    dateModified: string;
    /**
     * Description for maintenance window
     */
    description: string;
    entity: string;
    entityId: string;
    entityType: string;
    id: string;
    maintenanceWindowId: string;
    maintenanceWindowOwnerId: string;
    /**
     * Name for the maintenance window.
     */
    name: string;
    /**
     * owner id of maintenance window
     */
    ownerId: string;
    payloads: outputs.NdbMaintenanceWindowEntityTaskAssocPayload[];
    /**
     * properties of maintenance window
     */
    properties: outputs.NdbMaintenanceWindowEntityTaskAssocProperty[];
    /**
     * status of maintennace window
     */
    status: string;
    /**
     * tags of maintenance window
     */
    tags: outputs.NdbMaintenanceWindowEntityTaskAssocTag[];
    taskType: string;
}

export interface NdbMaintenanceWindowEntityTaskAssocPayload {
    prePostCommands: outputs.NdbMaintenanceWindowEntityTaskAssocPayloadPrePostCommand[];
}

export interface NdbMaintenanceWindowEntityTaskAssocPayloadPrePostCommand {
    postCommand: string;
    preCommand: string;
}

export interface NdbMaintenanceWindowEntityTaskAssocProperty {
    /**
     * Name for the maintenance window.
     */
    name: string;
    value: string;
}

export interface NdbMaintenanceWindowEntityTaskAssocTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbMaintenanceWindowProperty {
    /**
     * Name for the maintenance window.
     */
    name: string;
    value: string;
}

export interface NdbMaintenanceWindowSchedule {
    /**
     * Day of the week to trigger maintenance window. Supports [ MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY ]
     */
    dayOfWeek: string;
    /**
     * duration in hours. Default is 2
     */
    duration: number;
    hour: number;
    minute: number;
    /**
     * Supported values [ MONTHLY, WEEKLY ]
     */
    recurrence: string;
    /**
     * start time for maintenance window to trigger
     */
    startTime?: string;
    threshold: string;
    /**
     * timezone . Default is Asia/Calcutta .
     */
    timezone: string;
    /**
     * week of the month. Supports [1, 2, 3, 4] .
     */
    weekOfMonth: number;
}

export interface NdbMaintenanceWindowTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbNetworkIpPool {
    addresses: outputs.NdbNetworkIpPoolAddress[];
    /**
     * ending IP address range for new database servers
     */
    endIp: string;
    id: string;
    modifiedBy: string;
    /**
     * starting IP address range for new database servers
     */
    startIp: string;
}

export interface NdbNetworkIpPoolAddress {
    ip: string;
    status: string;
}

export interface NdbNetworkPropertiesMap {
    vlanGateway: string;
    vlanPrimaryDns: string;
    vlanSecondaryDns: string;
    vlanSubnetMask: string;
}

export interface NdbNetworkProperty {
    /**
     * Name of the vlan to be attached in NDB
     */
    name: string;
    secure: boolean;
    value: string;
}

export interface NdbProfileClusterAvailability {
    dateCreated: string;
    dateModified: string;
    /**
     * cluster on which profile created
     */
    nxClusterId: string;
    ownerId: string;
    profileId: string;
    /**
     * status of profile
     */
    status: string;
}

export interface NdbProfileComputeProfile {
    /**
     * number of cores per vCPU for the database server VM.
     */
    corePerCpu?: string;
    /**
     * number of vCPUs for the database server VM.
     */
    cpus?: string;
    /**
     * amount of memory for the database server VM.
     */
    memorySize?: string;
}

export interface NdbProfileDatabaseParameterProfile {
    /**
     * Database parameters suuported for postgress.
     * * `postgres_database.max_connections`: (Optional) Determines the maximum number of concurrent connections to the database server. The default is set to 100
     * * `postgres_database.max_replication_slots`: (Optional) Specifies the maximum number of replication slots that the server can support. The default is zero. walLevel must be set to archive or higher to allow replication slots to be used. Setting it to a lower value than the number of currently existing replication slots will prevent the server from starting.
     * * `postgres_database.effective_io_concurrency`: (Optional) Sets the number of concurrent disk I/O operations that PostgreSQL expects can be executed simultaneously. Raising this value will increase the number of I/O operations that any individual PostgreSQL session attempts to initiate in parallel.
     * * `postgres_database.timezone`: (Optional) Sets the time zone for displaying and interpreting time stamps. Defult is UTC .
     * * `postgres_database.max_prepared_transactions`: (Optional) Sets the maximum number of transactions that can be in the prepared state simultaneously. Setting this parameter to zero (which is the default) disables the prepared-transaction feature.
     * * `postgres_database.max_locks_per_transaction`: (Optional) This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. Default is 64.
     * * `postgres_database.max_wal_senders`: (Optional) Specifies the maximum number of concurrent connections from standby servers or streaming base backup clients (i.e., the maximum number of simultaneously running WAL sender processes). The default is 10.
     * * `postgres_database.max_worker_processes`: (Optional) Sets the maximum number of background processes that the system can support. The default is 8.
     * * `postgres_database.min_wal_size`: (Optional) As long as WAL disk usage stays below this setting, old WAL files are always recycled for future use at a checkpoint, rather than removed. This can be used to ensure that enough WAL space is reserved to handle spikes in WAL usage, for example when running large batch jobs. The default is 80 MB.
     * * `postgres_database.max_wal_size`: (Optional) Maximum size to let the WAL grow to between automatic WAL checkpoints. The default is 1 GB
     * * `postgres_database.checkpoint_timeout`: (Optional) Sets the maximum time between automatic WAL checkpoints . High Value gives Good Performance, but takes More Recovery Time, Reboot time. can reduce the I/O load on your system, especially when using large values for shared_buffers. Default is 5min
     * * `postgres_database.autovacuum`: (Optional) Controls whether the server should run the autovacuum launcher daemon. This is on by default; however, trackCounts must also be enabled for autovacuum to work.
     * * `postgres_database.checkpoint_completion_target`: (Optional)
     * Specifies the target of checkpoint completion, as a fraction of total time between checkpoints. Time spent flushing dirty buffers during checkpoint, as fraction of checkpoint interval . Formula - (checkpoint_timeout - 2min) / checkpoint_timeout. The default is 0.5.
     * * `postgres_database.autovacuum_freeze_max_age`: (Optional) Age at which to autovacuum a table to prevent transaction ID wraparound. Default is 200000000
     * * `postgres_database.autovacuum_vacuum_threshold`: (Optional) Min number of row updates before vacuum. Minimum number of tuple updates or deletes prior to vacuum. Take value in KB. Default is 50 .
     * * `postgres_database.autovacuum_vacuum_scale_factor`: (Optional) Number of tuple updates or deletes prior to vacuum as a fraction of reltuples. Default is 0.2
     * * `postgres_database.autovacuum_work_mem`: (Optional) Sets the maximum memory to be used by each autovacuum worker process. Unit is in KB. Default is -1
     * * `postgres_database.autovacuum_max_workers`: (Optional) Sets the maximum number of simultaneously running autovacuum worker processes. Default is 3
     * * `postgres_database.autovacuum_vacuum_cost_delay`: (Optional) Vacuum cost delay in milliseconds, for autovacuum. Specifies the cost delay value that will be used in automatic VACUUM operation. Default is 2ms
     * * `postgres_database.wal_buffers`: (Optional)
     * Sets the number of disk-page buffers in shared memory for WAL. The amount of shared memory used for WAL data that has not yet been written to disk. The default is -1.
     * * `postgres_database.synchronous_commit`: (Optional) Sets the current transaction's synchronization level. Specifies whether transaction commit will wait for WAL records to be written to disk before the command returns a success indication to the client. Default is on.
     * * `postgres_database.random_page_cost`: (Optional) Sets the planner's estimate of the cost of a nonsequentially fetched disk page. Sets the planner's estimate of the cost of a non-sequentially-fetched disk page. The default is 4.0.
     * * `postgres_database.wal_keep_segments`: (Optional) Sets the number of WAL files held for standby servers, Specifies the minimum number of past log file segments kept in the pgWal directory. Default is 700 .
     */
    postgresDatabases?: outputs.NdbProfileDatabaseParameterProfilePostgresDatabase[];
}

export interface NdbProfileDatabaseParameterProfilePostgresDatabase {
    autovacuum?: string;
    autovacuumFreezeMaxAge?: string;
    autovacuumMaxWorkers?: string;
    autovacuumVacuumCostDelay?: string;
    autovacuumVacuumScaleFactor?: string;
    autovacuumVacuumThreshold?: string;
    autovacuumWorkMem?: string;
    checkpointCompletionTarget?: string;
    checkpointTimeout?: string;
    effectiveIoConcurrency?: string;
    maxConnections?: string;
    maxLocksPerTransaction?: string;
    maxPreparedTransactions?: string;
    maxReplicationSlots?: string;
    maxWalSenders?: string;
    maxWalSize?: string;
    maxWorkerProcesses?: string;
    minWalSize?: string;
    randomPageCost?: string;
    synchronousCommit?: string;
    timezone?: string;
    walBuffers?: string;
    walKeepSegments?: string;
}

export interface NdbProfileNetworkProfile {
    /**
     * Postgres Info to create network profile
     *
     * * `postgres_database.single_instance`: (Optional) Info for postgres database to create single instance network profile.
     * * `postgres_database.single_instance.vlan_name`: (Required) specify the VLAN to provide the IP address used to connect the database from the public network.
     * * `postgres_database.single_instance.enable_ip_address_selection`: (Optional) If Advanced Network Segmentation is enabled, then this vLAN needs to be a static vLAN and needs to be true.
     *
     * * `postgres_database.ha_instance`: (Optional) Info for craeting Network profile for HA instance
     * * `postgres_database.ha_instance.vlan_name`: (Required) specify the VLANs for network
     * * `postgres_database.ha_instance.cluster_name`: (Required) specify the cluster name associated with given VLANs
     * * `postgres_database.ha_instance.cluster_id`: (Optional) specify the cluster ids associated with given VLANs
     * * `postgres_database.ha_instance.num_of_clusters`: (Required) number of cluster attached to network profile
     */
    postgresDatabases?: outputs.NdbProfileNetworkProfilePostgresDatabase[];
    /**
     * Topology supported for network profile. Allowed values are "cluster" and "single"
     */
    topology: string;
    /**
     * cluster associated with VLAN. this is used with Single instance for postgres database.
     * * `version_cluster_association.nx_cluster_id`: (Required) cluster id for associated VLAN.
     */
    versionClusterAssociations?: outputs.NdbProfileNetworkProfileVersionClusterAssociation[];
}

export interface NdbProfileNetworkProfilePostgresDatabase {
    haInstances?: outputs.NdbProfileNetworkProfilePostgresDatabaseHaInstance[];
    singleInstances?: outputs.NdbProfileNetworkProfilePostgresDatabaseSingleInstance[];
}

export interface NdbProfileNetworkProfilePostgresDatabaseHaInstance {
    clusterIds?: string[];
    clusterNames?: string[];
    numOfClusters?: string;
    vlanNames?: string[];
}

export interface NdbProfileNetworkProfilePostgresDatabaseSingleInstance {
    enableIpAddressSelection?: string;
    vlanName?: string;
}

export interface NdbProfileNetworkProfileVersionClusterAssociation {
    /**
     * cluster on which profile created
     */
    nxClusterId: string;
}

export interface NdbProfileSoftwareProfile {
    /**
     * specify Nutanix clusters where this profile is available.
     */
    availableClusterIds?: string[];
    /**
     * Software profile info about postgres database.
     * * `postgres_database.source_dbserver_id`: source dbserver id where postgress software will be installed.
     * * `postgres_database.base_profile_version_name`: name for the software profile version.
     * * `postgres_database.base_profile_version_description`: description for the software profile version.
     * * `postgres_database.os_notes`: a note to provide additional information about the operating system
     * * `postgres_database.db_software_notes`: a note to provide additional information about the database software.
     */
    postgresDatabases?: outputs.NdbProfileSoftwareProfilePostgresDatabase[];
    /**
     * Topology of software profile. Allowed values are "cluster" and "single"
     */
    topology: string;
}

export interface NdbProfileSoftwareProfilePostgresDatabase {
    baseProfileVersionDescription?: string;
    baseProfileVersionName?: string;
    dbSoftwareNotes?: string;
    osNotes?: string;
    sourceDbserverId?: string;
}

export interface NdbProfileVersion {
    dbVersion: string;
    deprecated: boolean;
    /**
     * Description of profile
     */
    description: string;
    /**
     * Engine Type of database
     */
    engineType: string;
    id: string;
    /**
     * Name of profile
     */
    name: string;
    /**
     * owner  of profile
     */
    owner: string;
    profileId: string;
    properties: outputs.NdbProfileVersionProperty[];
    propertiesMap: {[key: string]: string};
    /**
     * Publish for all users
     */
    published: boolean;
    /**
     * status of profile
     */
    status: string;
    systemProfile: boolean;
    topology: string;
    type: string;
    version: string;
    /**
     * cluster associated with VLAN. this is used with Single instance for postgres database.
     * * `version_cluster_association.nx_cluster_id`: (Required) cluster id for associated VLAN.
     */
    versionClusterAssociations: outputs.NdbProfileVersionVersionClusterAssociation[];
}

export interface NdbProfileVersionProperty {
    /**
     * Name of profile
     */
    name: string;
    secure: boolean;
    value: string;
}

export interface NdbProfileVersionVersionClusterAssociation {
    dateCreated: string;
    dateModified: string;
    /**
     * cluster on which profile created
     */
    nxClusterId: string;
    optimizedForProvisioning: boolean;
    ownerId: string;
    profileVersionId: string;
    properties: outputs.NdbProfileVersionVersionClusterAssociationProperty[];
    /**
     * status of profile
     */
    status: string;
}

export interface NdbProfileVersionVersionClusterAssociationProperty {
    /**
     * Name of profile
     */
    name: string;
    secure: boolean;
    value: string;
}

export interface NdbRegisterDatabaseActionargument {
    /**
     * - (Required) name of argument
     */
    name: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbRegisterDatabaseDatabaseNode {
    accessLevel: {[key: string]: string};
    databaseId: string;
    /**
     * status of database
     */
    databaseStatus: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    dbserver: {[key: string]: string};
    dbserverId: string;
    /**
     * description
     */
    description: string;
    id: string;
    /**
     * info of instance
     */
    infos: outputs.NdbRegisterDatabaseDatabaseNodeInfo[];
    /**
     * Name of database instance
     */
    name: string;
    primary: boolean;
    /**
     * properties of database created
     */
    properties: outputs.NdbRegisterDatabaseDatabaseNodeProperty[];
    protectionDomainId: string;
    protectionDomains: outputs.NdbRegisterDatabaseDatabaseNodeProtectionDomain[];
    softwareInstallationId: string;
    /**
     * status of instance
     */
    status: string;
    /**
     * tags
     */
    tags: outputs.NdbRegisterDatabaseDatabaseNodeTag[];
}

export interface NdbRegisterDatabaseDatabaseNodeInfo {
    /**
     * info of instance
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbRegisterDatabaseDatabaseNodeProperty {
    /**
     * description
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbRegisterDatabaseDatabaseNodeProtectionDomain {
    assocEntities: string[];
    cloudId: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description
     */
    description: string;
    eraCreated: boolean;
    id: string;
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    primaryHost: string;
    /**
     * properties of database created
     */
    properties: outputs.NdbRegisterDatabaseDatabaseNodeProtectionDomainProperty[];
    /**
     * status of instance
     */
    status: string;
    /**
     * type of database
     */
    type: string;
}

export interface NdbRegisterDatabaseDatabaseNodeProtectionDomainProperty {
    /**
     * description
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbRegisterDatabaseDatabaseNodeTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbRegisterDatabaseInfo {
    bpgConfigs: outputs.NdbRegisterDatabaseInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface NdbRegisterDatabaseInfoBpgConfig {
    bpgDbParams: outputs.NdbRegisterDatabaseInfoBpgConfigBpgDbParam[];
    storages: outputs.NdbRegisterDatabaseInfoBpgConfigStorage[];
    vmProperties: outputs.NdbRegisterDatabaseInfoBpgConfigVmProperty[];
}

export interface NdbRegisterDatabaseInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface NdbRegisterDatabaseInfoBpgConfigStorage {
    archiveStorages: outputs.NdbRegisterDatabaseInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.NdbRegisterDatabaseInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.NdbRegisterDatabaseInfoBpgConfigStorageLogDisk[];
}

export interface NdbRegisterDatabaseInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface NdbRegisterDatabaseInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface NdbRegisterDatabaseInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface NdbRegisterDatabaseInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface NdbRegisterDatabaseLcmConfig {
    expiryDetails: outputs.NdbRegisterDatabaseLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.NdbRegisterDatabaseLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.NdbRegisterDatabaseLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.NdbRegisterDatabaseLcmConfigRefreshDetail[];
}

export interface NdbRegisterDatabaseLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    /**
     * - (Optional) Delete the database's Time Machine (snapshots/logs) from the NDB. Default value is true
     */
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface NdbRegisterDatabaseLcmConfigPostDeleteCommand {
    command: string;
}

export interface NdbRegisterDatabaseLcmConfigPreDeleteCommand {
    command: string;
}

export interface NdbRegisterDatabaseLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface NdbRegisterDatabaseLinkedDatabase {
    /**
     * name of database
     */
    databaseName: string;
    /**
     * status of database
     */
    databaseStatus: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description
     */
    description: string;
    id: string;
    /**
     * info of instance
     */
    infos: outputs.NdbRegisterDatabaseLinkedDatabaseInfo[];
    /**
     * Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
     */
    metric: {[key: string]: string};
    /**
     * Name of database instance
     */
    name: string;
    /**
     * parent database id
     */
    parentDatabaseId: string;
    parentLinkedDatabaseId: string;
    snapshotId: string;
    /**
     * status of instance
     */
    status: string;
    timezone: string;
}

export interface NdbRegisterDatabaseLinkedDatabaseInfo {
    /**
     * info of instance
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbRegisterDatabasePostgressInfo {
    /**
     * allow multiple databases. Default is true
     */
    allowMultipleDatabases?: boolean;
    /**
     * backup policy of database. Default is prefer_secondary.
     */
    backupPolicy?: string;
    /**
     * name of the database server VM on which the instance you want to register is running.
     */
    dbName: string;
    /**
     * database password
     */
    dbPassword: string;
    /**
     * username of the NDB drive user account that has sudo access.
     */
    dbUser?: string;
    /**
     * listner port of database
     */
    listenerPort: string;
    /**
     * path to the PostgreSQL home directory in which the PostgreSQL software is installed.
     */
    postgresSoftwareHome: string;
    /**
     * path to the directory in which the PostgreSQL software is installed.
     */
    softwareHome?: string;
    /**
     * switch log of database. Default is true
     */
    switchLog?: boolean;
    /**
     * VM IP of the database server VM on which the instance you want to register is running.
     */
    vmIp?: string;
}

export interface NdbRegisterDatabaseProperty {
    /**
     * Name of database instance
     */
    name: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbRegisterDatabaseTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbRegisterDatabaseTimeMachine {
    accessLevel: string;
    /**
     * whether instance is cloned or not
     */
    clone: boolean;
    clones: string;
    /**
     * clustered or not. Default is false
     */
    clustered: boolean;
    database: string;
    databaseId: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description
     */
    description: string;
    eaStatus: string;
    id: string;
    /**
     * Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
     */
    metric: string;
    /**
     * Name of database instance
     */
    name: string;
    /**
     * properties of database created
     */
    properties: outputs.NdbRegisterDatabaseTimeMachineProperty[];
    scheduleId: string;
    /**
     * - (Optional) schedule for snapshots
     */
    schedules: outputs.NdbRegisterDatabaseTimeMachineSchedule[];
    scope: string;
    slaId: string;
    slaUpdateInProgress: boolean;
    slaUpdateMetadata: string;
    slas: outputs.NdbRegisterDatabaseTimeMachineSla[];
    sourceNxClusters: string[];
    /**
     * status of instance
     */
    status: string;
    /**
     * tags
     */
    tags: outputs.NdbRegisterDatabaseTimeMachineTag[];
    /**
     * type of database
     */
    type: string;
}

export interface NdbRegisterDatabaseTimeMachineInfo {
    /**
     * - (Optional) enable auto tune log drive. Default: true
     */
    autotunelogdrive?: boolean;
    /**
     * - (Optional) description of time machine
     */
    description?: string;
    /**
     * - (Required) name of time machine
     */
    name: string;
    /**
     * - (Optional) schedule for snapshots
     */
    schedule: outputs.NdbRegisterDatabaseTimeMachineInfoSchedule;
    /**
     * -  (optional) SLA details for HA instance
     */
    slaDetails?: outputs.NdbRegisterDatabaseTimeMachineInfoSlaDetail[];
    /**
     * - (Optional) SLA ID for single instance
     */
    slaid?: string;
    /**
     * - (Optional) tags
     */
    tags: outputs.NdbRegisterDatabaseTimeMachineInfoTag[];
}

export interface NdbRegisterDatabaseTimeMachineInfoSchedule {
    /**
     * - (Optional) snapshot freq and log config
     */
    continuousschedule?: outputs.NdbRegisterDatabaseTimeMachineInfoScheduleContinuousschedule;
    /**
     * - (Optional) monthly snapshot config
     */
    monthlyschedule?: outputs.NdbRegisterDatabaseTimeMachineInfoScheduleMonthlyschedule;
    /**
     * - (Optional) quaterly snapshot config
     */
    quartelyschedule?: outputs.NdbRegisterDatabaseTimeMachineInfoScheduleQuartelyschedule;
    /**
     * - (Optional) daily snapshot config
     */
    snapshottimeofday?: outputs.NdbRegisterDatabaseTimeMachineInfoScheduleSnapshottimeofday;
    /**
     * - (Optional) weekly snapshot config
     */
    weeklyschedule?: outputs.NdbRegisterDatabaseTimeMachineInfoScheduleWeeklyschedule;
    /**
     * - (Optional) yearly snapshot config
     */
    yearlyschedule?: outputs.NdbRegisterDatabaseTimeMachineInfoScheduleYearlyschedule;
}

export interface NdbRegisterDatabaseTimeMachineInfoScheduleContinuousschedule {
    enabled: boolean;
    logbackupinterval: number;
    snapshotsperday: number;
}

export interface NdbRegisterDatabaseTimeMachineInfoScheduleMonthlyschedule {
    dayofmonth: number;
    enabled: boolean;
}

export interface NdbRegisterDatabaseTimeMachineInfoScheduleQuartelyschedule {
    dayofmonth: number;
    enabled: boolean;
    startmonth: string;
}

export interface NdbRegisterDatabaseTimeMachineInfoScheduleSnapshottimeofday {
    hours: number;
    minutes: number;
    seconds: number;
}

export interface NdbRegisterDatabaseTimeMachineInfoScheduleWeeklyschedule {
    dayofweek: string;
    enabled: boolean;
}

export interface NdbRegisterDatabaseTimeMachineInfoScheduleYearlyschedule {
    dayofmonth: number;
    enabled: boolean;
    month: string;
}

export interface NdbRegisterDatabaseTimeMachineInfoSlaDetail {
    /**
     * - (Required) primary sla details
     * * `primary_sla.sla_id` :- (Required) sla id
     * * `primary_sla.nx_cluster_ids` -: (Optioanl) cluster ids
     */
    primarySlas?: outputs.NdbRegisterDatabaseTimeMachineInfoSlaDetailPrimarySla[];
}

export interface NdbRegisterDatabaseTimeMachineInfoSlaDetailPrimarySla {
    nxClusterIds?: string[];
    /**
     * description of SLA ID.
     */
    slaId: string;
}

export interface NdbRegisterDatabaseTimeMachineInfoTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbRegisterDatabaseTimeMachineProperty {
    /**
     * description
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbRegisterDatabaseTimeMachineSchedule {
    continuousSchedules: outputs.NdbRegisterDatabaseTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.NdbRegisterDatabaseTimeMachineScheduleDailySchedule[];
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description
     */
    description: string;
    globalPolicy: boolean;
    id: string;
    monthlySchedules: outputs.NdbRegisterDatabaseTimeMachineScheduleMonthlySchedule[];
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.NdbRegisterDatabaseTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.NdbRegisterDatabaseTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    /**
     * timezone on which instance is created xw
     */
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.NdbRegisterDatabaseTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.NdbRegisterDatabaseTimeMachineScheduleYearlySchedule[];
}

export interface NdbRegisterDatabaseTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface NdbRegisterDatabaseTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface NdbRegisterDatabaseTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface NdbRegisterDatabaseTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface NdbRegisterDatabaseTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface NdbRegisterDatabaseTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface NdbRegisterDatabaseTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface NdbRegisterDatabaseTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description
     */
    description: string;
    id: string;
    monthlyRetention: number;
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface NdbRegisterDatabaseTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbRegisterDbserverCredential {
    label?: string;
    /**
     * password of the NDB drive user account. Conflicts with ssh_key.
     */
    password: string;
    /**
     * username of the NDB drive user account that has sudo access
     */
    username: string;
}

export interface NdbRegisterDbserverPostgresDatabase {
    /**
     * listener port of db server
     */
    listenerPort?: string;
    /**
     * path to the PostgreSQL home directory in which the PostgreSQL software is installed
     */
    postgresSoftwareHome?: string;
}

export interface NdbRegisterDbserverProperty {
    /**
     * Name of db server vm. Should be used in Update Method only.
     */
    name: string;
    value: string;
}

export interface NdbRegisterDbserverTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbScaleDatabaseDatabaseNode {
    accessLevel: {[key: string]: string};
    databaseId: string;
    databaseStatus: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    dbserver: {[key: string]: string};
    dbserverId: string;
    /**
     * description of database instance
     */
    description: string;
    id: string;
    /**
     * info of instance
     */
    infos: outputs.NdbScaleDatabaseDatabaseNodeInfo[];
    /**
     * Name of database instance
     */
    name: string;
    primary: boolean;
    /**
     * properties of database created
     */
    properties: outputs.NdbScaleDatabaseDatabaseNodeProperty[];
    protectionDomainId: string;
    protectionDomains: outputs.NdbScaleDatabaseDatabaseNodeProtectionDomain[];
    softwareInstallationId: string;
    /**
     * status of instance
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.NdbScaleDatabaseDatabaseNodeTag[];
}

export interface NdbScaleDatabaseDatabaseNodeInfo {
    /**
     * info of instance
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbScaleDatabaseDatabaseNodeProperty {
    /**
     * description of database instance
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbScaleDatabaseDatabaseNodeProtectionDomain {
    assocEntities: string[];
    cloudId: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    eraCreated: boolean;
    id: string;
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    primaryHost: string;
    /**
     * properties of database created
     */
    properties: outputs.NdbScaleDatabaseDatabaseNodeProtectionDomainProperty[];
    /**
     * status of instance
     */
    status: string;
    /**
     * type of database
     */
    type: string;
}

export interface NdbScaleDatabaseDatabaseNodeProtectionDomainProperty {
    /**
     * description of database instance
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbScaleDatabaseDatabaseNodeTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbScaleDatabaseInfo {
    bpgConfigs: outputs.NdbScaleDatabaseInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface NdbScaleDatabaseInfoBpgConfig {
    bpgDbParams: outputs.NdbScaleDatabaseInfoBpgConfigBpgDbParam[];
    storages: outputs.NdbScaleDatabaseInfoBpgConfigStorage[];
    vmProperties: outputs.NdbScaleDatabaseInfoBpgConfigVmProperty[];
}

export interface NdbScaleDatabaseInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface NdbScaleDatabaseInfoBpgConfigStorage {
    archiveStorages: outputs.NdbScaleDatabaseInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.NdbScaleDatabaseInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.NdbScaleDatabaseInfoBpgConfigStorageLogDisk[];
}

export interface NdbScaleDatabaseInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface NdbScaleDatabaseInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface NdbScaleDatabaseInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface NdbScaleDatabaseInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface NdbScaleDatabaseLcmConfig {
    expiryDetails: outputs.NdbScaleDatabaseLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.NdbScaleDatabaseLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.NdbScaleDatabaseLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.NdbScaleDatabaseLcmConfigRefreshDetail[];
}

export interface NdbScaleDatabaseLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface NdbScaleDatabaseLcmConfigPostDeleteCommand {
    command: string;
}

export interface NdbScaleDatabaseLcmConfigPreDeleteCommand {
    command: string;
}

export interface NdbScaleDatabaseLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface NdbScaleDatabaseLinkedDatabase {
    /**
     * name of database
     */
    databaseName: string;
    databaseStatus: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    id: string;
    /**
     * info of instance
     */
    infos: outputs.NdbScaleDatabaseLinkedDatabaseInfo[];
    /**
     * Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
     */
    metric: {[key: string]: string};
    /**
     * Name of database instance
     */
    name: string;
    /**
     * parent database id
     */
    parentDatabaseId: string;
    parentLinkedDatabaseId: string;
    snapshotId: string;
    /**
     * status of instance
     */
    status: string;
    timezone: string;
}

export interface NdbScaleDatabaseLinkedDatabaseInfo {
    /**
     * info of instance
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbScaleDatabaseProperty {
    /**
     * Name of database instance
     */
    name: string;
    value: string;
}

export interface NdbScaleDatabaseTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbScaleDatabaseTimeMachine {
    accessLevel: string;
    /**
     * whether instance is cloned or not
     */
    clone: boolean;
    clones: string;
    clustered: boolean;
    database: string;
    databaseId: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    eaStatus: string;
    id: string;
    /**
     * Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
     */
    metric: string;
    /**
     * Name of database instance
     */
    name: string;
    /**
     * properties of database created
     */
    properties: outputs.NdbScaleDatabaseTimeMachineProperty[];
    scheduleId: string;
    schedules: outputs.NdbScaleDatabaseTimeMachineSchedule[];
    scope: string;
    slaId: string;
    slaUpdateInProgress: boolean;
    slaUpdateMetadata: string;
    slas: outputs.NdbScaleDatabaseTimeMachineSla[];
    sourceNxClusters: string[];
    /**
     * status of instance
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.NdbScaleDatabaseTimeMachineTag[];
    /**
     * type of database
     */
    type: string;
}

export interface NdbScaleDatabaseTimeMachineProperty {
    /**
     * description of database instance
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbScaleDatabaseTimeMachineSchedule {
    continuousSchedules: outputs.NdbScaleDatabaseTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.NdbScaleDatabaseTimeMachineScheduleDailySchedule[];
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    globalPolicy: boolean;
    id: string;
    monthlySchedules: outputs.NdbScaleDatabaseTimeMachineScheduleMonthlySchedule[];
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.NdbScaleDatabaseTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.NdbScaleDatabaseTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    /**
     * timezone on which instance is created xw
     */
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.NdbScaleDatabaseTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.NdbScaleDatabaseTimeMachineScheduleYearlySchedule[];
}

export interface NdbScaleDatabaseTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface NdbScaleDatabaseTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface NdbScaleDatabaseTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface NdbScaleDatabaseTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface NdbScaleDatabaseTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface NdbScaleDatabaseTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface NdbScaleDatabaseTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface NdbScaleDatabaseTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    id: string;
    monthlyRetention: number;
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface NdbScaleDatabaseTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbSoftwareVersionProfilePostgresDatabase {
    /**
     * db software notes
     */
    dbSoftwareNotes?: string;
    /**
     * os notes for software profile
     */
    osNotes?: string;
    /**
     * source dbserver id
     */
    sourceDbserverId?: string;
}

export interface NdbSoftwareVersionProfileProperty {
    /**
     * Name of profile
     */
    name: string;
    /**
     * secure or not
     */
    secure: boolean;
    /**
     * value of property
     */
    value: string;
}

export interface NdbSoftwareVersionProfileVersionClusterAssociation {
    /**
     * date created of profile
     */
    dateCreated: string;
    /**
     * date modified of profile
     */
    dateModified: string;
    /**
     * nutanix cluster id
     */
    nxClusterId: string;
    /**
     * version optimized for provisioning
     */
    optimizedForProvisioning: boolean;
    /**
     * owner id
     */
    ownerId: string;
    /**
     * profile version id
     */
    profileVersionId: string;
    /**
     * properties of software profile
     */
    properties: outputs.NdbSoftwareVersionProfileVersionClusterAssociationProperty[];
    /**
     * status of profile. Allowed Values are "deprecated", "published", "unpublished"
     */
    status: string;
}

export interface NdbSoftwareVersionProfileVersionClusterAssociationProperty {
    /**
     * Name of profile
     */
    name: string;
    /**
     * secure or not
     */
    secure: boolean;
    /**
     * value of property
     */
    value: string;
}

export interface NdbStretchedVlanMetadata {
    gateway: string;
    subnetMask: string;
}

export interface NdbStretchedVlanVlansList {
    /**
     * cluster id where network is present
     */
    clusterId: string;
    /**
     * network id
     */
    id: string;
    /**
     * network managed by NDB or not
     */
    managed: boolean;
    /**
     * name for the stretched VLAN
     */
    name: string;
    /**
     * properties of network
     */
    properties: outputs.NdbStretchedVlanVlansListProperty[];
    /**
     * properties map of network
     */
    propertiesMaps: outputs.NdbStretchedVlanVlansListPropertiesMap[];
    /**
     * stretched vlan id
     */
    stretchedVlanId: string;
    /**
     * type of vlan. static VLANs that are managed in NDB can be added to a stretched VLAN.
     */
    type: string;
}

export interface NdbStretchedVlanVlansListPropertiesMap {
    /**
     * gateway of vlan
     */
    vlanGateway: string;
    /**
     * primary dns of vlan
     */
    vlanPrimaryDns: string;
    /**
     * secondary dns of vlan
     */
    vlanSecondaryDns: string;
    /**
     * subnet mask of vlan
     */
    vlanSubnetMask: string;
}

export interface NdbStretchedVlanVlansListProperty {
    /**
     * name for the stretched VLAN
     */
    name: string;
    secure: boolean;
    value: string;
}

export interface NetworkSecurityRuleAdRuleInboundAllowList {
    addressGroupInclusionLists: outputs.NetworkSecurityRuleAdRuleInboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.NetworkSecurityRuleAdRuleInboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.NetworkSecurityRuleAdRuleInboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.NetworkSecurityRuleAdRuleInboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.NetworkSecurityRuleAdRuleInboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.NetworkSecurityRuleAdRuleInboundAllowListUdpPortRangeList[];
}

export interface NetworkSecurityRuleAdRuleInboundAllowListAddressGroupInclusionList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface NetworkSecurityRuleAdRuleInboundAllowListFilterParam {
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    values: string[];
}

export interface NetworkSecurityRuleAdRuleInboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface NetworkSecurityRuleAdRuleInboundAllowListServiceGroupList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface NetworkSecurityRuleAdRuleInboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAdRuleInboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAdRuleOutboundAllowList {
    addressGroupInclusionLists: outputs.NetworkSecurityRuleAdRuleOutboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.NetworkSecurityRuleAdRuleOutboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.NetworkSecurityRuleAdRuleOutboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.NetworkSecurityRuleAdRuleOutboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.NetworkSecurityRuleAdRuleOutboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.NetworkSecurityRuleAdRuleOutboundAllowListUdpPortRangeList[];
}

export interface NetworkSecurityRuleAdRuleOutboundAllowListAddressGroupInclusionList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface NetworkSecurityRuleAdRuleOutboundAllowListFilterParam {
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    values: string[];
}

export interface NetworkSecurityRuleAdRuleOutboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface NetworkSecurityRuleAdRuleOutboundAllowListServiceGroupList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface NetworkSecurityRuleAdRuleOutboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAdRuleOutboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAdRuleTargetGroupFilterParam {
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    values: string[];
}

export interface NetworkSecurityRuleAppRuleInboundAllowList {
    addressGroupInclusionLists: outputs.NetworkSecurityRuleAppRuleInboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.NetworkSecurityRuleAppRuleInboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.NetworkSecurityRuleAppRuleInboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.NetworkSecurityRuleAppRuleInboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.NetworkSecurityRuleAppRuleInboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.NetworkSecurityRuleAppRuleInboundAllowListUdpPortRangeList[];
}

export interface NetworkSecurityRuleAppRuleInboundAllowListAddressGroupInclusionList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface NetworkSecurityRuleAppRuleInboundAllowListFilterParam {
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    values: string[];
}

export interface NetworkSecurityRuleAppRuleInboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface NetworkSecurityRuleAppRuleInboundAllowListServiceGroupList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface NetworkSecurityRuleAppRuleInboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAppRuleInboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAppRuleOutboundAllowList {
    addressGroupInclusionLists: outputs.NetworkSecurityRuleAppRuleOutboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.NetworkSecurityRuleAppRuleOutboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.NetworkSecurityRuleAppRuleOutboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.NetworkSecurityRuleAppRuleOutboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.NetworkSecurityRuleAppRuleOutboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.NetworkSecurityRuleAppRuleOutboundAllowListUdpPortRangeList[];
}

export interface NetworkSecurityRuleAppRuleOutboundAllowListAddressGroupInclusionList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface NetworkSecurityRuleAppRuleOutboundAllowListFilterParam {
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    values: string[];
}

export interface NetworkSecurityRuleAppRuleOutboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface NetworkSecurityRuleAppRuleOutboundAllowListServiceGroupList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface NetworkSecurityRuleAppRuleOutboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAppRuleOutboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAppRuleTargetGroupFilterParam {
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    values: string[];
}

export interface NetworkSecurityRuleCategory {
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    value: string;
}

export interface NetworkSecurityRuleIsolationRuleFirstEntityFilterParam {
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    values: string[];
}

export interface NetworkSecurityRuleIsolationRuleSecondEntityFilterParam {
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    values: string[];
}

export interface PbrDestination {
    addressType?: string;
    prefixLength?: number;
    subnetIp?: string;
}

export interface PbrProtocolParameters {
    icmp?: outputs.PbrProtocolParametersIcmp;
    protocolNumber?: string;
    tcp?: outputs.PbrProtocolParametersTcp;
    udp?: outputs.PbrProtocolParametersUdp;
}

export interface PbrProtocolParametersIcmp {
    icmpCode: number;
    icmpType: number;
}

export interface PbrProtocolParametersTcp {
    destinationPortRangeLists: outputs.PbrProtocolParametersTcpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.PbrProtocolParametersTcpSourcePortRangeList[];
}

export interface PbrProtocolParametersTcpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface PbrProtocolParametersTcpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface PbrProtocolParametersUdp {
    destinationPortRangeLists: outputs.PbrProtocolParametersUdpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.PbrProtocolParametersUdpSourcePortRangeList[];
}

export interface PbrProtocolParametersUdpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface PbrProtocolParametersUdpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface PbrSource {
    addressType?: string;
    prefixLength?: number;
    subnetIp?: string;
}

export interface ProjectAccountReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectAcp {
    /**
     * The list of context filters. These are OR filters. The scope-expression-list defines the context, and the filter works in conjunction with the entity-expression-list.
     */
    contextFilterLists: outputs.ProjectAcpContextFilterList[];
    /**
     * A description for project.
     */
    description?: string;
    metadata: {[key: string]: string};
    /**
     * The name for the project.
     */
    name: string;
    /**
     * Reference to role.
     */
    roleReference: outputs.ProjectAcpRoleReference;
    /**
     * List of Reference of users groups.
     */
    userGroupReferenceLists?: outputs.ProjectAcpUserGroupReferenceList[];
    /**
     * List of Reference of users.
     */
    userReferenceLists?: outputs.ProjectAcpUserReferenceList[];
}

export interface ProjectAcpContextFilterList {
    /**
     * (Required) A list of Entity filter expressions.
     */
    entityFilterExpressionLists: outputs.ProjectAcpContextFilterListEntityFilterExpressionList[];
    /**
     * - (Optional) Filter the scope of an Access Control Policy.
     */
    scopeFilterExpressionLists?: outputs.ProjectAcpContextFilterListScopeFilterExpressionList[];
}

export interface ProjectAcpContextFilterListEntityFilterExpressionList {
    /**
     * - (Optional)  The LHS of the filter expression - the entity type.
     */
    leftHandSideEntityType: string;
    /**
     * - (Required) The operator in the filter expression.
     */
    operator: string;
    /**
     * - (Required) The right hand side (RHS) of an scope expression.
     */
    rightHandSide: outputs.ProjectAcpContextFilterListEntityFilterExpressionListRightHandSide;
}

export interface ProjectAcpContextFilterListEntityFilterExpressionListRightHandSide {
    /**
     * - (Optional) The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideCategories;
    /**
     * - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
     */
    collection: string;
    /**
     * - (Optional) The explicit list of UUIDs for the given kind.
     */
    uuidLists: string[];
}

export interface ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideCategories {
    /**
     * The name for the project.
     */
    name: string;
    /**
     * value of the key.
     */
    values: string[];
}

export interface ProjectAcpContextFilterListScopeFilterExpressionList {
    /**
     * - (Optional)  The LHS of the filter expression - the scope type.
     */
    leftHandSide: string;
    /**
     * - (Required) The operator in the filter expression.
     */
    operator: string;
    /**
     * - (Required) The right hand side (RHS) of an scope expression.
     */
    rightHandSide: outputs.ProjectAcpContextFilterListScopeFilterExpressionListRightHandSide;
}

export interface ProjectAcpContextFilterListScopeFilterExpressionListRightHandSide {
    /**
     * - (Optional) The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideCategories;
    /**
     * - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
     */
    collection: string;
    /**
     * - (Optional) The explicit list of UUIDs for the given kind.
     */
    uuidLists: string[];
}

export interface ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideCategories {
    /**
     * The name for the project.
     */
    name: string;
    /**
     * value of the key.
     */
    values: string[];
}

export interface ProjectAcpRoleReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectAcpUserGroupReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name?: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectAcpUserReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name?: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectCategory {
    /**
     * The name for the project.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface ProjectClusterReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectDefaultEnvironmentReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectDefaultSubnetReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectEnvironmentReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectExternalNetworkList {
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectExternalUserGroupReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectResourceDomain {
    resources: outputs.ProjectResourceDomainResource[];
}

export interface ProjectResourceDomainResource {
    limit: number;
    resourceType: string;
    units: string;
    /**
     * value of the key.
     */
    value: number;
}

export interface ProjectSubnetReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectTunnelReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectUserGroupList {
    directoryServiceOus?: outputs.ProjectUserGroupListDirectoryServiceOus[];
    directoryServiceUserGroups?: outputs.ProjectUserGroupListDirectoryServiceUserGroup[];
    metadata?: {[key: string]: string};
    samlUserGroups?: outputs.ProjectUserGroupListSamlUserGroup[];
}

export interface ProjectUserGroupListDirectoryServiceOus {
    distinguishedName: string;
}

export interface ProjectUserGroupListDirectoryServiceUserGroup {
    distinguishedName: string;
}

export interface ProjectUserGroupListSamlUserGroup {
    idpUuid: string;
    /**
     * The name for the project.
     */
    name: string;
}

export interface ProjectUserList {
    directoryServiceUser: outputs.ProjectUserListDirectoryServiceUser;
    identityProviderUser: outputs.ProjectUserListIdentityProviderUser;
    metadata?: {[key: string]: string};
}

export interface ProjectUserListDirectoryServiceUser {
    defaultUserPrincipalName: string;
    directoryServiceReference: outputs.ProjectUserListDirectoryServiceUserDirectoryServiceReference;
    userPrincipalName: string;
}

export interface ProjectUserListDirectoryServiceUserDirectoryServiceReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectUserListIdentityProviderUser {
    identityProviderReference: outputs.ProjectUserListIdentityProviderUserIdentityProviderReference;
    username: string;
}

export interface ProjectUserListIdentityProviderUserIdentityProviderReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectUserReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectVpcReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProtectionRuleAvailabilityZoneConnectivityList {
    destinationAvailabilityZoneIndex: number;
    snapshotScheduleLists: outputs.ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleList[];
    sourceAvailabilityZoneIndex: number;
}

export interface ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleList {
    autoSuspendTimeoutSecs: number;
    localSnapshotRetentionPolicy: outputs.ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicy;
    recoveryPointObjectiveSecs: number;
    remoteSnapshotRetentionPolicy: outputs.ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicy;
    snapshotType: string;
}

export interface ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicy {
    numSnapshots: number;
    rollupRetentionPolicyMultiple: number;
    rollupRetentionPolicySnapshotIntervalType: string;
}

export interface ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicy {
    numSnapshots: number;
    rollupRetentionPolicyMultiple: number;
    rollupRetentionPolicySnapshotIntervalType: string;
}

export interface ProtectionRuleCategory {
    /**
     * The name for the protection rule.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface ProtectionRuleCategoryFilter {
    kindLists: string[];
    params: outputs.ProtectionRuleCategoryFilterParam[];
    type: string;
}

export interface ProtectionRuleCategoryFilterParam {
    /**
     * The name for the protection rule.
     */
    name: string;
    values: string[];
}

export interface ProtectionRuleOrderedAvailabilityZoneList {
    availabilityZoneUrl: string;
    clusterUuid: string;
}

export interface ProtectionRuleOwnerReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the protection rule.
     */
    name?: string;
    /**
     * (Required) the UUID.
     */
    uuid?: string;
}

export interface ProtectionRuleProjectReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the protection rule.
     */
    name?: string;
    /**
     * (Required) the UUID.
     */
    uuid?: string;
}

export interface RecoveryPlanCategory {
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface RecoveryPlanOwnerReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the Recovery Plan.
     */
    name?: string;
    /**
     * (Required) the UUID.
     */
    uuid?: string;
}

export interface RecoveryPlanParameters {
    floatingIpAssignmentLists: outputs.RecoveryPlanParametersFloatingIpAssignmentList[];
    networkMappingLists: outputs.RecoveryPlanParametersNetworkMappingList[];
}

export interface RecoveryPlanParametersFloatingIpAssignmentList {
    availabilityZoneUrl: string;
    vmIpAssignmentLists: outputs.RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentList[];
}

export interface RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentList {
    recoveryFloatingIpConfig: outputs.RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfig;
    testFloatingIpConfig: outputs.RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfig;
    vmNicInformation: outputs.RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmNicInformation;
    vmReference: outputs.RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmReference;
}

export interface RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfig {
    ip: string;
    shouldAllocateDynamically: boolean;
}

export interface RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfig {
    ip: string;
    shouldAllocateDynamically: boolean;
}

export interface RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmNicInformation {
    ip: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersNetworkMappingList {
    areNetworksStretched: boolean;
    availabilityZoneNetworkMappingLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingList[];
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingList {
    availabilityZoneUrl: string;
    clusterReferenceLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceList[];
    recoveryIpAssignmentLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentList[];
    recoveryNetwork: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetwork;
    testIpAssignmentLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentList[];
    testNetwork: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetwork;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentList {
    ipConfigLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigList[];
    vmReference: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReference;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigList {
    ipAddress: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetwork {
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    subnetLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetList[];
    useVpcReference: boolean;
    virtualNetworkReference: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReference;
    vpcReference: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReference;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetList {
    externalConnectivityState: string;
    gatewayIp: string;
    prefixLength: number;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentList {
    ipConfigLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigList[];
    vmReference: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReference;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigList {
    ipAddress: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetwork {
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    subnetLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetList[];
    useVpcReference: boolean;
    virtualNetworkReference: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReference;
    vpcReference: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReference;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetList {
    externalConnectivityState: string;
    gatewayIp: string;
    prefixLength: number;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanProjectReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the Recovery Plan.
     */
    name?: string;
    /**
     * (Required) the UUID.
     */
    uuid?: string;
}

export interface RecoveryPlanStageList {
    delayTimeSecs: number;
    stageUuid: string;
    stageWork: outputs.RecoveryPlanStageListStageWork;
}

export interface RecoveryPlanStageListStageWork {
    recoverEntities: outputs.RecoveryPlanStageListStageWorkRecoverEntities;
}

export interface RecoveryPlanStageListStageWorkRecoverEntities {
    entityInfoLists: outputs.RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoList[];
}

export interface RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoList {
    anyEntityReferenceKind?: string;
    anyEntityReferenceName?: string;
    anyEntityReferenceUuid?: string;
    categories?: outputs.RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListCategory[];
    scriptLists: outputs.RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListScriptList[];
}

export interface RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListCategory {
    /**
     * The name for the Recovery Plan.
     */
    name?: string;
    /**
     * value of the key.
     */
    value?: string;
}

export interface RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListScriptList {
    enableScriptExec: boolean;
    timeout: string;
}

export interface RoleCategory {
    /**
     * - (Optional) Name of the role.
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface RoleOwnerReference {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind?: string;
    /**
     * - (Optional) Name of the role.
     */
    name?: string;
    /**
     * - the UUID(Required).
     */
    uuid?: string;
}

export interface RolePermissionReferenceList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind?: string;
    /**
     * - (Optional) Name of the role.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface RoleProjectReference {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind?: string;
    /**
     * - (Optional) Name of the role.
     */
    name?: string;
    /**
     * - the UUID(Required).
     */
    uuid?: string;
}

export interface ServiceGroupServiceList {
    /**
     * - (Optional) ICMP type code list
     */
    icmpTypeCodeLists?: outputs.ServiceGroupServiceListIcmpTypeCodeList[];
    /**
     * - (Optional) The UserPrincipalName of the user from the directory service.
     */
    protocol?: string;
    /**
     * - (Optional) TCP Port range list
     */
    tcpPortRangeLists?: outputs.ServiceGroupServiceListTcpPortRangeList[];
    /**
     * - (Optional) UDP port range list
     */
    udpPortRangeLists?: outputs.ServiceGroupServiceListUdpPortRangeList[];
}

export interface ServiceGroupServiceListIcmpTypeCodeList {
    /**
     * - (Optional) Code as text
     */
    code?: string;
    /**
     * - (Optional) Type as text
     */
    type?: string;
}

export interface ServiceGroupServiceListTcpPortRangeList {
    endPort?: number;
    startPort?: number;
}

export interface ServiceGroupServiceListUdpPortRangeList {
    endPort?: number;
    startPort?: number;
}

export interface StaticRoutesDefaultRouteNexthop {
    /**
     * Reference to a subnet.
     */
    externalSubnetReferenceUuid?: string;
}

export interface StaticRoutesStaticRoutesList {
    /**
     * Destination ip with prefix.
     */
    destination: string;
    /**
     * Reference to a subnet. Supported with 2022.x .
     */
    externalSubnetReferenceUuid?: string;
    /**
     * Reference to a vpn connection.
     */
    vpnConnectionReferenceUuid?: string;
}

export interface SubnetCategory {
    /**
     * - (Optional) Subnet name (Readonly).
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface UserAccessControlPolicyReferenceList {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface UserCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface UserDirectoryServiceUser {
    defaultUserPrincipalName: string;
    /**
     * - (Optional) The reference to a directory service. See #reference for to look the supported attributes.
     */
    directoryServiceReference: outputs.UserDirectoryServiceUserDirectoryServiceReference;
    /**
     * - (Optional) The UserPrincipalName of the user from the directory service.
     */
    userPrincipalName: string;
}

export interface UserDirectoryServiceUserDirectoryServiceReference {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind?: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface UserGroupsCategory {
    /**
     * - subnet name.
     */
    name: string;
    value: string;
}

export interface UserGroupsDirectoryServiceOus {
    /**
     * - (Required) The Distinguished name for the user group.
     */
    distinguishedName: string;
}

export interface UserGroupsDirectoryServiceUserGroup {
    /**
     * - (Required) The Distinguished name for the user group.
     */
    distinguishedName: string;
}

export interface UserGroupsSamlUserGroup {
    /**
     * - (Required) The UUID of the Identity Provider that the group belongs to.
     */
    idpUuid: string;
    /**
     * - (Required) The name of the SAML group which the IDP provides.
     */
    name: string;
}

export interface UserIdentityProviderUser {
    /**
     * - (Optional) The reference to a identity provider. See #reference for to look the supported attributes.
     */
    identityProviderReference: outputs.UserIdentityProviderUserIdentityProviderReference;
    /**
     * - (Optional) The username from identity provider. Name ID for SAML Identity Provider.
     */
    username: string;
}

export interface UserIdentityProviderUserIdentityProviderReference {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind?: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface UserProjectReferenceList {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface VirtualMachineCategory {
    /**
     * - (Required) The name for the vm.
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface VirtualMachineDiskList {
    /**
     * Reference to a data source.
     *
     * The diskSize (the disk sizeMib and the diskSizeBytes attributes) is only honored by creating an empty disk. When you are creating from an image, the size is ignored and the disk becomes the size of the image from which it was cloned. In VM creation, you can't set either disk sizeMib or diskSizeBytes when you set dataSourceReference but, you can update the diskSize after creation (second apply).
     */
    dataSourceReference: {[key: string]: string};
    /**
     * Properties to a device.
     */
    deviceProperties: outputs.VirtualMachineDiskListDeviceProperties;
    /**
     * Size of the disk in Bytes.
     */
    diskSizeBytes: number;
    /**
     * Size of the disk in MiB. Must match the size specified in 'disk_size_bytes' - rounded up to the nearest MiB - when that field is present.
     */
    diskSizeMib: number;
    storageConfig: outputs.VirtualMachineDiskListStorageConfig;
    /**
     * - (Optional) The device ID which is used to uniquely identify this particular disk.
     */
    uuid: string;
    volumeGroupReference: {[key: string]: string};
}

export interface VirtualMachineDiskListDeviceProperties {
    /**
     * - A Disk type (default: DISK).
     */
    deviceType?: string;
    /**
     * - Address of disk to boot from.
     */
    diskAddress: {[key: string]: string};
}

export interface VirtualMachineDiskListStorageConfig {
    /**
     * - State of the storage policy to pin virtual disks to the hot tier. When specified as a VM attribute, the storage policy applies to all virtual disks of the VM unless overridden by the same attribute specified for a virtual disk.
     */
    flashMode?: string;
    /**
     * - Reference to a kind. Either one of (kind, uuid) or url needs to be specified. Requires Prism Central / AOS 5.17+.
     * * `storage_container_reference.#.url`: - GET query on the URL will provide information on the source.
     * * `storage_container_reference.#.kind`: - kind of the container reference
     * * `storage_container_reference.#.name`: - name of the container reference
     * * `storage_container_reference.#.uuid`: - uiid of the container reference
     */
    storageContainerReferences: outputs.VirtualMachineDiskListStorageConfigStorageContainerReference[];
}

export interface VirtualMachineDiskListStorageConfigStorageContainerReference {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind?: string;
    /**
     * - (Required) The name for the vm.
     */
    name: string;
    url: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface VirtualMachineGpuList {
    /**
     * - (Computed) The device ID of the GPU.
     */
    deviceId: number;
    /**
     * Fraction of the physical GPU assigned.
     */
    fraction: number;
    /**
     * - (ReadOnly) GPU frame buffer size in MiB.
     */
    frameBufferSizeMib: number;
    /**
     * - (ReadOnly) Last determined guest driver version.
     */
    guestDriverVersion: string;
    /**
     * - (Optional) The mode of this GPU.
     */
    mode: string;
    /**
     * - (ReadOnly) Name of the GPU resource.
     */
    name: string;
    /**
     * - (ReadOnly) Number of supported virtual display heads.
     */
    numVirtualDisplayHeads: number;
    /**
     * GPU {segment:bus:device:function} (sbdf) address if assigned.
     */
    pciAddress: string;
    /**
     * - (ReadOnly) UUID of the GPU.
     */
    uuid: string;
    /**
     * - (Optional) The vendor of the GPU.
     */
    vendor: string;
}

export interface VirtualMachineNicList {
    /**
     * - IP endpoints for the adapter. Currently, IPv4 addresses are supported.
     */
    ipEndpointLists: outputs.VirtualMachineNicListIpEndpointList[];
    /**
     * - Indicates whether the serial port connection is connected or not (`true` or `false`).
     */
    isConnected?: string;
    /**
     * - The MAC address for the adapter.
     */
    macAddress: string;
    /**
     * - The model of this NIC. (Options : VIRTIO , E1000).
     */
    model: string;
    /**
     * - The reference to a network_function_chain.
     */
    networkFunctionChainReference: {[key: string]: string};
    /**
     * - The type of this Network function NIC. Defaults to INGRESS. (Options : INGRESS , EGRESS , TAP).
     */
    networkFunctionNicType: string;
    /**
     * - The type of this NIC. Defaults to NORMAL_NIC. (Options : NORMAL_NIC , DIRECT_NIC , NETWORK_FUNCTION_NIC).
     */
    nicType: string;
    /**
     * - The number of tx/rx queue pairs for this NIC.
     */
    numQueues: number;
    /**
     * - The name of the subnet reference to.
     */
    subnetName: string;
    /**
     * - The reference to a subnet.
     */
    subnetUuid?: string;
    /**
     * - The NIC's UUID, which is used to uniquely identify this particular NIC. This UUID may be used to refer to the NIC outside the context of the particular VM it is attached to.
     */
    uuid: string;
}

export interface VirtualMachineNicListIpEndpointList {
    /**
     * - Address string.
     */
    ip: string;
    /**
     * - Address type. It can only be "ASSIGNED" in the spec. If no type is specified in the spec, the default type is set to "ASSIGNED". (Options : ASSIGNED , LEARNED)
     */
    type: string;
}

export interface VirtualMachineNicListStatus {
    /**
     * -  The Floating IP associated with the vnic. (Only in `nicListStatus`)
     */
    floatingIp: string;
    /**
     * - IP endpoints for the adapter. Currently, IPv4 addresses are supported.
     */
    ipEndpointLists: outputs.VirtualMachineNicListStatusIpEndpointList[];
    /**
     * - Indicates whether the serial port connection is connected or not (`true` or `false`).
     */
    isConnected: string;
    /**
     * - The MAC address for the adapter.
     */
    macAddress: string;
    /**
     * - The model of this NIC. (Options : VIRTIO , E1000).
     */
    model: string;
    /**
     * - The reference to a network_function_chain.
     */
    networkFunctionChainReference: {[key: string]: string};
    /**
     * - The type of this Network function NIC. Defaults to INGRESS. (Options : INGRESS , EGRESS , TAP).
     */
    networkFunctionNicType: string;
    /**
     * - The type of this NIC. Defaults to NORMAL_NIC. (Options : NORMAL_NIC , DIRECT_NIC , NETWORK_FUNCTION_NIC).
     */
    nicType: string;
    /**
     * - The number of tx/rx queue pairs for this NIC.
     */
    numQueues: number;
    /**
     * - The name of the subnet reference to.
     */
    subnetName: string;
    /**
     * - The reference to a subnet.
     */
    subnetUuid: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface VirtualMachineNicListStatusIpEndpointList {
    /**
     * - Address string.
     */
    ip: string;
    /**
     * - Address type. It can only be "ASSIGNED" in the spec. If no type is specified in the spec, the default type is set to "ASSIGNED". (Options : ASSIGNED , LEARNED)
     */
    type: string;
}

export interface VirtualMachineSerialPortList {
    /**
     * - Index of the serial port (int).
     */
    index: number;
    /**
     * - Indicates whether the serial port connection is connected or not (`true` or `false`).
     */
    isConnected: boolean;
}

export interface VpcCommonDomainNameServerIpList {
    /**
     * ip address.
     */
    ip: string;
}

export interface VpcExternalSubnetListStatus {
    activeGatewayNode: outputs.VpcExternalSubnetListStatusActiveGatewayNode;
    externalIpLists: string[];
    externalSubnetReference: {[key: string]: string};
}

export interface VpcExternalSubnetListStatusActiveGatewayNode {
    hostReference: {[key: string]: string};
    ipAddress: string;
}

export interface VpcExternallyRoutablePrefixList {
    /**
     * ip address.
     */
    ip: string;
    /**
     * prefix length.
     */
    prefixLength: number;
}

