// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AccessControlPolicyCategory {
    /**
     * - (Optional) Name of the Access Control Policy.
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface AccessControlPolicyContextFilterList {
    /**
     * A list of Entity filter expressions.
     */
    entityFilterExpressionLists: outputs.AccessControlPolicyContextFilterListEntityFilterExpressionList[];
    /**
     * - (Optional) Filter the scope of an Access Control Policy.
     */
    scopeFilterExpressionLists: outputs.AccessControlPolicyContextFilterListScopeFilterExpressionList[];
}

export interface AccessControlPolicyContextFilterListEntityFilterExpressionList {
    /**
     * - (Optional)  The LHS of the filter expression - the entity type.
     */
    leftHandSideEntityType: string;
    /**
     * - (Required) The operator in the filter expression.
     */
    operator: string;
    /**
     * - (Required) The right hand side (RHS) of an scope expression.
     */
    rightHandSide: outputs.AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSide;
}

export interface AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSide {
    /**
     * - (Optional) The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategories;
    /**
     * - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
     */
    collection: string;
    /**
     * - (Optional) The explicit list of UUIDs for the given kind.
     */
    uuidLists: string[];
}

export interface AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategories {
    /**
     * - (Optional) Name of the Access Control Policy.
     */
    name: string;
    /**
     * - value of the key.
     */
    values: string[];
}

export interface AccessControlPolicyContextFilterListScopeFilterExpressionList {
    /**
     * - (Optional)  The LHS of the filter expression - the scope type.
     */
    leftHandSide: string;
    /**
     * - (Required) The operator of the filter expression.
     */
    operator: string;
    /**
     * - (Required) The right hand side (RHS) of an scope expression.
     */
    rightHandSide: outputs.AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSide;
}

export interface AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSide {
    /**
     * - (Optional) The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategories;
    /**
     * - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
     */
    collection: string;
    /**
     * - (Optional) The explicit list of UUIDs for the given kind.
     */
    uuidLists: string[];
}

export interface AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategories {
    /**
     * - (Optional) Name of the Access Control Policy.
     */
    name: string;
    /**
     * - value of the key.
     */
    values: string[];
}

export interface AccessControlPolicyOwnerReference {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind?: string;
    /**
     * - (Optional) Name of the Access Control Policy.
     */
    name?: string;
    /**
     * - the UUID(Required).
     */
    uuid?: string;
}

export interface AccessControlPolicyRoleReference {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Optional) Name of the Access Control Policy.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface AccessControlPolicyUserGroupReferenceList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Optional) Name of the Access Control Policy.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface AccessControlPolicyUserReferenceList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Optional) Name of the Access Control Policy.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface AddressGroupIpAddressBlockList {
    /**
     * - (Required) IP of the address block
     */
    ip: string;
    /**
     * - (Required) Prefix length of address block in int
     *
     * See detailed information in [Nutanix Address Groups](https://www.nutanix.dev/api_references/prism-central-v3/#/5ccef53a546a4-create-a-new-address-group).
     */
    prefixLength: number;
}

export interface AddressGroupsV2IpRange {
    endIp: string;
    startIp: string;
}

export interface AddressGroupsV2Ipv4Address {
    prefixLength: number;
    value: string;
}

export interface AddressGroupsV2Link {
    href: string;
    rel: string;
}

export interface AssociateCategoryToVolumeGroupV2Category {
    /**
     * -(Optional) Type of entity that's represented by this reference. Default value is "CATEGORY". Valid values are:
     * * "CATEGORY".
     *
     * See detailed information in [Nutanix Associate/Disassociate category to/from a Volume Group V4](https://developers.nutanix.com/api-reference?namespace=volumes&version=v4.0#tag/VolumeGroups/operation/associateCategory).
     */
    entityType?: string;
    /**
     * -(Required) The external identifier of the category.
     */
    extId: string;
    /**
     * -(Optional) Name of entity that's represented by this reference
     */
    name?: string;
    /**
     * -(Optional) URI of entities that's represented by this reference.
     */
    uris: string[];
}

export interface AuthorizationPolicyV2Entity {
    reserved?: string;
}

export interface AuthorizationPolicyV2Identity {
    reserved?: string;
}

export interface CategoryV2Association {
    /**
     * External identifier for the given category, used across all v4 apis/entities/resources where categories are referenced.
     */
    categoryId: string;
    /**
     * Count of associations of a particular type of entity or policy
     */
    count: string;
    /**
     * An enum denoting the resource group.
     * Resources can be organized into either an entity or a policy.
     * Valid values are:
     * - `POLICY`:  A ResourceGroup denoting a nutanix policy like VM host affinity policy, image placement policy, access control policy, and so on.<br> A category is generally associated with many entities.<br> The policy which is associated with this category, is then applied to those entities which are also associated with the same category.
     * - `ENTITY`: A ResourceGroup denoting a nutanix entity like VM, cluster, host, image, and so on.<br> A category is generally associated with many entities.<br> A policy is then applied to these entities through the category.
     */
    resourceGroup: string;
    /**
     * An enum denoting the associated resource types. Resource types are further grouped into 2 types - entity or a policy.
     * Valid values are:
     * - `APP`:  A resource of type application.
     * - `PROTECTION_RULE`:  A policy or rule of type protection rule.
     * - `IMAGE_RATE_LIMIT`: A resource of type rate limit.
     * - `MH_VM`: A resource of type Virtual Machine.
     * - `BLUEPRINT`:  A resource of type blueprint.
     * - `HOST`:  A resource representing the underlying host, the machine hosting the hypervisors and VMs.
     * - `IMAGE`:  A resource of type image.
     * - `VM_VM_ANTI_AFFINITY_POLICY`:  A policy of type VM-VM anti-affinity; This policy decides that the specified set of VMs are running on different hosts.
     * - `ACCESS_CONTROL_POLICY`: A policy or rule of type access control policy or ACP; the rules that decide authorization of users to access an API.
     * - `VM_HOST_AFFINITY_POLICY`: A policy of type VM host affinity; The policy decides the affinity between a set of VMs to be run only a specified set of hosts
     * - `NGT_POLICY`:  A policy or rule of type NGT policy.
     * - `RECOVERY_PLAN`:  A policy or rule of type recovery plan.
     * - `MARKETPLACE_ITEM`: A resource of type marketplace item.
     * - `CLUSTER`:  A resource of type cluster, usually refers to a PE cluster.
     * - `NETWORK_SECURITY_RULE`:  A rule of type network security.
     * - `HOST_NIC`:  A resource of type Physical NIC.
     * - `ACTION_RULE`:  A policy of type Playbook.
     * - `VOLUMEGROUP`:  A resource of type volume group.
     * - `REPORT`:  A resource of type report.
     * - `STORAGE_POLICY`: A policy or rule of type storage policy.
     * - `BUNDLE`:  A resource of type bundle.
     * - `QOS_POLICY`: A policy or rule of type QoS policy.
     * - `SUBNET`:  A resource of type network subnets.
     * - `VM`: A resource of type Virtual Machine.
     * - `NETWORK_SECURITY_POLICY`:  A policy of type network security.
     * - `POLICY_SCHEMA`:  Policies like user-defined-alerts.
     * - `IMAGE_PLACEMENT_POLICY`:  A policy of type image placement.
     */
    resourceType: string;
}

export interface CategoryV2DetailedAssociation {
    /**
     * External identifier for the given category, used across all v4 apis/entities/resources where categories are referenced.
     */
    categoryId: string;
    /**
     * An enum denoting the resource group.
     * Resources can be organized into either an entity or a policy.
     * Valid values are:
     * - `POLICY`:  A ResourceGroup denoting a nutanix policy like VM host affinity policy, image placement policy, access control policy, and so on.<br> A category is generally associated with many entities.<br> The policy which is associated with this category, is then applied to those entities which are also associated with the same category.
     * - `ENTITY`: A ResourceGroup denoting a nutanix entity like VM, cluster, host, image, and so on.<br> A category is generally associated with many entities.<br> A policy is then applied to these entities through the category.
     */
    resourceGroup: string;
    /**
     * The UUID of the entity or policy associated with the particular category.
     */
    resourceId: string;
    /**
     * An enum denoting the associated resource types. Resource types are further grouped into 2 types - entity or a policy.
     * Valid values are:
     * - `APP`:  A resource of type application.
     * - `PROTECTION_RULE`:  A policy or rule of type protection rule.
     * - `IMAGE_RATE_LIMIT`: A resource of type rate limit.
     * - `MH_VM`: A resource of type Virtual Machine.
     * - `BLUEPRINT`:  A resource of type blueprint.
     * - `HOST`:  A resource representing the underlying host, the machine hosting the hypervisors and VMs.
     * - `IMAGE`:  A resource of type image.
     * - `VM_VM_ANTI_AFFINITY_POLICY`:  A policy of type VM-VM anti-affinity; This policy decides that the specified set of VMs are running on different hosts.
     * - `ACCESS_CONTROL_POLICY`: A policy or rule of type access control policy or ACP; the rules that decide authorization of users to access an API.
     * - `VM_HOST_AFFINITY_POLICY`: A policy of type VM host affinity; The policy decides the affinity between a set of VMs to be run only a specified set of hosts
     * - `NGT_POLICY`:  A policy or rule of type NGT policy.
     * - `RECOVERY_PLAN`:  A policy or rule of type recovery plan.
     * - `MARKETPLACE_ITEM`: A resource of type marketplace item.
     * - `CLUSTER`:  A resource of type cluster, usually refers to a PE cluster.
     * - `NETWORK_SECURITY_RULE`:  A rule of type network security.
     * - `HOST_NIC`:  A resource of type Physical NIC.
     * - `ACTION_RULE`:  A policy of type Playbook.
     * - `VOLUMEGROUP`:  A resource of type volume group.
     * - `REPORT`:  A resource of type report.
     * - `STORAGE_POLICY`: A policy or rule of type storage policy.
     * - `BUNDLE`:  A resource of type bundle.
     * - `QOS_POLICY`: A policy or rule of type QoS policy.
     * - `SUBNET`:  A resource of type network subnets.
     * - `VM`: A resource of type Virtual Machine.
     * - `NETWORK_SECURITY_POLICY`:  A policy of type network security.
     * - `POLICY_SCHEMA`:  Policies like user-defined-alerts.
     * - `IMAGE_PLACEMENT_POLICY`:  A policy of type image placement.
     */
    resourceType: string;
}

export interface ClusterAddNodeV2ConfigParam {
    /**
     * -(Optional) HyperV Credentials.
     */
    hipervs: outputs.ClusterAddNodeV2ConfigParamHiperv[];
    /**
     * -(Optional) Indicates whether the node is compute only or not.
     */
    isComputeOnly: boolean;
    /**
     * -(Optional) Indicates whether the node is marked to be never schedulable or not.
     */
    isNeverSchedulable: boolean;
    /**
     * -(Optional) Indicates if node is compatible or not.
     */
    isNosCompatible: boolean;
    /**
     * -(Optional) Indicates if node discovery need to be skipped or not.
     */
    shouldSkipDiscovery: boolean;
    /**
     * -(Optional) Indicates if node imaging needs to be skipped or not.
     */
    shouldSkipImaging: boolean;
    /**
     * -(Optional) Indicates if rack awareness needs to be validated or not.
     */
    shouldValidateRackAwareness: boolean;
    /**
     * -(Optional) Target hypervisor.
     */
    targetHypervisor: string;
}

export interface ClusterAddNodeV2ConfigParamHiperv {
    /**
     * -(Optional) UserName and Password model.
     */
    domainDetails: outputs.ClusterAddNodeV2ConfigParamHipervDomainDetail[];
    /**
     * -(Optional) UserName and Password model.
     */
    failoverClusterDetails: outputs.ClusterAddNodeV2ConfigParamHipervFailoverClusterDetail[];
}

export interface ClusterAddNodeV2ConfigParamHipervDomainDetail {
    /**
     * -(Optional) Cluster name. This is part of payload for both cluster create & update operations.
     */
    clusterName: string;
    /**
     * -(Optional) Password.
     */
    password: string;
    /**
     * -(Optional) Username.
     */
    username: string;
}

export interface ClusterAddNodeV2ConfigParamHipervFailoverClusterDetail {
    /**
     * -(Optional) Cluster name. This is part of payload for both cluster create & update operations.
     */
    clusterName: string;
    /**
     * -(Optional) Password.
     */
    password: string;
    /**
     * -(Optional) Username.
     */
    username: string;
}

export interface ClusterAddNodeV2NodeParam {
    /**
     * -(Optional) Block list of a cluster.
     */
    blockLists: outputs.ClusterAddNodeV2NodeParamBlockList[];
    /**
     * -(Optional) Hypervisor bundle information.
     */
    bundleInfos: outputs.ClusterAddNodeV2NodeParamBundleInfo[];
    computeNodeLists: outputs.ClusterAddNodeV2NodeParamComputeNodeList[];
    /**
     * -(Optional) Hyperv SKU.
     */
    hypervSku: string;
    /**
     * -(Optional) Hypervisor type to md5sum map.
     */
    hypervisorIsos: outputs.ClusterAddNodeV2NodeParamHypervisorIso[];
    /**
     * -(Required) List of nodes in a cluster.
     */
    nodeLists: outputs.ClusterAddNodeV2NodeParamNodeList[];
    /**
     * -(Optional) Indicates if the host networking needs to be skipped or not.
     */
    shouldSkipHostNetworking: boolean;
}

export interface ClusterAddNodeV2NodeParamBlockList {
    /**
     * -(Required) List of nodes in a block.
     */
    blockId: string;
    /**
     * -(Optional) Indicates if the host networking needs to be skipped or not.
     */
    rackName: string;
}

export interface ClusterAddNodeV2NodeParamBundleInfo {
    /**
     * -(Optional) Name of the hypervisor bundle.
     */
    name: string;
}

export interface ClusterAddNodeV2NodeParamComputeNodeList {
    blockId: string;
    digitalCertificateMapLists: outputs.ClusterAddNodeV2NodeParamComputeNodeListDigitalCertificateMapList[];
    hypervisorHostname?: string;
    hypervisorIps: outputs.ClusterAddNodeV2NodeParamComputeNodeListHypervisorIp[];
    ipmiIps: outputs.ClusterAddNodeV2NodeParamComputeNodeListIpmiIp[];
    model: string;
    nodePosition: string;
    nodeUuid: string;
}

export interface ClusterAddNodeV2NodeParamComputeNodeListDigitalCertificateMapList {
    /**
     * -(Optional) Field containing digitalCertificateBase64 and keyManagementServerUuid for key management server.
     */
    key: string;
    value: string;
}

export interface ClusterAddNodeV2NodeParamComputeNodeListHypervisorIp {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv6[];
}

export interface ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv4 {
    prefixLength?: number;
    value: string;
}

export interface ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv6 {
    prefixLength?: number;
    value: string;
}

export interface ClusterAddNodeV2NodeParamComputeNodeListIpmiIp {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv6[];
}

export interface ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv4 {
    prefixLength?: number;
    value: string;
}

export interface ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv6 {
    prefixLength?: number;
    value: string;
}

export interface ClusterAddNodeV2NodeParamHypervisorIso {
    md5Sum: string;
    /**
     * -(Optional) Hypervisor type.
     * Valid values are:
     * - `XEN`: Xen hypervisor.
     * - `HYPERV`: Hyper-V hypervisor.
     * - `NATIVEHOST`: NativeHost type where AOS runs natively, without hypervisor.
     * - `ESX`: ESX hypervisor.
     * - `AHV`: AHV hypervisor.
     */
    type: string;
}

export interface ClusterAddNodeV2NodeParamNodeList {
    /**
     * -(Optional) Block ID.
     */
    blockId: string;
    /**
     * -(Optional) Current network interface of a node.
     */
    currentNetworkInterface: string;
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    cvmIps: outputs.ClusterAddNodeV2NodeParamNodeListCvmIp[];
    /**
     * -(Optional) List of objects containing digitalCertificateBase64 and keyManagementServerUuid fields for key management server.
     */
    digitalCertificateMapLists: outputs.ClusterAddNodeV2NodeParamNodeListDigitalCertificateMapList[];
    /**
     * -(Optional) Name of the host.
     */
    hypervisorHostname: string;
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    hypervisorIps: outputs.ClusterAddNodeV2NodeParamNodeListHypervisorIp[];
    /**
     * -(Optional) Hypervisor type.
     * Valid values are:
     * - `XEN`: Xen hypervisor.
     * - `HYPERV`: Hyper-V hypervisor.
     * - `NATIVEHOST`: NativeHost type where AOS runs natively, without hypervisor.
     * - `ESX`: ESX hypervisor.
     * - `AHV`: AHV hypervisor.
     */
    hypervisorType: string;
    /**
     * -(Optional) Host version of the node.
     */
    hypervisorVersion: string;
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    ipmiIps: outputs.ClusterAddNodeV2NodeParamNodeListIpmiIp[];
    isLightCompute: boolean;
    /**
     * -(Optional) Is ROBO mixed hypervisor.
     */
    isRoboMixedHypervisor: boolean;
    /**
     * -(Optional) Rackable unit model name.
     */
    model: string;
    /**
     * -(Optional) Active and standby uplink information of the target nodes.
     */
    networks?: outputs.ClusterAddNodeV2NodeParamNodeListNetwork[];
    /**
     * -(Optional) Node position.
     */
    nodePosition: string;
    /**
     * -(Optional) Node UUID.
     */
    nodeUuid: string;
    /**
     * -(Optional) NOS software version of a node.
     */
    nosVersion: string;
}

export interface ClusterAddNodeV2NodeParamNodeListCvmIp {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.ClusterAddNodeV2NodeParamNodeListCvmIpIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.ClusterAddNodeV2NodeParamNodeListCvmIpIpv6[];
}

export interface ClusterAddNodeV2NodeParamNodeListCvmIpIpv4 {
    prefixLength?: number;
    value: string;
}

export interface ClusterAddNodeV2NodeParamNodeListCvmIpIpv6 {
    prefixLength?: number;
    value: string;
}

export interface ClusterAddNodeV2NodeParamNodeListDigitalCertificateMapList {
    /**
     * -(Optional) Field containing digitalCertificateBase64 and keyManagementServerUuid for key management server.
     */
    key: string;
    value: string;
}

export interface ClusterAddNodeV2NodeParamNodeListHypervisorIp {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv6[];
}

export interface ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv4 {
    prefixLength?: number;
    value: string;
}

export interface ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv6 {
    prefixLength?: number;
    value: string;
}

export interface ClusterAddNodeV2NodeParamNodeListIpmiIp {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.ClusterAddNodeV2NodeParamNodeListIpmiIpIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.ClusterAddNodeV2NodeParamNodeListIpmiIpIpv6[];
}

export interface ClusterAddNodeV2NodeParamNodeListIpmiIpIpv4 {
    prefixLength?: number;
    value: string;
}

export interface ClusterAddNodeV2NodeParamNodeListIpmiIpIpv6 {
    prefixLength?: number;
    value: string;
}

export interface ClusterAddNodeV2NodeParamNodeListNetwork {
    /**
     * -(Optional) Name of the uplink.
     */
    name?: string;
    /**
     * -(Optional) List of network types.
     */
    networks?: string[];
    /**
     * -(Optional) Active and standby uplink information of the target nodes.
     */
    uplinks?: outputs.ClusterAddNodeV2NodeParamNodeListNetworkUplink[];
}

export interface ClusterAddNodeV2NodeParamNodeListNetworkUplink {
    /**
     * -(Optional) Active uplink information.
     */
    actives?: outputs.ClusterAddNodeV2NodeParamNodeListNetworkUplinkActive[];
    /**
     * -(Optional) Standby uplink information.
     */
    standbies?: outputs.ClusterAddNodeV2NodeParamNodeListNetworkUplinkStandby[];
}

export interface ClusterAddNodeV2NodeParamNodeListNetworkUplinkActive {
    /**
     * -(Optional) Mac address.
     */
    mac?: string;
    /**
     * -(Optional) Interface name.
     */
    name?: string;
    /**
     * -(Optional) Interface value.
     */
    value?: string;
}

export interface ClusterAddNodeV2NodeParamNodeListNetworkUplinkStandby {
    /**
     * -(Optional) Mac address.
     */
    mac?: string;
    /**
     * -(Optional) Interface name.
     */
    name?: string;
    /**
     * -(Optional) Interface value.
     */
    value?: string;
}

export interface ClusterAddNodeV2RemoveNodeParam {
    /**
     * -(Optional) Extra parameters for node addition.
     */
    extraParams?: outputs.ClusterAddNodeV2RemoveNodeParamExtraParam[];
    /**
     * -(Optional) Indicates if prechecks can be skipped for node removal.
     */
    shouldSkipPrechecks?: boolean;
    /**
     * -(Optional) Indicates if node removal can be skipped.
     */
    shouldSkipRemove?: boolean;
}

export interface ClusterAddNodeV2RemoveNodeParamExtraParam {
    /**
     * -(Optional) Indicates if add check needs to be skipped or not.
     *
     *
     *
     *
     * See detailed information in [Nutanix Cluster - Add Node on a Cluster V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0#tag/Clusters/operation/expandCluster).
     */
    shouldSkipAddCheck?: boolean;
    /**
     * -(Optional) Indicates if upgrade check needs to be skipped or not.
     */
    shouldSkipUpgradeCheck?: boolean;
    /**
     * -(Optional) Indicates if space check needs to be skipped or not.
     */
    skipSpaceCheck?: boolean;
}

export interface ClusterV2Config {
    /**
     * - (Optional) Public ssh key details. This is part of payload for cluster update operation only.
     */
    authorizedPublicKeyLists: outputs.ClusterV2ConfigAuthorizedPublicKeyList[];
    /**
     * - (Optional) Build information details.
     */
    buildInfos: outputs.ClusterV2ConfigBuildInfo[];
    /**
     * - (Optional) Cluster arch.
     * Valid values are:
     * - "PPC64LE" PPC64LE cluster architecture type.
     * - "X86_64" X86_64 cluster architecture type.
     */
    clusterArch: string;
    /**
     * - (Optional) Cluster function. This is part of payload for cluster
     * create operation only (allowed enum values for creation are AOS, ONE_NODE & TWO_NODE only).
     * Valid values are:
     * - "AOS"
     * - "PRISM_CENTRAL"
     * - "CLOUD_DATA_GATEWAY"
     * - "AFS"
     * - "ONE_NODE"
     * - "TWO_NODE"
     * - "ANALYTICS_PLATFORM"
     */
    clusterFunctions: string[];
    clusterSoftwareMaps: outputs.ClusterV2ConfigClusterSoftwareMap[];
    /**
     * - (Optional) Encryption in transit Status.
     * Valid values are:
     * - "DISABLED"	Disabled encryption status.
     * - "ENABLED"	Enabled encryption status.
     */
    encryptionInTransitStatus: string;
    encryptionOptions: string[];
    encryptionScopes: string[];
    /**
     * - (Optional) Fault tolerant state of cluster.
     */
    faultToleranceStates: outputs.ClusterV2ConfigFaultToleranceState[];
    hypervisorTypes: string[];
    incarnationId: number;
    isAvailable: boolean;
    isLts: boolean;
    isPasswordRemoteLoginEnabled: boolean;
    isRemoteSupportEnabled: boolean;
    /**
     * - (Optional) Cluster operation mode. This is part of payload for cluster
     * update operation only.
     * Valid values are:
     * - "OVERRIDE"	Override operation mode.
     * - "STAND_ALONE"	Stand-alone operation mode.
     * - "SWITCH_TO_TWO_NODE"	Switch to two-node operation mode.
     * - "NORMAL"	Normal operation mode.
     * - "READ_ONLY"	Read-only operation mode.
     */
    operationMode: string;
    /**
     * - (Optional) Pulse status for a cluster. `supported only for update operations and not available during creation.`
     */
    pulseStatuses: outputs.ClusterV2ConfigPulseStatus[];
    /**
     * - (Optional) Redundancy factor of a cluster. This is part of payload for both cluster create & update operations.
     */
    redundancyFactor: number;
    timezone: string;
}

export interface ClusterV2ConfigAuthorizedPublicKeyList {
    /**
     * Ssh key value.
     */
    key: string;
    /**
     * Ssh key name.
     */
    name: string;
}

export interface ClusterV2ConfigBuildInfo {
    /**
     * Software build type.
     */
    buildType: string;
    /**
     * Commit Id used for version.
     */
    commitId: string;
    /**
     * Full name of software version.
     */
    fullVersion: string;
    /**
     * Short commit Id used for version.
     */
    shortCommitId: string;
    /**
     * Software version.
     */
    version: string;
}

export interface ClusterV2ConfigClusterSoftwareMap {
    softwareType: string;
    /**
     * Software version.
     */
    version: string;
}

export interface ClusterV2ConfigFaultToleranceState {
    currentClusterFaultTolerance: string;
    currentMaxFaultTolerance: number;
    desiredClusterFaultTolerance: string;
    desiredMaxFaultTolerance: number;
    /**
     * Domain awareness level corresponds to unit of cluster group. This is part of payload for both cluster create & update operations.
     * Valid values are:
     * - "RACK"	Rack level awareness.
     * - "NODE"	Node level awareness.
     * - "BLOCK"	Block level awareness.
     * - "DISK"	Disk level awareness.
     */
    domainAwarenessLevel: string;
    redundancyStatuses: outputs.ClusterV2ConfigFaultToleranceStateRedundancyStatus[];
}

export interface ClusterV2ConfigFaultToleranceStateRedundancyStatus {
    isCassandraPreparationDone: boolean;
    isZookeeperPreparationDone: boolean;
}

export interface ClusterV2ConfigPulseStatus {
    /**
     * - (Optional) Flag to indicate if pulse is enabled or not.
     */
    isEnabled: boolean;
    /**
     * - (Optional) PII scrubbing level.
     * Valid values are:
     * - "ALL" :	Scrub All PII Information from Pulse including data like entity names and IP addresses.
     * - "DEFAULT":	Default PII Scrubbing level. Data like entity names and IP addresses will not be scrubbed from Pulse.
     */
    piiScrubbingLevel: string;
}

export interface ClusterV2Link {
    href: string;
    rel: string;
}

export interface ClusterV2Network {
    /**
     * Params associated to the backplane network segmentation. This is part of payload for cluster(create operation only.)
     */
    backplanes: outputs.ClusterV2NetworkBackplane[];
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    externalAddresses: outputs.ClusterV2NetworkExternalAddress[];
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    externalDataServicesIps: outputs.ClusterV2NetworkExternalDataServicesIp[];
    externalSubnet: string;
    /**
     * Cluster fully qualified domain name. This is part of payload for cluster update operation only.
     */
    fqdn: string;
    /**
     * List of HTTP Proxy server configuration needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
     */
    httpProxyLists: outputs.ClusterV2NetworkHttpProxyList[];
    httpProxyWhiteLists: outputs.ClusterV2NetworkHttpProxyWhiteList[];
    internalSubnet: string;
    /**
     * Management server type.
     * Valid values are:
     * - "PRISM_CENTRAL"	Prism Central management server.
     * - "EXTERNAL"	External management server.
     * - "LOCAL"	Local management server.
     */
    keyManagementServerType: string;
    /**
     * Management server information.
     */
    managementServers: outputs.ClusterV2NetworkManagementServer[];
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    masqueradingIps: outputs.ClusterV2NetworkMasqueradingIp[];
    masqueradingPort: string;
    /**
     * List of name servers on a cluster. This is part of payload for both cluster create & update operations. For create operation, only ipv4 address / fqdn values are supported currently.
     */
    nameServerIpLists: outputs.ClusterV2NetworkNameServerIpList[];
    /**
     * NFS subnet whitelist addresses. This is part of payload for cluster update operation only.
     */
    nfsSubnetWhiteLists: string[];
    /**
     * List of NTP servers on a cluster. This is part of payload for both cluster create & update operations. For create operation, only ipv4 address / fqdn values are supported currently.
     */
    ntpServerIpLists: outputs.ClusterV2NetworkNtpServerIpList[];
    /**
     * SMTP servers on a cluster. This is part of payload for cluster update operation only.
     */
    smtpServers: outputs.ClusterV2NetworkSmtpServer[];
}

export interface ClusterV2NetworkBackplane {
    /**
     * Flag to indicate if the backplane segmentation needs to be enabled or not.
     */
    isSegmentationEnabled: boolean;
    /**
     * Netmask configs.
     */
    netmasks: outputs.ClusterV2NetworkBackplaneNetmask[];
    /**
     * Subnet configs.
     */
    subnets: outputs.ClusterV2NetworkBackplaneSubnet[];
    /**
     * VLAN Id tagged to the backplane network on the cluster. This is part of cluster create payload.
     */
    vlanTag: number;
}

export interface ClusterV2NetworkBackplaneNetmask {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     */
    value: string;
}

export interface ClusterV2NetworkBackplaneSubnet {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     */
    value: string;
}

export interface ClusterV2NetworkExternalAddress {
    /**
     * - (Optional) ip address params.
     */
    ipv4s: outputs.ClusterV2NetworkExternalAddressIpv4[];
    /**
     * - (Optional) Ip address params.
     */
    ipv6s: outputs.ClusterV2NetworkExternalAddressIpv6[];
}

export interface ClusterV2NetworkExternalAddressIpv4 {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     */
    value: string;
}

export interface ClusterV2NetworkExternalAddressIpv6 {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     *
     * See detailed information in [Nutanix Create Cluster V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0#tag/Clusters/operation/createCluster).
     */
    value: string;
}

export interface ClusterV2NetworkExternalDataServicesIp {
    /**
     * - (Optional) ip address params.
     */
    ipv4s: outputs.ClusterV2NetworkExternalDataServicesIpIpv4[];
    /**
     * - (Optional) Ip address params.
     */
    ipv6s: outputs.ClusterV2NetworkExternalDataServicesIpIpv6[];
}

export interface ClusterV2NetworkExternalDataServicesIpIpv4 {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     */
    value: string;
}

export interface ClusterV2NetworkExternalDataServicesIpIpv6 {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     *
     * See detailed information in [Nutanix Create Cluster V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0#tag/Clusters/operation/createCluster).
     */
    value: string;
}

export interface ClusterV2NetworkHttpProxyList {
    /**
     * - (Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    ipAddresses: outputs.ClusterV2NetworkHttpProxyListIpAddress[];
    /**
     * - (Required) HTTP Proxy server name configuration needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
     */
    name: string;
    /**
     * - (Optional) HTTP Proxy server password needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
     */
    password?: string;
    /**
     * - (Optional) HTTP Proxy server port configuration needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
     */
    port: number;
    proxyTypes: string[];
    /**
     * - (Optional) HTTP Proxy server username needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
     */
    username: string;
}

export interface ClusterV2NetworkHttpProxyListIpAddress {
    /**
     * - (Optional) ip address params.
     */
    ipv4s: outputs.ClusterV2NetworkHttpProxyListIpAddressIpv4[];
    /**
     * - (Optional) Ip address params.
     */
    ipv6s: outputs.ClusterV2NetworkHttpProxyListIpAddressIpv6[];
}

export interface ClusterV2NetworkHttpProxyListIpAddressIpv4 {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     */
    value: string;
}

export interface ClusterV2NetworkHttpProxyListIpAddressIpv6 {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     *
     * See detailed information in [Nutanix Create Cluster V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0#tag/Clusters/operation/createCluster).
     */
    value: string;
}

export interface ClusterV2NetworkHttpProxyWhiteList {
    /**
     * - (Required) Target's identifier which is exempted from going through the configured HTTP Proxy.
     */
    target: string;
    /**
     * - (Optional) Target type.
     * Valid values are:
     * - "IPV6_ADDRESS"	IPV6 address.
     * - "HOST_NAME"	Name of the host.
     * - "IPV4_ADDRESS"	IPV4 address.
     * - "DOMAIN_NAME_SUFFIX"	Domain Name Suffix required for http proxy whitelist.
     * - "IPV4_NETWORK_MASK" Network Mask of the IpV4 family.
     */
    targetType: string;
}

export interface ClusterV2NetworkManagementServer {
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    ips: outputs.ClusterV2NetworkManagementServerIp[];
    isDrsEnabled: boolean;
    isInUse: boolean;
    /**
     * Indicates whether it is registered or not.
     */
    isRegistered: boolean;
    /**
     * Management server type.
     * Valid values are:
     * - "VCENTER"	Vcenter management server.
     */
    type: string;
}

export interface ClusterV2NetworkManagementServerIp {
    /**
     * - (Optional) ip address params.
     */
    ipv4s: outputs.ClusterV2NetworkManagementServerIpIpv4[];
    /**
     * - (Optional) Ip address params.
     */
    ipv6s: outputs.ClusterV2NetworkManagementServerIpIpv6[];
}

export interface ClusterV2NetworkManagementServerIpIpv4 {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     */
    value: string;
}

export interface ClusterV2NetworkManagementServerIpIpv6 {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     *
     * See detailed information in [Nutanix Create Cluster V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0#tag/Clusters/operation/createCluster).
     */
    value: string;
}

export interface ClusterV2NetworkMasqueradingIp {
    /**
     * - (Optional) ip address params.
     */
    ipv4s: outputs.ClusterV2NetworkMasqueradingIpIpv4[];
    /**
     * - (Optional) Ip address params.
     */
    ipv6s: outputs.ClusterV2NetworkMasqueradingIpIpv6[];
}

export interface ClusterV2NetworkMasqueradingIpIpv4 {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     */
    value: string;
}

export interface ClusterV2NetworkMasqueradingIpIpv6 {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     *
     * See detailed information in [Nutanix Create Cluster V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0#tag/Clusters/operation/createCluster).
     */
    value: string;
}

export interface ClusterV2NetworkNameServerIpList {
    /**
     * - (Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.ClusterV2NetworkNameServerIpListFqdn[];
    /**
     * - (Optional) ip address params.
     */
    ipv4s: outputs.ClusterV2NetworkNameServerIpListIpv4[];
    /**
     * - (Optional) Ip address params.
     */
    ipv6s: outputs.ClusterV2NetworkNameServerIpListIpv6[];
}

export interface ClusterV2NetworkNameServerIpListFqdn {
    value: string;
}

export interface ClusterV2NetworkNameServerIpListIpv4 {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     */
    value: string;
}

export interface ClusterV2NetworkNameServerIpListIpv6 {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     *
     * See detailed information in [Nutanix Create Cluster V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0#tag/Clusters/operation/createCluster).
     */
    value: string;
}

export interface ClusterV2NetworkNtpServerIpList {
    /**
     * - (Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.ClusterV2NetworkNtpServerIpListFqdn[];
    /**
     * - (Optional) ip address params.
     */
    ipv4s: outputs.ClusterV2NetworkNtpServerIpListIpv4[];
    /**
     * - (Optional) Ip address params.
     */
    ipv6s: outputs.ClusterV2NetworkNtpServerIpListIpv6[];
}

export interface ClusterV2NetworkNtpServerIpListFqdn {
    value: string;
}

export interface ClusterV2NetworkNtpServerIpListIpv4 {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     */
    value: string;
}

export interface ClusterV2NetworkNtpServerIpListIpv6 {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     *
     * See detailed information in [Nutanix Create Cluster V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0#tag/Clusters/operation/createCluster).
     */
    value: string;
}

export interface ClusterV2NetworkSmtpServer {
    /**
     * SMTP email address.
     */
    emailAddress: string;
    /**
     * SMTP network details.
     */
    servers: outputs.ClusterV2NetworkSmtpServerServer[];
    /**
     * Type of SMTP server.
     * Valid values are:
     * - "PLAIN"	Plain type SMTP server.
     * - "STARTTLS"	Start TLS type SMTP server.
     * - "SSL"	SSL type SMTP server.
     */
    type: string;
}

export interface ClusterV2NetworkSmtpServerServer {
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    ipAddresses: outputs.ClusterV2NetworkSmtpServerServerIpAddress[];
    /**
     * SMTP server password.
     */
    password?: string;
    /**
     * SMTP port.
     */
    port: number;
    /**
     * SMTP server user name.
     */
    username: string;
}

export interface ClusterV2NetworkSmtpServerServerIpAddress {
    /**
     * - (Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.ClusterV2NetworkSmtpServerServerIpAddressFqdn[];
    /**
     * - (Optional) ip address params.
     */
    ipv4s: outputs.ClusterV2NetworkSmtpServerServerIpAddressIpv4[];
    /**
     * - (Optional) Ip address params.
     */
    ipv6s: outputs.ClusterV2NetworkSmtpServerServerIpAddressIpv6[];
}

export interface ClusterV2NetworkSmtpServerServerIpAddressFqdn {
    value: string;
}

export interface ClusterV2NetworkSmtpServerServerIpAddressIpv4 {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     */
    value: string;
}

export interface ClusterV2NetworkSmtpServerServerIpAddressIpv6 {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     *
     * See detailed information in [Nutanix Create Cluster V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0#tag/Clusters/operation/createCluster).
     */
    value: string;
}

export interface ClusterV2Node {
    /**
     * - (Optional) List of nodes in a cluster.
     */
    nodeLists: outputs.ClusterV2NodeNodeList[];
    numberOfNodes: number;
}

export interface ClusterV2NodeNodeList {
    /**
     * - (Required) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    controllerVmIps: outputs.ClusterV2NodeNodeListControllerVmIp[];
    /**
     * - (Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    hostIps: outputs.ClusterV2NodeNodeListHostIp[];
    nodeUuid: string;
}

export interface ClusterV2NodeNodeListControllerVmIp {
    /**
     * - (Optional) ip address params.
     */
    ipv4s: outputs.ClusterV2NodeNodeListControllerVmIpIpv4[];
    /**
     * - (Optional) Ip address params.
     */
    ipv6s: outputs.ClusterV2NodeNodeListControllerVmIpIpv6[];
}

export interface ClusterV2NodeNodeListControllerVmIpIpv4 {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     */
    value: string;
}

export interface ClusterV2NodeNodeListControllerVmIpIpv6 {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     *
     * See detailed information in [Nutanix Create Cluster V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0#tag/Clusters/operation/createCluster).
     */
    value: string;
}

export interface ClusterV2NodeNodeListHostIp {
    /**
     * - (Optional) ip address params.
     */
    ipv4s: outputs.ClusterV2NodeNodeListHostIpIpv4[];
    /**
     * - (Optional) Ip address params.
     */
    ipv6s: outputs.ClusterV2NodeNodeListHostIpIpv6[];
}

export interface ClusterV2NodeNodeListHostIpIpv4 {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     */
    value: string;
}

export interface ClusterV2NodeNodeListHostIpIpv6 {
    /**
     * - (Optional) The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength?: number;
    /**
     * - (Required) Ip address.
     *
     * See detailed information in [Nutanix Create Cluster V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0#tag/Clusters/operation/createCluster).
     */
    value: string;
}

export interface ClustersDiscoverUnconfiguredNodesV2IpFilterList {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv6[];
}

export interface ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface ClustersDiscoverUnconfiguredNodesV2UnconfiguredNode {
    /**
     * Cluster arch type.
     */
    arch: string;
    /**
     * Attributes of a node.
     */
    attributes: outputs.ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeAttribute[];
    /**
     * Cluster ID.
     */
    clusterId: string;
    /**
     * CPU type.
     */
    cpuTypes: string[];
    /**
     * Current CVM VLAN tag.
     */
    currentCvmVlanTag: string;
    /**
     * Current network interface of a node.
     */
    currentNetworkInterface: string;
    /**
     * CVM IP.
     */
    cvmIps: outputs.ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIp[];
    /**
     * Foundation version.
     */
    foundationVersion: string;
    /**
     * Host type.
     */
    hostType: string;
    /**
     * Hypervisor IP Address.
     */
    hypervisorIps: outputs.ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIp[];
    /**
     * Hypervisor type.
     */
    hypervisorType: string;
    /**
     * Host version of the node.
     */
    hypervisorVersion: string;
    /**
     * Interface IPV6 address.
     */
    interfaceIpv6: string;
    /**
     * IPMI IP Address.
     */
    ipmiIps: outputs.ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIp[];
    /**
     * Secure boot status.
     */
    isSecureBooted: boolean;
    /**
     * Position of a node in a rackable unit.
     */
    nodePosition: string;
    /**
     * UUID of the host.
     */
    nodeUuid: string;
    /**
     * NOS software version of a node.
     */
    nosVersion: string;
    /**
     * Maximum number of nodes in rackable-unit.
     */
    rackableUnitMaxNodes: number;
    /**
     * Rackable unit model type.
     */
    rackableUnitModel: string;
    /**
     * Rackable unit serial name.
     */
    rackableUnitSerial: string;
}

export interface ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeAttribute {
    /**
     * Default workload.
     */
    defaultWorkload: string;
    /**
     * Indicates whether the model is supported or not.
     */
    isModelSupported: boolean;
    /**
     * Indicates whether the hypervisor is robo mixed or not.
     */
    isRoboMixedHypervisor: boolean;
    /**
     * LCM family name.
     */
    lcmFamily: string;
    /**
     * Indicates if cvm interface can work with 1 GIG NIC or not.
     */
    shouldWorkWith1gNic: boolean;
}

export interface ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIp {
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv4[];
    /**
     * An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv6[];
}

export interface ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIp {
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv4[];
    /**
     * An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv6[];
}

export interface ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIp {
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv4[];
    /**
     * An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv6[];
}

export interface ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface ClustersUnconfiguredNodeNetworksV2NodeList {
    /**
     * -(Optional) Block ID.
     */
    blockId: string;
    /**
     * -(Optional) Current network interface.
     */
    currentNetworkInterface: string;
    /**
     * -(Optional) CVM IP.
     */
    cvmIps: outputs.ClustersUnconfiguredNodeNetworksV2NodeListCvmIp[];
    /**
     * -(Optional) Digital certificate map list.
     */
    digitalCertificateMapLists: outputs.ClustersUnconfiguredNodeNetworksV2NodeListDigitalCertificateMapList[];
    /**
     * -(Optional) Hypervisor IP.
     */
    hypervisorIps: outputs.ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIp[];
    /**
     * -(Optional) Hypervisor type.
     */
    hypervisorType: string;
    /**
     * -(Optional) Hypervisor version.
     */
    hypervisorVersion: string;
    /**
     * -(Optional) IPMI IP.
     */
    ipmiIps: outputs.ClustersUnconfiguredNodeNetworksV2NodeListIpmiIp[];
    /**
     * -(Optional) Is compute only.
     */
    isComputeOnly: boolean;
    isLightCompute: boolean;
    /**
     * -(Optional) Is ROBO mixed hypervisor.
     */
    isRoboMixedHypervisor: boolean;
    /**
     * -(Optional) Model name.
     */
    model: string;
    /**
     * -(Optional) Node position.
     */
    nodePosition: string;
    /**
     * -(Optional) Node UUID.
     */
    nodeUuid: string;
    /**
     * -(Optional) NOS version.
     */
    nosVersion: string;
}

export interface ClustersUnconfiguredNodeNetworksV2NodeListCvmIp {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv6[];
}

export interface ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface ClustersUnconfiguredNodeNetworksV2NodeListDigitalCertificateMapList {
    /**
     * -(Optional) Field containing digitalCertificateBase64 and keyManagementServerUuid for key management server.
     */
    key: string;
    value: string;
}

export interface ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIp {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv6[];
}

export interface ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface ClustersUnconfiguredNodeNetworksV2NodeListIpmiIp {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv6[];
}

export interface ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetail {
    /**
     * - Network information for the given nodes.
     */
    networkInfos: outputs.ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfo[];
    /**
     * - List of uplinks information for each CVM IP.
     */
    uplinks: outputs.ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplink[];
    /**
     * - List of warning messages.
     */
    warnings: string[];
}

export interface ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfo {
    /**
     * - Network information of HCI nodes.
     */
    hcis: outputs.ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoHci[];
    /**
     * - Network information of SO nodes.
     */
    sos: outputs.ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoSo[];
}

export interface ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoHci {
    /**
     * - Hypervisor type.
     */
    hypervisorType: string;
    /**
     * - Interface name.
     */
    name: string;
    /**
     * - List of networks for interface.
     */
    networks: string[];
}

export interface ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoSo {
    /**
     * - Hypervisor type.
     */
    hypervisorType: string;
    /**
     * - Interface name.
     */
    name: string;
    /**
     * - List of networks for interface.
     */
    networks: string[];
}

export interface ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplink {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    cvmIps: outputs.ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIp[];
    /**
     * - Uplink details for a controller VM.
     */
    uplinkLists: outputs.ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkUplinkList[];
}

export interface ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIp {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv6[];
}

export interface ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkUplinkList {
    /**
     * - MAC address.
     */
    mac: string;
    /**
     * - Interface name.
     */
    name: string;
}

export interface DeployTemplatesV2OverrideVmConfigMap {
    guestCustomizations: outputs.DeployTemplatesV2OverrideVmConfigMapGuestCustomization[];
    memorySizeBytes?: number;
    name?: string;
    nics?: outputs.DeployTemplatesV2OverrideVmConfigMapNic[];
    numCoresPerSocket?: number;
    numSockets?: number;
    numThreadsPerCore?: number;
}

export interface DeployTemplatesV2OverrideVmConfigMapGuestCustomization {
    configs: outputs.DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfig[];
}

export interface DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfig {
    cloudInits: outputs.DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInit[];
    syspreps: outputs.DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprep[];
}

export interface DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInit {
    cloudInitScripts: outputs.DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScript[];
    datasourceType?: string;
    metadata: string;
}

export interface DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScript {
    customKeyValues: outputs.DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValue[];
    userDatas: outputs.DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptUserData[];
}

export interface DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValue {
    keyValuePairs: outputs.DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePair[];
}

export interface DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePair {
    name: string;
    values: outputs.DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValue[];
}

export interface DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString {
    map: {[key: string]: string};
}

export interface DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptUserData {
    value: string;
}

export interface DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprep {
    installType: string;
    sysprepScripts: outputs.DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScript[];
}

export interface DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScript {
    customKeyValues: outputs.DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValue[];
    unattendXmls: outputs.DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptUnattendXml[];
}

export interface DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValue {
    keyValuePairs: outputs.DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePair[];
}

export interface DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePair {
    name: string;
    values: outputs.DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValue[];
}

export interface DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfString {
    map: {[key: string]: string};
}

export interface DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptUnattendXml {
    value: string;
}

export interface DeployTemplatesV2OverrideVmConfigMapNic {
    backingInfos?: outputs.DeployTemplatesV2OverrideVmConfigMapNicBackingInfo[];
    extId: string;
    networkInfos?: outputs.DeployTemplatesV2OverrideVmConfigMapNicNetworkInfo[];
}

export interface DeployTemplatesV2OverrideVmConfigMapNicBackingInfo {
    isConnected?: boolean;
    macAddress?: string;
    model?: string;
    numQueues?: number;
}

export interface DeployTemplatesV2OverrideVmConfigMapNicNetworkInfo {
    ipv4Configs?: outputs.DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4Config[];
    ipv4Infos: outputs.DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4Info[];
    networkFunctionChains?: outputs.DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoNetworkFunctionChain[];
    networkFunctionNicType?: string;
    nicType?: string;
    shouldAllowUnknownMacs?: boolean;
    subnets?: outputs.DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoSubnet[];
    trunkedVlans?: number[];
    vlanMode?: string;
}

export interface DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4Config {
    ipAddresses?: outputs.DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigIpAddress[];
    secondaryIpAddressLists?: outputs.DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigSecondaryIpAddressList[];
    shouldAssignIp?: boolean;
}

export interface DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigIpAddress {
    prefixLength?: number;
    value?: string;
}

export interface DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigSecondaryIpAddressList {
    prefixLength?: number;
    value?: string;
}

export interface DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4Info {
    learnedIpAddresses: outputs.DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4InfoLearnedIpAddress[];
}

export interface DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4InfoLearnedIpAddress {
    prefixLength?: number;
    value: string;
}

export interface DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoNetworkFunctionChain {
    extId?: string;
}

export interface DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoSubnet {
    extId?: string;
}

export interface DirectoryServicesV2OpenLdapConfiguration {
    /**
     * -(Required) this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
     */
    userConfigurations: outputs.DirectoryServicesV2OpenLdapConfigurationUserConfiguration[];
    /**
     * -(Required) this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
     */
    userGroupConfigurations: outputs.DirectoryServicesV2OpenLdapConfigurationUserGroupConfiguration[];
}

export interface DirectoryServicesV2OpenLdapConfigurationUserConfiguration {
    /**
     * -(Required) Object class in the OpenLDAP system that corresponds to Users.
     */
    userObjectClass: string;
    /**
     * -(Required) Base DN for User search.
     */
    userSearchBase: string;
    /**
     * -(Required) Unique Identifier for each User which can be used in Authentication.
     */
    usernameAttribute: string;
}

export interface DirectoryServicesV2OpenLdapConfigurationUserGroupConfiguration {
    /**
     * -(Required) Attribute in a group that associates Users to the group.
     */
    groupMemberAttribute: string;
    /**
     * -(Required) User attribute value that will be used in group entity to associate User to the group.
     */
    groupMemberAttributeValue: string;
    /**
     * -(Required) Object class in the OpenLDAP system that corresponds to groups.
     */
    groupObjectClass: string;
    /**
     * -(Required) Base DN for group search.
     */
    groupSearchBase: string;
}

export interface DirectoryServicesV2ServiceAccount {
    /**
     * -(Required) Password to connect to the Directory Service.
     */
    password: string;
    /**
     * -(Required) Username to connect to the Directory Service.
     */
    username: string;
}

export interface FloatingIpV2Association {
    /**
     * Association of Floating IP with private IP
     * - `private_ip_association.vpc_reference`: (Required) VPC in which the private IP exists.
     * - `private_ip_association.private_ip`: (Required) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    privateIpAssociations?: outputs.FloatingIpV2AssociationPrivateIpAssociation[];
    /**
     * Association of Floating IP with nic
     * - `vm_nic_association.vm_nic_reference`: (Required) VM NIC reference.
     * - `vm_nic_association.vpc_reference`: (Optional) VPC reference to which the VM NIC subnet belongs.
     */
    vmNicAssociations?: outputs.FloatingIpV2AssociationVmNicAssociation[];
}

export interface FloatingIpV2AssociationPrivateIpAssociation {
    privateIps: outputs.FloatingIpV2AssociationPrivateIpAssociationPrivateIp[];
    /**
     * VPC reference UUID
     */
    vpcReference: string;
}

export interface FloatingIpV2AssociationPrivateIpAssociationPrivateIp {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv6[];
}

export interface FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2AssociationVmNicAssociation {
    /**
     * VM NIC reference.
     */
    vmNicReference: string;
    /**
     * VPC reference UUID
     */
    vpcReference: string;
}

export interface FloatingIpV2ExternalSubnet {
    bridgeName: string;
    clusterName: string;
    clusterReference: string;
    /**
     * Description for the Floating IP.
     */
    description: string;
    dhcpOptions: outputs.FloatingIpV2ExternalSubnetDhcpOption[];
    dynamicIpAddresses: outputs.FloatingIpV2ExternalSubnetDynamicIpAddress[];
    extId: string;
    hypervisorType: string;
    ipConfigs: outputs.FloatingIpV2ExternalSubnetIpConfig[];
    ipPrefix: string;
    ipUsages: outputs.FloatingIpV2ExternalSubnetIpUsage[];
    isAdvancedNetworking: boolean;
    isExternal: boolean;
    isNatEnabled: boolean;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.FloatingIpV2ExternalSubnetLink[];
    migrationState: string;
    /**
     * Name of the floating IP.
     */
    name: string;
    networkFunctionChainReference: string;
    networkId: number;
    reservedIpAddresses: outputs.FloatingIpV2ExternalSubnetReservedIpAddress[];
    subnetType: string;
    virtualSwitchReference: string;
    virtualSwitches: outputs.FloatingIpV2ExternalSubnetVirtualSwitch[];
    /**
     * VPC reference UUID
     */
    vpcReference: string;
    /**
     * Networking common base object
     */
    vpcs: outputs.FloatingIpV2ExternalSubnetVpc[];
}

export interface FloatingIpV2ExternalSubnetDhcpOption {
    bootFileName: string;
    domainName: string;
    domainNameServers: outputs.FloatingIpV2ExternalSubnetDhcpOptionDomainNameServer[];
    ntpServers: outputs.FloatingIpV2ExternalSubnetDhcpOptionNtpServer[];
    searchDomains: string[];
    tftpServerName: string;
}

export interface FloatingIpV2ExternalSubnetDhcpOptionDomainNameServer {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv6[];
}

export interface FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetDhcpOptionNtpServer {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv6[];
}

export interface FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetDynamicIpAddress {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.FloatingIpV2ExternalSubnetDynamicIpAddressIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.FloatingIpV2ExternalSubnetDynamicIpAddressIpv6[];
}

export interface FloatingIpV2ExternalSubnetDynamicIpAddressIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetDynamicIpAddressIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetIpConfig {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.FloatingIpV2ExternalSubnetIpConfigIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.FloatingIpV2ExternalSubnetIpConfigIpv6[];
}

export interface FloatingIpV2ExternalSubnetIpConfigIpv4 {
    defaultGatewayIps: outputs.FloatingIpV2ExternalSubnetIpConfigIpv4DefaultGatewayIp[];
    dhcpServerAddresses: outputs.FloatingIpV2ExternalSubnetIpConfigIpv4DhcpServerAddress[];
    ipSubnets: outputs.FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnet[];
    poolLists: outputs.FloatingIpV2ExternalSubnetIpConfigIpv4PoolList[];
}

export interface FloatingIpV2ExternalSubnetIpConfigIpv4DefaultGatewayIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetIpConfigIpv4DhcpServerAddress {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnet {
    ips: outputs.FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetIp[];
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
}

export interface FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetIpConfigIpv4PoolList {
    endIps: outputs.FloatingIpV2ExternalSubnetIpConfigIpv4PoolListEndIp[];
    startIps: outputs.FloatingIpV2ExternalSubnetIpConfigIpv4PoolListStartIp[];
}

export interface FloatingIpV2ExternalSubnetIpConfigIpv4PoolListEndIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetIpConfigIpv4PoolListStartIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetIpConfigIpv6 {
    defaultGatewayIps: outputs.FloatingIpV2ExternalSubnetIpConfigIpv6DefaultGatewayIp[];
    dhcpServerAddresses: outputs.FloatingIpV2ExternalSubnetIpConfigIpv6DhcpServerAddress[];
    ipSubnets: outputs.FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnet[];
    poolLists: outputs.FloatingIpV2ExternalSubnetIpConfigIpv6PoolList[];
}

export interface FloatingIpV2ExternalSubnetIpConfigIpv6DefaultGatewayIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetIpConfigIpv6DhcpServerAddress {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnet {
    ips: outputs.FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetIp[];
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
}

export interface FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetIpConfigIpv6PoolList {
    endIps: outputs.FloatingIpV2ExternalSubnetIpConfigIpv6PoolListEndIp[];
    startIps: outputs.FloatingIpV2ExternalSubnetIpConfigIpv6PoolListStartIp[];
}

export interface FloatingIpV2ExternalSubnetIpConfigIpv6PoolListEndIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetIpConfigIpv6PoolListStartIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetIpUsage {
    ipPoolUsages: outputs.FloatingIpV2ExternalSubnetIpUsageIpPoolUsage[];
    numAssignedIps: number;
    numFreeIps: number;
    numMacs: number;
}

export interface FloatingIpV2ExternalSubnetIpUsageIpPoolUsage {
    numFreeIps: number;
    numTotalIps: number;
    ranges: outputs.FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRange[];
}

export interface FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRange {
    endIps: outputs.FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeEndIp[];
    startIps: outputs.FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeStartIp[];
}

export interface FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeEndIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeStartIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetLink {
    href: string;
    rel: string;
}

export interface FloatingIpV2ExternalSubnetReservedIpAddress {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetVirtualSwitch {
    bondMode: boolean;
    clusters: outputs.FloatingIpV2ExternalSubnetVirtualSwitchCluster[];
    /**
     * Description for the Floating IP.
     */
    description: string;
    extId: string;
    hasDeploymentError: boolean;
    isDefault: boolean;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.FloatingIpV2ExternalSubnetVirtualSwitchLink[];
    /**
     * Metadata associated with this resource.
     */
    metadatas: outputs.FloatingIpV2ExternalSubnetVirtualSwitchMetadata[];
    mtu: number;
    /**
     * Name of the floating IP.
     */
    name: string;
    /**
     * A globally unique identifier that represents the tenant that owns this entity.
     */
    tenantId: string;
}

export interface FloatingIpV2ExternalSubnetVirtualSwitchCluster {
    extId: string;
    gatewayIpAddresses: outputs.FloatingIpV2ExternalSubnetVirtualSwitchClusterGatewayIpAddress[];
    hosts: outputs.FloatingIpV2ExternalSubnetVirtualSwitchClusterHost[];
}

export interface FloatingIpV2ExternalSubnetVirtualSwitchClusterGatewayIpAddress {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetVirtualSwitchClusterHost {
    extId: string;
    hostNics: string[];
    internalBridgeName: string;
    ipAddresses: outputs.FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddress[];
    routeTable: number;
}

export interface FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddress {
    ips: outputs.FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressIp[];
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
}

export interface FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetVirtualSwitchLink {
    href: string;
    rel: string;
}

export interface FloatingIpV2ExternalSubnetVirtualSwitchMetadata {
    categoryIds: any[][];
    ownerReferenceId: string;
    ownerUserName: string;
    projectName: string;
    projectReferenceId: string;
}

export interface FloatingIpV2ExternalSubnetVpc {
    commonDhcpOptions: outputs.FloatingIpV2ExternalSubnetVpcCommonDhcpOption[];
    /**
     * Description for the Floating IP.
     */
    description: string;
    extId: string;
    externalRoutingDomainReference: string;
    externalSubnets: outputs.FloatingIpV2ExternalSubnetVpcExternalSubnet[];
    externallyRoutablePrefixes: outputs.FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefix[];
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.FloatingIpV2ExternalSubnetVpcLink[];
    /**
     * Metadata associated with this resource.
     */
    metadatas: outputs.FloatingIpV2ExternalSubnetVpcMetadata[];
    /**
     * Name of the floating IP.
     */
    name: string;
    snatIps: outputs.FloatingIpV2ExternalSubnetVpcSnatIp[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity.
     */
    tenantId: string;
    vpcType: string;
}

export interface FloatingIpV2ExternalSubnetVpcCommonDhcpOption {
    domainNameServers: outputs.FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServer[];
}

export interface FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServer {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv6[];
}

export interface FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetVpcExternalSubnet {
    activeGatewayCount: number;
    activeGatewayNodes: outputs.FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNode[];
    externalIps: outputs.FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIp[];
    gatewayNodes: string[];
    subnetReference: string;
}

export interface FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNode {
    nodeId: string;
    nodeIpAddresses: outputs.FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddress[];
}

export interface FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddress {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6[];
}

export interface FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIp {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv6[];
}

export interface FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefix {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6[];
}

export interface FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4 {
    ips: outputs.FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4Ip[];
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
}

export interface FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4Ip {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6 {
    ips: outputs.FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6Ip[];
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
}

export interface FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6Ip {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetVpcLink {
    href: string;
    rel: string;
}

export interface FloatingIpV2ExternalSubnetVpcMetadata {
    categoryIds: any[][];
    ownerReferenceId: string;
    ownerUserName: string;
    projectName: string;
    projectReferenceId: string;
}

export interface FloatingIpV2ExternalSubnetVpcSnatIp {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.FloatingIpV2ExternalSubnetVpcSnatIpIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.FloatingIpV2ExternalSubnetVpcSnatIpIpv6[];
}

export interface FloatingIpV2ExternalSubnetVpcSnatIpIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2ExternalSubnetVpcSnatIpIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2FloatingIp {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.FloatingIpV2FloatingIpIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.FloatingIpV2FloatingIpIpv6[];
}

export interface FloatingIpV2FloatingIpIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2FloatingIpIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2Link {
    href?: string;
    rel?: string;
}

export interface FloatingIpV2Metadata {
    categoryIds: any[][];
    ownerReferenceId: string;
    ownerUserName: string;
    projectName: string;
    projectReferenceId: string;
}

export interface FloatingIpV2VmNic {
    privateIp?: string;
}

export interface FloatingIpV2Vpc {
    commonDhcpOptions: outputs.FloatingIpV2VpcCommonDhcpOption[];
    /**
     * Description for the Floating IP.
     */
    description: string;
    extId: string;
    externalRoutingDomainReference: string;
    externalSubnets: outputs.FloatingIpV2VpcExternalSubnet[];
    externallyRoutablePrefixes: outputs.FloatingIpV2VpcExternallyRoutablePrefix[];
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.FloatingIpV2VpcLink[];
    /**
     * Metadata associated with this resource.
     */
    metadatas: outputs.FloatingIpV2VpcMetadata[];
    /**
     * Name of the floating IP.
     */
    name: string;
    snatIps: outputs.FloatingIpV2VpcSnatIp[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity.
     */
    tenantId: string;
    vpcType: string;
}

export interface FloatingIpV2VpcCommonDhcpOption {
    domainNameServers: outputs.FloatingIpV2VpcCommonDhcpOptionDomainNameServer[];
}

export interface FloatingIpV2VpcCommonDhcpOptionDomainNameServer {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv6[];
}

export interface FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2VpcExternalSubnet {
    activeGatewayCount: number;
    activeGatewayNodes: outputs.FloatingIpV2VpcExternalSubnetActiveGatewayNode[];
    externalIps: outputs.FloatingIpV2VpcExternalSubnetExternalIp[];
    gatewayNodes: string[];
    subnetReference: string;
}

export interface FloatingIpV2VpcExternalSubnetActiveGatewayNode {
    nodeId: string;
    nodeIpAddresses: outputs.FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddress[];
}

export interface FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddress {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6[];
}

export interface FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2VpcExternalSubnetExternalIp {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.FloatingIpV2VpcExternalSubnetExternalIpIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.FloatingIpV2VpcExternalSubnetExternalIpIpv6[];
}

export interface FloatingIpV2VpcExternalSubnetExternalIpIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2VpcExternalSubnetExternalIpIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2VpcExternallyRoutablePrefix {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.FloatingIpV2VpcExternallyRoutablePrefixIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.FloatingIpV2VpcExternallyRoutablePrefixIpv6[];
}

export interface FloatingIpV2VpcExternallyRoutablePrefixIpv4 {
    ips: outputs.FloatingIpV2VpcExternallyRoutablePrefixIpv4Ip[];
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
}

export interface FloatingIpV2VpcExternallyRoutablePrefixIpv4Ip {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2VpcExternallyRoutablePrefixIpv6 {
    ips: outputs.FloatingIpV2VpcExternallyRoutablePrefixIpv6Ip[];
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
}

export interface FloatingIpV2VpcExternallyRoutablePrefixIpv6Ip {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2VpcLink {
    href: string;
    rel: string;
}

export interface FloatingIpV2VpcMetadata {
    categoryIds: any[][];
    ownerReferenceId: string;
    ownerUserName: string;
    projectName: string;
    projectReferenceId: string;
}

export interface FloatingIpV2VpcSnatIp {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.FloatingIpV2VpcSnatIpIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.FloatingIpV2VpcSnatIpIpv6[];
}

export interface FloatingIpV2VpcSnatIpIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FloatingIpV2VpcSnatIpIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface FoundationCentralImageClusterClusterStatus {
    aggregatePercentComplete: number;
    clusterCreationStarted: boolean;
    clusterProgressDetails: outputs.FoundationCentralImageClusterClusterStatusClusterProgressDetail[];
    currentFoundationIp: string;
    foundationSessionId: string;
    imagingStopped: boolean;
    intentPickedUp: boolean;
    nodeProgressDetails: outputs.FoundationCentralImageClusterClusterStatusNodeProgressDetail[];
}

export interface FoundationCentralImageClusterClusterStatusClusterProgressDetail {
    /**
     * Name of the cluster.
     */
    clusterName: string;
    messageLists: string[];
    percentComplete: number;
    status: string;
}

export interface FoundationCentralImageClusterClusterStatusNodeProgressDetail {
    /**
     * UUID of the node.
     */
    imagedNodeUuid: string;
    imagingStopped: boolean;
    intentPickedUp: boolean;
    messageLists: string[];
    percentComplete: number;
    status: string;
}

export interface FoundationCentralImageClusterCommonNetworkSettings {
    /**
     * List of dns servers for the cvms in the cluster.
     */
    cvmDnsServers: string[];
    /**
     * List of ntp servers for the cvms in the cluster.
     */
    cvmNtpServers: string[];
    /**
     * List of dns servers for the hypervisors in the cluster.
     */
    hypervisorDnsServers: string[];
    /**
     * List of ntp servers for the hypervisors in the cluster.
     */
    hypervisorNtpServers: string[];
}

export interface FoundationCentralImageClusterFoundationInitConfig {
    blocks: outputs.FoundationCentralImageClusterFoundationInitConfigBlock[];
    clusters: outputs.FoundationCentralImageClusterFoundationInitConfigCluster[];
    /**
     * Gateway of the cvm.
     */
    cvmGateway: string;
    /**
     * Netmask of the cvm.
     */
    cvmNetmask: string;
    dnsServers: string;
    /**
     * Product key for hyperv isos. Required only if the hypervisor type is hyperv and product key is mandatory (ex: for volume license).
     */
    hypervProductKey: string;
    /**
     * SKU of hyperv to be installed if hypervisorType is hyperv.
     */
    hypervSku: string;
    /**
     * Gateway of the hypervisor.
     */
    hypervisorGateway: string;
    hypervisorIsoUrl: {[key: string]: string};
    /**
     * Details of the hypervisor iso. Required for deploying node with AOS >= 6.8
     */
    hypervisorIsos: outputs.FoundationCentralImageClusterFoundationInitConfigHypervisorIso[];
    /**
     * Netmask of the hypervisor.
     */
    hypervisorNetmask: string;
    /**
     * Gateway of the ipmi.
     */
    ipmiGateway: string;
    /**
     * Netmask of the ipmi.
     */
    ipmiNetmask: string;
    nosPackageUrls: outputs.FoundationCentralImageClusterFoundationInitConfigNosPackageUrl[];
}

export interface FoundationCentralImageClusterFoundationInitConfigBlock {
    blockId: string;
    nodes: outputs.FoundationCentralImageClusterFoundationInitConfigBlockNode[];
}

export interface FoundationCentralImageClusterFoundationInitConfigBlockNode {
    /**
     * IP address to be set for the cvm on the node.
     */
    cvmIp: string;
    /**
     * Vlan tag of the cvm, if the cvm is on a vlan.
     */
    cvmVlanId: number;
    fcImagedNodeUuid: string;
    /**
     * Hardware attributes override json for the node.
     */
    hardwareAttributesOverride: {[key: string]: string};
    hypervisor: string;
    /**
     * Name to be set for the hypervisor host.
     */
    hypervisorHostname: string;
    /**
     * IP address to be set for the hypervisor on the node.
     */
    hypervisorIp: string;
    /**
     * True, if the node should be imaged, False, otherwise.
     */
    imageNow: boolean;
    /**
     * IP address to be set for the ipmi of the node.
     */
    ipmiIp: string;
    ipv6Address: string;
    nodePosition: string;
    nodeSerial: string;
}

export interface FoundationCentralImageClusterFoundationInitConfigCluster {
    /**
     * External management ip of the cluster.
     */
    clusterExternalIp: string;
    clusterInitNow: boolean;
    clusterInitSuccessful: boolean;
    clusterMembers: string[];
    /**
     * Name of the cluster.
     */
    clusterName: string;
    /**
     * List of dns servers for the cvms in the cluster.
     */
    cvmDnsServers: string;
    /**
     * List of ntp servers for the cvms in the cluster.
     */
    cvmNtpServers: string;
    /**
     * Redundancy factor of the cluster.
     */
    redundancyFactor: number;
    /**
     * Timezone to be set on the cluster.
     */
    timezone: string;
}

export interface FoundationCentralImageClusterFoundationInitConfigHypervisorIso {
    hypervisorType: string;
    /**
     * sha256sum of the hypervisor iso.
     */
    sha256sum: string;
    /**
     * URL to download hypervisor iso. Required only if imaging is needed.
     */
    url: string;
}

export interface FoundationCentralImageClusterFoundationInitConfigNosPackageUrl {
    /**
     * sha256sum of the hypervisor iso.
     */
    sha256sum: string;
    /**
     * URL to download hypervisor iso. Required only if imaging is needed.
     */
    url: string;
}

export interface FoundationCentralImageClusterHypervisorIsoDetails {
    /**
     * Product key for hyperv isos. Required only if the hypervisor type is hyperv and product key is mandatory (ex: for volume license).
     */
    hypervProductKey: string;
    /**
     * SKU of hyperv to be installed if hypervisorType is hyperv.
     */
    hypervSku: string;
    /**
     * sha256sum of the hypervisor iso.
     */
    sha256sum: string;
    /**
     * URL to download hypervisor iso. Required only if imaging is needed.
     */
    url?: string;
}

export interface FoundationCentralImageClusterHypervisorIsos {
    /**
     * Product key for hyperv isos. Required only if the hypervisor type is hyperv and product key is mandatory (ex: for volume license).
     */
    hypervProductKey?: string;
    /**
     * SKU of hyperv to be installed if hypervisorType is hyperv.
     */
    hypervSku?: string;
    hypervisorType?: string;
    /**
     * sha256sum of the hypervisor iso.
     */
    sha256sum?: string;
    /**
     * URL to download hypervisor iso. Required only if imaging is needed.
     */
    url?: string;
}

export interface FoundationCentralImageClusterNodeList {
    /**
     * Gateway of the cvm.
     */
    cvmGateway: string;
    /**
     * IP address to be set for the cvm on the node.
     */
    cvmIp: string;
    /**
     * Netmask of the cvm.
     */
    cvmNetmask?: string;
    /**
     * Amount of memory to be assigned for the cvm.
     */
    cvmRamGb?: number;
    /**
     * Vlan tag of the cvm, if the cvm is on a vlan.
     */
    cvmVlanId: number;
    /**
     * Hardware attributes override json for the node.
     */
    hardwareAttributesOverride: {[key: string]: string};
    /**
     * Gateway of the hypervisor.
     */
    hypervisorGateway: string;
    /**
     * Name to be set for the hypervisor host.
     */
    hypervisorHostname: string;
    /**
     * IP address to be set for the hypervisor on the node.
     */
    hypervisorIp: string;
    /**
     * Netmask of the hypervisor.
     */
    hypervisorNetmask: string;
    hypervisorType?: string;
    /**
     * True, if the node should be imaged, False, otherwise.
     */
    imageNow: boolean;
    /**
     * UUID of the node.
     */
    imagedNodeUuid: string;
    /**
     * Gateway of the ipmi.
     */
    ipmiGateway: string;
    /**
     * IP address to be set for the ipmi of the node.
     */
    ipmiIp: string;
    /**
     * Netmask of the ipmi.
     */
    ipmiNetmask?: string;
    /**
     * Passthrough RDMA nic to CVM if possible, default to false.
     */
    rdmaPassthrough?: boolean;
    /**
     * Decides whether to use the existing network settings for the node. If True, the existing network settings of the node will be used during cluster creation. If False, then client must provide new network settings. If all nodes are booted in phoenix, this field is, by default, considered to be False.
     */
    useExistingNetworkSettings?: boolean;
}

export interface FoundationImageNodesBlock {
    /**
     * - Block ID.
     */
    blockId?: string;
    nodes: outputs.FoundationImageNodesBlockNode[];
}

export interface FoundationImageNodesBlockNode {
    /**
     * - (Required if node is lacp configured) slow or fast if lacp if being used at the switch
     */
    bondLacpRate?: string;
    /**
     * - (Required if node is capable) dynamic if using LACP, static for LAG
     */
    bondMode?: string;
    /**
     * - MAC Addresses of NICs in a team/bond
     */
    bondUplinks?: string;
    /**
     * - ID of cluster.
     */
    clusterId?: string;
    /**
     * - Current CVM vlan tag. 0 Value with remove vlan tag.
     */
    currentCvmVlanTag?: number;
    /**
     * - CVM current network interface.
     */
    currentNetworkInterface?: string;
    /**
     * - RAM capacity of CVM in GB.
     */
    cvmGbRam?: number;
    cvmIp?: string;
    /**
     * - Number of CVM vcpus.
     */
    cvmNumVcpus?: number;
    /**
     * - use "vmInstaller" to enable CVM imaging from standalone.
     */
    deviceHint?: string;
    /**
     * - serial of boot device to be excluded (used by NX G6 platforms)
     */
    exludeBootSerial?: string;
    hypervisor?: string;
    /**
     * - (Required) Hypervisor Hostname.
     */
    hypervisorHostname: string;
    /**
     * - (Required) Hypervisor IP address.
     */
    hypervisorIp: string;
    /**
     * - Imaging delay.
     */
    imageDelay?: number;
    /**
     * - (Optional, Default = true) If the node should be imaged now.
     */
    imageNow?: boolean;
    imageSuccessful?: boolean;
    /**
     * - Whether IPMI should be configured.
     */
    ipmiConfigureNow?: boolean;
    /**
     * - (Required incase using IPMI based imaging either here or outside blocks) IPMI gateway for this node
     */
    ipmiGateway?: string;
    /**
     * - (Required) IPMI IP address.
     */
    ipmiIp?: string;
    /**
     * - IPMI MAC address.
     */
    ipmiMac?: string;
    /**
     * - (Required incase using IPMI based imaging either here or outside blocks) IPMI netmask for this node
     */
    ipmiNetmask?: string;
    /**
     * - (Required incase using IPMI based imaging either here or outside blocks) IPMI username
     */
    ipmiPassword?: string;
    /**
     * - (Required incase using IPMI based imaging either here or outside blocks) IPMI password
     */
    ipmiUser?: string;
    /**
     * - (Required when deviceHint = "vmInstaller" for imaging using node's existing cvm for imaging) IPV6 address.
     */
    ipv6Address?: string;
    /**
     * - (Required when deviceHint = "vmInstaller" for imaging using node's existing cvm for imaging) ipv6 interface.
     */
    ipv6Interface?: string;
    /**
     * - relocate bootbank files to make space for phoenix files.
     */
    mitigateLowBootSpace?: boolean;
    /**
     * - (Required) Position of the node in the block.
     */
    nodePosition: string;
    /**
     * - serial number of the node.
     */
    nodeSerial?: string;
    /**
     * - mac address of nic to be used for rdma
     */
    rdmaMacAddr?: string;
    /**
     * - (Required if node is capable) passthru RDMA nic to CVM if possible, default to false
     */
    rdmaPassthrough?: boolean;
    /**
     * - UCSM Managed mode.
     */
    ucsmManagedMode?: string;
    /**
     * - UCSM node serial.
     */
    ucsmNodeSerial?: string;
    /**
     * - Object of UCSM parameters.
     * * `ucsm_params.native_vlan` :- If the vlan is native.
     * * `ucsm_params.keep_ucsm_settings` :- Whether UCSM settings should be kept.
     * * `ucsm_params.mac_pool` :- Mac address pool.
     * * `ucsm_params.vlan_name` :- Name of vlan.
     */
    ucsmParams?: outputs.FoundationImageNodesBlockNodeUcsmParams;
    vswitches?: outputs.FoundationImageNodesBlockNodeVswitch[];
}

export interface FoundationImageNodesBlockNodeUcsmParams {
    keepUcsmSettings?: boolean;
    macPool?: string;
    nativeVlan?: boolean;
    vlanName?: string;
}

export interface FoundationImageNodesBlockNodeVswitch {
    /**
     * - (Required if node is capable) dynamic if using LACP, static for LAG
     */
    bondMode?: string;
    lacp?: string;
    mtu?: number;
    name?: string;
    otherConfigs?: string[];
    uplinks?: string[];
}

export interface FoundationImageNodesCluster {
    /**
     * - Backplane netmask.
     */
    backplaneNetmask?: string;
    /**
     * - Backplane subnet address.
     */
    backplaneSubnet?: string;
    /**
     * - Backplane vlan.
     */
    backplaneVlan?: string;
    /**
     * - External IP of the cluster.
     */
    clusterExternalIp?: string;
    /**
     * - (Optional, Default = true) If cluster should be created.
     */
    clusterInitNow?: boolean;
    /**
     * - If cluster initialization was successful.
     */
    clusterInitSuccessful?: boolean;
    /**
     * - (Required) Members in the cluster.
     */
    clusterMembers: string[];
    /**
     * - (Required) Name of the cluster.
     */
    clusterName: string;
    /**
     * - DNS servers of CVM.
     */
    cvmDnsServers?: string;
    /**
     * - NTP servers of CVM.
     */
    cvmNtpServers?: string;
    /**
     * - If network segmentation should be enabled.
     */
    enableNs?: boolean;
    /**
     * - NTP servers of hypervisor.
     */
    hypervisorNtpServers?: string;
    /**
     * - (Required) Cluster Redundancy Factor.
     */
    redundancyFactor: number;
    /**
     * - If it is a single node cluster.
     */
    singleNodeCluster?: boolean;
    /**
     * - Set timezone for every CVM
     */
    timezone?: string;
}

export interface FoundationImageNodesClusterUrl {
    /**
     * - (Required) Name of the cluster.
     */
    clusterName: string;
    clusterUrl: string;
}

export interface FoundationImageNodesEosMetadata {
    /**
     * - arrya of account names
     */
    accountNames?: string[];
    /**
     * - Id of the Eos config uploaded in foundation GUI.
     */
    configId?: string;
    /**
     * - Email address of the user who downloaded Eos config.
     */
    email?: string;
}

export interface FoundationImageNodesFcSettings {
    /**
     * - Foundation Central metadata which will be transferred to the newly imaged node.
     * * `fc_metadata.fc_ip` :- IP address of foundation central.
     * * `fc_metadata.api_key` :- apiKey which the node uses to register itself with foundation central.
     */
    fcMetadata: outputs.FoundationImageNodesFcSettingsFcMetadata;
    /**
     * - If this attribute is set to True, FC workflow will be invoked.
     */
    foundationCentral: boolean;
}

export interface FoundationImageNodesFcSettingsFcMetadata {
    apiKey: string;
    fcIp: string;
}

export interface FoundationImageNodesHypervisorIso {
    /**
     * - Details of hypervisor ISO of type esx.
     */
    esx?: outputs.FoundationImageNodesHypervisorIsoEsx;
    /**
     * - Details of hypervisor ISO of type hyperv.
     */
    hyperv?: outputs.FoundationImageNodesHypervisorIsoHyperv;
    /**
     * - Details of hypervisor ISO of type kvm.
     */
    kvm?: outputs.FoundationImageNodesHypervisorIsoKvm;
    /**
     * - Details of hypervisor ISO of type xen.
     */
    xen?: outputs.FoundationImageNodesHypervisorIsoXen;
}

export interface FoundationImageNodesHypervisorIsoEsx {
    /**
     * - (Required) Filename of hypervisor ISO.
     */
    checksum: string;
    /**
     * - (Required) Checksum for ISO file.
     */
    filename: string;
}

export interface FoundationImageNodesHypervisorIsoHyperv {
    /**
     * - (Required) Filename of hypervisor ISO.
     */
    checksum: string;
    /**
     * - (Required) Checksum for ISO file.
     */
    filename: string;
}

export interface FoundationImageNodesHypervisorIsoKvm {
    /**
     * - (Required) Filename of hypervisor ISO.
     */
    checksum: string;
    /**
     * - (Required) Checksum for ISO file.
     */
    filename: string;
}

export interface FoundationImageNodesHypervisorIsoXen {
    /**
     * - (Required) Filename of hypervisor ISO.
     */
    checksum: string;
    /**
     * - (Required) Checksum for ISO file.
     */
    filename: string;
}

export interface FoundationImageNodesTests {
    /**
     * - Whether NCC checks should run.
     */
    runNcc?: boolean;
    /**
     * - Whether system checks should run.
     */
    runSyscheck?: boolean;
}

export interface FoundationIpmiConfigBlock {
    /**
     * - (Optional) Block Id
     */
    blockId?: string;
    /**
     * - (Required) array of nodes for ipmi config.
     */
    nodes: outputs.FoundationIpmiConfigBlockNode[];
}

export interface FoundationIpmiConfigBlockNode {
    /**
     * - (Required) Whether IPMI should be configured. Should be kept true to configure
     */
    ipmiConfigureNow: boolean;
    /**
     * - Whether IPMI was successfully configured.
     */
    ipmiConfigureSuccessful: boolean;
    /**
     * - IPMI IP address.
     */
    ipmiIp: string;
    /**
     * - (Required) IPMI mac address.
     */
    ipmiMac: string;
    /**
     * - IPMI configuration status message if any.
     */
    ipmiMessage: string;
}

export interface GetAccessControlPoliciesEntity {
    accessControlPolicyId: string;
    /**
     * The version of the API.
     */
    apiVersion: string;
    /**
     * - The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.GetAccessControlPoliciesEntityCategory[];
    contextFilterLists: outputs.GetAccessControlPoliciesEntityContextFilterList[];
    /**
     * - The description of the Access Control Policy.
     */
    description: string;
    /**
     * - The Access Control Policy kind metadata.
     */
    metadata: {[key: string]: string};
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - The reference to a user.
     */
    ownerReference: {[key: string]: string};
    /**
     * - The reference to a project.
     */
    projectReference: {[key: string]: string};
    /**
     * - The reference to a role.
     */
    roleReferences: outputs.GetAccessControlPoliciesEntityRoleReference[];
    /**
     * - The state of the Access Control Policy.
     */
    state: string;
    /**
     * - The User group(s) being assigned a given role.
     */
    userGroupReferenceLists: outputs.GetAccessControlPoliciesEntityUserGroupReferenceList[];
    /**
     * - The User(s) being assigned a given role.
     */
    userReferenceLists: outputs.GetAccessControlPoliciesEntityUserReferenceList[];
}

export interface GetAccessControlPoliciesEntityCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetAccessControlPoliciesEntityContextFilterList {
    /**
     * A list of Entity filter expressions.
     */
    entityFilterExpressionLists: outputs.GetAccessControlPoliciesEntityContextFilterListEntityFilterExpressionList[];
    /**
     * - The device ID which is used to uniquely identify this particular disk.
     */
    scopeFilterExpressionLists: outputs.GetAccessControlPoliciesEntityContextFilterListScopeFilterExpressionList[];
}

export interface GetAccessControlPoliciesEntityContextFilterListEntityFilterExpressionList {
    /**
     * -  The LHS of the filter expression - the entity type.
     */
    leftHandSideEntityType: string;
    /**
     * - The operator in the filter expression.
     */
    operator: string;
    /**
     * - The right hand side (RHS) of an scope expression.
     */
    rightHandSides: outputs.GetAccessControlPoliciesEntityContextFilterListEntityFilterExpressionListRightHandSide[];
}

export interface GetAccessControlPoliciesEntityContextFilterListEntityFilterExpressionListRightHandSide {
    /**
     * - The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.GetAccessControlPoliciesEntityContextFilterListEntityFilterExpressionListRightHandSideCategory[];
    /**
     * -  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
     */
    collection: string;
    /**
     * - The explicit list of UUIDs for the given kind.
     */
    uuidLists: string[];
}

export interface GetAccessControlPoliciesEntityContextFilterListEntityFilterExpressionListRightHandSideCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    values: string[];
}

export interface GetAccessControlPoliciesEntityContextFilterListScopeFilterExpressionList {
    /**
     * -  The LHS of the filter expression - the scope type.
     */
    leftHandSide: string;
    /**
     * - The operator in the filter expression.
     */
    operator: string;
    /**
     * - The right hand side (RHS) of an scope expression.
     */
    rightHandSides: outputs.GetAccessControlPoliciesEntityContextFilterListScopeFilterExpressionListRightHandSide[];
}

export interface GetAccessControlPoliciesEntityContextFilterListScopeFilterExpressionListRightHandSide {
    /**
     * - The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.GetAccessControlPoliciesEntityContextFilterListScopeFilterExpressionListRightHandSideCategory[];
    /**
     * -  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
     */
    collection: string;
    /**
     * - The explicit list of UUIDs for the given kind.
     */
    uuidLists: string[];
}

export interface GetAccessControlPoliciesEntityContextFilterListScopeFilterExpressionListRightHandSideCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    values: string[];
}

export interface GetAccessControlPoliciesEntityRoleReference {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetAccessControlPoliciesEntityUserGroupReferenceList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetAccessControlPoliciesEntityUserReferenceList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetAccessControlPoliciesMetadata {
    filter: string;
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetAccessControlPolicyCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetAccessControlPolicyContextFilterList {
    /**
     * A list of Entity filter expressions.
     */
    entityFilterExpressionLists: outputs.GetAccessControlPolicyContextFilterListEntityFilterExpressionList[];
    /**
     * - The device ID which is used to uniquely identify this particular disk.
     */
    scopeFilterExpressionLists: outputs.GetAccessControlPolicyContextFilterListScopeFilterExpressionList[];
}

export interface GetAccessControlPolicyContextFilterListEntityFilterExpressionList {
    /**
     * -  The LHS of the filter expression - the entity type.
     */
    leftHandSideEntityType: string;
    /**
     * - The operator in the filter expression.
     */
    operator: string;
    /**
     * - The right hand side (RHS) of an scope expression.
     */
    rightHandSides: outputs.GetAccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSide[];
}

export interface GetAccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSide {
    /**
     * - The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.GetAccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategory[];
    /**
     * -  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
     */
    collection: string;
    /**
     * - The explicit list of UUIDs for the given kind.
     */
    uuidLists: string[];
}

export interface GetAccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    values: string[];
}

export interface GetAccessControlPolicyContextFilterListScopeFilterExpressionList {
    /**
     * -  The LHS of the filter expression - the scope type.
     */
    leftHandSide: string;
    /**
     * - The operator in the filter expression.
     */
    operator: string;
    /**
     * - The right hand side (RHS) of an scope expression.
     */
    rightHandSides: outputs.GetAccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSide[];
}

export interface GetAccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSide {
    /**
     * - The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.GetAccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategory[];
    /**
     * -  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
     */
    collection: string;
    /**
     * - The explicit list of UUIDs for the given kind.
     */
    uuidLists: string[];
}

export interface GetAccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    values: string[];
}

export interface GetAccessControlPolicyRoleReference {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetAccessControlPolicyUserGroupReferenceList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetAccessControlPolicyUserReferenceList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetAddressGroupIpAddressBlockList {
    /**
     * - (ReadOnly) IP of the address block
     */
    ip: string;
    /**
     * - (ReadOnly) Prefix length of address block in int
     */
    prefixLength: number;
}

export interface GetAddressGroupV2IpRange {
    /**
     * end ip
     */
    endIp: string;
    /**
     * start ip
     */
    startIp: string;
}

export interface GetAddressGroupV2Ipv4Address {
    /**
     * The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength: number;
    /**
     * ip of address
     */
    value: string;
}

export interface GetAddressGroupV2Link {
    href: string;
    rel: string;
}

export interface GetAddressGroupsEntity {
    /**
     * Information about address_group
     */
    addressGroups: outputs.GetAddressGroupsEntityAddressGroup[];
    /**
     * List of associated policies to address group
     */
    associatedPoliciesLists: outputs.GetAddressGroupsEntityAssociatedPoliciesList[];
    /**
     * - (ReadOnly) UUID of associated policy
     */
    uuid: string;
}

export interface GetAddressGroupsEntityAddressGroup {
    /**
     * - (ReadOnly) Address Group string
     */
    addressGroupString: string;
    /**
     * - (ReadOnly) Description of the address group
     */
    description: string;
    /**
     * - (ReadOnly) list of IP address blocks with their prefix length
     */
    ipAddressBlockLists: outputs.GetAddressGroupsEntityAddressGroupIpAddressBlockList[];
    /**
     * - (ReadOnly) Name of associated policy
     */
    name: string;
}

export interface GetAddressGroupsEntityAddressGroupIpAddressBlockList {
    /**
     * - (ReadOnly) IP of the address block
     */
    ip: string;
    /**
     * - (ReadOnly) Prefix length of address block in int
     */
    prefixLength: number;
}

export interface GetAddressGroupsEntityAssociatedPoliciesList {
    kind: string;
    /**
     * - (ReadOnly) Name of associated policy
     */
    name: string;
    /**
     * - (ReadOnly) UUID of associated policy
     */
    uuid: string;
}

export interface GetAddressGroupsMetadata {
    /**
     * (Optional) Filter in FIQL Syntax
     */
    filter: string;
    kind: string;
    /**
     * (Optional) Integer
     */
    length: number;
    /**
     * (Optional) Integer
     */
    offset: number;
    /**
     * (Optional) attribute to sort
     */
    sortAttribute: string;
    /**
     * (Optional) order of sorting
     */
    sortOrder: string;
}

export interface GetAddressGroupsV2AddressGroup {
    /**
     * created by.
     */
    createdBy: string;
    /**
     * A user defined annotation for an Address Group.
     */
    description: string;
    /**
     * Address group UUID.
     */
    extId: string;
    /**
     * List of IP range containing start and end IP
     */
    ipRanges: outputs.GetAddressGroupsV2AddressGroupIpRange[];
    /**
     * List of CIDR blocks in the Address Group.
     */
    ipv4Addresses: outputs.GetAddressGroupsV2AddressGroupIpv4Address[];
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetAddressGroupsV2AddressGroupLink[];
    /**
     * A short identifier for an Address Group.
     */
    name: string;
    /**
     * Reference to policy associated with Address Group.
     */
    policyReferences: string[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity.
     */
    tenantId: string;
}

export interface GetAddressGroupsV2AddressGroupIpRange {
    /**
     * end ip
     */
    endIp: string;
    /**
     * start ip
     */
    startIp: string;
}

export interface GetAddressGroupsV2AddressGroupIpv4Address {
    /**
     * The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength: number;
    /**
     * ip of address
     */
    value: string;
}

export interface GetAddressGroupsV2AddressGroupLink {
    href: string;
    rel: string;
}

export interface GetAssertHelperCheck {
    condition: boolean;
    errorMessage: string;
}

export interface GetAuthorizationPoliciesV2AuthPolicy {
    authorizationPolicyType: string;
    clientName: string;
    createdBy: string;
    createdTime: string;
    description: string;
    displayName: string;
    entities: outputs.GetAuthorizationPoliciesV2AuthPolicyEntity[];
    extId: string;
    identities: outputs.GetAuthorizationPoliciesV2AuthPolicyIdentity[];
    isSystemDefined: boolean;
    lastUpdatedTime: string;
    role: string;
}

export interface GetAuthorizationPoliciesV2AuthPolicyEntity {
    reserved: string;
}

export interface GetAuthorizationPoliciesV2AuthPolicyIdentity {
    reserved: string;
}

export interface GetAuthorizationPolicyV2Entity {
    reserved: string;
}

export interface GetAuthorizationPolicyV2Identity {
    reserved: string;
}

export interface GetBlueprintRuntimeEditablesRuntimeEditable {
    /**
     * -  A list of actions associated with the blueprint. Each action contains runtime specifications (defined in RuntimeSpecDS).
     */
    actionLists: outputs.GetBlueprintRuntimeEditablesRuntimeEditableActionList[];
    /**
     * -  A list of application profiles associated with the blueprint. Each application profile contains runtime specifications (defined in RuntimeSpecDS).
     */
    appProfiles: outputs.GetBlueprintRuntimeEditablesRuntimeEditableAppProfile[];
    /**
     * -  A list of credentials associated with the blueprint. Each credential contains runtime specifications (defined in RuntimeSpecDS).
     */
    credentialLists: outputs.GetBlueprintRuntimeEditablesRuntimeEditableCredentialList[];
    /**
     * -  A list of deployments associated with the blueprint. Each deployment contains runtime specifications (defined in RuntimeSpecDS).
     */
    deploymentLists: outputs.GetBlueprintRuntimeEditablesRuntimeEditableDeploymentList[];
    /**
     * -  A list of packages associated with the blueprint. Each package contains runtime specifications (defined in RuntimeSpecDS).
     */
    packageLists: outputs.GetBlueprintRuntimeEditablesRuntimeEditablePackageList[];
    /**
     * -  A list of restore configurations associated with the blueprint. Each restore configuration contains runtime specifications (defined in RuntimeSpecDS).
     */
    restoreConfigLists: outputs.GetBlueprintRuntimeEditablesRuntimeEditableRestoreConfigList[];
    /**
     * - A list of services associated with the blueprint. Each service contains runtime specifications (defined in RuntimeSpecDS).
     */
    serviceLists: outputs.GetBlueprintRuntimeEditablesRuntimeEditableServiceList[];
    /**
     * - A list of snapshot configurations associated with the blueprint. Each snapshot configuration contains runtime specifications (defined in RuntimeSpecDS).
     */
    snapshotConfigLists: outputs.GetBlueprintRuntimeEditablesRuntimeEditableSnapshotConfigList[];
    /**
     * - A list of substrates associated with the blueprint. Each substrate contains runtime specifications (defined in RuntimeSpecDS).
     */
    substrateLists: outputs.GetBlueprintRuntimeEditablesRuntimeEditableSubstrateList[];
    /**
     * - A list of tasks associated with the blueprint. Each task contains runtime specifications (defined in RuntimeSpecDS).
     */
    taskLists: outputs.GetBlueprintRuntimeEditablesRuntimeEditableTaskList[];
    /**
     * - A list of variables associated with the blueprint. Each variable contains runtime specifications (defined in RuntimeSpecDS).
     */
    variableLists: outputs.GetBlueprintRuntimeEditablesRuntimeEditableVariableList[];
}

export interface GetBlueprintRuntimeEditablesRuntimeEditableActionList {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * (Optional, Computed) A textual description of the runtime specification. This field provides additional information or context about the entity.
     */
    description: string;
    /**
     * (Optional, Computed) The name of the runtime specification. This could be the name of an action, service, credential, or other runtime-editable resource.
     */
    name: string;
    /**
     * (Optional, Computed) The type of runtime specification. This field indicates the category or classification of the runtime resource, such as an action, service, or credential.
     */
    type: string;
    /**
     * (Optional, Computed) The unique identifier (UUID) associated with the runtime specification. This is useful for identifying specific resources or entities.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface GetBlueprintRuntimeEditablesRuntimeEditableAppProfile {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * (Optional, Computed) A textual description of the runtime specification. This field provides additional information or context about the entity.
     */
    description: string;
    /**
     * (Optional, Computed) The name of the runtime specification. This could be the name of an action, service, credential, or other runtime-editable resource.
     */
    name: string;
    /**
     * (Optional, Computed) The type of runtime specification. This field indicates the category or classification of the runtime resource, such as an action, service, or credential.
     */
    type: string;
    /**
     * (Optional, Computed) The unique identifier (UUID) associated with the runtime specification. This is useful for identifying specific resources or entities.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface GetBlueprintRuntimeEditablesRuntimeEditableCredentialList {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * (Optional, Computed) A textual description of the runtime specification. This field provides additional information or context about the entity.
     */
    description: string;
    /**
     * (Optional, Computed) The name of the runtime specification. This could be the name of an action, service, credential, or other runtime-editable resource.
     */
    name: string;
    /**
     * (Optional, Computed) The type of runtime specification. This field indicates the category or classification of the runtime resource, such as an action, service, or credential.
     */
    type: string;
    /**
     * (Optional, Computed) The unique identifier (UUID) associated with the runtime specification. This is useful for identifying specific resources or entities.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface GetBlueprintRuntimeEditablesRuntimeEditableDeploymentList {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * (Optional, Computed) A textual description of the runtime specification. This field provides additional information or context about the entity.
     */
    description: string;
    /**
     * (Optional, Computed) The name of the runtime specification. This could be the name of an action, service, credential, or other runtime-editable resource.
     */
    name: string;
    /**
     * (Optional, Computed) The type of runtime specification. This field indicates the category or classification of the runtime resource, such as an action, service, or credential.
     */
    type: string;
    /**
     * (Optional, Computed) The unique identifier (UUID) associated with the runtime specification. This is useful for identifying specific resources or entities.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface GetBlueprintRuntimeEditablesRuntimeEditablePackageList {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * (Optional, Computed) A textual description of the runtime specification. This field provides additional information or context about the entity.
     */
    description: string;
    /**
     * (Optional, Computed) The name of the runtime specification. This could be the name of an action, service, credential, or other runtime-editable resource.
     */
    name: string;
    /**
     * (Optional, Computed) The type of runtime specification. This field indicates the category or classification of the runtime resource, such as an action, service, or credential.
     */
    type: string;
    /**
     * (Optional, Computed) The unique identifier (UUID) associated with the runtime specification. This is useful for identifying specific resources or entities.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface GetBlueprintRuntimeEditablesRuntimeEditableRestoreConfigList {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * (Optional, Computed) A textual description of the runtime specification. This field provides additional information or context about the entity.
     */
    description: string;
    /**
     * (Optional, Computed) The name of the runtime specification. This could be the name of an action, service, credential, or other runtime-editable resource.
     */
    name: string;
    /**
     * (Optional, Computed) The type of runtime specification. This field indicates the category or classification of the runtime resource, such as an action, service, or credential.
     */
    type: string;
    /**
     * (Optional, Computed) The unique identifier (UUID) associated with the runtime specification. This is useful for identifying specific resources or entities.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface GetBlueprintRuntimeEditablesRuntimeEditableServiceList {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * (Optional, Computed) A textual description of the runtime specification. This field provides additional information or context about the entity.
     */
    description: string;
    /**
     * (Optional, Computed) The name of the runtime specification. This could be the name of an action, service, credential, or other runtime-editable resource.
     */
    name: string;
    /**
     * (Optional, Computed) The type of runtime specification. This field indicates the category or classification of the runtime resource, such as an action, service, or credential.
     */
    type: string;
    /**
     * (Optional, Computed) The unique identifier (UUID) associated with the runtime specification. This is useful for identifying specific resources or entities.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface GetBlueprintRuntimeEditablesRuntimeEditableSnapshotConfigList {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * (Optional, Computed) A textual description of the runtime specification. This field provides additional information or context about the entity.
     */
    description: string;
    /**
     * (Optional, Computed) The name of the runtime specification. This could be the name of an action, service, credential, or other runtime-editable resource.
     */
    name: string;
    /**
     * (Optional, Computed) The type of runtime specification. This field indicates the category or classification of the runtime resource, such as an action, service, or credential.
     */
    type: string;
    /**
     * (Optional, Computed) The unique identifier (UUID) associated with the runtime specification. This is useful for identifying specific resources or entities.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface GetBlueprintRuntimeEditablesRuntimeEditableSubstrateList {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * (Optional, Computed) A textual description of the runtime specification. This field provides additional information or context about the entity.
     */
    description: string;
    /**
     * (Optional, Computed) The name of the runtime specification. This could be the name of an action, service, credential, or other runtime-editable resource.
     */
    name: string;
    /**
     * (Optional, Computed) The type of runtime specification. This field indicates the category or classification of the runtime resource, such as an action, service, or credential.
     */
    type: string;
    /**
     * (Optional, Computed) The unique identifier (UUID) associated with the runtime specification. This is useful for identifying specific resources or entities.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface GetBlueprintRuntimeEditablesRuntimeEditableTaskList {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * (Optional, Computed) A textual description of the runtime specification. This field provides additional information or context about the entity.
     */
    description: string;
    /**
     * (Optional, Computed) The name of the runtime specification. This could be the name of an action, service, credential, or other runtime-editable resource.
     */
    name: string;
    /**
     * (Optional, Computed) The type of runtime specification. This field indicates the category or classification of the runtime resource, such as an action, service, or credential.
     */
    type: string;
    /**
     * (Optional, Computed) The unique identifier (UUID) associated with the runtime specification. This is useful for identifying specific resources or entities.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface GetBlueprintRuntimeEditablesRuntimeEditableVariableList {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * (Optional, Computed) A textual description of the runtime specification. This field provides additional information or context about the entity.
     */
    description: string;
    /**
     * (Optional, Computed) The name of the runtime specification. This could be the name of an action, service, credential, or other runtime-editable resource.
     */
    name: string;
    /**
     * (Optional, Computed) The type of runtime specification. This field indicates the category or classification of the runtime resource, such as an action, service, or credential.
     */
    type: string;
    /**
     * (Optional, Computed) The unique identifier (UUID) associated with the runtime specification. This is useful for identifying specific resources or entities.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface GetCategoriesV2Category {
    associations: outputs.GetCategoriesV2CategoryAssociation[];
    description: string;
    detailedAssociations: outputs.GetCategoriesV2CategoryDetailedAssociation[];
    extId: string;
    key: string;
    links: outputs.GetCategoriesV2CategoryLink[];
    ownerUuid: string;
    tenantId: string;
    type: string;
    value: string;
}

export interface GetCategoriesV2CategoryAssociation {
    categoryId: string;
    count: number;
    resourceGroup: string;
    resourceType: string;
}

export interface GetCategoriesV2CategoryDetailedAssociation {
    categoryId: string;
    resourceGroup: string;
    resourceId: string;
    resourceType: string;
}

export interface GetCategoriesV2CategoryLink {
    href: string;
    rel: string;
}

export interface GetCategoryV2Association {
    /**
     * External identifier for the given category, used across all v4 apis/entities/resources where categories are referenced.
     */
    categoryId: string;
    /**
     * Count of associations of a particular type of entity or policy
     */
    count: number;
    /**
     * An enum denoting the resource group.
     * Resources can be organized into either an entity or a policy.
     */
    resourceGroup: string;
    /**
     * An enum denoting the associated resource types. Resource types are further grouped into 2 types - entity or a policy.
     */
    resourceType: string;
}

export interface GetCategoryV2DetailedAssociation {
    /**
     * External identifier for the given category, used across all v4 apis/entities/resources where categories are referenced.
     */
    categoryId: string;
    /**
     * An enum denoting the resource group.
     * Resources can be organized into either an entity or a policy.
     */
    resourceGroup: string;
    /**
     * The UUID of the entity or policy associated with the particular category.
     */
    resourceId: string;
    /**
     * An enum denoting the associated resource types. Resource types are further grouped into 2 types - entity or a policy.
     */
    resourceType: string;
}

export interface GetCategoryV2Link {
    href: string;
    rel: string;
}

export interface GetClusterAuthorizedPublicKeyList {
    key: string;
    /**
     * Represents the name of cluster
     */
    name: string;
}

export interface GetClusterCaCertificateList {
    caName: string;
    certificate: string;
}

export interface GetClusterCategory {
    /**
     * - the key name.
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetClusterHttpProxyList {
    address: {[key: string]: string};
    credentials: {[key: string]: string};
    proxyTypeLists: string[];
}

export interface GetClusterHttpProxyWhitelist {
    target: string;
    targetType: string;
}

export interface GetClusterManagementServerList {
    drsEnabled: boolean;
    ip: string;
    statusLists: string[];
    type: string;
}

export interface GetClusterNode {
    ip: string;
    type: string;
    version: string;
}

export interface GetClusterV2Config {
    /**
     * - Public ssh key details. This is part of payload for cluster update operation only.
     */
    authorizedPublicKeyLists: outputs.GetClusterV2ConfigAuthorizedPublicKeyList[];
    /**
     * - Build information details.
     */
    buildInfos: outputs.GetClusterV2ConfigBuildInfo[];
    /**
     * - Cluster arch.
     * Valid values are:
     * - "PPC64LE" PPC64LE cluster architecture type.
     * - "X86_64" X86_64 cluster architecture type.
     */
    clusterArch: string;
    /**
     * - Cluster function. This is part of payload for cluster
     * create operation only (allowed enum values for creation are AOS, ONE_NODE & TWO_NODE only).
     * Valid values are:
     * - "AOS"
     * - "PRISM_CENTRAL"
     * - "CLOUD_DATA_GATEWAY"
     * - "AFS"
     * - "ONE_NODE"
     * - "TWO_NODE"
     * - "ANALYTICS_PLATFORM"
     */
    clusterFunctions: string[];
    /**
     * - Cluster software version details.
     */
    clusterSoftwareMaps: outputs.GetClusterV2ConfigClusterSoftwareMap[];
    /**
     * - Encryption in transit Status.
     * Valid values are:
     * - "DISABLED"	Disabled encryption status.
     * - "ENABLED" 	Enabled encryption status.
     */
    encryptionInTransitStatus: string;
    /**
     * - Encryption option.
     * Valid values are:
     * - "SOFTWARE".
     * - "HARDWARE".
     * - "SOFTWARE_AND_HARDWARE"
     */
    encryptionOptions: string[];
    /**
     * - Encryption scope.
     * Valid values are:
     * - "CLUSTER".
     * - "CONTAINER".
     */
    encryptionScopes: string[];
    /**
     * - Fault tolerance state of a cluster.
     */
    faultToleranceStates: outputs.GetClusterV2ConfigFaultToleranceState[];
    /**
     * - Hypervisor types.
     * Valid values are:
     * - "AHV".
     * - "ESX".
     * - "HYPERV".
     * - "XEN".
     * - "NATIVEHOST".
     */
    hypervisorTypes: string[];
    /**
     * - Cluster incarnation Id. This is part of payload for cluster update operation only.
     */
    incarnationId: number;
    /**
     * - Indicates if cluster is available to contact or not.
     */
    isAvailable: boolean;
    /**
     * - Indicates whether the release is categorized as Long-term or not.
     */
    isLts: boolean;
    /**
     * - Indicates whether the password ssh into the cluster is enabled or not.
     */
    isPasswordRemoteLoginEnabled: boolean;
    /**
     * - Remote support status.
     */
    isRemoteSupportEnabled: boolean;
    /**
     * - Cluster operation mode. This is part of payload for cluster
     * update operation only.
     * Valid values are:
     * - "OVERRIDE"	Override operation mode.
     * - "STAND_ALONE"	Stand-alone operation mode.
     * - "SWITCH_TO_TWO_NODE"	Switch to two-node operation mode.
     * - "NORMAL"	Normal operation mode.
     * - "READ_ONLY"	Read-only operation mode.
     */
    operationMode: string;
    /**
     * - Pulse status for a cluster.
     */
    pulseStatuses: outputs.GetClusterV2ConfigPulseStatus[];
    /**
     * - Redundancy factor of a cluster. This is part of payload for both cluster create & update operations.
     */
    redundancyFactor: number;
    /**
     * - Time zone on a cluster.
     */
    timezone: string;
}

export interface GetClusterV2ConfigAuthorizedPublicKeyList {
    /**
     * - SSH key value.
     */
    key: string;
    /**
     * - HTTP Proxy server name configuration needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
     */
    name: string;
}

export interface GetClusterV2ConfigBuildInfo {
    /**
     * - Software build type.
     */
    buildType: string;
    /**
     * - Commit ID used for version.
     */
    commitId: string;
    /**
     * - Full name of software version.
     */
    fullVersion: string;
    /**
     * - Short commit Id used for version.
     */
    shortCommitId: string;
    /**
     * - Software version.
     */
    version: string;
}

export interface GetClusterV2ConfigClusterSoftwareMap {
    /**
     * - Software type. This is part of payload for cluster create operation only.
     * Valid values are:
     * - "PRISM_CENTRAL": Prism Central software type.
     * - "NOS": NOS software.
     * - "NCC": NCC software.
     */
    softwareType: string;
    /**
     * - Software version.
     */
    version: string;
}

export interface GetClusterV2ConfigFaultToleranceState {
    /**
     * - Cluster Fault tolerance. Set desiredClusterFaultTolerance for cluster create and update.
     * Valid values are:
     * - "CFT_1N_OR_1D":     - System can handle fault of one node or one disk.
     * - "CFT_2N_OR_2D":     - System can handle fault of two nodes or two disks.
     * - "CFT_1N_AND_1D":    - System can handle fault of one node and one disk on the other node simultaneously.
     * - "CFT_0N_AND_0D":    - System can not handle any fault with a node or a disk.
     */
    currentClusterFaultTolerance: string;
    /**
     * - Maximum fault tolerance that is supported currently.
     */
    currentMaxFaultTolerance: number;
    /**
     * - Cluster Fault tolerance. Set desiredClusterFaultTolerance for cluster create and update.
     * Valid values are:
     * - "CFT_1N_OR_1D":     - System can handle fault of one node or one disk.
     * - "CFT_2N_OR_2D":     - System can handle fault of two nodes or two disks.
     * - "CFT_1N_AND_1D":    - System can handle fault of one node and one disk on the other node simultaneously.
     * - "CFT_0N_AND_0D":    - System can not handle any fault with a node or a disk.
     */
    desiredClusterFaultTolerance: string;
    /**
     * - Maximum fault tolerance desired.
     */
    desiredMaxFaultTolerance: number;
    /**
     * - Domain awareness level corresponds to unit of cluster group. This is part of payload for both cluster create & update operations.
     * Valid values are:
     * - "RACK"	Rack level awareness.
     * - "NODE"	Node level awareness.
     * - "BLOCK"	Block level awareness.
     * - "DISK"	Disk level awareness.
     */
    domainAwarenessLevel: string;
    /**
     * - Redundancy Status of the cluster
     */
    redundancyStatuses: outputs.GetClusterV2ConfigFaultToleranceStateRedundancyStatus[];
}

export interface GetClusterV2ConfigFaultToleranceStateRedundancyStatus {
    /**
     * - Boolean flag to indicate if Cassandra ensemble can meet the desired FT.
     */
    isCassandraPreparationDone: boolean;
    /**
     * - Boolean flag to indicate if Zookeeper ensemble can meet the desired FT.
     */
    isZookeeperPreparationDone: boolean;
}

export interface GetClusterV2ConfigPulseStatus {
    /**
     * - (Optional) Flag to indicate if pulse is enabled or not.
     */
    isEnabled: boolean;
    /**
     * - (Optional) PII scrubbing level.
     * Valid values are:
     * - "ALL" :	Scrub All PII Information from Pulse including data like entity names and IP addresses.
     * - "DEFAULT":	Default PII Scrubbing level. Data like entity names and IP addresses will not be scrubbed from Pulse.
     */
    piiScrubbingLevel: string;
}

export interface GetClusterV2Link {
    href: string;
    rel: string;
}

export interface GetClusterV2Network {
    /**
     * - Params associated to the backplane network segmentation. This is part of payload for cluster create operation only.
     */
    backplanes: outputs.GetClusterV2NetworkBackplane[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    externalAddresses: outputs.GetClusterV2NetworkExternalAddress[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    externalDataServicesIps: outputs.GetClusterV2NetworkExternalDataServicesIp[];
    /**
     * - Cluster external subnet address.
     */
    externalSubnet: string;
    /**
     * - Fully Qualified Domain Name (FQDN) of the server.
     */
    fqdn: string;
    /**
     * - List of HTTP Proxy server configuration needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
     */
    httpProxyLists: outputs.GetClusterV2NetworkHttpProxyList[];
    httpProxyWhiteLists: outputs.GetClusterV2NetworkHttpProxyWhiteList[];
    /**
     * - Cluster internal subnet address.
     */
    internalSubnet: string;
    /**
     * - Key management server type.
     * Valid values are:
     * - "PRISM_CENTRAL"	Prism Central management server.
     * - "EXTERNAL"	External management server.
     * - "LOCAL"	Local management server.
     */
    keyManagementServerType: string;
    /**
     * - Management server information.
     */
    managementServers: outputs.GetClusterV2NetworkManagementServer[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    masqueradingIps: outputs.GetClusterV2NetworkMasqueradingIp[];
    /**
     * - The port to connect to the cluster when using masquerading IP.
     */
    masqueradingPort: string;
    /**
     * - List of name servers on a cluster. This is part of payload for both cluster create & update operations. For create operation, only ipv4 address / fqdn values are supported currently
     */
    nameServerIpLists: outputs.GetClusterV2NetworkNameServerIpList[];
    nfsSubnetWhiteLists: string[];
    /**
     * - List of NTP servers on a cluster. This is part of payload for both cluster create & update operations. For create operation, only ipv4 address / fqdn values are supported currently.
     */
    ntpServerIpLists: outputs.GetClusterV2NetworkNtpServerIpList[];
    /**
     * - SMTP servers on a cluster. This is part of payload for cluster update operation only.
     */
    smtpServers: outputs.GetClusterV2NetworkSmtpServer[];
}

export interface GetClusterV2NetworkBackplane {
    /**
     * - Flag to indicate if the backplane segmentation needs to be enabled or not.
     */
    isSegmentationEnabled: boolean;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    netmasks: outputs.GetClusterV2NetworkBackplaneNetmask[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    subnets: outputs.GetClusterV2NetworkBackplaneSubnet[];
    /**
     * - VLAN Id tagged to the backplane network on the cluster. This is part of cluster create payload.
     */
    vlanTag: number;
}

export interface GetClusterV2NetworkBackplaneNetmask {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NetworkBackplaneSubnet {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NetworkExternalAddress {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetClusterV2NetworkExternalAddressIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetClusterV2NetworkExternalAddressIpv6[];
}

export interface GetClusterV2NetworkExternalAddressIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NetworkExternalAddressIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NetworkExternalDataServicesIp {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetClusterV2NetworkExternalDataServicesIpIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetClusterV2NetworkExternalDataServicesIpIpv6[];
}

export interface GetClusterV2NetworkExternalDataServicesIpIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NetworkExternalDataServicesIpIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NetworkHttpProxyList {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    ipAddresses: outputs.GetClusterV2NetworkHttpProxyListIpAddress[];
    /**
     * - HTTP Proxy server name configuration needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
     */
    name: string;
    /**
     * - SMTP server password.
     */
    password: string;
    /**
     * - SMTP port.
     */
    port: number;
    proxyTypes: string[];
    /**
     * - SMTP server user name.
     */
    username: string;
}

export interface GetClusterV2NetworkHttpProxyListIpAddress {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetClusterV2NetworkHttpProxyListIpAddressIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetClusterV2NetworkHttpProxyListIpAddressIpv6[];
}

export interface GetClusterV2NetworkHttpProxyListIpAddressIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NetworkHttpProxyListIpAddressIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NetworkHttpProxyWhiteList {
    /**
     * - Target's identifier which is exempted from going through the configured HTTP Proxy.
     */
    target: string;
    /**
     * - Type of the target which is exempted from going through the configured HTTP Proxy.
     * Valid values are:
     * - "IPV6_ADDRESS"	IPV6 address.
     * - "HOST_NAME"	Name of the host.
     * - "DOMAIN_NAME_SUFFIX" Domain Name Suffix required for http proxy whitelist.
     * - "IPV4_NETWORK_MASK" Network Mask of the IpV4 family.
     * - "IPV4_ADDRESS" IPV4 address.
     */
    targetType: string;
}

export interface GetClusterV2NetworkManagementServer {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    ips: outputs.GetClusterV2NetworkManagementServerIp[];
    /**
     * - Indicates whether it is DRS enabled or not.
     */
    isDrsEnabled: boolean;
    /**
     * - Indicates whether the host is managed by an entity or not.
     */
    isInUse: boolean;
    /**
     * - Indicates whether it is registered or not.
     */
    isRegistered: boolean;
    /**
     * - Type of management server.
     * Valid values are:
     * - "VCENTER"   	Vcenter management server.
     */
    type: boolean;
}

export interface GetClusterV2NetworkManagementServerIp {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetClusterV2NetworkManagementServerIpIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetClusterV2NetworkManagementServerIpIpv6[];
}

export interface GetClusterV2NetworkManagementServerIpIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NetworkManagementServerIpIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NetworkMasqueradingIp {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetClusterV2NetworkMasqueradingIpIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetClusterV2NetworkMasqueradingIpIpv6[];
}

export interface GetClusterV2NetworkMasqueradingIpIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NetworkMasqueradingIpIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NetworkNameServerIpList {
    /**
     * - Fully Qualified Domain Name (FQDN) of the server.
     */
    fqdns: outputs.GetClusterV2NetworkNameServerIpListFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetClusterV2NetworkNameServerIpListIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetClusterV2NetworkNameServerIpListIpv6[];
}

export interface GetClusterV2NetworkNameServerIpListFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NetworkNameServerIpListIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NetworkNameServerIpListIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NetworkNtpServerIpList {
    /**
     * - Fully Qualified Domain Name (FQDN) of the server.
     */
    fqdns: outputs.GetClusterV2NetworkNtpServerIpListFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetClusterV2NetworkNtpServerIpListIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetClusterV2NetworkNtpServerIpListIpv6[];
}

export interface GetClusterV2NetworkNtpServerIpListFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NetworkNtpServerIpListIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NetworkNtpServerIpListIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NetworkSmtpServer {
    /**
     * - SMTP email address.
     */
    emailAddress: string;
    /**
     * - SMTP network details.
     */
    servers: outputs.GetClusterV2NetworkSmtpServerServer[];
    /**
     * - Type of management server.
     * Valid values are:
     * - "VCENTER"   	Vcenter management server.
     */
    type: string;
}

export interface GetClusterV2NetworkSmtpServerServer {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    ipAddresses: outputs.GetClusterV2NetworkSmtpServerServerIpAddress[];
    /**
     * - SMTP server password.
     */
    password: string;
    /**
     * - SMTP port.
     */
    port: number;
    /**
     * - SMTP server user name.
     */
    username: string;
}

export interface GetClusterV2NetworkSmtpServerServerIpAddress {
    /**
     * - Fully Qualified Domain Name (FQDN) of the server.
     */
    fqdns: outputs.GetClusterV2NetworkSmtpServerServerIpAddressFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetClusterV2NetworkSmtpServerServerIpAddressIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetClusterV2NetworkSmtpServerServerIpAddressIpv6[];
}

export interface GetClusterV2NetworkSmtpServerServerIpAddressFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NetworkSmtpServerServerIpAddressIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NetworkSmtpServerServerIpAddressIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2Node {
    /**
     * - List of nodes in a cluster.
     */
    nodeLists: outputs.GetClusterV2NodeNodeList[];
    /**
     * - Number of nodes in a cluster.
     */
    numberOfNodes: number;
}

export interface GetClusterV2NodeNodeList {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    controllerVmIps: outputs.GetClusterV2NodeNodeListControllerVmIp[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    hostIps: outputs.GetClusterV2NodeNodeListHostIp[];
    /**
     * - UUID of the host.
     */
    nodeUuid: string;
}

export interface GetClusterV2NodeNodeListControllerVmIp {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetClusterV2NodeNodeListControllerVmIpIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetClusterV2NodeNodeListControllerVmIpIpv6[];
}

export interface GetClusterV2NodeNodeListControllerVmIpIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NodeNodeListControllerVmIpIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NodeNodeListHostIp {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetClusterV2NodeNodeListHostIpIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetClusterV2NodeNodeListHostIpIpv6[];
}

export interface GetClusterV2NodeNodeListHostIpIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClusterV2NodeNodeListHostIpIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersEntity {
    /**
     * - Map of cluster efficiency which includes numbers of inefficient vms. The value is populated by analytics on PC. (Readonly)
     */
    analysisVmEfficiencyMap: {[key: string]: string};
    /**
     * The API version.
     */
    apiVersion: string;
    authorizedPublicKeyLists: outputs.GetClustersEntityAuthorizedPublicKeyList[];
    /**
     * - Cluster build details.
     */
    build: {[key: string]: string};
    /**
     * - Zone name used in value of TZ environment variable.
     */
    caCertificateLists: outputs.GetClustersEntityCaCertificateList[];
    /**
     * - Categories for the image.
     */
    categories: outputs.GetClustersEntityCategory[];
    /**
     * - Customer information used in Certificate Signing Request for creating digital certificates.
     */
    certificationSigningInfo: {[key: string]: string};
    /**
     * - Client authentication config.
     */
    clientAuth: {[key: string]: string};
    /**
     * - Cluster architecture. (Readonly, Options: Options : X86_64 , PPC64LE)
     */
    clusterArch: string;
    /**
     * - Cluster domain credentials.
     */
    domainServerCredentials: {[key: string]: string};
    /**
     * - Joined domain name. In 'put' request, empty name will unjoin the cluster from current domain.
     */
    domainServerName: string;
    /**
     * -  The IP of the nameserver that can resolve the domain name. Must set when joining the domain.
     */
    domainServerNameserver: string;
    /**
     * - Array of enabled features.
     */
    enabledFeatureLists: string[];
    /**
     * - Cluster encryption status.
     */
    encryptionStatus: string;
    /**
     * - The cluster IP address that provides external entities access to various cluster data services.
     */
    externalDataServicesIp: string;
    /**
     * - The local IP of cluster visible externally.
     */
    externalIp: string;
    /**
     * - External subnet for cross server communication. The format is IP/netmask. (default 172.16.0.0/255.240.0.0)
     */
    externalSubnet: string;
    /**
     * - GPU driver version.
     */
    gpuDriverVersion: string;
    /**
     * - List of proxies to connect to the service centers.
     */
    httpProxyLists: outputs.GetClustersEntityHttpProxyList[];
    /**
     * - HTTP proxy whitelist.
     */
    httpProxyWhitelists: outputs.GetClustersEntityHttpProxyWhitelist[];
    /**
     * - The internal subnet is local to every server - its not visible outside.iSCSI requests generated internally within the appliance (by user VMs or VMFS) are sent to the internal subnet. The format is IP/netmask.
     */
    internalSubnet: string;
    /**
     * - Indicates if cluster is available to contact. (Readonly)
     */
    isAvailable: boolean;
    /**
     * - List of cluster management servers. (Readonly)
     */
    managementServerLists: outputs.GetClustersEntityManagementServerList[];
    /**
     * - The cluster NAT'd or proxy IP which maps to the cluster local IP.
     */
    masqueradingIp: string;
    /**
     * - Port used together with masqueradingIp to connect to the cluster.
     */
    masqueradingPort: number;
    /**
     * - The image kind metadata.
     */
    metadata: {[key: string]: string};
    /**
     * -  The name for the image.
     */
    name: string;
    /**
     * - The list of IP addresses of the name servers.
     */
    nameServerIpLists: string[];
    /**
     * - Comma separated list of subnets (of the form 'a.b.c.d/l.m.n.o') that are allowed to send NFS requests to this container. If not specified, the global NFS whitelist will be looked up for access permission. The internal subnet is always automatically considered part of the whitelist, even if the field below does not explicitly specify it. Similarly, all the hypervisor IPs are considered part of the whitelist. Finally, to permit debugging, all of the SVMs local IPs are considered to be implicitly part of the whitelist.
     */
    nfsSubnetWhitelists: string[];
    nodes: outputs.GetClustersEntityNode[];
    /**
     * - The list of IP addresses or FQDNs of the NTP servers.
     */
    ntpServerIpLists: string[];
    /**
     * - Cluster operation mode. - 'NORMAL': Cluster is operating normally. - 'READ_ONLY': Cluster is operating in read only mode. - 'STAND_ALONE': Only one node is operational in the cluster. This is valid only for single node or two node clusters. - 'SWITCH_TO_TWO_NODE': Cluster is moving from single node to two node cluster. - 'OVERRIDE': Valid only for single node cluster. If the user wants to run vms on a single node cluster in read only mode, he can set the cluster peration mode to override. Writes will be allowed in override mode.
     */
    operationMode: string;
    /**
     * - The reference to a user.
     */
    ownerReference: {[key: string]: string};
    /**
     * - The reference to a project.
     */
    projectReference: {[key: string]: string};
    /**
     * - Array of enabled cluster services. For example, a cluster can function as both AOS and cloud data gateway. - 'AOS': Regular Prism Element - 'PRISM_CENTRAL': Prism Central - 'CLOUD_DATA_GATEWAY': Cloud backup and DR gateway - 'AFS': Cluster for file server - 'WITNESS' : Witness cluster - 'XI_PORTAL': Xi cluster.
     */
    serviceLists: string[];
    /**
     * - SMTP Server Address.
     */
    smtpServerAddress: {[key: string]: string};
    /**
     * - SMTP Server Credentials.
     */
    smtpServerCredentials: {[key: string]: string};
    /**
     * - SMTP Server Email Address.
     */
    smtpServerEmailAddress: string;
    /**
     * - SMTP Server Proxy Type List
     */
    smtpServerProxyTypeLists: string[];
    /**
     * - SMTP Server type.
     */
    smtpServerType: string;
    /**
     * - Map of software on the cluster with software type as the key.
     */
    softwareMapNcc: {[key: string]: string};
    /**
     * - Map of software on the cluster with software type as the key.
     */
    softwareMapNos: {[key: string]: string};
    /**
     * - UTC date and time in RFC-3339 format when the key expires
     */
    sslKeyExpireDatetime: string;
    sslKeyName: string;
    /**
     * - Customer information used in Certificate Signing Request for creating digital certificates.
     */
    sslKeySigningInfo: {[key: string]: string};
    /**
     * - SSL key type. Key types with RSA_2048, ECDSA_256 and ECDSA_384 are supported for key generation and importing.
     */
    sslKeyType: string;
    /**
     * - The state of the cluster entity.
     */
    state: string;
    /**
     * - Verbosity level settings for populating support information. - 'Nothing': Send nothing - 'Basic': Send basic information - skip core dump and hypervisor stats information - 'BasicPlusCoreDump': Send basic and core dump information - 'All': Send all information (Default value: BASIC_PLUS_CORE_DUMP)
     */
    supportedInformationVerbosity: string;
    /**
     * - Zone name used in value of TZ environment variable.
     */
    timezone: string;
}

export interface GetClustersEntityAuthorizedPublicKeyList {
    key: string;
    /**
     * -  The name for the image.
     */
    name: string;
}

export interface GetClustersEntityCaCertificateList {
    caName: string;
    certificate: string;
}

export interface GetClustersEntityCategory {
    /**
     * - the key name.
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetClustersEntityHttpProxyList {
    address: {[key: string]: string};
    credentials: {[key: string]: string};
    proxyTypeLists: string[];
}

export interface GetClustersEntityHttpProxyWhitelist {
    target: string;
    targetType: string;
}

export interface GetClustersEntityManagementServerList {
    drsEnabled: boolean;
    ip: string;
    statusLists: string[];
    type: string;
}

export interface GetClustersEntityNode {
    ip: string;
    type: string;
    version: string;
}

export interface GetClustersV2ClusterEntity {
    /**
     * -  Score to indicate how much cluster is eligible for storing domain manager backup.
     */
    backupEligibilityScore: number;
    /**
     * -  List of categories associated to the PE cluster.
     */
    categories: string[];
    /**
     * -  Cluster profile UUID.
     */
    clusterProfileExtId: string;
    /**
     * -  Cluster configuration details.
     */
    configs: outputs.GetClustersV2ClusterEntityConfig[];
    /**
     * -  The name of the default container created as part of cluster creation. This is part of payload for cluster create operation only.
     */
    containerName: string;
    /**
     * -(Optional) A URL query parameter that allows clients to request related resources when a resource that satisfies a particular request is retrieved. Each expanded item is evaluated relative to the entity containing the property being expanded. Other query options can be applied to an expanded property by appending a semicolon-separated list of query options, enclosed in parentheses, to the property name. Permissible system query options are \$filter, \$select and \$orderby.
     * The `expand` can be applied on the following fields:
     * - clusterProfile
     * - storageSummary
     */
    expand?: string;
    /**
     * -  A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    /**
     * -  Number of inefficient VMs in the cluster.
     */
    inefficientVmCount: number;
    /**
     * - A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetClustersV2ClusterEntityLink[];
    /**
     * - HTTP Proxy server name configuration needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
     */
    name: string;
    /**
     * -  Network details of a cluster.
     */
    networks: outputs.GetClustersV2ClusterEntityNetwork[];
    /**
     * -  Node reference for a cluster.
     */
    nodes: outputs.GetClustersV2ClusterEntityNode[];
    /**
     * -  globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server).
     */
    tenantId: string;
    /**
     * -  Upgrade status of a cluster.
     * Valid values are:
     * - "CANCELLED"	The cluster upgrade is cancelled.
     * - "FAILED"	The cluster upgrade failed.
     * - "QUEUED"	The cluster upgrade is in the queue.
     * - "SUCCEEDED"	The cluster was upgraded successfully.
     * - "DOWNLOADING" The luster upgrade is downloading.
     * - "PENDING"The cluster upgrade is in pending state.
     * - "UPGRADING" The cluster is in upgrade state.
     * - "PREUPGRADE" The cluster is in pre-upgrade state.
     * - "SCHEDULED" The cluster upgrade is in scheduled state.
     */
    upgradeStatus: string;
    /**
     * -  Number of VMs in the cluster.
     */
    vmCount: number;
}

export interface GetClustersV2ClusterEntityConfig {
    /**
     * - Public ssh key details. This is part of payload for cluster update operation only.
     */
    authorizedPublicKeyLists: outputs.GetClustersV2ClusterEntityConfigAuthorizedPublicKeyList[];
    /**
     * - Build information details.
     */
    buildInfos: outputs.GetClustersV2ClusterEntityConfigBuildInfo[];
    /**
     * - Cluster arch.
     * Valid values are:
     * - "PPC64LE" PPC64LE cluster architecture type.
     * - "X86_64" X86_64 cluster architecture type.
     */
    clusterArch: string;
    /**
     * - Cluster function. This is part of payload for cluster
     * create operation only (allowed enum values for creation are AOS, ONE_NODE & TWO_NODE only).
     * Valid values are:
     * - "AOS"
     * - "PRISM_CENTRAL"
     * - "CLOUD_DATA_GATEWAY"
     * - "AFS"
     * - "ONE_NODE"
     * - "TWO_NODE"
     * - "ANALYTICS_PLATFORM"
     */
    clusterFunctions: string[];
    /**
     * - Cluster software version details.
     */
    clusterSoftwareMaps: outputs.GetClustersV2ClusterEntityConfigClusterSoftwareMap[];
    /**
     * - Encryption in transit Status.
     * Valid values are:
     * - "DISABLED"	Disabled encryption status.
     * - "ENABLED" 	Enabled encryption status.
     */
    encryptionInTransitStatus: string;
    /**
     * - Encryption option.
     * Valid values are:
     * - "SOFTWARE".
     * - "HARDWARE".
     * - "SOFTWARE_AND_HARDWARE"
     */
    encryptionOptions: string[];
    /**
     * - Encryption scope.
     * Valid values are:
     * - "CLUSTER".
     * - "CONTAINER".
     */
    encryptionScopes: string[];
    /**
     * - Fault tolerance state of a cluster.
     */
    faultToleranceStates: outputs.GetClustersV2ClusterEntityConfigFaultToleranceState[];
    /**
     * - Hypervisor types.
     * Valid values are:
     * - "AHV".
     * - "ESX".
     * - "HYPERV".
     * - "XEN".
     * - "NATIVEHOST".
     */
    hypervisorTypes: string[];
    /**
     * - Cluster incarnation Id. This is part of payload for cluster update operation only.
     */
    incarnationId: number;
    /**
     * - Indicates if cluster is available to contact or not.
     */
    isAvailable: boolean;
    /**
     * - Indicates whether the release is categorized as Long-term or not.
     */
    isLts: boolean;
    /**
     * - Indicates whether the password ssh into the cluster is enabled or not.
     */
    isPasswordRemoteLoginEnabled: boolean;
    /**
     * - Remote support status.
     */
    isRemoteSupportEnabled: boolean;
    /**
     * - Cluster operation mode. This is part of payload for cluster
     * update operation only.
     * Valid values are:
     * - "OVERRIDE"	Override operation mode.
     * - "STAND_ALONE"	Stand-alone operation mode.
     * - "SWITCH_TO_TWO_NODE"	Switch to two-node operation mode.
     * - "NORMAL"	Normal operation mode.
     * - "READ_ONLY"	Read-only operation mode.
     */
    operationMode: string;
    /**
     * - Pulse status for a cluster.
     */
    pulseStatuses: outputs.GetClustersV2ClusterEntityConfigPulseStatus[];
    /**
     * - Redundancy factor of a cluster. This is part of payload for both cluster create & update operations.
     */
    redundancyFactor: number;
    /**
     * - Time zone on a cluster.
     */
    timezone: string;
}

export interface GetClustersV2ClusterEntityConfigAuthorizedPublicKeyList {
    /**
     * - SSH key value.
     */
    key: string;
    /**
     * - HTTP Proxy server name configuration needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
     */
    name: string;
}

export interface GetClustersV2ClusterEntityConfigBuildInfo {
    /**
     * - Software build type.
     */
    buildType: string;
    /**
     * - Commit ID used for version.
     */
    commitId: string;
    /**
     * - Full name of software version.
     */
    fullVersion: string;
    /**
     * - Short commit Id used for version.
     */
    shortCommitId: string;
    /**
     * - Software version.
     */
    version: string;
}

export interface GetClustersV2ClusterEntityConfigClusterSoftwareMap {
    /**
     * - Software type. This is part of payload for cluster create operation only.
     * Valid values are:
     * - "PRISM_CENTRAL": Prism Central software type.
     * - "NOS": NOS software.
     * - "NCC": NCC software.
     */
    softwareType: string;
    /**
     * - Software version.
     */
    version: string;
}

export interface GetClustersV2ClusterEntityConfigFaultToleranceState {
    /**
     * - Cluster Fault tolerance. Set desiredClusterFaultTolerance for cluster create and update.
     * Valid values are:
     * - "CFT_1N_OR_1D":     - System can handle fault of one node or one disk.
     * - "CFT_2N_OR_2D":     - System can handle fault of two nodes or two disks.
     * - "CFT_1N_AND_1D":    - System can handle fault of one node and one disk on the other node simultaneously.
     * - "CFT_0N_AND_0D":    - System can not handle any fault with a node or a disk.
     */
    currentClusterFaultTolerance: string;
    /**
     * - Maximum fault tolerance that is supported currently.
     */
    currentMaxFaultTolerance: number;
    /**
     * - Cluster Fault tolerance. Set desiredClusterFaultTolerance for cluster create and update.
     * Valid values are:
     * - "CFT_1N_OR_1D":     - System can handle fault of one node or one disk.
     * - "CFT_2N_OR_2D":     - System can handle fault of two nodes or two disks.
     * - "CFT_1N_AND_1D":    - System can handle fault of one node and one disk on the other node simultaneously.
     * - "CFT_0N_AND_0D":    - System can not handle any fault with a node or a disk.
     */
    desiredClusterFaultTolerance: string;
    /**
     * - Maximum fault tolerance desired.
     */
    desiredMaxFaultTolerance: number;
    /**
     * - Domain awareness level corresponds to unit of cluster group. This is part of payload for both cluster create & update operations.
     * Valid values are:
     * - "RACK"	Rack level awareness.
     * - "NODE"	Node level awareness.
     * - "BLOCK"	Block level awareness.
     * - "DISK"	Disk level awareness.
     */
    domainAwarenessLevel: string;
    /**
     * - Redundancy Status of the cluster
     */
    redundancyStatuses: outputs.GetClustersV2ClusterEntityConfigFaultToleranceStateRedundancyStatus[];
}

export interface GetClustersV2ClusterEntityConfigFaultToleranceStateRedundancyStatus {
    /**
     * - Boolean flag to indicate if Cassandra ensemble can meet the desired FT.
     */
    isCassandraPreparationDone: boolean;
    /**
     * - Boolean flag to indicate if Zookeeper ensemble can meet the desired FT.
     */
    isZookeeperPreparationDone: boolean;
}

export interface GetClustersV2ClusterEntityConfigPulseStatus {
    /**
     * - (Optional) Flag to indicate if pulse is enabled or not.
     */
    isEnabled: boolean;
    /**
     * - (Optional) PII scrubbing level.
     * Valid values are:
     * - "ALL" :	Scrub All PII Information from Pulse including data like entity names and IP addresses.
     * - "DEFAULT":	Default PII Scrubbing level. Data like entity names and IP addresses will not be scrubbed from Pulse.
     */
    piiScrubbingLevel: string;
}

export interface GetClustersV2ClusterEntityLink {
    href: string;
    rel: string;
}

export interface GetClustersV2ClusterEntityNetwork {
    /**
     * - Params associated to the backplane network segmentation. This is part of payload for cluster create operation only.
     */
    backplanes: outputs.GetClustersV2ClusterEntityNetworkBackplane[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    externalAddresses: outputs.GetClustersV2ClusterEntityNetworkExternalAddress[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    externalDataServicesIps: outputs.GetClustersV2ClusterEntityNetworkExternalDataServicesIp[];
    /**
     * - Cluster external subnet address.
     */
    externalSubnet: string;
    /**
     * - Cluster fully qualified domain name. This is part of payload for cluster update operation only.
     */
    fqdn: string;
    /**
     * - List of HTTP Proxy server configuration needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
     */
    httpProxyLists: outputs.GetClustersV2ClusterEntityNetworkHttpProxyList[];
    httpProxyWhiteLists: outputs.GetClustersV2ClusterEntityNetworkHttpProxyWhiteList[];
    /**
     * - Cluster internal subnet address.
     */
    internalSubnet: string;
    /**
     * - Key management server type.
     * Valid values are:
     * - "PRISM_CENTRAL"	Prism Central management server.
     * - "EXTERNAL"	External management server.
     * - "LOCAL"	Local management server.
     */
    keyManagementServerType: string;
    /**
     * - Management server information.
     */
    managementServers: outputs.GetClustersV2ClusterEntityNetworkManagementServer[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    masqueradingIps: outputs.GetClustersV2ClusterEntityNetworkMasqueradingIp[];
    /**
     * - The port to connect to the cluster when using masquerading IP.
     */
    masqueradingPort: string;
    /**
     * - List of name servers on a cluster. This is part of payload for both cluster create & update operations. For create operation, only ipv4 address / fqdn values are supported currently
     */
    nameServerIpLists: outputs.GetClustersV2ClusterEntityNetworkNameServerIpList[];
    nfsSubnetWhiteLists: string[];
    /**
     * - List of NTP servers on a cluster. This is part of payload for both cluster create & update operations. For create operation, only ipv4 address / fqdn values are supported currently.
     */
    ntpServerIpLists: outputs.GetClustersV2ClusterEntityNetworkNtpServerIpList[];
    /**
     * - SMTP servers on a cluster. This is part of payload for cluster update operation only.
     */
    smtpServers: outputs.GetClustersV2ClusterEntityNetworkSmtpServer[];
}

export interface GetClustersV2ClusterEntityNetworkBackplane {
    /**
     * - Flag to indicate if the backplane segmentation needs to be enabled or not.
     */
    isSegmentationEnabled: boolean;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    netmasks: outputs.GetClustersV2ClusterEntityNetworkBackplaneNetmask[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    subnets: outputs.GetClustersV2ClusterEntityNetworkBackplaneSubnet[];
    /**
     * - VLAN Id tagged to the backplane network on the cluster. This is part of cluster create payload.
     */
    vlanTag: number;
}

export interface GetClustersV2ClusterEntityNetworkBackplaneNetmask {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNetworkBackplaneSubnet {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNetworkExternalAddress {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetClustersV2ClusterEntityNetworkExternalAddressIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetClustersV2ClusterEntityNetworkExternalAddressIpv6[];
}

export interface GetClustersV2ClusterEntityNetworkExternalAddressIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNetworkExternalAddressIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNetworkExternalDataServicesIp {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetClustersV2ClusterEntityNetworkExternalDataServicesIpIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetClustersV2ClusterEntityNetworkExternalDataServicesIpIpv6[];
}

export interface GetClustersV2ClusterEntityNetworkExternalDataServicesIpIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNetworkExternalDataServicesIpIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNetworkHttpProxyList {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    ipAddresses: outputs.GetClustersV2ClusterEntityNetworkHttpProxyListIpAddress[];
    /**
     * - HTTP Proxy server name configuration needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
     */
    name: string;
    /**
     * - SMTP server password.
     */
    password: string;
    /**
     * - SMTP port.
     */
    port: number;
    proxyTypes: string[];
    /**
     * - SMTP server user name.
     */
    username: string;
}

export interface GetClustersV2ClusterEntityNetworkHttpProxyListIpAddress {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetClustersV2ClusterEntityNetworkHttpProxyListIpAddressIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetClustersV2ClusterEntityNetworkHttpProxyListIpAddressIpv6[];
}

export interface GetClustersV2ClusterEntityNetworkHttpProxyListIpAddressIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNetworkHttpProxyListIpAddressIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNetworkHttpProxyWhiteList {
    /**
     * - Target's identifier which is exempted from going through the configured HTTP Proxy.
     */
    target: string;
    /**
     * - Type of the target which is exempted from going through the configured HTTP Proxy.
     * Valid values are:
     * - "IPV6_ADDRESS"	IPV6 address.
     * - "HOST_NAME"	Name of the host.
     * - "DOMAIN_NAME_SUFFIX" Domain Name Suffix required for http proxy whitelist.
     * - "IPV4_NETWORK_MASK" Network Mask of the IpV4 family.
     * - "IPV4_ADDRESS" IPV4 address.
     */
    targetType: string;
}

export interface GetClustersV2ClusterEntityNetworkManagementServer {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    ips: outputs.GetClustersV2ClusterEntityNetworkManagementServerIp[];
    /**
     * - Indicates whether it is DRS enabled or not.
     */
    isDrsEnabled: boolean;
    /**
     * - Indicates whether the host is managed by an entity or not.
     */
    isInUse: boolean;
    /**
     * - Indicates whether it is registered or not.
     */
    isRegistered: boolean;
    /**
     * - Type of management server.
     * Valid values are:
     * - "VCENTER"   	Vcenter management server.
     */
    type: boolean;
}

export interface GetClustersV2ClusterEntityNetworkManagementServerIp {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetClustersV2ClusterEntityNetworkManagementServerIpIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetClustersV2ClusterEntityNetworkManagementServerIpIpv6[];
}

export interface GetClustersV2ClusterEntityNetworkManagementServerIpIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNetworkManagementServerIpIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNetworkMasqueradingIp {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetClustersV2ClusterEntityNetworkMasqueradingIpIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetClustersV2ClusterEntityNetworkMasqueradingIpIpv6[];
}

export interface GetClustersV2ClusterEntityNetworkMasqueradingIpIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNetworkMasqueradingIpIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNetworkNameServerIpList {
    /**
     * - Cluster fully qualified domain name. This is part of payload for cluster update operation only.
     */
    fqdns: outputs.GetClustersV2ClusterEntityNetworkNameServerIpListFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetClustersV2ClusterEntityNetworkNameServerIpListIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetClustersV2ClusterEntityNetworkNameServerIpListIpv6[];
}

export interface GetClustersV2ClusterEntityNetworkNameServerIpListFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNetworkNameServerIpListIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNetworkNameServerIpListIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNetworkNtpServerIpList {
    /**
     * - Cluster fully qualified domain name. This is part of payload for cluster update operation only.
     */
    fqdns: outputs.GetClustersV2ClusterEntityNetworkNtpServerIpListFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetClustersV2ClusterEntityNetworkNtpServerIpListIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetClustersV2ClusterEntityNetworkNtpServerIpListIpv6[];
}

export interface GetClustersV2ClusterEntityNetworkNtpServerIpListFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNetworkNtpServerIpListIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNetworkNtpServerIpListIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNetworkSmtpServer {
    /**
     * - SMTP email address.
     */
    emailAddress: string;
    /**
     * - SMTP network details.
     */
    servers: outputs.GetClustersV2ClusterEntityNetworkSmtpServerServer[];
    /**
     * - Type of management server.
     * Valid values are:
     * - "VCENTER"   	Vcenter management server.
     */
    type: string;
}

export interface GetClustersV2ClusterEntityNetworkSmtpServerServer {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    ipAddresses: outputs.GetClustersV2ClusterEntityNetworkSmtpServerServerIpAddress[];
    /**
     * - SMTP server password.
     */
    password: string;
    /**
     * - SMTP port.
     */
    port: number;
    /**
     * - SMTP server user name.
     */
    username: string;
}

export interface GetClustersV2ClusterEntityNetworkSmtpServerServerIpAddress {
    /**
     * - Cluster fully qualified domain name. This is part of payload for cluster update operation only.
     */
    fqdns: outputs.GetClustersV2ClusterEntityNetworkSmtpServerServerIpAddressFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetClustersV2ClusterEntityNetworkSmtpServerServerIpAddressIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetClustersV2ClusterEntityNetworkSmtpServerServerIpAddressIpv6[];
}

export interface GetClustersV2ClusterEntityNetworkSmtpServerServerIpAddressFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNetworkSmtpServerServerIpAddressIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNetworkSmtpServerServerIpAddressIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNode {
    /**
     * - List of nodes in a cluster.
     */
    nodeLists: outputs.GetClustersV2ClusterEntityNodeNodeList[];
    /**
     * - Number of nodes in a cluster.
     */
    numberOfNodes: number;
}

export interface GetClustersV2ClusterEntityNodeNodeList {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    controllerVmIps: outputs.GetClustersV2ClusterEntityNodeNodeListControllerVmIp[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    hostIps: outputs.GetClustersV2ClusterEntityNodeNodeListHostIp[];
    /**
     * - UUID of the host.
     */
    nodeUuid: string;
}

export interface GetClustersV2ClusterEntityNodeNodeListControllerVmIp {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetClustersV2ClusterEntityNodeNodeListControllerVmIpIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetClustersV2ClusterEntityNodeNodeListControllerVmIpIpv6[];
}

export interface GetClustersV2ClusterEntityNodeNodeListControllerVmIpIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNodeNodeListControllerVmIpIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNodeNodeListHostIp {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetClustersV2ClusterEntityNodeNodeListHostIpIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetClustersV2ClusterEntityNodeNodeListHostIpIpv6[];
}

export interface GetClustersV2ClusterEntityNodeNodeListHostIpIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetClustersV2ClusterEntityNodeNodeListHostIpIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetDirectoryServiceV2OpenLdapConfiguration {
    /**
     * - this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
     */
    userConfigurations: outputs.GetDirectoryServiceV2OpenLdapConfigurationUserConfiguration[];
    /**
     * - this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
     */
    userGroupConfigurations: outputs.GetDirectoryServiceV2OpenLdapConfigurationUserGroupConfiguration[];
}

export interface GetDirectoryServiceV2OpenLdapConfigurationUserConfiguration {
    /**
     * - Object class in the OpenLDAP system that corresponds to Users.
     */
    userObjectClass: string;
    /**
     * - Base DN for User search.
     */
    userSearchBase: string;
    /**
     * - Unique Identifier for each User which can be used in Authentication.
     */
    usernameAttribute: string;
}

export interface GetDirectoryServiceV2OpenLdapConfigurationUserGroupConfiguration {
    /**
     * - Attribute in a group that associates Users to the group.
     */
    groupMemberAttribute: string;
    /**
     * - User attribute value that will be used in group entity to associate User to the group.
     */
    groupMemberAttributeValue: string;
    /**
     * - Object class in the OpenLDAP system that corresponds to groups.
     */
    groupObjectClass: string;
    /**
     * - Base DN for group search.
     */
    groupSearchBase: string;
}

export interface GetDirectoryServiceV2ServiceAccount {
    /**
     * - Password to connect to the Directory Service.
     */
    password: string;
    /**
     * - Username to connect to the Directory Service.
     */
    username: string;
}

export interface GetDirectoryServicesV2DirectoryService {
    /**
     * - User or Service who created the Directory Service.
     */
    createdBy: string;
    /**
     * - Creation time of the Directory Service.
     */
    createdTime: string;
    /**
     * - Type of Directory Service, Supported values are: "ACTIVE_DIRECTORY" (Directory Service type is Active Directory.) and "OPEN_LDAP" (Directory Service type is Open LDAP.)
     */
    directoryType: string;
    /**
     * - Domain name for the Directory Service.
     */
    domainName: string;
    /**
     * - A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    /**
     * - Group membership search type for the Directory Service. Supported values are: "NON_RECURSIVE" (Doesn't search recursively within groups.) and "RECURSIVE" (Searches recursively within groups.)
     */
    groupSearchType: string;
    /**
     * - Last updated time of the Directory Service.
     */
    lastUpdatedTime: string;
    /**
     * - Name for the Directory Service.
     */
    name: string;
    /**
     * - Configuration for OpenLDAP Directory Service.
     */
    openLdapConfigurations: outputs.GetDirectoryServicesV2DirectoryServiceOpenLdapConfiguration[];
    /**
     * - Secondary URL for the Directory Service.
     */
    secondaryUrls: string[];
    /**
     * - Information of Service account to connect to the Directory Service.
     */
    serviceAccounts: outputs.GetDirectoryServicesV2DirectoryServiceServiceAccount[];
    /**
     * - URL for the Directory Service.
     */
    url: string;
    /**
     * - List of allowed User Groups for the Directory Service.
     */
    whiteListedGroups: string[];
}

export interface GetDirectoryServicesV2DirectoryServiceOpenLdapConfiguration {
    /**
     * - this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
     */
    userConfigurations: outputs.GetDirectoryServicesV2DirectoryServiceOpenLdapConfigurationUserConfiguration[];
    /**
     * - this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
     */
    userGroupConfigurations: outputs.GetDirectoryServicesV2DirectoryServiceOpenLdapConfigurationUserGroupConfiguration[];
}

export interface GetDirectoryServicesV2DirectoryServiceOpenLdapConfigurationUserConfiguration {
    /**
     * - Object class in the OpenLDAP system that corresponds to Users.
     */
    userObjectClass: string;
    /**
     * - Base DN for User search.
     */
    userSearchBase: string;
    /**
     * - Unique Identifier for each User which can be used in Authentication.
     */
    usernameAttribute: string;
}

export interface GetDirectoryServicesV2DirectoryServiceOpenLdapConfigurationUserGroupConfiguration {
    /**
     * - Attribute in a group that associates Users to the group.
     */
    groupMemberAttribute: string;
    /**
     * - User attribute value that will be used in group entity to associate User to the group.
     */
    groupMemberAttributeValue: string;
    /**
     * - Object class in the OpenLDAP system that corresponds to groups.
     */
    groupObjectClass: string;
    /**
     * - Base DN for group search.
     */
    groupSearchBase: string;
}

export interface GetDirectoryServicesV2DirectoryServiceServiceAccount {
    /**
     * - Password to connect to the Directory Service.
     */
    password: string;
    /**
     * - Username to connect to the Directory Service.
     */
    username: string;
}

export interface GetFloatingIpSpec {
    /**
     * Floating IP allocation status.
     */
    resources: outputs.GetFloatingIpSpecResource[];
}

export interface GetFloatingIpSpecResource {
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a vm_nic
     */
    vmNicReference: {[key: string]: string};
    /**
     * The reference to a vpc
     */
    vpcReference: {[key: string]: string};
}

export interface GetFloatingIpStatus {
    /**
     * Execution Context of Floating IP.
     */
    executionContexts: outputs.GetFloatingIpStatusExecutionContext[];
    /**
     * - the name.
     */
    name: string;
    /**
     * Floating IP allocation status.
     */
    resources: outputs.GetFloatingIpStatusResource[];
    /**
     * The state of the floating_ip.
     */
    state: string;
}

export interface GetFloatingIpStatusExecutionContext {
    taskUuids: string[];
}

export interface GetFloatingIpStatusResource {
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * Private IP with which the floating IP is associated.
     */
    floatingIp: string;
    /**
     * The reference to a vm_nic
     */
    vmNicReference: {[key: string]: string};
    /**
     * The reference to a vpc
     */
    vpcReference: {[key: string]: string};
}

export interface GetFloatingIpV2Association {
    /**
     * Association of Floating IP with private IP
     */
    privateIpAssociations: outputs.GetFloatingIpV2AssociationPrivateIpAssociation[];
    /**
     * Association of Floating IP with nic
     */
    vmNicAssociations: outputs.GetFloatingIpV2AssociationVmNicAssociation[];
}

export interface GetFloatingIpV2AssociationPrivateIpAssociation {
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    privateIps: outputs.GetFloatingIpV2AssociationPrivateIpAssociationPrivateIp[];
    /**
     * VPC in which the private IP exists.
     */
    vpcReference: string;
}

export interface GetFloatingIpV2AssociationPrivateIpAssociationPrivateIp {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv6[];
}

export interface GetFloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2AssociationVmNicAssociation {
    /**
     * VM NIC reference.
     */
    vmNicReference: string;
    /**
     * VPC reference to which the VM NIC subnet belongs.
     */
    vpcReference: string;
}

export interface GetFloatingIpV2ExternalSubnet {
    bridgeName: string;
    clusterName: string;
    clusterReference: string;
    /**
     * Description for the Floating IP.
     */
    description: string;
    dhcpOptions: outputs.GetFloatingIpV2ExternalSubnetDhcpOption[];
    dynamicIpAddresses: outputs.GetFloatingIpV2ExternalSubnetDynamicIpAddress[];
    /**
     * Floating IP UUID
     */
    extId: string;
    hypervisorType: string;
    ipConfigs: outputs.GetFloatingIpV2ExternalSubnetIpConfig[];
    ipPrefix: string;
    ipUsages: outputs.GetFloatingIpV2ExternalSubnetIpUsage[];
    isAdvancedNetworking: boolean;
    isExternal: boolean;
    isNatEnabled: boolean;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetFloatingIpV2ExternalSubnetLink[];
    migrationState: string;
    /**
     * Name of the floating IP.
     */
    name: string;
    networkFunctionChainReference: string;
    networkId: number;
    reservedIpAddresses: outputs.GetFloatingIpV2ExternalSubnetReservedIpAddress[];
    subnetType: string;
    virtualSwitchReference: string;
    virtualSwitches: outputs.GetFloatingIpV2ExternalSubnetVirtualSwitch[];
    /**
     * VPC reference UUID
     */
    vpcReference: string;
    /**
     * Networking common base object
     */
    vpcs: outputs.GetFloatingIpV2ExternalSubnetVpc[];
}

export interface GetFloatingIpV2ExternalSubnetDhcpOption {
    bootFileName: string;
    domainName: string;
    domainNameServers: outputs.GetFloatingIpV2ExternalSubnetDhcpOptionDomainNameServer[];
    ntpServers: outputs.GetFloatingIpV2ExternalSubnetDhcpOptionNtpServer[];
    searchDomains: string[];
    tftpServerName: string;
}

export interface GetFloatingIpV2ExternalSubnetDhcpOptionDomainNameServer {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv6[];
}

export interface GetFloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetDhcpOptionNtpServer {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv6[];
}

export interface GetFloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetDynamicIpAddress {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpV2ExternalSubnetDynamicIpAddressIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpV2ExternalSubnetDynamicIpAddressIpv6[];
}

export interface GetFloatingIpV2ExternalSubnetDynamicIpAddressIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetDynamicIpAddressIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetIpConfig {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpV2ExternalSubnetIpConfigIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpV2ExternalSubnetIpConfigIpv6[];
}

export interface GetFloatingIpV2ExternalSubnetIpConfigIpv4 {
    defaultGatewayIps: outputs.GetFloatingIpV2ExternalSubnetIpConfigIpv4DefaultGatewayIp[];
    dhcpServerAddresses: outputs.GetFloatingIpV2ExternalSubnetIpConfigIpv4DhcpServerAddress[];
    ipSubnets: outputs.GetFloatingIpV2ExternalSubnetIpConfigIpv4IpSubnet[];
    poolLists: outputs.GetFloatingIpV2ExternalSubnetIpConfigIpv4PoolList[];
}

export interface GetFloatingIpV2ExternalSubnetIpConfigIpv4DefaultGatewayIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetIpConfigIpv4DhcpServerAddress {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetIpConfigIpv4IpSubnet {
    ips: outputs.GetFloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetIp[];
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
}

export interface GetFloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetIpConfigIpv4PoolList {
    endIps: outputs.GetFloatingIpV2ExternalSubnetIpConfigIpv4PoolListEndIp[];
    startIps: outputs.GetFloatingIpV2ExternalSubnetIpConfigIpv4PoolListStartIp[];
}

export interface GetFloatingIpV2ExternalSubnetIpConfigIpv4PoolListEndIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetIpConfigIpv4PoolListStartIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetIpConfigIpv6 {
    defaultGatewayIps: outputs.GetFloatingIpV2ExternalSubnetIpConfigIpv6DefaultGatewayIp[];
    dhcpServerAddresses: outputs.GetFloatingIpV2ExternalSubnetIpConfigIpv6DhcpServerAddress[];
    ipSubnets: outputs.GetFloatingIpV2ExternalSubnetIpConfigIpv6IpSubnet[];
    poolLists: outputs.GetFloatingIpV2ExternalSubnetIpConfigIpv6PoolList[];
}

export interface GetFloatingIpV2ExternalSubnetIpConfigIpv6DefaultGatewayIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetIpConfigIpv6DhcpServerAddress {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetIpConfigIpv6IpSubnet {
    ips: outputs.GetFloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetIp[];
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
}

export interface GetFloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetIpConfigIpv6PoolList {
    endIps: outputs.GetFloatingIpV2ExternalSubnetIpConfigIpv6PoolListEndIp[];
    startIps: outputs.GetFloatingIpV2ExternalSubnetIpConfigIpv6PoolListStartIp[];
}

export interface GetFloatingIpV2ExternalSubnetIpConfigIpv6PoolListEndIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetIpConfigIpv6PoolListStartIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetIpUsage {
    ipPoolUsages: outputs.GetFloatingIpV2ExternalSubnetIpUsageIpPoolUsage[];
    numAssignedIps: number;
    numFreeIps: number;
    numMacs: number;
}

export interface GetFloatingIpV2ExternalSubnetIpUsageIpPoolUsage {
    numFreeIps: number;
    numTotalIps: number;
    ranges: outputs.GetFloatingIpV2ExternalSubnetIpUsageIpPoolUsageRange[];
}

export interface GetFloatingIpV2ExternalSubnetIpUsageIpPoolUsageRange {
    endIps: outputs.GetFloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeEndIp[];
    startIps: outputs.GetFloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeStartIp[];
}

export interface GetFloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeEndIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeStartIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetFloatingIpV2ExternalSubnetReservedIpAddress {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetVirtualSwitch {
    bondMode: boolean;
    clusters: outputs.GetFloatingIpV2ExternalSubnetVirtualSwitchCluster[];
    /**
     * Description for the Floating IP.
     */
    description: string;
    /**
     * Floating IP UUID
     */
    extId: string;
    hasDeploymentError: boolean;
    isDefault: boolean;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetFloatingIpV2ExternalSubnetVirtualSwitchLink[];
    /**
     * Metadata associated with this resource.
     */
    metadatas: outputs.GetFloatingIpV2ExternalSubnetVirtualSwitchMetadata[];
    mtu: number;
    /**
     * Name of the floating IP.
     */
    name: string;
    /**
     * A globally unique identifier that represents the tenant that owns this entity.
     */
    tenantId: string;
}

export interface GetFloatingIpV2ExternalSubnetVirtualSwitchCluster {
    /**
     * Floating IP UUID
     */
    extId: string;
    gatewayIpAddresses: outputs.GetFloatingIpV2ExternalSubnetVirtualSwitchClusterGatewayIpAddress[];
    hosts: outputs.GetFloatingIpV2ExternalSubnetVirtualSwitchClusterHost[];
}

export interface GetFloatingIpV2ExternalSubnetVirtualSwitchClusterGatewayIpAddress {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetVirtualSwitchClusterHost {
    /**
     * Floating IP UUID
     */
    extId: string;
    hostNics: string[];
    internalBridgeName: string;
    ipAddresses: outputs.GetFloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddress[];
    routeTable: number;
}

export interface GetFloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddress {
    ips: outputs.GetFloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressIp[];
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
}

export interface GetFloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetVirtualSwitchLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetFloatingIpV2ExternalSubnetVirtualSwitchMetadata {
    /**
     * A list of globally unique identifiers that represent all the categories the resource is associated with.
     */
    categoryIds: any[][];
    /**
     * A globally unique identifier that represents the owner of this resource.
     */
    ownerReferenceId: string;
    /**
     * The userName of the owner of this resource.
     */
    ownerUserName: string;
    /**
     * The name of the project this resource belongs to.
     */
    projectName: string;
    /**
     * A globally unique identifier that represents the project this resource belongs to.
     */
    projectReferenceId: string;
}

export interface GetFloatingIpV2ExternalSubnetVpc {
    commonDhcpOptions: outputs.GetFloatingIpV2ExternalSubnetVpcCommonDhcpOption[];
    /**
     * Description for the Floating IP.
     */
    description: string;
    /**
     * Floating IP UUID
     */
    extId: string;
    externalRoutingDomainReference: string;
    externalSubnets: outputs.GetFloatingIpV2ExternalSubnetVpcExternalSubnet[];
    externallyRoutablePrefixes: outputs.GetFloatingIpV2ExternalSubnetVpcExternallyRoutablePrefix[];
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetFloatingIpV2ExternalSubnetVpcLink[];
    /**
     * Metadata associated with this resource.
     */
    metadatas: outputs.GetFloatingIpV2ExternalSubnetVpcMetadata[];
    /**
     * Name of the floating IP.
     */
    name: string;
    snatIps: outputs.GetFloatingIpV2ExternalSubnetVpcSnatIp[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity.
     */
    tenantId: string;
    vpcType: string;
}

export interface GetFloatingIpV2ExternalSubnetVpcCommonDhcpOption {
    domainNameServers: outputs.GetFloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServer[];
}

export interface GetFloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServer {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv6[];
}

export interface GetFloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetVpcExternalSubnet {
    activeGatewayCount: number;
    activeGatewayNodes: outputs.GetFloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNode[];
    externalIps: outputs.GetFloatingIpV2ExternalSubnetVpcExternalSubnetExternalIp[];
    gatewayNodes: string[];
    subnetReference: string;
}

export interface GetFloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNode {
    nodeId: string;
    nodeIpAddresses: outputs.GetFloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddress[];
}

export interface GetFloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddress {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6[];
}

export interface GetFloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetVpcExternalSubnetExternalIp {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv6[];
}

export interface GetFloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetVpcExternallyRoutablePrefix {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6[];
}

export interface GetFloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4 {
    ips: outputs.GetFloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4Ip[];
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
}

export interface GetFloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4Ip {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6 {
    ips: outputs.GetFloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6Ip[];
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
}

export interface GetFloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6Ip {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetVpcLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetFloatingIpV2ExternalSubnetVpcMetadata {
    /**
     * A list of globally unique identifiers that represent all the categories the resource is associated with.
     */
    categoryIds: any[][];
    /**
     * A globally unique identifier that represents the owner of this resource.
     */
    ownerReferenceId: string;
    /**
     * The userName of the owner of this resource.
     */
    ownerUserName: string;
    /**
     * The name of the project this resource belongs to.
     */
    projectName: string;
    /**
     * A globally unique identifier that represents the project this resource belongs to.
     */
    projectReferenceId: string;
}

export interface GetFloatingIpV2ExternalSubnetVpcSnatIp {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpV2ExternalSubnetVpcSnatIpIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpV2ExternalSubnetVpcSnatIpIpv6[];
}

export interface GetFloatingIpV2ExternalSubnetVpcSnatIpIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2ExternalSubnetVpcSnatIpIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2FloatingIp {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpV2FloatingIpIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpV2FloatingIpIpv6[];
}

export interface GetFloatingIpV2FloatingIpIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2FloatingIpIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2Link {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetFloatingIpV2Metadata {
    /**
     * A list of globally unique identifiers that represent all the categories the resource is associated with.
     */
    categoryIds: any[][];
    /**
     * A globally unique identifier that represents the owner of this resource.
     */
    ownerReferenceId: string;
    /**
     * The userName of the owner of this resource.
     */
    ownerUserName: string;
    /**
     * The name of the project this resource belongs to.
     */
    projectName: string;
    /**
     * A globally unique identifier that represents the project this resource belongs to.
     */
    projectReferenceId: string;
}

export interface GetFloatingIpV2VmNic {
    /**
     * Private IP value in string
     */
    privateIp: string;
}

export interface GetFloatingIpV2Vpc {
    commonDhcpOptions: outputs.GetFloatingIpV2VpcCommonDhcpOption[];
    /**
     * Description for the Floating IP.
     */
    description: string;
    /**
     * Floating IP UUID
     */
    extId: string;
    externalRoutingDomainReference: string;
    externalSubnets: outputs.GetFloatingIpV2VpcExternalSubnet[];
    externallyRoutablePrefixes: outputs.GetFloatingIpV2VpcExternallyRoutablePrefix[];
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetFloatingIpV2VpcLink[];
    /**
     * Metadata associated with this resource.
     */
    metadatas: outputs.GetFloatingIpV2VpcMetadata[];
    /**
     * Name of the floating IP.
     */
    name: string;
    snatIps: outputs.GetFloatingIpV2VpcSnatIp[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity.
     */
    tenantId: string;
    vpcType: string;
}

export interface GetFloatingIpV2VpcCommonDhcpOption {
    domainNameServers: outputs.GetFloatingIpV2VpcCommonDhcpOptionDomainNameServer[];
}

export interface GetFloatingIpV2VpcCommonDhcpOptionDomainNameServer {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv6[];
}

export interface GetFloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2VpcExternalSubnet {
    activeGatewayCount: number;
    activeGatewayNodes: outputs.GetFloatingIpV2VpcExternalSubnetActiveGatewayNode[];
    externalIps: outputs.GetFloatingIpV2VpcExternalSubnetExternalIp[];
    gatewayNodes: string[];
    subnetReference: string;
}

export interface GetFloatingIpV2VpcExternalSubnetActiveGatewayNode {
    nodeId: string;
    nodeIpAddresses: outputs.GetFloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddress[];
}

export interface GetFloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddress {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6[];
}

export interface GetFloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2VpcExternalSubnetExternalIp {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpV2VpcExternalSubnetExternalIpIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpV2VpcExternalSubnetExternalIpIpv6[];
}

export interface GetFloatingIpV2VpcExternalSubnetExternalIpIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2VpcExternalSubnetExternalIpIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2VpcExternallyRoutablePrefix {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpV2VpcExternallyRoutablePrefixIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpV2VpcExternallyRoutablePrefixIpv6[];
}

export interface GetFloatingIpV2VpcExternallyRoutablePrefixIpv4 {
    ips: outputs.GetFloatingIpV2VpcExternallyRoutablePrefixIpv4Ip[];
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
}

export interface GetFloatingIpV2VpcExternallyRoutablePrefixIpv4Ip {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2VpcExternallyRoutablePrefixIpv6 {
    ips: outputs.GetFloatingIpV2VpcExternallyRoutablePrefixIpv6Ip[];
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
}

export interface GetFloatingIpV2VpcExternallyRoutablePrefixIpv6Ip {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2VpcLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetFloatingIpV2VpcMetadata {
    /**
     * A list of globally unique identifiers that represent all the categories the resource is associated with.
     */
    categoryIds: any[][];
    /**
     * A globally unique identifier that represents the owner of this resource.
     */
    ownerReferenceId: string;
    /**
     * The userName of the owner of this resource.
     */
    ownerUserName: string;
    /**
     * The name of the project this resource belongs to.
     */
    projectName: string;
    /**
     * A globally unique identifier that represents the project this resource belongs to.
     */
    projectReferenceId: string;
}

export interface GetFloatingIpV2VpcSnatIp {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpV2VpcSnatIpIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpV2VpcSnatIpIpv6[];
}

export interface GetFloatingIpV2VpcSnatIpIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpV2VpcSnatIpIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsEntity {
    /**
     * - The floatingIp kind metadata.
     */
    metadata: {[key: string]: string};
    /**
     * Floating IP spec
     */
    specs: outputs.GetFloatingIpsEntitySpec[];
    /**
     * Floating IP output status
     */
    statuses: outputs.GetFloatingIpsEntityStatus[];
}

export interface GetFloatingIpsEntitySpec {
    /**
     * Floating IP allocation status.
     */
    resources: outputs.GetFloatingIpsEntitySpecResource[];
}

export interface GetFloatingIpsEntitySpecResource {
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a vm_nic
     */
    vmNicReference: {[key: string]: string};
    /**
     * The reference to a vpc
     */
    vpcReference: {[key: string]: string};
}

export interface GetFloatingIpsEntityStatus {
    /**
     * Execution Context of Floating IP.
     */
    executionContexts: outputs.GetFloatingIpsEntityStatusExecutionContext[];
    /**
     * - the name.
     */
    name: string;
    /**
     * Floating IP allocation status.
     */
    resources: outputs.GetFloatingIpsEntityStatusResource[];
    /**
     * The state of the floating_ip.
     */
    state: string;
}

export interface GetFloatingIpsEntityStatusExecutionContext {
    taskUuids: string[];
}

export interface GetFloatingIpsEntityStatusResource {
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * Private IP with which the floating IP is associated.
     */
    floatingIp: string;
    /**
     * The reference to a vm_nic
     */
    vmNicReference: {[key: string]: string};
    /**
     * The reference to a vpc
     */
    vpcReference: {[key: string]: string};
}

export interface GetFloatingIpsMetadata {
    filter: string;
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
    totalMatches: number;
}

export interface GetFloatingIpsV2FloatingIp {
    /**
     * Association status of floating IP.
     */
    associationStatus: string;
    /**
     * Association of the Floating IP with either NIC or Private IP
     */
    associations: outputs.GetFloatingIpsV2FloatingIpAssociation[];
    /**
     * Description for the Floating IP.
     */
    description: string;
    /**
     * Floating IP UUID
     */
    extId: string;
    /**
     * External subnet reference for the Floating IP to be allocated in on-prem only.
     */
    externalSubnetReference: string;
    /**
     * Networking common base object
     */
    externalSubnets: outputs.GetFloatingIpsV2FloatingIpExternalSubnet[];
    /**
     * Floating IP value in string
     */
    floatingIpValue: string;
    /**
     * Floating IP address.
     */
    floatingIps: outputs.GetFloatingIpsV2FloatingIpFloatingIp[];
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetFloatingIpsV2FloatingIpLink[];
    /**
     * Metadata associated with this resource.
     */
    metadatas: outputs.GetFloatingIpsV2FloatingIpMetadata[];
    /**
     * Name of the floating IP.
     */
    name: string;
    /**
     * Private IP value in string
     */
    privateIp: string;
    /**
     * A globally unique identifier that represents the tenant that owns this entity.
     */
    tenantId: string;
    /**
     * VM NIC reference.
     */
    vmNicReference: string;
    /**
     * Virtual NIC for projections
     */
    vmNics: outputs.GetFloatingIpsV2FloatingIpVmNic[];
    /**
     * VPC reference UUID
     */
    vpcReference: string;
    /**
     * Networking common base object
     */
    vpcs: outputs.GetFloatingIpsV2FloatingIpVpc[];
}

export interface GetFloatingIpsV2FloatingIpAssociation {
    /**
     * Association of Floating IP with private IP
     */
    privateIpAssociations: outputs.GetFloatingIpsV2FloatingIpAssociationPrivateIpAssociation[];
    /**
     * Association of Floating IP with nic
     */
    vmNicAssociations: outputs.GetFloatingIpsV2FloatingIpAssociationVmNicAssociation[];
}

export interface GetFloatingIpsV2FloatingIpAssociationPrivateIpAssociation {
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    privateIps: outputs.GetFloatingIpsV2FloatingIpAssociationPrivateIpAssociationPrivateIp[];
    /**
     * VPC in which the private IP exists.
     */
    vpcReference: string;
}

export interface GetFloatingIpsV2FloatingIpAssociationPrivateIpAssociationPrivateIp {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpsV2FloatingIpAssociationPrivateIpAssociationPrivateIpIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpsV2FloatingIpAssociationPrivateIpAssociationPrivateIpIpv6[];
}

export interface GetFloatingIpsV2FloatingIpAssociationPrivateIpAssociationPrivateIpIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpAssociationPrivateIpAssociationPrivateIpIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpAssociationVmNicAssociation {
    /**
     * VM NIC reference.
     */
    vmNicReference: string;
    /**
     * VPC reference to which the VM NIC subnet belongs.
     */
    vpcReference: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnet {
    bridgeName: string;
    clusterName: string;
    clusterReference: string;
    /**
     * Description for the Floating IP.
     */
    description: string;
    dhcpOptions: outputs.GetFloatingIpsV2FloatingIpExternalSubnetDhcpOption[];
    dynamicIpAddresses: outputs.GetFloatingIpsV2FloatingIpExternalSubnetDynamicIpAddress[];
    /**
     * Floating IP UUID
     */
    extId: string;
    hypervisorType: string;
    ipConfigs: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpConfig[];
    ipPrefix: string;
    ipUsages: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpUsage[];
    isAdvancedNetworking: boolean;
    isExternal: boolean;
    isNatEnabled: boolean;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetFloatingIpsV2FloatingIpExternalSubnetLink[];
    migrationState: string;
    /**
     * Name of the floating IP.
     */
    name: string;
    networkFunctionChainReference: string;
    networkId: number;
    reservedIpAddresses: outputs.GetFloatingIpsV2FloatingIpExternalSubnetReservedIpAddress[];
    subnetType: string;
    virtualSwitchReference: string;
    virtualSwitches: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVirtualSwitch[];
    /**
     * VPC reference UUID
     */
    vpcReference: string;
    /**
     * Networking common base object
     */
    vpcs: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpc[];
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetDhcpOption {
    bootFileName: string;
    domainName: string;
    domainNameServers: outputs.GetFloatingIpsV2FloatingIpExternalSubnetDhcpOptionDomainNameServer[];
    ntpServers: outputs.GetFloatingIpsV2FloatingIpExternalSubnetDhcpOptionNtpServer[];
    searchDomains: string[];
    tftpServerName: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetDhcpOptionDomainNameServer {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpsV2FloatingIpExternalSubnetDhcpOptionDomainNameServerIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpsV2FloatingIpExternalSubnetDhcpOptionDomainNameServerIpv6[];
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetDhcpOptionDomainNameServerIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetDhcpOptionDomainNameServerIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetDhcpOptionNtpServer {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpsV2FloatingIpExternalSubnetDhcpOptionNtpServerIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpsV2FloatingIpExternalSubnetDhcpOptionNtpServerIpv6[];
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetDhcpOptionNtpServerIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetDhcpOptionNtpServerIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetDynamicIpAddress {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpsV2FloatingIpExternalSubnetDynamicIpAddressIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpsV2FloatingIpExternalSubnetDynamicIpAddressIpv6[];
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetDynamicIpAddressIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetDynamicIpAddressIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpConfig {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv6[];
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv4 {
    defaultGatewayIps: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv4DefaultGatewayIp[];
    dhcpServerAddresses: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv4DhcpServerAddress[];
    ipSubnets: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv4IpSubnet[];
    poolLists: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv4PoolList[];
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv4DefaultGatewayIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv4DhcpServerAddress {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv4IpSubnet {
    ips: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv4IpSubnetIp[];
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv4IpSubnetIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv4PoolList {
    endIps: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv4PoolListEndIp[];
    startIps: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv4PoolListStartIp[];
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv4PoolListEndIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv4PoolListStartIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv6 {
    defaultGatewayIps: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv6DefaultGatewayIp[];
    dhcpServerAddresses: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv6DhcpServerAddress[];
    ipSubnets: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv6IpSubnet[];
    poolLists: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv6PoolList[];
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv6DefaultGatewayIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv6DhcpServerAddress {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv6IpSubnet {
    ips: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv6IpSubnetIp[];
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv6IpSubnetIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv6PoolList {
    endIps: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv6PoolListEndIp[];
    startIps: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv6PoolListStartIp[];
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv6PoolListEndIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpConfigIpv6PoolListStartIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpUsage {
    ipPoolUsages: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpUsageIpPoolUsage[];
    numAssignedIps: number;
    numFreeIps: number;
    numMacs: number;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpUsageIpPoolUsage {
    numFreeIps: number;
    numTotalIps: number;
    ranges: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpUsageIpPoolUsageRange[];
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpUsageIpPoolUsageRange {
    endIps: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpUsageIpPoolUsageRangeEndIp[];
    startIps: outputs.GetFloatingIpsV2FloatingIpExternalSubnetIpUsageIpPoolUsageRangeStartIp[];
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpUsageIpPoolUsageRangeEndIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetIpUsageIpPoolUsageRangeStartIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetReservedIpAddress {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVirtualSwitch {
    bondMode: boolean;
    clusters: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVirtualSwitchCluster[];
    /**
     * Description for the Floating IP.
     */
    description: string;
    /**
     * Floating IP UUID
     */
    extId: string;
    hasDeploymentError: boolean;
    isDefault: boolean;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVirtualSwitchLink[];
    /**
     * Metadata associated with this resource.
     */
    metadatas: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVirtualSwitchMetadata[];
    mtu: number;
    /**
     * Name of the floating IP.
     */
    name: string;
    /**
     * A globally unique identifier that represents the tenant that owns this entity.
     */
    tenantId: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVirtualSwitchCluster {
    /**
     * Floating IP UUID
     */
    extId: string;
    gatewayIpAddresses: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVirtualSwitchClusterGatewayIpAddress[];
    hosts: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVirtualSwitchClusterHost[];
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVirtualSwitchClusterGatewayIpAddress {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVirtualSwitchClusterHost {
    /**
     * Floating IP UUID
     */
    extId: string;
    hostNics: string[];
    internalBridgeName: string;
    ipAddresses: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVirtualSwitchClusterHostIpAddress[];
    routeTable: number;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVirtualSwitchClusterHostIpAddress {
    ips: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVirtualSwitchClusterHostIpAddressIp[];
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVirtualSwitchClusterHostIpAddressIp {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVirtualSwitchLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVirtualSwitchMetadata {
    /**
     * A list of globally unique identifiers that represent all the categories the resource is associated with.
     */
    categoryIds: any[][];
    /**
     * A globally unique identifier that represents the owner of this resource.
     */
    ownerReferenceId: string;
    /**
     * The userName of the owner of this resource.
     */
    ownerUserName: string;
    /**
     * The name of the project this resource belongs to.
     */
    projectName: string;
    /**
     * A globally unique identifier that represents the project this resource belongs to.
     */
    projectReferenceId: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpc {
    commonDhcpOptions: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcCommonDhcpOption[];
    /**
     * Description for the Floating IP.
     */
    description: string;
    /**
     * Floating IP UUID
     */
    extId: string;
    externalRoutingDomainReference: string;
    externalSubnets: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcExternalSubnet[];
    externallyRoutablePrefixes: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcExternallyRoutablePrefix[];
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcLink[];
    /**
     * Metadata associated with this resource.
     */
    metadatas: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcMetadata[];
    /**
     * Name of the floating IP.
     */
    name: string;
    snatIps: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcSnatIp[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity.
     */
    tenantId: string;
    vpcType: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcCommonDhcpOption {
    domainNameServers: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcCommonDhcpOptionDomainNameServer[];
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcCommonDhcpOptionDomainNameServer {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv6[];
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcExternalSubnet {
    activeGatewayCount: number;
    activeGatewayNodes: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcExternalSubnetActiveGatewayNode[];
    externalIps: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcExternalSubnetExternalIp[];
    gatewayNodes: string[];
    subnetReference: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcExternalSubnetActiveGatewayNode {
    nodeId: string;
    nodeIpAddresses: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddress[];
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddress {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6[];
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcExternalSubnetExternalIp {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcExternalSubnetExternalIpIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcExternalSubnetExternalIpIpv6[];
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcExternalSubnetExternalIpIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcExternalSubnetExternalIpIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcExternallyRoutablePrefix {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcExternallyRoutablePrefixIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcExternallyRoutablePrefixIpv6[];
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcExternallyRoutablePrefixIpv4 {
    ips: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcExternallyRoutablePrefixIpv4Ip[];
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcExternallyRoutablePrefixIpv4Ip {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcExternallyRoutablePrefixIpv6 {
    ips: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcExternallyRoutablePrefixIpv6Ip[];
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcExternallyRoutablePrefixIpv6Ip {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcMetadata {
    /**
     * A list of globally unique identifiers that represent all the categories the resource is associated with.
     */
    categoryIds: any[][];
    /**
     * A globally unique identifier that represents the owner of this resource.
     */
    ownerReferenceId: string;
    /**
     * The userName of the owner of this resource.
     */
    ownerUserName: string;
    /**
     * The name of the project this resource belongs to.
     */
    projectName: string;
    /**
     * A globally unique identifier that represents the project this resource belongs to.
     */
    projectReferenceId: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcSnatIp {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcSnatIpIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpsV2FloatingIpExternalSubnetVpcSnatIpIpv6[];
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcSnatIpIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpExternalSubnetVpcSnatIpIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpFloatingIp {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpsV2FloatingIpFloatingIpIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpsV2FloatingIpFloatingIpIpv6[];
}

export interface GetFloatingIpsV2FloatingIpFloatingIpIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpFloatingIpIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetFloatingIpsV2FloatingIpMetadata {
    /**
     * A list of globally unique identifiers that represent all the categories the resource is associated with.
     */
    categoryIds: any[][];
    /**
     * A globally unique identifier that represents the owner of this resource.
     */
    ownerReferenceId: string;
    /**
     * The userName of the owner of this resource.
     */
    ownerUserName: string;
    /**
     * The name of the project this resource belongs to.
     */
    projectName: string;
    /**
     * A globally unique identifier that represents the project this resource belongs to.
     */
    projectReferenceId: string;
}

export interface GetFloatingIpsV2FloatingIpVmNic {
    /**
     * Private IP value in string
     */
    privateIp: string;
}

export interface GetFloatingIpsV2FloatingIpVpc {
    commonDhcpOptions: outputs.GetFloatingIpsV2FloatingIpVpcCommonDhcpOption[];
    /**
     * Description for the Floating IP.
     */
    description: string;
    /**
     * Floating IP UUID
     */
    extId: string;
    externalRoutingDomainReference: string;
    externalSubnets: outputs.GetFloatingIpsV2FloatingIpVpcExternalSubnet[];
    externallyRoutablePrefixes: outputs.GetFloatingIpsV2FloatingIpVpcExternallyRoutablePrefix[];
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetFloatingIpsV2FloatingIpVpcLink[];
    /**
     * Metadata associated with this resource.
     */
    metadatas: outputs.GetFloatingIpsV2FloatingIpVpcMetadata[];
    /**
     * Name of the floating IP.
     */
    name: string;
    snatIps: outputs.GetFloatingIpsV2FloatingIpVpcSnatIp[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity.
     */
    tenantId: string;
    vpcType: string;
}

export interface GetFloatingIpsV2FloatingIpVpcCommonDhcpOption {
    domainNameServers: outputs.GetFloatingIpsV2FloatingIpVpcCommonDhcpOptionDomainNameServer[];
}

export interface GetFloatingIpsV2FloatingIpVpcCommonDhcpOptionDomainNameServer {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpsV2FloatingIpVpcCommonDhcpOptionDomainNameServerIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpsV2FloatingIpVpcCommonDhcpOptionDomainNameServerIpv6[];
}

export interface GetFloatingIpsV2FloatingIpVpcCommonDhcpOptionDomainNameServerIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpVpcCommonDhcpOptionDomainNameServerIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpVpcExternalSubnet {
    activeGatewayCount: number;
    activeGatewayNodes: outputs.GetFloatingIpsV2FloatingIpVpcExternalSubnetActiveGatewayNode[];
    externalIps: outputs.GetFloatingIpsV2FloatingIpVpcExternalSubnetExternalIp[];
    gatewayNodes: string[];
    subnetReference: string;
}

export interface GetFloatingIpsV2FloatingIpVpcExternalSubnetActiveGatewayNode {
    nodeId: string;
    nodeIpAddresses: outputs.GetFloatingIpsV2FloatingIpVpcExternalSubnetActiveGatewayNodeNodeIpAddress[];
}

export interface GetFloatingIpsV2FloatingIpVpcExternalSubnetActiveGatewayNodeNodeIpAddress {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpsV2FloatingIpVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpsV2FloatingIpVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6[];
}

export interface GetFloatingIpsV2FloatingIpVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpVpcExternalSubnetExternalIp {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpsV2FloatingIpVpcExternalSubnetExternalIpIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpsV2FloatingIpVpcExternalSubnetExternalIpIpv6[];
}

export interface GetFloatingIpsV2FloatingIpVpcExternalSubnetExternalIpIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpVpcExternalSubnetExternalIpIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpVpcExternallyRoutablePrefix {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpsV2FloatingIpVpcExternallyRoutablePrefixIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpsV2FloatingIpVpcExternallyRoutablePrefixIpv6[];
}

export interface GetFloatingIpsV2FloatingIpVpcExternallyRoutablePrefixIpv4 {
    ips: outputs.GetFloatingIpsV2FloatingIpVpcExternallyRoutablePrefixIpv4Ip[];
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
}

export interface GetFloatingIpsV2FloatingIpVpcExternallyRoutablePrefixIpv4Ip {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpVpcExternallyRoutablePrefixIpv6 {
    ips: outputs.GetFloatingIpsV2FloatingIpVpcExternallyRoutablePrefixIpv6Ip[];
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
}

export interface GetFloatingIpsV2FloatingIpVpcExternallyRoutablePrefixIpv6Ip {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpVpcLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetFloatingIpsV2FloatingIpVpcMetadata {
    /**
     * A list of globally unique identifiers that represent all the categories the resource is associated with.
     */
    categoryIds: any[][];
    /**
     * A globally unique identifier that represents the owner of this resource.
     */
    ownerReferenceId: string;
    /**
     * The userName of the owner of this resource.
     */
    ownerUserName: string;
    /**
     * The name of the project this resource belongs to.
     */
    projectName: string;
    /**
     * A globally unique identifier that represents the project this resource belongs to.
     */
    projectReferenceId: string;
}

export interface GetFloatingIpsV2FloatingIpVpcSnatIp {
    /**
     * Reference to IP Configuration
     */
    ipv4s: outputs.GetFloatingIpsV2FloatingIpVpcSnatIpIpv4[];
    /**
     * Reference to IP Configuration
     */
    ipv6s: outputs.GetFloatingIpsV2FloatingIpVpcSnatIpIpv6[];
}

export interface GetFloatingIpsV2FloatingIpVpcSnatIpIpv4 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFloatingIpsV2FloatingIpVpcSnatIpIpv6 {
    /**
     * Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetFoundationCentralClusterDetailsClusterStatus {
    /**
     * Overall progress percentage including imaging and cluster creation.
     */
    aggregatePercentComplete: number;
    /**
     * Denotes whether cluster creation has started in a phoenix workflow. For foundation workflows, this field will be same as intent_picked_up.
     */
    clusterCreationStarted: boolean;
    /**
     * Denotes the progress status of cluster creation.
     */
    clusterProgressDetails: outputs.GetFoundationCentralClusterDetailsClusterStatusClusterProgressDetail[];
    /**
     * Current IP address of the coordinating foundation node.
     */
    currentFoundationIp: string;
    /**
     * Foundation session id for cluster creation.
     */
    foundationSessionId: string;
    /**
     * Describes whether imaging has stopped. True indicates that process has stopped. False indicates that process is still going on. This field will only be used by phoenix nodes to update FC.
     */
    imagingStopped: boolean;
    /**
     * Denotes whether the remote nodes has picked up the cluster creation intent.
     */
    intentPickedUp: boolean;
    /**
     * List of progress details of each node.
     */
    nodeProgressDetails: outputs.GetFoundationCentralClusterDetailsClusterStatusNodeProgressDetail[];
}

export interface GetFoundationCentralClusterDetailsClusterStatusClusterProgressDetail {
    /**
     * Cluster name.
     */
    clusterName: string;
    /**
     * List of messages for the client based on process state.
     */
    messageLists: string[];
    /**
     * Percent completion of cluster creation process.
     */
    percentComplete: number;
    /**
     * Current status of cluster creation process.
     */
    status: string;
}

export interface GetFoundationCentralClusterDetailsClusterStatusNodeProgressDetail {
    /**
     * UUID of the node.
     */
    imagedNodeUuid: string;
    /**
     * Describes whether imaging has stopped. True indicates that process has stopped. False indicates that process is still going on. This field will only be used by phoenix nodes to update FC.
     */
    imagingStopped: boolean;
    /**
     * Denotes whether the remote nodes has picked up the cluster creation intent.
     */
    intentPickedUp: boolean;
    /**
     * List of messages for the client based on process state.
     */
    messageLists: string[];
    /**
     * Percent completion of cluster creation process.
     */
    percentComplete: number;
    /**
     * Current status of cluster creation process.
     */
    status: string;
}

export interface GetFoundationCentralClusterDetailsCommonNetworkSettings {
    /**
     * List of dns servers for the cvms in the cluster.
     */
    cvmDnsServers: string[];
    /**
     * List of ntp servers for the cvms in the cluster.
     */
    cvmNtpServers: string[];
    /**
     * List of dns servers for the hypervisors in the cluster.
     */
    hypervisorDnsServers: string[];
    /**
     * List of ntp servers for the hypervisors in the cluster.
     */
    hypervisorNtpServers: string[];
}

export interface GetFoundationCentralClusterDetailsFoundationInitConfig {
    blocks: outputs.GetFoundationCentralClusterDetailsFoundationInitConfigBlock[];
    clusters: outputs.GetFoundationCentralClusterDetailsFoundationInitConfigCluster[];
    cvmGateway: string;
    cvmNetmask: string;
    dnsServers: string;
    hypervProductKey: string;
    hypervSku: string;
    hypervisorGateway: string;
    hypervisorIsoUrl: {[key: string]: string};
    hypervisorIsos: outputs.GetFoundationCentralClusterDetailsFoundationInitConfigHypervisorIso[];
    hypervisorNetmask: string;
    ipmiGateway: string;
    ipmiNetmask: string;
    nosPackageUrls: outputs.GetFoundationCentralClusterDetailsFoundationInitConfigNosPackageUrl[];
}

export interface GetFoundationCentralClusterDetailsFoundationInitConfigBlock {
    blockId: string;
    nodes: outputs.GetFoundationCentralClusterDetailsFoundationInitConfigBlockNode[];
}

export interface GetFoundationCentralClusterDetailsFoundationInitConfigBlockNode {
    cvmIp: string;
    cvmVlanId: number;
    fcImagedNodeUuid: string;
    hardwareAttributesOverride: {[key: string]: string};
    hypervisor: string;
    hypervisorHostname: string;
    hypervisorIp: string;
    imageNow: boolean;
    ipmiIp: string;
    ipv6Address: string;
    nodePosition: string;
    nodeSerial: string;
}

export interface GetFoundationCentralClusterDetailsFoundationInitConfigCluster {
    /**
     * External management ip of the cluster.
     */
    clusterExternalIp: string;
    clusterInitNow: boolean;
    clusterInitSuccessful: boolean;
    clusterMembers: string[];
    /**
     * Cluster name.
     */
    clusterName: string;
    /**
     * List of dns servers for the cvms in the cluster.
     */
    cvmDnsServers: string;
    /**
     * List of ntp servers for the cvms in the cluster.
     */
    cvmNtpServers: string;
    /**
     * Redundancy factor of the cluster.
     */
    redundancyFactor: number;
    timezone: string;
}

export interface GetFoundationCentralClusterDetailsFoundationInitConfigHypervisorIso {
    hypervisorType: string;
    sha256sum: string;
    url: string;
}

export interface GetFoundationCentralClusterDetailsFoundationInitConfigNosPackageUrl {
    sha256sum: string;
    url: string;
}

export interface GetFoundationCentralImagedClustersListFilters {
    /**
     * True if the cluster creation request is archived, False otherwise
     */
    archived?: boolean;
}

export interface GetFoundationCentralImagedClustersListImagedCluster {
    /**
     * True if the cluster creation request is archived, False otherwise
     */
    archived: boolean;
    /**
     * External management ip of the cluster.
     */
    clusterExternalIp: string;
    /**
     * Cluster name.
     */
    clusterName: string;
    /**
     * Number of nodes in the cluster.
     */
    clusterSize: number;
    /**
     * Details of cluster creation process.
     */
    clusterStatus: outputs.GetFoundationCentralImagedClustersListImagedClusterClusterStatus;
    /**
     * Common network settings across the nodes in the cluster.
     */
    commonNetworkSettings: outputs.GetFoundationCentralImagedClustersListImagedClusterCommonNetworkSettings;
    /**
     * Time when the cluster creation request was received in Foundation Central.
     */
    createdTimestamp: string;
    /**
     * Current time of Foundation Central.
     */
    currentTime: string;
    /**
     * True if the cluster is destroyed, False otherwise
     */
    destroyed: boolean;
    /**
     * Json config used by Foundation to create the cluster.
     */
    foundationInitConfigs: outputs.GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfig[];
    /**
     * UUID of the first node coordinating cluster creation.
     */
    foundationInitNodeUuid: string;
    /**
     * UUID of the cluster.
     */
    imagedClusterUuid: string;
    /**
     * List of UUIDs of imaged nodes.
     */
    imagedNodeUuidLists: string[];
    /**
     * Redundancy factor of the cluster.
     */
    redundancyFactor?: number;
    /**
     * Number of storage only nodes in the cluster. AHV iso for storage node will be taken from aos package.
     */
    storageNodeCount: number;
    /**
     * If imaging and cluster creation is coordinated by Foundation, value will be FOUNDATION_WF. If the nodes are in phoenix, value will be PHOENIX_WF.
     */
    workflowType: string;
}

export interface GetFoundationCentralImagedClustersListImagedClusterClusterStatus {
    /**
     * Overall progress percentage including imaging and cluster creation.
     */
    aggregatePercentComplete: number;
    /**
     * Denotes whether cluster creation has started in a phoenix workflow. For foundation workflows, this field will be same as intent_picked_up.
     */
    clusterCreationStarted: boolean;
    /**
     * Denotes the progress status of cluster creation.
     */
    clusterProgressDetails: outputs.GetFoundationCentralImagedClustersListImagedClusterClusterStatusClusterProgressDetail[];
    /**
     * Current IP address of the coordinating foundation node.
     */
    currentFoundationIp: string;
    /**
     * Foundation session id for cluster creation.
     */
    foundationSessionId: string;
    /**
     * Describes whether imaging has stopped. True indicates that process has stopped. False indicates that process is still going on. This field will only be used by phoenix nodes to update FC.
     */
    imagingStopped: boolean;
    /**
     * Denotes whether the remote nodes has picked up the cluster creation intent.
     */
    intentPickedUp: boolean;
    /**
     * List of progress details of each node.
     */
    nodeProgressDetails: outputs.GetFoundationCentralImagedClustersListImagedClusterClusterStatusNodeProgressDetail[];
}

export interface GetFoundationCentralImagedClustersListImagedClusterClusterStatusClusterProgressDetail {
    /**
     * Cluster name.
     */
    clusterName: string;
    /**
     * List of messages for the client based on process state.
     */
    messageLists: string[];
    /**
     * Percent completion of cluster creation process.
     */
    percentComplete: number;
    /**
     * Current status of cluster creation process.
     */
    status: string;
}

export interface GetFoundationCentralImagedClustersListImagedClusterClusterStatusNodeProgressDetail {
    /**
     * UUID of the node.
     */
    imagedNodeUuid: string;
    /**
     * Describes whether imaging has stopped. True indicates that process has stopped. False indicates that process is still going on. This field will only be used by phoenix nodes to update FC.
     */
    imagingStopped: boolean;
    /**
     * Denotes whether the remote nodes has picked up the cluster creation intent.
     */
    intentPickedUp: boolean;
    /**
     * List of messages for the client based on process state.
     */
    messageLists: string[];
    /**
     * Percent completion of cluster creation process.
     */
    percentComplete: number;
    /**
     * Current status of cluster creation process.
     */
    status: string;
}

export interface GetFoundationCentralImagedClustersListImagedClusterCommonNetworkSettings {
    /**
     * List of dns servers for the cvms in the cluster.
     */
    cvmDnsServers: string[];
    /**
     * List of ntp servers for the cvms in the cluster.
     */
    cvmNtpServers: string[];
    /**
     * List of dns servers for the hypervisors in the cluster.
     */
    hypervisorDnsServers: string[];
    /**
     * List of ntp servers for the hypervisors in the cluster.
     */
    hypervisorNtpServers: string[];
}

export interface GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfig {
    blocks: outputs.GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigBlock[];
    clusters: outputs.GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigCluster[];
    cvmGateway: string;
    cvmNetmask: string;
    dnsServers: string;
    hypervProductKey: string;
    hypervSku: string;
    hypervisorGateway: string;
    hypervisorIsoUrl: {[key: string]: string};
    hypervisorIsos: outputs.GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigHypervisorIso[];
    hypervisorNetmask: string;
    ipmiGateway: string;
    ipmiNetmask: string;
    nosPackageUrls: outputs.GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigNosPackageUrl[];
}

export interface GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigBlock {
    blockId: string;
    nodes: outputs.GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigBlockNode[];
}

export interface GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigBlockNode {
    cvmIp: string;
    cvmVlanId: number;
    fcImagedNodeUuid: string;
    hardwareAttributesOverride: {[key: string]: string};
    hypervisor: string;
    hypervisorHostname: string;
    hypervisorIp: string;
    imageNow: boolean;
    ipmiIp: string;
    ipv6Address: string;
    nodePosition: string;
    nodeSerial: string;
}

export interface GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigCluster {
    /**
     * External management ip of the cluster.
     */
    clusterExternalIp: string;
    clusterInitNow: boolean;
    clusterInitSuccessful: boolean;
    clusterMembers: string[];
    /**
     * Cluster name.
     */
    clusterName: string;
    /**
     * List of dns servers for the cvms in the cluster.
     */
    cvmDnsServers: string;
    /**
     * List of ntp servers for the cvms in the cluster.
     */
    cvmNtpServers: string;
    /**
     * Redundancy factor of the cluster.
     */
    redundancyFactor: number;
    timezone: string;
}

export interface GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigHypervisorIso {
    hypervisorType: string;
    sha256sum: string;
    url: string;
}

export interface GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigNosPackageUrl {
    sha256sum: string;
    url: string;
}

export interface GetFoundationCentralImagedClustersListMetadata {
    /**
     * The number of records retrieved.
     */
    length: number;
    /**
     * Offset from the start of the object list.
     */
    offset: number;
    /**
     * Total matches found.
     */
    totalMatches: number;
}

export interface GetFoundationCentralImagedNodesListFilters {
    /**
     * Specifies whether the node is discovering, available or unavailable for cluster creation.
     */
    nodeState?: string;
}

export interface GetFoundationCentralImagedNodesListImagedNode {
    /**
     * AOS version currently installed on the node.
     */
    aosVersion: string;
    /**
     * API key used to register the node.
     */
    apiKeyUuid: string;
    /**
     * Specifies whether the node is available for cluster creation.
     */
    available: boolean;
    /**
     * Serial number of the block to which the node belongs.
     */
    blockSerial: string;
    /**
     * Time when the node was discovered in Foundation Central.
     */
    createdTimestamp: string;
    /**
     * Current time of Foundation Central.
     */
    currentTime: string;
    /**
     * gateway of the cvm.
     */
    cvmGateway: string;
    /**
     * IP address of the cvm.
     */
    cvmIp: string;
    /**
     * IPv6 address of the cvm.
     */
    cvmIpv6: string;
    /**
     * netmask of the cvm.
     */
    cvmNetmask: string;
    /**
     * Denotes whether the CVM is up or not on this node.
     */
    cvmUp: boolean;
    /**
     * Node UUID from the node's cvm.
     */
    cvmUuid: string;
    /**
     * Vlan tag of the cvm, if the cvm is on a vlan.
     */
    cvmVlanId: number;
    /**
     * Foundation version installed on the node.
     */
    foundationVersion: string;
    /**
     * Hardware attributes json of the node.
     */
    hardwareAttributes: {[key: string]: string};
    /**
     * gateway of the hypervisor.
     */
    hypervisorGateway: string;
    /**
     * Name of the hypervisor host.
     */
    hypervisorHostname: string;
    /**
     * IP address of the hypervisor.
     */
    hypervisorIp: string;
    /**
     * netmask of the hypervisor.
     */
    hypervisorNetmask: string;
    /**
     * Hypervisor type currently installed on the node. Must be one of {kvm, esx, hyperv}.
     */
    hypervisorType: string;
    /**
     * Version of the hypervisor currently installed on the node.
     */
    hypervisorVersion: string;
    /**
     * UUID of the cluster to which the node belongs, if any.
     */
    imagedClusterUuid: string;
    /**
     * UUID of the node.
     */
    imagedNodeUuid: string;
    /**
     * gateway of the ipmi.
     */
    ipmiGateway: string;
    /**
     * IP address of the ipmi.
     */
    ipmiIp: string;
    /**
     * netmask of the ipmi.
     */
    ipmiNetmask: string;
    /**
     * Name of the cvm interface having ipv6 address.
     */
    ipv6Interface: string;
    /**
     * List of timestamps when the node has sent heartbeats to Foundation Central.
     */
    latestHbTsLists: string[];
    /**
     * Model of the node.
     */
    model: string;
    /**
     * Position of the node in the block.
     */
    nodePosition: string;
    /**
     * Serial number of the node.
     */
    nodeSerial: string;
    /**
     * Specifies whether the node is discovering, available or unavailable for cluster creation.
     */
    nodeState: string;
    /**
     * Specifies the type of node - on-prem, AWS, GCP etc.
     */
    nodeType: string;
    /**
     * Version of the node used for CAS.
     */
    objectVersion: number;
    supportedFeatures: string[];
}

export interface GetFoundationCentralImagedNodesListMetadata {
    /**
     * The number of records retrieved.
     */
    length: number;
    /**
     * Offset from the start of the object list.
     */
    offset: number;
    /**
     * Total matches found.
     */
    totalMatches: number;
}

export interface GetFoundationCentralListApiKeysApiKey {
    /**
     * Alias of the api key.
     */
    alias: string;
    /**
     * Api key in string format.
     */
    apiKey: string;
    /**
     * Time when the api key was created.
     */
    createdTimestamp: string;
    /**
     * Current time of Foundation Central.
     */
    currentTime: string;
    /**
     * UUID of the api key.
     */
    keyUuid: string;
}

export interface GetFoundationCentralListApiKeysMetadata {
    /**
     * The number of records retrieved.
     */
    length: number;
    /**
     * Offset from the start of the object list.
     */
    offset: number;
    /**
     * Total matches found.
     */
    totalMatches: number;
}

export interface GetFoundationDiscoverNodesEntity {
    /**
     * Chassis serial number.
     */
    blockId: string;
    /**
     * ID number of the block.
     */
    chassisN: number;
    /**
     * Model name of the node.
     */
    model: string;
    /**
     * Node level properties.
     */
    nodes: outputs.GetFoundationDiscoverNodesEntityNode[];
}

export interface GetFoundationDiscoverNodesEntityNode {
    /**
     * ID of the cluster the node is part of.
     */
    clusterId: string;
    /**
     * Whether the node is configured.
     */
    configured: boolean;
    /**
     * vlan tag of cvm.
     */
    currentCvmVlanTag: string;
    /**
     * Current network interface of the node.
     */
    currentNetworkInterface: string;
    /**
     * Version of foundation.
     */
    foundationVersion: string;
    /**
     * Type of hypervisor installed on the node.
     */
    hypervisor: string;
    /**
     * Version of hypervisor installed.
     */
    hypervisorVersion: string;
    /**
     * IPV6 address of the node.
     */
    ipv6Address: string;
    /**
     * Model name of the node.
     */
    model: string;
    /**
     * Position of the node in the block.
     */
    nodePosition: string;
    /**
     * Node serial of the node.
     */
    nodeSerial: string;
    /**
     * UUID of the node.
     */
    nodeUuid: string;
    /**
     * Version of NOS installed on the node.
     */
    nosVersion: string;
    /**
     * IP address of CVM.
     */
    svmIp: string;
}

export interface GetFoundationHypervisorIsosEsx {
    /**
     * Name of installer.
     */
    filename: string;
    /**
     * Whether front-end should treat hyp as supported.
     */
    supported: boolean;
}

export interface GetFoundationHypervisorIsosHyperv {
    /**
     * Name of installer.
     */
    filename: string;
    /**
     * Whether front-end should treat hyp as supported.
     */
    supported: boolean;
}

export interface GetFoundationHypervisorIsosKvm {
    /**
     * Name of installer.
     */
    filename: string;
    /**
     * Whether front-end should treat hyp as supported.
     */
    supported: boolean;
}

export interface GetFoundationHypervisorIsosLinux {
    /**
     * Name of installer.
     */
    filename: string;
    /**
     * Whether front-end should treat hyp as supported.
     */
    supported: boolean;
}

export interface GetFoundationHypervisorIsosXen {
    /**
     * Name of installer.
     */
    filename: string;
    /**
     * Whether front-end should treat hyp as supported.
     */
    supported: boolean;
}

export interface GetFoundationNodeNetworkDetailsNode {
    /**
     * Gateway of CVM.
     */
    cvmGateway: string;
    /**
     * CVM IP address.
     */
    cvmIp: string;
    /**
     * Netmask of CVM.
     */
    cvmNetmask: string;
    /**
     * CVM vlan tag.
     */
    cvmVlanId: string;
    /**
     * Only exists when failed to fetch node_info, with the reason of failure. all other fields will be empty.
     */
    error: string;
    /**
     * Gateway of the hypervisor.
     */
    hypervisorGateway: string;
    /**
     * Hypervisor hostname.
     */
    hypervisorHostname: string;
    /**
     * Hypervisor IP address.
     */
    hypervisorIp: string;
    /**
     * Netmask of the hypervisor.
     */
    hypervisorNetmask: string;
    /**
     * IPMI gateway.
     */
    ipmiGateway: string;
    /**
     * IPMI IP address.
     */
    ipmiIp: string;
    /**
     * IPMI netmask.
     */
    ipmiNetmask: string;
    /**
     * IPV6 address of the CVM.
     */
    ipv6Address: string;
    /**
     * Node serial.
     */
    nodeSerial: string;
}

export interface GetHostCategory {
    /**
     * - the key name.
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetHostGpuList {
    assignable: boolean;
    consumerReference: {[key: string]: string};
    deviceId: number;
    fraction: number;
    frameBufferSizeMib: number;
    guestDriverVersion: string;
    index: number;
    licenseLists: string[];
    maxResolution: string;
    mode: string;
    /**
     * - the name.
     */
    name: string;
    numVgpusAllocated: number;
    numVirtualDisplayHeads: number;
    numaNode: number;
    pciAddress: string;
    status: string;
    /**
     * - the uuid.
     */
    uuid: string;
    vendor: string;
}

export interface GetHostHostDisksReferenceList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the uuid.
     */
    uuid: string;
}

export interface GetHostV2Cluster {
    /**
     * - Cluster name. This is part of payload for both cluster create & update operations.
     */
    name: string;
    /**
     * - Disk UUID.
     */
    uuid: string;
}

export interface GetHostV2ControllerVm {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    backplaneAddresses: outputs.GetHostV2ControllerVmBackplaneAddress[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    externalAddresses: outputs.GetHostV2ControllerVmExternalAddress[];
    /**
     * - Controller VM Id.
     */
    id: number;
    /**
     * - Maintenance mode status.
     */
    maintenanceMode: boolean;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    natIps: outputs.GetHostV2ControllerVmNatIp[];
    /**
     * - NAT port.
     */
    natPort: number;
    /**
     * - RDMA backplane address.
     */
    rdmaBackplaneAddresses: outputs.GetHostV2ControllerVmRdmaBackplaneAddress[];
}

export interface GetHostV2ControllerVmBackplaneAddress {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetHostV2ControllerVmBackplaneAddressIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetHostV2ControllerVmBackplaneAddressIpv6[];
}

export interface GetHostV2ControllerVmBackplaneAddressIpv4 {
    /**
     * - The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    value: string;
}

export interface GetHostV2ControllerVmBackplaneAddressIpv6 {
    /**
     * - The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    value: string;
}

export interface GetHostV2ControllerVmExternalAddress {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetHostV2ControllerVmExternalAddressIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetHostV2ControllerVmExternalAddressIpv6[];
}

export interface GetHostV2ControllerVmExternalAddressIpv4 {
    /**
     * - The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    value: string;
}

export interface GetHostV2ControllerVmExternalAddressIpv6 {
    /**
     * - The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    value: string;
}

export interface GetHostV2ControllerVmNatIp {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetHostV2ControllerVmNatIpIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetHostV2ControllerVmNatIpIpv6[];
}

export interface GetHostV2ControllerVmNatIpIpv4 {
    /**
     * - The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    value: string;
}

export interface GetHostV2ControllerVmNatIpIpv6 {
    /**
     * - The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    value: string;
}

export interface GetHostV2ControllerVmRdmaBackplaneAddress {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetHostV2ControllerVmRdmaBackplaneAddressIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetHostV2ControllerVmRdmaBackplaneAddressIpv6[];
}

export interface GetHostV2ControllerVmRdmaBackplaneAddressIpv4 {
    /**
     * - The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    value: string;
}

export interface GetHostV2ControllerVmRdmaBackplaneAddressIpv6 {
    /**
     * - The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    value: string;
}

export interface GetHostV2Disk {
    /**
     * - Disk mount path.
     */
    mountPath: string;
    /**
     * - Disk serial Id.
     */
    serialId: string;
    /**
     * - Disk size.
     */
    sizeInBytes: number;
    /**
     * - Disk storage Tier type.
     * * `HDD`: HDD storage tier.
     * * `PCIE_SSD`: PCIE SSD storage tier.
     * * `SATA_SSD`: SATA SSD storage tier.
     */
    storageTier: string;
    /**
     * - Disk UUID.
     */
    uuid: string;
}

export interface GetHostV2Hypervisor {
    /**
     * - Status of Acropolis connection to hypervisor.
     * * `DISCONNECTED`: Acropolis disconnected.
     * * `CONNECTED`: Acropolis connected.
     */
    acropolisConnectionState: string;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    externalAddresses: outputs.GetHostV2HypervisorExternalAddress[];
    /**
     * - Hypervisor full name.
     */
    fullName: string;
    /**
     * - Number of VMs.
     */
    numberOfVms: number;
    /**
     * - Hypervisor state.
     * * `HA_HEALING_TARGET`: Hypervisor in HA healing target state.
     * * `ENTERING_MAINTENANCE_MODE`: Hypervisor entering maintenance mode.
     * * `RESERVED_FOR_HA_FAILOVER`: Hypervisor reserved for HA failover.
     * * `HA_HEALING_SOURCE`: Hypervisor in HA healing source state.
     * * `RESERVING_FOR_HA_FAILOVER`: Hypervisor that is planned to be reserved for HA failover.
     * * `HA_FAILOVER_SOURCE`: Hypervisor in HA failover source state.
     * * `ACROPOLIS_NORMAL`: Hypervisor in Acropolis normal state.
     * * `ENTERED_MAINTENANCE_MODE`: Hypervisor entered maintenance mode.
     * * `ENTERING_MAINTENANCE_MODE_FROM_HA_FAILOVER`: Hypervisor entering maintenance mode from HA failover.
     * * `HA_FAILOVER_TARGET`: Hypervisor in HA failover target state.
     */
    state: string;
    /**
     * - Hypervisor type.
     * * `XEN`: Xen hypervisor.
     * * `HYPERV`: HyperV hypervisor.
     * * `ESX`: ESX hypervisor.
     * * `AHV`: AHV hypervisor.
     */
    type: string;
    /**
     * - Hypervisor user name.
     */
    userName: string;
}

export interface GetHostV2HypervisorExternalAddress {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetHostV2HypervisorExternalAddressIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetHostV2HypervisorExternalAddressIpv6[];
}

export interface GetHostV2HypervisorExternalAddressIpv4 {
    /**
     * - The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    value: string;
}

export interface GetHostV2HypervisorExternalAddressIpv6 {
    /**
     * - The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    value: string;
}

export interface GetHostV2Ipmi {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    ips: outputs.GetHostV2IpmiIp[];
    /**
     * - IPMI username.
     */
    username: string;
}

export interface GetHostV2IpmiIp {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetHostV2IpmiIpIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetHostV2IpmiIpIpv6[];
}

export interface GetHostV2IpmiIpIpv4 {
    /**
     * - The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    value: string;
}

export interface GetHostV2IpmiIpIpv6 {
    /**
     * - The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    value: string;
}

export interface GetHostV2KeyManagementDeviceToCertStatus {
    isCertificatePresent: boolean;
    /**
     * - Key management server name.
     */
    keyManagementServerName: string;
}

export interface GetHostV2Link {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetHostsEntity {
    /**
     * The API version.
     */
    apiVersion: string;
    /**
     * - Host block config info.
     */
    block: {[key: string]: string};
    /**
     * - Categories for the image.
     */
    categories: outputs.GetHostsEntityCategory[];
    /**
     * - Reference to a kind. Either one of (kind, uuid) or url needs to be specified.
     */
    clusterReference: {[key: string]: string};
    /**
     * - Host controller vm information.
     */
    controllerVm: {[key: string]: string};
    /**
     * - Host CPU capacity.
     */
    cpuCapacityHz: number;
    /**
     * - Host CPU model.
     */
    cpuModel: string;
    /**
     * - Hyper-V failover cluster.
     */
    failoverCluster: {[key: string]: string};
    /**
     * - Host GPU driver version.
     */
    gpuDriverVersion: string;
    /**
     * - List of GPUs on the host.
     */
    gpuLists: outputs.GetHostsEntityGpuList[];
    /**
     * - The reference to a disk.
     */
    hostDisksReferenceLists: outputs.GetHostsEntityHostDisksReferenceList[];
    /**
     * - Host NICs.
     */
    hostNicsIdLists: string[];
    /**
     * - Host type.
     */
    hostType: string;
    /**
     * - Host Hypervisor information.
     */
    hypervisor: {[key: string]: string};
    /**
     * - Host IPMI info.
     */
    ipmi: {[key: string]: string};
    /**
     * - Host memory capacity in MiB.
     */
    memoryCapacityMib: number;
    metadata: {[key: string]: string};
    /**
     * - Host monitoring status.
     */
    monitoringState: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - Number of CPU cores on Host.
     */
    numCpuCores: number;
    /**
     * - Number of CPU sockets.
     */
    numCpuSockets: number;
    /**
     * - The reference to a user.
     */
    ownerReference: {[key: string]: string};
    /**
     * - The reference to a project.
     */
    projectReference: {[key: string]: string};
    /**
     * - The reference to a rackable_unit.
     */
    rackableUnitReference: {[key: string]: string};
    /**
     * - Node serial number.
     */
    serialNumber: string;
    /**
     * - The name of the node to be renamed to during domain-join. If not given,a new name will be automatically assigned.
     */
    windowsDomain: {[key: string]: string};
}

export interface GetHostsEntityCategory {
    /**
     * - the name.
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetHostsEntityGpuList {
    assignable: boolean;
    consumerReference: {[key: string]: string};
    deviceId: number;
    fraction: number;
    frameBufferSizeMib: number;
    guestDriverVersion: string;
    index: number;
    licenseLists: string[];
    maxResolution: string;
    mode: string;
    /**
     * - the name.
     */
    name: string;
    numVgpusAllocated: number;
    numVirtualDisplayHeads: number;
    numaNode: number;
    pciAddress: string;
    status: string;
    /**
     * - the uuid.
     */
    uuid: string;
    vendor: string;
}

export interface GetHostsEntityHostDisksReferenceList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the uuid.
     */
    uuid: string;
}

export interface GetHostsV2HostEntity {
    blockModel: string;
    blockSerial: string;
    bootTimeUsecs: number;
    clusterExtId: string;
    /**
     * * `cpuCapacityHz`
     * * `cpuFrequencyHz`
     * * `cpuModel`
     * * `defaultVhdContainerUuid`
     * * `defaultVhdLocation`
     * * `defaultVmContainerUuid`
     * * `defaultVmLocation`
     * * `failoverClusterFqdn`
     * * `failoverClusterNodeStatus`
     * * `gpuDriverVersion`
     * * `gpuList`
     * * `hostName`
     * * `hostType`
     * * `maintenanceState`
     * * `memorySizeBytes`
     * * `nodeStatus`
     * * `numberOfCpuCores`
     * * `numberOfCpuSockets`
     * * `numberOfCpuThreads`
     * * `rebootPending`
     */
    clusters: outputs.GetHostsV2HostEntityCluster[];
    controllerVms: outputs.GetHostsV2HostEntityControllerVm[];
    cpuCapacityHz: number;
    cpuFrequencyHz: number;
    cpuModel: string;
    defaultVhdContainerUuid: string;
    defaultVhdLocation: string;
    defaultVmContainerUuid: string;
    defaultVmLocation: string;
    disks: outputs.GetHostsV2HostEntityDisk[];
    extId: string;
    failoverClusterFqdn: string;
    failoverClusterNodeStatus: string;
    gpuDriverVersion: string;
    gpuLists: string[];
    hasCsr: boolean;
    hostName: string;
    hostType: string;
    hypervisors: outputs.GetHostsV2HostEntityHypervisor[];
    ipmis: outputs.GetHostsV2HostEntityIpmi[];
    isDegraded: boolean;
    isHardwareVirtualized: boolean;
    isRebootPending: boolean;
    isSecureBooted: boolean;
    keyManagementDeviceToCertStatuses: outputs.GetHostsV2HostEntityKeyManagementDeviceToCertStatus[];
    links: outputs.GetHostsV2HostEntityLink[];
    maintenanceState: string;
    memorySizeBytes: number;
    nodeStatus: string;
    numberOfCpuCores: number;
    numberOfCpuSockets: number;
    numberOfCpuThreads: number;
    rackableUnitUuid: string;
    tenantId: string;
}

export interface GetHostsV2HostEntityCluster {
    name: string;
    uuid: string;
}

export interface GetHostsV2HostEntityControllerVm {
    backplaneAddresses: outputs.GetHostsV2HostEntityControllerVmBackplaneAddress[];
    externalAddresses: outputs.GetHostsV2HostEntityControllerVmExternalAddress[];
    id: number;
    maintenanceMode: boolean;
    natIps: outputs.GetHostsV2HostEntityControllerVmNatIp[];
    natPort: number;
    rdmaBackplaneAddresses: outputs.GetHostsV2HostEntityControllerVmRdmaBackplaneAddress[];
}

export interface GetHostsV2HostEntityControllerVmBackplaneAddress {
    ipv4s: outputs.GetHostsV2HostEntityControllerVmBackplaneAddressIpv4[];
    ipv6s: outputs.GetHostsV2HostEntityControllerVmBackplaneAddressIpv6[];
}

export interface GetHostsV2HostEntityControllerVmBackplaneAddressIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetHostsV2HostEntityControllerVmBackplaneAddressIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetHostsV2HostEntityControllerVmExternalAddress {
    ipv4s: outputs.GetHostsV2HostEntityControllerVmExternalAddressIpv4[];
    ipv6s: outputs.GetHostsV2HostEntityControllerVmExternalAddressIpv6[];
}

export interface GetHostsV2HostEntityControllerVmExternalAddressIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetHostsV2HostEntityControllerVmExternalAddressIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetHostsV2HostEntityControllerVmNatIp {
    ipv4s: outputs.GetHostsV2HostEntityControllerVmNatIpIpv4[];
    ipv6s: outputs.GetHostsV2HostEntityControllerVmNatIpIpv6[];
}

export interface GetHostsV2HostEntityControllerVmNatIpIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetHostsV2HostEntityControllerVmNatIpIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetHostsV2HostEntityControllerVmRdmaBackplaneAddress {
    ipv4s: outputs.GetHostsV2HostEntityControllerVmRdmaBackplaneAddressIpv4[];
    ipv6s: outputs.GetHostsV2HostEntityControllerVmRdmaBackplaneAddressIpv6[];
}

export interface GetHostsV2HostEntityControllerVmRdmaBackplaneAddressIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetHostsV2HostEntityControllerVmRdmaBackplaneAddressIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetHostsV2HostEntityDisk {
    mountPath: string;
    serialId: string;
    sizeInBytes: number;
    storageTier: string;
    uuid: string;
}

export interface GetHostsV2HostEntityHypervisor {
    acropolisConnectionState: string;
    externalAddresses: outputs.GetHostsV2HostEntityHypervisorExternalAddress[];
    fullName: string;
    numberOfVms: number;
    state: string;
    type: string;
    userName: string;
}

export interface GetHostsV2HostEntityHypervisorExternalAddress {
    ipv4s: outputs.GetHostsV2HostEntityHypervisorExternalAddressIpv4[];
    ipv6s: outputs.GetHostsV2HostEntityHypervisorExternalAddressIpv6[];
}

export interface GetHostsV2HostEntityHypervisorExternalAddressIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetHostsV2HostEntityHypervisorExternalAddressIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetHostsV2HostEntityIpmi {
    ips: outputs.GetHostsV2HostEntityIpmiIp[];
    username: string;
}

export interface GetHostsV2HostEntityIpmiIp {
    ipv4s: outputs.GetHostsV2HostEntityIpmiIpIpv4[];
    ipv6s: outputs.GetHostsV2HostEntityIpmiIpIpv6[];
}

export interface GetHostsV2HostEntityIpmiIpIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetHostsV2HostEntityIpmiIpIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetHostsV2HostEntityKeyManagementDeviceToCertStatus {
    isCertificatePresent: boolean;
    keyManagementServerName: string;
}

export interface GetHostsV2HostEntityLink {
    href: string;
    rel: string;
}

export interface GetImageCategory {
    /**
     * - the name.
     */
    name: string;
    value: string;
}

export interface GetImageClusterReference {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetImageCurrentClusterReferenceList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetImagePlacementPoliciesV2PlacementPolicy {
    /**
     * (Required) Category-based entity filter.
     */
    clusterEntityFilters: outputs.GetImagePlacementPoliciesV2PlacementPolicyClusterEntityFilter[];
    createTime: string;
    /**
     * (Optional) Description of the image placement policy.
     */
    description: string;
    /**
     * (Optional) Enforcement status of the image placement policy. Valid values:
     * - ACTIVE: The image placement policy is being actively enforced.
     * - SUSPENDED: The policy enforcement for image placement is suspended.
     */
    enforcementState: string;
    /**
     * The external identifier of an image placement policy.
     */
    extId: string;
    /**
     * (Required) Category-based entity filter.
     */
    imageEntityFilters: outputs.GetImagePlacementPoliciesV2PlacementPolicyImageEntityFilter[];
    lastUpdateTime: string;
    /**
     * (Required) Name of the image placement policy.
     */
    name: string;
    ownerExtId: string;
    /**
     * (Required) Type of the image placement policy. Valid values:
     * - HARD: Hard placement policy. Images can only be placed on clusters enforced by the image placement policy.
     * - SOFT: Soft placement policy. Images can be placed on clusters apart from those enforced by the image placement policy.
     */
    placementType: string;
}

export interface GetImagePlacementPoliciesV2PlacementPolicyClusterEntityFilter {
    /**
     * Array of strings
     */
    categoryExtIds: string[];
    /**
     * (Required) Filter matching type. Valid values:
     * - CATEGORIES_MATCH_ALL: Image policy only applies to the entities that are matched to all the corresponding entity categories attached to the image policy.
     * - CATEGORIES_MATCH_ANY: Image policy applies to the entities that match any subset of the entity categories attached to the image policy.
     */
    type: string;
}

export interface GetImagePlacementPoliciesV2PlacementPolicyImageEntityFilter {
    /**
     * Array of strings
     */
    categoryExtIds: string[];
    /**
     * (Required) Filter matching type. Valid values:
     * - CATEGORIES_MATCH_ALL: Image policy only applies to the entities that are matched to all the corresponding entity categories attached to the image policy.
     * - CATEGORIES_MATCH_ANY: Image policy applies to the entities that match any subset of the entity categories attached to the image policy.
     */
    type: string;
}

export interface GetImagePlacementPolicyV2ClusterEntityFilter {
    /**
     * Array of strings
     */
    categoryExtIds: string[];
    /**
     * (Required) Filter matching type. Valid values:
     * - CATEGORIES_MATCH_ALL: Image policy only applies to the entities that are matched to all the corresponding entity categories attached to the image policy.
     * - CATEGORIES_MATCH_ANY: Image policy applies to the entities that match any subset of the entity categories attached to the image policy.
     */
    type: string;
}

export interface GetImagePlacementPolicyV2ImageEntityFilter {
    /**
     * Array of strings
     */
    categoryExtIds: string[];
    /**
     * (Required) Filter matching type. Valid values:
     * - CATEGORIES_MATCH_ALL: Image policy only applies to the entities that are matched to all the corresponding entity categories attached to the image policy.
     * - CATEGORIES_MATCH_ANY: Image policy applies to the entities that match any subset of the entity categories attached to the image policy.
     */
    type: string;
}

export interface GetImageV2Checksum {
    hexDigest: string;
}

export interface GetImageV2PlacementPolicyStatus {
    /**
     * Compliance status for a placement policy.
     */
    complianceStatus: string;
    /**
     * List of image placement policy external identifier that conflict with the current one.
     */
    conflictingPolicyExtIds: string[];
    /**
     * List of cluster external identifiers for the enforced placement policy.
     */
    enforcedClusterExtIds: string[];
    /**
     * Indicates whether the placement policy enforcement is ongoing or has failed.
     */
    enforcementMode: string;
    /**
     * Image placement policy external identifier.
     */
    placementPolicyExtId: string;
    /**
     * List of cluster external identifiers of the image location for the enforced placement policy.
     */
    policyClusterExtIds: string[];
}

export interface GetImageV2Source {
    objectLiteSources: outputs.GetImageV2SourceObjectLiteSource[];
    urlSources: outputs.GetImageV2SourceUrlSource[];
    vmDiskSources: outputs.GetImageV2SourceVmDiskSource[];
}

export interface GetImageV2SourceObjectLiteSource {
    key: string;
}

export interface GetImageV2SourceUrlSource {
    /**
     * Basic authentication credentials for image source HTTP/S URL.
     */
    basicAuths: outputs.GetImageV2SourceUrlSourceBasicAuth[];
    shouldAllowInsecureUrl: boolean;
    /**
     * The URL for creating an image.
     */
    url: string;
}

export interface GetImageV2SourceUrlSourceBasicAuth {
    /**
     * Password for basic authentication.
     */
    password: string;
    /**
     * Username for basic authentication.
     */
    username: string;
}

export interface GetImageV2SourceVmDiskSource {
    /**
     * The external identifier of an image.
     */
    extId: string;
}

export interface GetImagesV2Image {
    categoryExtIds: string[];
    checksums: outputs.GetImagesV2ImageChecksum[];
    clusterLocationExtIds: string[];
    createTime: string;
    description: string;
    extId: string;
    lastUpdateTime: string;
    name: string;
    ownerExtId: string;
    placementPolicyStatuses: outputs.GetImagesV2ImagePlacementPolicyStatus[];
    sizeBytes: number;
    sources: outputs.GetImagesV2ImageSource[];
    type: string;
}

export interface GetImagesV2ImageChecksum {
    hexDigest: string;
}

export interface GetImagesV2ImagePlacementPolicyStatus {
    complianceStatus: string;
    conflictingPolicyExtIds: string[];
    enforcedClusterExtIds: string[];
    enforcementMode: string;
    placementPolicyExtId: string;
    policyClusterExtIds: string[];
}

export interface GetImagesV2ImageSource {
    objectLiteSources: outputs.GetImagesV2ImageSourceObjectLiteSource[];
    urlSources: outputs.GetImagesV2ImageSourceUrlSource[];
    vmDiskSources: outputs.GetImagesV2ImageSourceVmDiskSource[];
}

export interface GetImagesV2ImageSourceObjectLiteSource {
    key: string;
}

export interface GetImagesV2ImageSourceUrlSource {
    basicAuths: outputs.GetImagesV2ImageSourceUrlSourceBasicAuth[];
    shouldAllowInsecureUrl: boolean;
    url: string;
}

export interface GetImagesV2ImageSourceUrlSourceBasicAuth {
    password: string;
    username: string;
}

export interface GetImagesV2ImageSourceVmDiskSource {
    extId: string;
}

export interface GetKarbonClusterEtcdNodePool {
    /**
     * - VM configuration in AHV.
     */
    ahvConfigs: outputs.GetKarbonClusterEtcdNodePoolAhvConfig[];
    /**
     * - Unique name of the node pool.
     */
    name: string;
    /**
     * - The version of the node OS image.
     */
    nodeOsVersion: string;
    /**
     * - List of the deployed nodes in the node pool.
     */
    nodes: outputs.GetKarbonClusterEtcdNodePoolNode[];
    /**
     * - Number of nodes in the node pool.
     */
    numInstances: number;
}

export interface GetKarbonClusterEtcdNodePoolAhvConfig {
    /**
     * - The number of VCPUs allocated for each VM on the PE cluster.
     */
    cpu: number;
    /**
     * - Size of local storage for each VM on the PE cluster in MiB.
     */
    diskMib: number;
    /**
     * - Memory allocated for each VM on the PE cluster in MiB.
     */
    memoryMib: number;
    /**
     * - The UUID of the network for the VMs deployed with this resource configuration.
     */
    networkUuid: string;
    /**
     * - The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
     */
    prismElementClusterUuid: string;
}

export interface GetKarbonClusterEtcdNodePoolNode {
    /**
     * - Hostname of the deployed node.
     */
    hostname: string;
    /**
     * - IP of the deployed node.
     */
    ipv4Address: string;
}

export interface GetKarbonClusterMasterNodePool {
    /**
     * - VM configuration in AHV.
     */
    ahvConfigs: outputs.GetKarbonClusterMasterNodePoolAhvConfig[];
    /**
     * - Unique name of the node pool.
     */
    name: string;
    /**
     * - The version of the node OS image.
     */
    nodeOsVersion: string;
    /**
     * - List of the deployed nodes in the node pool.
     */
    nodes: outputs.GetKarbonClusterMasterNodePoolNode[];
    /**
     * - Number of nodes in the node pool.
     */
    numInstances: number;
}

export interface GetKarbonClusterMasterNodePoolAhvConfig {
    /**
     * - The number of VCPUs allocated for each VM on the PE cluster.
     */
    cpu: number;
    /**
     * - Size of local storage for each VM on the PE cluster in MiB.
     */
    diskMib: number;
    /**
     * - Memory allocated for each VM on the PE cluster in MiB.
     */
    memoryMib: number;
    /**
     * - The UUID of the network for the VMs deployed with this resource configuration.
     */
    networkUuid: string;
    /**
     * - The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
     */
    prismElementClusterUuid: string;
}

export interface GetKarbonClusterMasterNodePoolNode {
    /**
     * - Hostname of the deployed node.
     */
    hostname: string;
    /**
     * - IP of the deployed node.
     */
    ipv4Address: string;
}

export interface GetKarbonClusterWorkerNodePool {
    /**
     * - VM configuration in AHV.
     */
    ahvConfigs: outputs.GetKarbonClusterWorkerNodePoolAhvConfig[];
    /**
     * - Unique name of the node pool.
     */
    name: string;
    /**
     * - The version of the node OS image.
     */
    nodeOsVersion: string;
    /**
     * - List of the deployed nodes in the node pool.
     */
    nodes: outputs.GetKarbonClusterWorkerNodePoolNode[];
    /**
     * - Number of nodes in the node pool.
     */
    numInstances: number;
}

export interface GetKarbonClusterWorkerNodePoolAhvConfig {
    /**
     * - The number of VCPUs allocated for each VM on the PE cluster.
     */
    cpu: number;
    /**
     * - Size of local storage for each VM on the PE cluster in MiB.
     */
    diskMib: number;
    /**
     * - Memory allocated for each VM on the PE cluster in MiB.
     */
    memoryMib: number;
    /**
     * - The UUID of the network for the VMs deployed with this resource configuration.
     */
    networkUuid: string;
    /**
     * - The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
     */
    prismElementClusterUuid: string;
}

export interface GetKarbonClusterWorkerNodePoolNode {
    /**
     * - Hostname of the deployed node.
     */
    hostname: string;
    /**
     * - IP of the deployed node.
     */
    ipv4Address: string;
}

export interface GetKarbonClustersCluster {
    deploymentType: string;
    /**
     * - Configuration of the node pools that the nodes in the etcd cluster belong to. The etcd nodes require a minimum of 8,192 MiB memory and 409,60 MiB disk space.
     */
    etcdNodePools: outputs.GetKarbonClustersClusterEtcdNodePool[];
    kubeapiServerIpv4Address: string;
    /**
     * - .
     */
    masterNodePools: outputs.GetKarbonClustersClusterMasterNodePool[];
    /**
     * - Unique name of the node pool.
     */
    name: string;
    status: string;
    uuid: string;
    /**
     * - K8s version of the cluster.
     */
    version: string;
    workerNodePools: outputs.GetKarbonClustersClusterWorkerNodePool[];
}

export interface GetKarbonClustersClusterEtcdNodePool {
    /**
     * - .
     */
    ahvConfigs: outputs.GetKarbonClustersClusterEtcdNodePoolAhvConfig[];
    /**
     * - Unique name of the node pool.
     */
    name: string;
    /**
     * - The version of the node OS image.
     */
    nodeOsVersion: string;
    nodes: outputs.GetKarbonClustersClusterEtcdNodePoolNode[];
    /**
     * - Number of nodes in the node pool.
     */
    numInstances: number;
}

export interface GetKarbonClustersClusterEtcdNodePoolAhvConfig {
    /**
     * - The number of VCPUs allocated for each VM on the PE cluster.
     */
    cpu: number;
    /**
     * - Size of local storage for each VM on the PE cluster in MiB.
     */
    diskMib: number;
    /**
     * - Memory allocated for each VM on the PE cluster in MiB.
     */
    memoryMib: number;
    /**
     * - The UUID of the network for the VMs deployed with this resource configuration.
     */
    networkUuid: string;
    /**
     * - The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
     */
    prismElementClusterUuid: string;
}

export interface GetKarbonClustersClusterEtcdNodePoolNode {
    hostname: string;
    ipv4Address: string;
}

export interface GetKarbonClustersClusterMasterNodePool {
    /**
     * - .
     */
    ahvConfigs: outputs.GetKarbonClustersClusterMasterNodePoolAhvConfig[];
    /**
     * - Unique name of the node pool.
     */
    name: string;
    /**
     * - The version of the node OS image.
     */
    nodeOsVersion: string;
    nodes: outputs.GetKarbonClustersClusterMasterNodePoolNode[];
    /**
     * - Number of nodes in the node pool.
     */
    numInstances: number;
}

export interface GetKarbonClustersClusterMasterNodePoolAhvConfig {
    /**
     * - The number of VCPUs allocated for each VM on the PE cluster.
     */
    cpu: number;
    /**
     * - Size of local storage for each VM on the PE cluster in MiB.
     */
    diskMib: number;
    /**
     * - Memory allocated for each VM on the PE cluster in MiB.
     */
    memoryMib: number;
    /**
     * - The UUID of the network for the VMs deployed with this resource configuration.
     */
    networkUuid: string;
    /**
     * - The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
     */
    prismElementClusterUuid: string;
}

export interface GetKarbonClustersClusterMasterNodePoolNode {
    hostname: string;
    ipv4Address: string;
}

export interface GetKarbonClustersClusterWorkerNodePool {
    /**
     * - .
     */
    ahvConfigs: outputs.GetKarbonClustersClusterWorkerNodePoolAhvConfig[];
    /**
     * - Unique name of the node pool.
     */
    name: string;
    /**
     * - The version of the node OS image.
     */
    nodeOsVersion: string;
    nodes: outputs.GetKarbonClustersClusterWorkerNodePoolNode[];
    /**
     * - Number of nodes in the node pool.
     */
    numInstances: number;
}

export interface GetKarbonClustersClusterWorkerNodePoolAhvConfig {
    /**
     * - The number of VCPUs allocated for each VM on the PE cluster.
     */
    cpu: number;
    /**
     * - Size of local storage for each VM on the PE cluster in MiB.
     */
    diskMib: number;
    /**
     * - Memory allocated for each VM on the PE cluster in MiB.
     */
    memoryMib: number;
    /**
     * - The UUID of the network for the VMs deployed with this resource configuration.
     */
    networkUuid: string;
    /**
     * - The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
     */
    prismElementClusterUuid: string;
}

export interface GetKarbonClustersClusterWorkerNodePoolNode {
    hostname: string;
    ipv4Address: string;
}

export interface GetKarbonPrivateRegistriesPrivateRegistry {
    /**
     * - Endpoint of the private in format `url:port`.
     */
    endpoint: string;
    /**
     * - Name of the private registry.
     */
    name: string;
    /**
     * - UUID of the private registry.
     */
    uuid: string;
}

export interface GetLcmConfigV2Link {
    href: string;
    rel: string;
}

export interface GetLcmEntitiesV2Entity {
    /**
     * List of available versions for an LCM entity to update.
     */
    availableVersions: outputs.GetLcmEntitiesV2EntityAvailableVersion[];
    /**
     * Component information for the payload based entity.
     */
    childEntities: string[];
    /**
     * Cluster uuid on which the resource is present or operation is being performed.
     */
    clusterExtId: string;
    /**
     * Unique identifier of an LCM entity e.g. "HDD serial number".
     */
    deviceId: string;
    /**
     * LCM entity class.
     */
    entityClass: string;
    /**
     * Description of an LCM entity.
     */
    entityDescription: string;
    /**
     * Detailed information for the LCM entity. For example, firmware entities contain additional information about NIC and so on.
     */
    entityDetails: outputs.GetLcmEntitiesV2EntityEntityDetail[];
    /**
     * LCM entity model.
     */
    entityModel: string;
    /**
     * Type of an LCM entity.  Enum Values:
     * * `FIRMWARE`: LCM entity type firmware.
     * * `SOFTWARE`: LCM entity type software.
     */
    entityType: string;
    /**
     * Current version of an LCM entity.
     */
    entityVersion: string;
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    /**
     * UUID of the group that this LCM entity is part of.
     */
    groupUuid: string;
    /**
     * A hardware family for a LCM entity.
     */
    hardwareFamily: string;
    /**
     * Hardware vendor information.
     */
    hardwareVendor: string;
    /**
     * UTC date and time in RFC-3339 format when the task was last updated.
     */
    lastUpdatedTime: string;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetLcmEntitiesV2EntityLink[];
    /**
     * Location info corresponds to a tuple of location type (either node/cluster) and ExtID
     */
    locationInfos: outputs.GetLcmEntitiesV2EntityLocationInfo[];
    /**
     * A list of sub-entities applicable to the entity.
     */
    subEntities: outputs.GetLcmEntitiesV2EntitySubEntity[];
    /**
     * The requested update version of an LCM entity.
     */
    targetVersion: string;
    /**
     * A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server).
     */
    tenantId: string;
}

export interface GetLcmEntitiesV2EntityAvailableVersion {
    /**
     * Available version UUID.
     */
    availableVersionUuid: string;
    /**
     * Component information for the payload based entity.
     */
    childEntities: string[];
    /**
     * Custom message associated with the available version.
     */
    customMessage: string;
    /**
     * List of dependencies for the available version.
     */
    dependencies: outputs.GetLcmEntitiesV2EntityAvailableVersionDependency[];
    /**
     * Reason for disablement of the available version.
     */
    disablementReason: string;
    /**
     * UUID of the group that this LCM entity is part of.
     */
    groupUuid: string;
    /**
     * Indicates if the available update is enabled.
     */
    isEnabled: boolean;
    /**
     * Order of the available version.
     */
    order: number;
    /**
     * Release date of the available version.
     */
    releaseDate: string;
    /**
     * Release notes for the available version.
     */
    releaseNotes: string;
    /**
     * Status of the LCM entity. Enum Values:
     * * `AVAILABLE`: Available version.
     * * `EMERGENCY`: Emergency version.
     * * `RECOMMENDED`: Deprecated version.
     * * `STS`: Short-term supported version.
     * * `LTS`: Long-term supported version.
     * * `LATEST`: Latest version.
     * * `DEPRECATED`: Deprecated version.
     * * `ESTS`: Extended short-term supported version.
     * * `CRITICAL`: Critical version.
     */
    status: string;
    /**
     * Version of the LCM entity.
     */
    version: string;
}

export interface GetLcmEntitiesV2EntityAvailableVersionDependency {
    /**
     * Information of the dependent entity versions for this available entity.
     */
    dependentVersions: outputs.GetLcmEntitiesV2EntityAvailableVersionDependencyDependentVersion[];
    /**
     * LCM entity class.
     */
    entityClass: string;
    /**
     * LCM entity model.
     */
    entityModel: string;
    /**
     * Type of an LCM entity.  Enum Values:
     * * `FIRMWARE`: LCM entity type firmware.
     * * `SOFTWARE`: LCM entity type software.
     */
    entityType: string;
    /**
     * Current version of an LCM entity.
     */
    entityVersion: string;
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    /**
     * A hardware family for a LCM entity.
     */
    hardwareFamily: string;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetLcmEntitiesV2EntityAvailableVersionDependencyLink[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server).
     */
    tenantId: string;
}

export interface GetLcmEntitiesV2EntityAvailableVersionDependencyDependentVersion {
    /**
     * The key of the key-value pair.
     */
    name: string;
    /**
     * The value associated with the key for this key-value pair, string or integer or boolean or Array of strings or object or Array of MapOfString(objects) or Array of integers
     */
    values: outputs.GetLcmEntitiesV2EntityAvailableVersionDependencyDependentVersionValue[];
}

export interface GetLcmEntitiesV2EntityAvailableVersionDependencyDependentVersionValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.GetLcmEntitiesV2EntityAvailableVersionDependencyDependentVersionValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface GetLcmEntitiesV2EntityAvailableVersionDependencyDependentVersionValueMapOfString {
    map: {[key: string]: string};
}

export interface GetLcmEntitiesV2EntityAvailableVersionDependencyLink {
    href: string;
    rel: string;
}

export interface GetLcmEntitiesV2EntityEntityDetail {
    /**
     * The key of the key-value pair.
     */
    name: string;
    /**
     * The value associated with the key for this key-value pair, string or integer or boolean or Array of strings or object or Array of MapOfString(objects) or Array of integers
     */
    values: outputs.GetLcmEntitiesV2EntityEntityDetailValue[];
}

export interface GetLcmEntitiesV2EntityEntityDetailValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.GetLcmEntitiesV2EntityEntityDetailValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface GetLcmEntitiesV2EntityEntityDetailValueMapOfString {
    map: {[key: string]: string};
}

export interface GetLcmEntitiesV2EntityLink {
    href: string;
    rel: string;
}

export interface GetLcmEntitiesV2EntityLocationInfo {
    /**
     * Scope of entity represented in LCM. This could be either Node or cluster type. Enum Values:
     * * `PC`: Entity for which the scope is Prism Central wide.
     * * `NODE`: Entity that belongs to a node in the cluster.
     * * `CLUSTER`: Entity for which the scope is cluster wide.
     */
    locationType: string;
    /**
     * Location UUID of the resource.
     */
    uuid: string;
}

export interface GetLcmEntitiesV2EntitySubEntity {
    /**
     * LCM entity class.
     */
    entityClass: string;
    /**
     * LCM entity model.
     */
    entityModel: string;
    /**
     * Type of an LCM entity.  Enum Values:
     * * `FIRMWARE`: LCM entity type firmware.
     * * `SOFTWARE`: LCM entity type software.
     */
    entityType: string;
    /**
     * Current version of an LCM entity.
     */
    entityVersion: string;
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    /**
     * A hardware family for a LCM entity.
     */
    hardwareFamily: string;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetLcmEntitiesV2EntitySubEntityLink[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server).
     */
    tenantId: string;
}

export interface GetLcmEntitiesV2EntitySubEntityLink {
    href: string;
    rel: string;
}

export interface GetLcmEntityV2AvailableVersion {
    /**
     * Available version UUID.
     */
    availableVersionUuid: string;
    /**
     * Component information for the payload based entity.
     */
    childEntities: string[];
    /**
     * Custom message associated with the available version.
     */
    customMessage: string;
    /**
     * List of dependencies for the available version.
     */
    dependencies: outputs.GetLcmEntityV2AvailableVersionDependency[];
    /**
     * Reason for disablement of the available version.
     */
    disablementReason: string;
    /**
     * UUID of the group that this LCM entity is part of.
     */
    groupUuid: string;
    /**
     * Indicates if the available update is enabled.
     */
    isEnabled: boolean;
    /**
     * Order of the available version.
     */
    order: number;
    /**
     * Release date of the available version.
     */
    releaseDate: string;
    /**
     * Release notes for the available version.
     */
    releaseNotes: string;
    /**
     * Status of the LCM entity. Enum Values:
     * * `AVAILABLE`: Available version.
     * * `EMERGENCY`: Emergency version.
     * * `RECOMMENDED`: Deprecated version.
     * * `STS`: Short-term supported version.
     * * `LTS`: Long-term supported version.
     * * `LATEST`: Latest version.
     * * `DEPRECATED`: Deprecated version.
     * * `ESTS`: Extended short-term supported version.
     * * `CRITICAL`: Critical version.
     */
    status: string;
    /**
     * Version of the LCM entity.
     */
    version: string;
}

export interface GetLcmEntityV2AvailableVersionDependency {
    /**
     * Information of the dependent entity versions for this available entity.
     */
    dependentVersions: outputs.GetLcmEntityV2AvailableVersionDependencyDependentVersion[];
    /**
     * LCM entity class.
     */
    entityClass: string;
    /**
     * LCM entity model.
     */
    entityModel: string;
    /**
     * Type of an LCM entity.  Enum Values:
     * * `FIRMWARE`: LCM entity type firmware.
     * * `SOFTWARE`: LCM entity type software.
     */
    entityType: string;
    /**
     * Current version of an LCM entity.
     */
    entityVersion: string;
    /**
     * ExtId of the LCM entity.
     */
    extId: string;
    /**
     * A hardware family for a LCM entity.
     */
    hardwareFamily: string;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetLcmEntityV2AvailableVersionDependencyLink[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server).
     */
    tenantId: string;
}

export interface GetLcmEntityV2AvailableVersionDependencyDependentVersion {
    /**
     * The key of the key-value pair.
     */
    name: string;
    /**
     * The value associated with the key for this key-value pair, string or integer or boolean or Array of strings or object or Array of MapOfString(objects) or Array of integers
     */
    values: outputs.GetLcmEntityV2AvailableVersionDependencyDependentVersionValue[];
}

export interface GetLcmEntityV2AvailableVersionDependencyDependentVersionValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.GetLcmEntityV2AvailableVersionDependencyDependentVersionValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface GetLcmEntityV2AvailableVersionDependencyDependentVersionValueMapOfString {
    map: {[key: string]: string};
}

export interface GetLcmEntityV2AvailableVersionDependencyLink {
    href: string;
    rel: string;
}

export interface GetLcmEntityV2EntityDetail {
    /**
     * The key of the key-value pair.
     */
    name: string;
    /**
     * The value associated with the key for this key-value pair, string or integer or boolean or Array of strings or object or Array of MapOfString(objects) or Array of integers
     */
    values: outputs.GetLcmEntityV2EntityDetailValue[];
}

export interface GetLcmEntityV2EntityDetailValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.GetLcmEntityV2EntityDetailValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface GetLcmEntityV2EntityDetailValueMapOfString {
    map: {[key: string]: string};
}

export interface GetLcmEntityV2Link {
    href: string;
    rel: string;
}

export interface GetLcmEntityV2LocationInfo {
    /**
     * Scope of entity represented in LCM. This could be either Node or cluster type. Enum Values:
     * * `PC`: Entity for which the scope is Prism Central wide.
     * * `NODE`: Entity that belongs to a node in the cluster.
     * * `CLUSTER`: Entity for which the scope is cluster wide.
     */
    locationType: string;
    /**
     * Location UUID of the resource.
     */
    uuid: string;
}

export interface GetLcmEntityV2SubEntity {
    /**
     * LCM entity class.
     */
    entityClass: string;
    /**
     * LCM entity model.
     */
    entityModel: string;
    /**
     * Type of an LCM entity.  Enum Values:
     * * `FIRMWARE`: LCM entity type firmware.
     * * `SOFTWARE`: LCM entity type software.
     */
    entityType: string;
    /**
     * Current version of an LCM entity.
     */
    entityVersion: string;
    /**
     * ExtId of the LCM entity.
     */
    extId: string;
    /**
     * A hardware family for a LCM entity.
     */
    hardwareFamily: string;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetLcmEntityV2SubEntityLink[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server).
     */
    tenantId: string;
}

export interface GetLcmEntityV2SubEntityLink {
    href: string;
    rel: string;
}

export interface GetLcmStatusV2FrameworkVersion {
    /**
     * - LCM framework version present in the LCM URL.
     */
    availableVersion: string;
    /**
     * - Current LCM Version.
     */
    currentVersion: string;
    /**
     * - Boolean that indicates if LCM framework update is needed.
     */
    isUpdateNeeded: boolean;
}

export interface GetLcmStatusV2InProgressOperation {
    /**
     * - Root task UUID of the operation, if it is in running state.
     */
    operationId: string;
    /**
     * - Type of the operation tracked by the task. Values are:
     * - `PRECHECKS`: Perform LCM prechecks for the intended update operation.
     * - `INVENTORY`: Perform an LCM inventory operation.
     * - `UPGRADE`: Perform upgrade operation to a specific target version for discovered LCM entity/entities.
     * - `NONE`: Indicates that no operation is currently ongoing.
     */
    operationType: string;
}

export interface GetLcmStatusV2Link {
    href: string;
    rel: string;
}

export interface GetNdbCloneDatabaseNode {
    accessLevel: {[key: string]: string};
    databaseId: string;
    /**
     * database status
     */
    databaseStatus: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    dbserver: {[key: string]: string};
    dbserverId: string;
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned id
     */
    id: string;
    /**
     * cloned info
     */
    infos: outputs.GetNdbCloneDatabaseNodeInfo[];
    /**
     * cloned name
     */
    name: string;
    primary: boolean;
    /**
     * properties of clone
     */
    properties: outputs.GetNdbCloneDatabaseNodeProperty[];
    protectionDomainId: string;
    protectionDomains: outputs.GetNdbCloneDatabaseNodeProtectionDomain[];
    softwareInstallationId: string;
    /**
     * status of clone
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.GetNdbCloneDatabaseNodeTag[];
}

export interface GetNdbCloneDatabaseNodeInfo {
    /**
     * cloned info
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface GetNdbCloneDatabaseNodeProperty {
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned name
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbCloneDatabaseNodeProtectionDomain {
    assocEntities: string[];
    cloudId: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * cloned description
     */
    description: string;
    eraCreated: boolean;
    /**
     * cloned id
     */
    id: string;
    /**
     * cloned name
     */
    name: string;
    ownerId: string;
    primaryHost: string;
    /**
     * properties of clone
     */
    properties: outputs.GetNdbCloneDatabaseNodeProtectionDomainProperty[];
    /**
     * status of clone
     */
    status: string;
    /**
     * type
     */
    type: string;
}

export interface GetNdbCloneDatabaseNodeProtectionDomainProperty {
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned name
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbCloneDatabaseNodeTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbCloneFilter {
    /**
     * Get entity(s) if it satisfies query criteria irrespective of status (retrieve even deleted). Default is false
     */
    anyStatus?: string;
    /**
     * Load entities with complete details. Default is false
     */
    detailed?: string;
    /**
     * Load cluster info. Default is false
     */
    loadDbserverCluster?: string;
    /**
     * Default is UTC
     */
    timezone?: string;
}

export interface GetNdbCloneInfo {
    bpgConfigs: outputs.GetNdbCloneInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface GetNdbCloneInfoBpgConfig {
    bpgDbParams: outputs.GetNdbCloneInfoBpgConfigBpgDbParam[];
    storages: outputs.GetNdbCloneInfoBpgConfigStorage[];
    vmProperties: outputs.GetNdbCloneInfoBpgConfigVmProperty[];
}

export interface GetNdbCloneInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface GetNdbCloneInfoBpgConfigStorage {
    archiveStorages: outputs.GetNdbCloneInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.GetNdbCloneInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.GetNdbCloneInfoBpgConfigStorageLogDisk[];
}

export interface GetNdbCloneInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface GetNdbCloneInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface GetNdbCloneInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface GetNdbCloneInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface GetNdbCloneLcmConfig {
    expiryDetails: outputs.GetNdbCloneLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.GetNdbCloneLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.GetNdbCloneLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.GetNdbCloneLcmConfigRefreshDetail[];
}

export interface GetNdbCloneLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface GetNdbCloneLcmConfigPostDeleteCommand {
    command: string;
}

export interface GetNdbCloneLcmConfigPreDeleteCommand {
    command: string;
}

export interface GetNdbCloneLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface GetNdbCloneLinkedDatabase {
    /**
     * database name
     */
    databaseName: string;
    /**
     * database status
     */
    databaseStatus: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned id
     */
    id: string;
    /**
     * cloned info
     */
    infos: outputs.GetNdbCloneLinkedDatabaseInfo[];
    /**
     * Metric of clone
     */
    metric: {[key: string]: string};
    /**
     * cloned name
     */
    name: string;
    /**
     * parent database id
     */
    parentDatabaseId: string;
    parentLinkedDatabaseId: string;
    snapshotId: string;
    /**
     * status of clone
     */
    status: string;
    /**
     * Default is UTC
     */
    timezone: string;
}

export interface GetNdbCloneLinkedDatabaseInfo {
    /**
     * cloned info
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface GetNdbCloneProperty {
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned name
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbCloneTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbCloneTimeMachine {
    accessLevel: string;
    /**
     * clone or not
     */
    clone: boolean;
    clones: string;
    /**
     * clustered or not
     */
    clustered: boolean;
    database: string;
    databaseId: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * cloned description
     */
    description: string;
    eaStatus: string;
    /**
     * cloned id
     */
    id: string;
    /**
     * Metric of clone
     */
    metric: string;
    /**
     * cloned name
     */
    name: string;
    /**
     * properties of clone
     */
    properties: outputs.GetNdbCloneTimeMachineProperty[];
    scheduleId: string;
    schedules: outputs.GetNdbCloneTimeMachineSchedule[];
    scope: string;
    slaId: string;
    slaUpdateInProgress: boolean;
    slaUpdateMetadata: string;
    slas: outputs.GetNdbCloneTimeMachineSla[];
    sourceNxClusters: string[];
    /**
     * status of clone
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.GetNdbCloneTimeMachineTag[];
    /**
     * type
     */
    type: string;
}

export interface GetNdbCloneTimeMachineProperty {
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned name
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbCloneTimeMachineSchedule {
    continuousSchedules: outputs.GetNdbCloneTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.GetNdbCloneTimeMachineScheduleDailySchedule[];
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * cloned description
     */
    description: string;
    globalPolicy: boolean;
    /**
     * cloned id
     */
    id: string;
    monthlySchedules: outputs.GetNdbCloneTimeMachineScheduleMonthlySchedule[];
    /**
     * cloned name
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.GetNdbCloneTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.GetNdbCloneTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    /**
     * time zone
     */
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.GetNdbCloneTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.GetNdbCloneTimeMachineScheduleYearlySchedule[];
}

export interface GetNdbCloneTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface GetNdbCloneTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface GetNdbCloneTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface GetNdbCloneTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface GetNdbCloneTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface GetNdbCloneTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface GetNdbCloneTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface GetNdbCloneTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned id
     */
    id: string;
    monthlyRetention: number;
    /**
     * cloned name
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface GetNdbCloneTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbClonesClone {
    /**
     * clone or not
     */
    clone: boolean;
    /**
     * clustered or not
     */
    clustered: boolean;
    /**
     * database cluster type
     */
    databaseClusterType: string;
    /**
     * database name
     */
    databaseName: string;
    /**
     * database nodes associated with database instance
     */
    databaseNodes: outputs.GetNdbClonesCloneDatabaseNode[];
    /**
     * database status
     */
    databaseStatus: string;
    /**
     * database for a cloned instance
     */
    databases: {[key: string]: string};
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * dbserver logical cluster
     */
    dbserverLogicalCluster: {[key: string]: string};
    /**
     * dbserver logical cluster id
     */
    dbserverLogicalClusterId: string;
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned id
     */
    id: string;
    /**
     * cloned info
     */
    infos: outputs.GetNdbClonesCloneInfo[];
    /**
     * LCM Config
     */
    lcmConfigs: outputs.GetNdbClonesCloneLcmConfig[];
    /**
     * linked databases within database instance
     */
    linkedDatabases: outputs.GetNdbClonesCloneLinkedDatabase[];
    /**
     * Metric of clone
     */
    metric: {[key: string]: string};
    /**
     * cloned name
     */
    name: string;
    /**
     * parent database id
     */
    parentDatabaseId: string;
    /**
     * parent source database id
     */
    parentSourceDatabaseId: string;
    /**
     * parent time machine id
     */
    parentTimeMachineId: string;
    /**
     * properties of clone
     */
    properties: outputs.GetNdbClonesCloneProperty[];
    /**
     * status of clone
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.GetNdbClonesCloneTag[];
    /**
     * time machine id
     */
    timeMachineId: string;
    /**
     * Time machine info
     */
    timeMachines: outputs.GetNdbClonesCloneTimeMachine[];
    /**
     * time zone
     */
    timeZone: string;
    /**
     * type
     */
    type: string;
}

export interface GetNdbClonesCloneDatabaseNode {
    accessLevel: {[key: string]: string};
    databaseId: string;
    /**
     * database status
     */
    databaseStatus: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    dbserver: {[key: string]: string};
    dbserverId: string;
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned id
     */
    id: string;
    /**
     * cloned info
     */
    infos: outputs.GetNdbClonesCloneDatabaseNodeInfo[];
    /**
     * cloned name
     */
    name: string;
    primary: boolean;
    /**
     * properties of clone
     */
    properties: outputs.GetNdbClonesCloneDatabaseNodeProperty[];
    protectionDomainId: string;
    protectionDomains: outputs.GetNdbClonesCloneDatabaseNodeProtectionDomain[];
    softwareInstallationId: string;
    /**
     * status of clone
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.GetNdbClonesCloneDatabaseNodeTag[];
}

export interface GetNdbClonesCloneDatabaseNodeInfo {
    /**
     * cloned info
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface GetNdbClonesCloneDatabaseNodeProperty {
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned name
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbClonesCloneDatabaseNodeProtectionDomain {
    assocEntities: string[];
    cloudId: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * cloned description
     */
    description: string;
    eraCreated: boolean;
    /**
     * cloned id
     */
    id: string;
    /**
     * cloned name
     */
    name: string;
    ownerId: string;
    primaryHost: string;
    /**
     * properties of clone
     */
    properties: outputs.GetNdbClonesCloneDatabaseNodeProtectionDomainProperty[];
    /**
     * status of clone
     */
    status: string;
    /**
     * type
     */
    type: string;
}

export interface GetNdbClonesCloneDatabaseNodeProtectionDomainProperty {
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned name
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbClonesCloneDatabaseNodeTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbClonesCloneInfo {
    bpgConfigs: outputs.GetNdbClonesCloneInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface GetNdbClonesCloneInfoBpgConfig {
    bpgDbParams: outputs.GetNdbClonesCloneInfoBpgConfigBpgDbParam[];
    storages: outputs.GetNdbClonesCloneInfoBpgConfigStorage[];
    vmProperties: outputs.GetNdbClonesCloneInfoBpgConfigVmProperty[];
}

export interface GetNdbClonesCloneInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface GetNdbClonesCloneInfoBpgConfigStorage {
    archiveStorages: outputs.GetNdbClonesCloneInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.GetNdbClonesCloneInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.GetNdbClonesCloneInfoBpgConfigStorageLogDisk[];
}

export interface GetNdbClonesCloneInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface GetNdbClonesCloneInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface GetNdbClonesCloneInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface GetNdbClonesCloneInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface GetNdbClonesCloneLcmConfig {
    expiryDetails: outputs.GetNdbClonesCloneLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.GetNdbClonesCloneLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.GetNdbClonesCloneLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.GetNdbClonesCloneLcmConfigRefreshDetail[];
}

export interface GetNdbClonesCloneLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface GetNdbClonesCloneLcmConfigPostDeleteCommand {
    command: string;
}

export interface GetNdbClonesCloneLcmConfigPreDeleteCommand {
    command: string;
}

export interface GetNdbClonesCloneLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface GetNdbClonesCloneLinkedDatabase {
    /**
     * database name
     */
    databaseName: string;
    /**
     * database status
     */
    databaseStatus: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned id
     */
    id: string;
    /**
     * cloned info
     */
    infos: outputs.GetNdbClonesCloneLinkedDatabaseInfo[];
    /**
     * Metric of clone
     */
    metric: {[key: string]: string};
    /**
     * cloned name
     */
    name: string;
    /**
     * parent database id
     */
    parentDatabaseId: string;
    parentLinkedDatabaseId: string;
    snapshotId: string;
    /**
     * status of clone
     */
    status: string;
    /**
     * Default is UTC
     */
    timezone: string;
}

export interface GetNdbClonesCloneLinkedDatabaseInfo {
    /**
     * cloned info
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface GetNdbClonesCloneProperty {
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned name
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbClonesCloneTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbClonesCloneTimeMachine {
    accessLevel: string;
    /**
     * clone or not
     */
    clone: boolean;
    /**
     * List of clones based on filters
     */
    clones: string;
    /**
     * clustered or not
     */
    clustered: boolean;
    database: string;
    databaseId: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * cloned description
     */
    description: string;
    eaStatus: string;
    /**
     * cloned id
     */
    id: string;
    /**
     * Metric of clone
     */
    metric: string;
    /**
     * cloned name
     */
    name: string;
    /**
     * properties of clone
     */
    properties: outputs.GetNdbClonesCloneTimeMachineProperty[];
    scheduleId: string;
    schedules: outputs.GetNdbClonesCloneTimeMachineSchedule[];
    scope: string;
    slaId: string;
    slaUpdateInProgress: boolean;
    slaUpdateMetadata: string;
    slas: outputs.GetNdbClonesCloneTimeMachineSla[];
    sourceNxClusters: string[];
    /**
     * status of clone
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.GetNdbClonesCloneTimeMachineTag[];
    /**
     * type
     */
    type: string;
}

export interface GetNdbClonesCloneTimeMachineProperty {
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned name
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbClonesCloneTimeMachineSchedule {
    continuousSchedules: outputs.GetNdbClonesCloneTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.GetNdbClonesCloneTimeMachineScheduleDailySchedule[];
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * cloned description
     */
    description: string;
    globalPolicy: boolean;
    /**
     * cloned id
     */
    id: string;
    monthlySchedules: outputs.GetNdbClonesCloneTimeMachineScheduleMonthlySchedule[];
    /**
     * cloned name
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.GetNdbClonesCloneTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.GetNdbClonesCloneTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    /**
     * time zone
     */
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.GetNdbClonesCloneTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.GetNdbClonesCloneTimeMachineScheduleYearlySchedule[];
}

export interface GetNdbClonesCloneTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface GetNdbClonesCloneTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface GetNdbClonesCloneTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface GetNdbClonesCloneTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface GetNdbClonesCloneTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface GetNdbClonesCloneTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface GetNdbClonesCloneTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface GetNdbClonesCloneTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * cloned description
     */
    description: string;
    /**
     * cloned id
     */
    id: string;
    monthlyRetention: number;
    /**
     * cloned name
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface GetNdbClonesCloneTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbClonesFilter {
    /**
     * Get entity(s) if it satisfies query criteria irrespective of status (retrieve even deleted). Default is false
     */
    anyStatus?: string;
    /**
     * Load entities with complete details. Default is false
     */
    detailed?: string;
    /**
     * Load cluster info. Default is false
     */
    loadDbserverCluster?: string;
    /**
     * Sorted by dbserver cluster. Default is false
     */
    orderByDbserverCluster?: string;
    /**
     * Sorted by dbserver logical cluster.  Default is false
     */
    orderByDbserverLogicalCluster?: string;
    /**
     * Default is UTC
     */
    timezone?: string;
}

export interface GetNdbClusterEntityCount {
    dbServers: number;
    engineCounts: outputs.GetNdbClusterEntityCountEngineCount[];
}

export interface GetNdbClusterEntityCountEngineCount {
    mariadbDatabases: outputs.GetNdbClusterEntityCountEngineCountMariadbDatabase[];
    mongodbDatabases: outputs.GetNdbClusterEntityCountEngineCountMongodbDatabase[];
    mysqlDatabases: outputs.GetNdbClusterEntityCountEngineCountMysqlDatabase[];
    oracleDatabases: outputs.GetNdbClusterEntityCountEngineCountOracleDatabase[];
    postgresDatabases: outputs.GetNdbClusterEntityCountEngineCountPostgresDatabase[];
    saphanaDatabases: outputs.GetNdbClusterEntityCountEngineCountSaphanaDatabase[];
    sqlserverDatabases: outputs.GetNdbClusterEntityCountEngineCountSqlserverDatabase[];
}

export interface GetNdbClusterEntityCountEngineCountMariadbDatabase {
    profiles: outputs.GetNdbClusterEntityCountEngineCountMariadbDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClusterEntityCountEngineCountMariadbDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClusterEntityCountEngineCountMongodbDatabase {
    profiles: outputs.GetNdbClusterEntityCountEngineCountMongodbDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClusterEntityCountEngineCountMongodbDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClusterEntityCountEngineCountMysqlDatabase {
    profiles: outputs.GetNdbClusterEntityCountEngineCountMysqlDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClusterEntityCountEngineCountMysqlDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClusterEntityCountEngineCountOracleDatabase {
    profiles: outputs.GetNdbClusterEntityCountEngineCountOracleDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClusterEntityCountEngineCountOracleDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClusterEntityCountEngineCountPostgresDatabase {
    profiles: outputs.GetNdbClusterEntityCountEngineCountPostgresDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClusterEntityCountEngineCountPostgresDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClusterEntityCountEngineCountSaphanaDatabase {
    profiles: outputs.GetNdbClusterEntityCountEngineCountSaphanaDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClusterEntityCountEngineCountSaphanaDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClusterEntityCountEngineCountSqlserverDatabase {
    profiles: outputs.GetNdbClusterEntityCountEngineCountSqlserverDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClusterEntityCountEngineCountSqlserverDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClusterProperty {
    /**
     * - description
     */
    description: string;
    /**
     * - name of cluster
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbClusterResourceConfig {
    memoryThresholdPercentage: number;
    storageThresholdPercentage: number;
}

export interface GetNdbClustersCluster {
    cloudInfo: string;
    cloudType: string;
    dateCreated: string;
    dateModified: string;
    description: string;
    entityCounts: outputs.GetNdbClustersClusterEntityCount[];
    fqdns: string;
    healthy: boolean;
    hypervisorType: string;
    hypervisorVersion: string;
    id: string;
    ipAddresses: string[];
    managementServerInfo: string;
    name: string;
    nxClusterUuid: string;
    ownerId: string;
    password: string;
    properties: outputs.GetNdbClustersClusterProperty[];
    referenceCount: number;
    resourceConfigs: outputs.GetNdbClustersClusterResourceConfig[];
    status: string;
    uniqueName: string;
    username: string;
    version: string;
}

export interface GetNdbClustersClusterEntityCount {
    dbServers: number;
    engineCounts: outputs.GetNdbClustersClusterEntityCountEngineCount[];
}

export interface GetNdbClustersClusterEntityCountEngineCount {
    mariadbDatabases: outputs.GetNdbClustersClusterEntityCountEngineCountMariadbDatabase[];
    mongodbDatabases: outputs.GetNdbClustersClusterEntityCountEngineCountMongodbDatabase[];
    mysqlDatabases: outputs.GetNdbClustersClusterEntityCountEngineCountMysqlDatabase[];
    oracleDatabases: outputs.GetNdbClustersClusterEntityCountEngineCountOracleDatabase[];
    postgresDatabases: outputs.GetNdbClustersClusterEntityCountEngineCountPostgresDatabase[];
    saphanaDatabases: outputs.GetNdbClustersClusterEntityCountEngineCountSaphanaDatabase[];
    sqlserverDatabases: outputs.GetNdbClustersClusterEntityCountEngineCountSqlserverDatabase[];
}

export interface GetNdbClustersClusterEntityCountEngineCountMariadbDatabase {
    profiles: outputs.GetNdbClustersClusterEntityCountEngineCountMariadbDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountMariadbDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountMongodbDatabase {
    profiles: outputs.GetNdbClustersClusterEntityCountEngineCountMongodbDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountMongodbDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountMysqlDatabase {
    profiles: outputs.GetNdbClustersClusterEntityCountEngineCountMysqlDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountMysqlDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountOracleDatabase {
    profiles: outputs.GetNdbClustersClusterEntityCountEngineCountOracleDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountOracleDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountPostgresDatabase {
    profiles: outputs.GetNdbClustersClusterEntityCountEngineCountPostgresDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountPostgresDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountSaphanaDatabase {
    profiles: outputs.GetNdbClustersClusterEntityCountEngineCountSaphanaDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountSaphanaDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountSqlserverDatabase {
    profiles: outputs.GetNdbClustersClusterEntityCountEngineCountSqlserverDatabaseProfile[];
    timeMachines: number;
}

export interface GetNdbClustersClusterEntityCountEngineCountSqlserverDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface GetNdbClustersClusterProperty {
    description: string;
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbClustersClusterResourceConfig {
    memoryThresholdPercentage: number;
    storageThresholdPercentage: number;
}

export interface GetNdbDatabaseDatabaseNode {
    accessLevel: {[key: string]: string};
    /**
     * ID of database instance
     */
    databaseId: string;
    databaseStatus: string;
    /**
     * - creation date
     */
    dateCreated: string;
    /**
     * - date modified
     */
    dateModified: string;
    dbserver: {[key: string]: string};
    dbserverId: string;
    /**
     * - description
     */
    description: string;
    /**
     * - id of database instance
     */
    id: string;
    /**
     * - info regarding disks, vm, storage, etc.
     */
    infos: outputs.GetNdbDatabaseDatabaseNodeInfo[];
    /**
     * - name of database instance
     */
    name: string;
    primary: boolean;
    /**
     * - properties
     */
    properties: outputs.GetNdbDatabaseDatabaseNodeProperty[];
    protectionDomainId: string;
    protectionDomains: outputs.GetNdbDatabaseDatabaseNodeProtectionDomain[];
    softwareInstallationId: string;
    /**
     * - status of database instance
     */
    status: string;
    /**
     * - tags attached
     */
    tags: outputs.GetNdbDatabaseDatabaseNodeTag[];
}

export interface GetNdbDatabaseDatabaseNodeInfo {
    /**
     * - info regarding disks, vm, storage, etc.
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface GetNdbDatabaseDatabaseNodeProperty {
    /**
     * - description
     */
    description: string;
    /**
     * - name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbDatabaseDatabaseNodeProtectionDomain {
    assocEntities: string[];
    cloudId: string;
    /**
     * - creation date
     */
    dateCreated: string;
    /**
     * - date modified
     */
    dateModified: string;
    /**
     * - description
     */
    description: string;
    eraCreated: boolean;
    /**
     * - id of database instance
     */
    id: string;
    /**
     * - name of database instance
     */
    name: string;
    ownerId: string;
    primaryHost: string;
    /**
     * - properties
     */
    properties: outputs.GetNdbDatabaseDatabaseNodeProtectionDomainProperty[];
    /**
     * - status of database instance
     */
    status: string;
    /**
     * - database engine type
     */
    type: string;
}

export interface GetNdbDatabaseDatabaseNodeProtectionDomainProperty {
    /**
     * - description
     */
    description: string;
    /**
     * - name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbDatabaseDatabaseNodeTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbDatabaseInfo {
    bpgConfigs: outputs.GetNdbDatabaseInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface GetNdbDatabaseInfoBpgConfig {
    bpgDbParams: outputs.GetNdbDatabaseInfoBpgConfigBpgDbParam[];
    storages: outputs.GetNdbDatabaseInfoBpgConfigStorage[];
    vmProperties: outputs.GetNdbDatabaseInfoBpgConfigVmProperty[];
}

export interface GetNdbDatabaseInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface GetNdbDatabaseInfoBpgConfigStorage {
    archiveStorages: outputs.GetNdbDatabaseInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.GetNdbDatabaseInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.GetNdbDatabaseInfoBpgConfigStorageLogDisk[];
}

export interface GetNdbDatabaseInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface GetNdbDatabaseInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface GetNdbDatabaseInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface GetNdbDatabaseInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface GetNdbDatabaseLcmConfig {
    expiryDetails: outputs.GetNdbDatabaseLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.GetNdbDatabaseLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.GetNdbDatabaseLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.GetNdbDatabaseLcmConfigRefreshDetail[];
}

export interface GetNdbDatabaseLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface GetNdbDatabaseLcmConfigPostDeleteCommand {
    command: string;
}

export interface GetNdbDatabaseLcmConfigPreDeleteCommand {
    command: string;
}

export interface GetNdbDatabaseLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface GetNdbDatabaseLinkedDatabase {
    /**
     * - database instance name
     */
    databaseName: string;
    databaseStatus: string;
    /**
     * - creation date
     */
    dateCreated: string;
    /**
     * - date modified
     */
    dateModified: string;
    /**
     * - description
     */
    description: string;
    /**
     * - id of database instance
     */
    id: string;
    /**
     * - info regarding disks, vm, storage, etc.
     */
    infos: outputs.GetNdbDatabaseLinkedDatabaseInfo[];
    /**
     * - metrics
     */
    metric: {[key: string]: string};
    /**
     * - name of database instance
     */
    name: string;
    /**
     * - parent database ID
     */
    parentDatabaseId: string;
    parentLinkedDatabaseId: string;
    snapshotId: string;
    /**
     * - status of database instance
     */
    status: string;
    timezone: string;
}

export interface GetNdbDatabaseLinkedDatabaseInfo {
    /**
     * - info regarding disks, vm, storage, etc.
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface GetNdbDatabaseProperty {
    /**
     * - description
     */
    description: string;
    /**
     * - name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbDatabaseTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbDatabaseTimeMachine {
    accessLevel: string;
    /**
     * - if cloned
     */
    clone: boolean;
    clones: string;
    /**
     * - if clustered or not
     */
    clustered: boolean;
    database: string;
    /**
     * ID of database instance
     */
    databaseId: string;
    /**
     * - creation date
     */
    dateCreated: string;
    /**
     * - date modified
     */
    dateModified: string;
    /**
     * - description
     */
    description: string;
    eaStatus: string;
    /**
     * - id of database instance
     */
    id: string;
    /**
     * - metrics
     */
    metric: string;
    /**
     * - name of database instance
     */
    name: string;
    /**
     * - properties
     */
    properties: outputs.GetNdbDatabaseTimeMachineProperty[];
    scheduleId: string;
    schedules: outputs.GetNdbDatabaseTimeMachineSchedule[];
    scope: string;
    slaId: string;
    slaUpdateInProgress: boolean;
    slaUpdateMetadata: string;
    slas: outputs.GetNdbDatabaseTimeMachineSla[];
    sourceNxClusters: string[];
    /**
     * - status of database instance
     */
    status: string;
    /**
     * - tags attached
     */
    tags: outputs.GetNdbDatabaseTimeMachineTag[];
    /**
     * - database engine type
     */
    type: string;
}

export interface GetNdbDatabaseTimeMachineProperty {
    /**
     * - description
     */
    description: string;
    /**
     * - name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbDatabaseTimeMachineSchedule {
    continuousSchedules: outputs.GetNdbDatabaseTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.GetNdbDatabaseTimeMachineScheduleDailySchedule[];
    /**
     * - creation date
     */
    dateCreated: string;
    /**
     * - date modified
     */
    dateModified: string;
    /**
     * - description
     */
    description: string;
    globalPolicy: boolean;
    /**
     * - id of database instance
     */
    id: string;
    monthlySchedules: outputs.GetNdbDatabaseTimeMachineScheduleMonthlySchedule[];
    /**
     * - name of database instance
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.GetNdbDatabaseTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.GetNdbDatabaseTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    /**
     * - timezone
     */
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.GetNdbDatabaseTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.GetNdbDatabaseTimeMachineScheduleYearlySchedule[];
}

export interface GetNdbDatabaseTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface GetNdbDatabaseTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface GetNdbDatabaseTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface GetNdbDatabaseTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface GetNdbDatabaseTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface GetNdbDatabaseTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface GetNdbDatabaseTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface GetNdbDatabaseTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    /**
     * - creation date
     */
    dateCreated: string;
    /**
     * - date modified
     */
    dateModified: string;
    /**
     * - description
     */
    description: string;
    /**
     * - id of database instance
     */
    id: string;
    monthlyRetention: number;
    /**
     * - name of database instance
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface GetNdbDatabaseTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbDatabasesDatabaseInstance {
    clone: boolean;
    clustered: boolean;
    databaseClusterType: string;
    databaseName: string;
    databaseNodes: outputs.GetNdbDatabasesDatabaseInstanceDatabaseNode[];
    databases: {[key: string]: string};
    dateCreated: string;
    dateModified: string;
    dbserverLogicalCluster: {[key: string]: string};
    dbserverLogicalClusterId: string;
    description: string;
    id: string;
    infos: outputs.GetNdbDatabasesDatabaseInstanceInfo[];
    lcmConfigs: outputs.GetNdbDatabasesDatabaseInstanceLcmConfig[];
    linkedDatabases: outputs.GetNdbDatabasesDatabaseInstanceLinkedDatabase[];
    metadatas: outputs.GetNdbDatabasesDatabaseInstanceMetadata[];
    metric: {[key: string]: string};
    name: string;
    parentDatabaseId: string;
    /**
     * List of all the properties
     */
    properties: outputs.GetNdbDatabasesDatabaseInstanceProperty[];
    status: string;
    tags: outputs.GetNdbDatabasesDatabaseInstanceTag[];
    timeMachineId: string;
    timeMachines: outputs.GetNdbDatabasesDatabaseInstanceTimeMachine[];
    timeZone: string;
    type: string;
}

export interface GetNdbDatabasesDatabaseInstanceDatabaseNode {
    accessLevel: {[key: string]: string};
    databaseId: string;
    databaseStatus: string;
    dateCreated: string;
    dateModified: string;
    dbserver: {[key: string]: string};
    dbserverId: string;
    description: string;
    id: string;
    infos: outputs.GetNdbDatabasesDatabaseInstanceDatabaseNodeInfo[];
    name: string;
    primary: boolean;
    /**
     * List of all the properties
     */
    properties: outputs.GetNdbDatabasesDatabaseInstanceDatabaseNodeProperty[];
    protectionDomainId: string;
    protectionDomains: outputs.GetNdbDatabasesDatabaseInstanceDatabaseNodeProtectionDomain[];
    softwareInstallationId: string;
    status: string;
    tags: outputs.GetNdbDatabasesDatabaseInstanceDatabaseNodeTag[];
}

export interface GetNdbDatabasesDatabaseInstanceDatabaseNodeInfo {
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface GetNdbDatabasesDatabaseInstanceDatabaseNodeProperty {
    description: string;
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbDatabasesDatabaseInstanceDatabaseNodeProtectionDomain {
    assocEntities: string[];
    cloudId: string;
    dateCreated: string;
    dateModified: string;
    description: string;
    eraCreated: boolean;
    id: string;
    name: string;
    ownerId: string;
    primaryHost: string;
    /**
     * List of all the properties
     */
    properties: outputs.GetNdbDatabasesDatabaseInstanceDatabaseNodeProtectionDomainProperty[];
    status: string;
    type: string;
}

export interface GetNdbDatabasesDatabaseInstanceDatabaseNodeProtectionDomainProperty {
    description: string;
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbDatabasesDatabaseInstanceDatabaseNodeTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbDatabasesDatabaseInstanceInfo {
    bpgConfigs: outputs.GetNdbDatabasesDatabaseInstanceInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface GetNdbDatabasesDatabaseInstanceInfoBpgConfig {
    bpgDbParams: outputs.GetNdbDatabasesDatabaseInstanceInfoBpgConfigBpgDbParam[];
    storages: outputs.GetNdbDatabasesDatabaseInstanceInfoBpgConfigStorage[];
    vmProperties: outputs.GetNdbDatabasesDatabaseInstanceInfoBpgConfigVmProperty[];
}

export interface GetNdbDatabasesDatabaseInstanceInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface GetNdbDatabasesDatabaseInstanceInfoBpgConfigStorage {
    archiveStorages: outputs.GetNdbDatabasesDatabaseInstanceInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.GetNdbDatabasesDatabaseInstanceInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.GetNdbDatabasesDatabaseInstanceInfoBpgConfigStorageLogDisk[];
}

export interface GetNdbDatabasesDatabaseInstanceInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface GetNdbDatabasesDatabaseInstanceInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface GetNdbDatabasesDatabaseInstanceInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface GetNdbDatabasesDatabaseInstanceInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface GetNdbDatabasesDatabaseInstanceLcmConfig {
    expiryDetails: outputs.GetNdbDatabasesDatabaseInstanceLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.GetNdbDatabasesDatabaseInstanceLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.GetNdbDatabasesDatabaseInstanceLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.GetNdbDatabasesDatabaseInstanceLcmConfigRefreshDetail[];
}

export interface GetNdbDatabasesDatabaseInstanceLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface GetNdbDatabasesDatabaseInstanceLcmConfigPostDeleteCommand {
    command: string;
}

export interface GetNdbDatabasesDatabaseInstanceLcmConfigPreDeleteCommand {
    command: string;
}

export interface GetNdbDatabasesDatabaseInstanceLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface GetNdbDatabasesDatabaseInstanceLinkedDatabase {
    databaseName: string;
    databaseStatus: string;
    dateCreated: string;
    dateModified: string;
    description: string;
    id: string;
    infos: outputs.GetNdbDatabasesDatabaseInstanceLinkedDatabaseInfo[];
    metric: {[key: string]: string};
    name: string;
    parentDatabaseId: string;
    parentLinkedDatabaseId: string;
    snapshotId: string;
    status: string;
    timezone: string;
}

export interface GetNdbDatabasesDatabaseInstanceLinkedDatabaseInfo {
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface GetNdbDatabasesDatabaseInstanceMetadata {
    baseSizeComputed: boolean;
    capabilityResetTime: string;
    createdDbservers: string[];
    deregisterInfos: outputs.GetNdbDatabasesDatabaseInstanceMetadataDeregisterInfo[];
    deregisteredWithDeleteTimeMachine: boolean;
    info: {[key: string]: string};
    lastLogCatchupForRestoreOperationId: string;
    lastRefreshTimestamp: string;
    lastRequestedRefreshTimestamp: string;
    logCatchupForRestoreDispatched: boolean;
    originalDatabaseName: string;
    pitrBased: boolean;
    provisionOperationId: string;
    refreshBlockerInfo: string;
    registeredDbservers: string[];
    secureInfo: {[key: string]: string};
    sourceSnapshotId: string;
    stateBeforeRefresh: string;
    stateBeforeRestore: string;
    stateBeforeScaling: string;
    tmActivateOperationId: string;
}

export interface GetNdbDatabasesDatabaseInstanceMetadataDeregisterInfo {
    message: string;
    operations: string[];
}

export interface GetNdbDatabasesDatabaseInstanceProperty {
    description: string;
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbDatabasesDatabaseInstanceTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachine {
    accessLevel: string;
    clone: boolean;
    clones: string;
    clustered: boolean;
    database: string;
    databaseId: string;
    dateCreated: string;
    dateModified: string;
    description: string;
    eaStatus: string;
    id: string;
    metric: string;
    name: string;
    /**
     * List of all the properties
     */
    properties: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineProperty[];
    scheduleId: string;
    schedules: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineSchedule[];
    scope: string;
    slaId: string;
    slaUpdateInProgress: boolean;
    slaUpdateMetadata: string;
    slas: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineSla[];
    sourceNxClusters: string[];
    status: string;
    tags: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineTag[];
    type: string;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineProperty {
    description: string;
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineSchedule {
    continuousSchedules: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineScheduleDailySchedule[];
    dateCreated: string;
    dateModified: string;
    description: string;
    globalPolicy: boolean;
    id: string;
    monthlySchedules: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineScheduleMonthlySchedule[];
    name: string;
    ownerId: string;
    quartelySchedules: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.GetNdbDatabasesDatabaseInstanceTimeMachineScheduleYearlySchedule[];
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    dateCreated: string;
    dateModified: string;
    description: string;
    id: string;
    monthlyRetention: number;
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface GetNdbDatabasesDatabaseInstanceTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbDbserverProperty {
    /**
     * name of database server vm
     */
    name: string;
    value: string;
}

export interface GetNdbDbserverTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbDbserverVmInfo {
    deregisterInfos: outputs.GetNdbDbserverVmInfoDeregisterInfo[];
    distribution: {[key: string]: string};
    infos: outputs.GetNdbDbserverVmInfoInfo[];
    networkInfos: outputs.GetNdbDbserverVmInfoNetworkInfo[];
    osType: string;
    osVersion: string;
    secureInfo: {[key: string]: string};
}

export interface GetNdbDbserverVmInfoDeregisterInfo {
    message: string;
    operations: string[];
}

export interface GetNdbDbserverVmInfoInfo {
    bpgConfigs: outputs.GetNdbDbserverVmInfoInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface GetNdbDbserverVmInfoInfoBpgConfig {
    bpgDbParams: outputs.GetNdbDbserverVmInfoInfoBpgConfigBpgDbParam[];
    storages: outputs.GetNdbDbserverVmInfoInfoBpgConfigStorage[];
    vmProperties: outputs.GetNdbDbserverVmInfoInfoBpgConfigVmProperty[];
}

export interface GetNdbDbserverVmInfoInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface GetNdbDbserverVmInfoInfoBpgConfigStorage {
    archiveStorages: outputs.GetNdbDbserverVmInfoInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.GetNdbDbserverVmInfoInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.GetNdbDbserverVmInfoInfoBpgConfigStorageLogDisk[];
}

export interface GetNdbDbserverVmInfoInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface GetNdbDbserverVmInfoInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface GetNdbDbserverVmInfoInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface GetNdbDbserverVmInfoInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface GetNdbDbserverVmInfoNetworkInfo {
    accessInfos: outputs.GetNdbDbserverVmInfoNetworkInfoAccessInfo[];
    defaultGatewayDevice: boolean;
    deviceName: string;
    eraConfigured: boolean;
    flags: string;
    gateway: string;
    hostname: string;
    /**
     * IP addresses of the dbserver vm
     */
    ipAddresses: string[];
    macAddress: string;
    mtu: string;
    subnetMask: string;
    vlanName: string;
    vlanType: string;
    vlanUuid: string;
}

export interface GetNdbDbserverVmInfoNetworkInfoAccessInfo {
    accessType: string;
    destinationSubnet: string;
}

export interface GetNdbDbserversDbserver {
    /**
     * access key id of dbserver vm
     */
    accessKeyId: string;
    /**
     * access level
     */
    accessLevel: string;
    /**
     * associated time machines ids
     */
    associatedTimeMachineIds: string[];
    /**
     * client id
     */
    clientId: string;
    /**
     * clustered or not
     */
    clustered: boolean;
    /**
     * database type
     */
    databaseType: string;
    /**
     * date created of db server vm
     */
    dateCreated: string;
    /**
     * date modified of db server vm
     */
    dateModified: string;
    /**
     * dbserver invalid ea state
     */
    dbserverInvalidEaState: boolean;
    /**
     * description of db server vm
     */
    description: string;
    /**
     * era drive id
     */
    eraDriveId: string;
    /**
     * era version
     */
    eraVersion: string;
    fqdns: string;
    id: string;
    /**
     * IP addresses of the dbserver vm
     */
    ipAddresses: string[];
    /**
     * is server down or not
     */
    isServerDriven: boolean;
    /**
     * Mac addresses of dbserver vm
     */
    macAddresses: string[];
    /**
     * name of dbserver vm
     */
    name: string;
    /**
     * properties of db server vm
     */
    properties: outputs.GetNdbDbserversDbserverProperty[];
    /**
     * protection domain id
     */
    protectionDomainId: string;
    /**
     * query count
     */
    queryCount: number;
    /**
     * Status of Dbserver . Active or not.
     */
    status: string;
    /**
     * tags for db server vm
     */
    tags: outputs.GetNdbDbserversDbserverTag[];
    /**
     * Type of entity. i.e. Dbserver
     */
    type: string;
    /**
     * valid diagnostic bundle state
     */
    validDiagnosticBundleState: boolean;
    /**
     * clusetr uuid for dbserver vm
     */
    vmClusterUuid: string;
    /**
     * info of dbserver vm
     */
    vmInfos: outputs.GetNdbDbserversDbserverVmInfo[];
    /**
     * timezone of dbserver vm
     */
    vmTimezone: string;
    /**
     * window db server
     */
    windowsDbServer: boolean;
    /**
     * working directory of db server vm
     */
    workingDirectory: string;
}

export interface GetNdbDbserversDbserverProperty {
    /**
     * name of dbserver vm
     */
    name: string;
    value: string;
}

export interface GetNdbDbserversDbserverTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbDbserversDbserverVmInfo {
    deregisterInfos: outputs.GetNdbDbserversDbserverVmInfoDeregisterInfo[];
    distribution: {[key: string]: string};
    infos: outputs.GetNdbDbserversDbserverVmInfoInfo[];
    networkInfos: outputs.GetNdbDbserversDbserverVmInfoNetworkInfo[];
    osType: string;
    osVersion: string;
    secureInfo: {[key: string]: string};
}

export interface GetNdbDbserversDbserverVmInfoDeregisterInfo {
    message: string;
    operations: string[];
}

export interface GetNdbDbserversDbserverVmInfoInfo {
    bpgConfigs: outputs.GetNdbDbserversDbserverVmInfoInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface GetNdbDbserversDbserverVmInfoInfoBpgConfig {
    bpgDbParams: outputs.GetNdbDbserversDbserverVmInfoInfoBpgConfigBpgDbParam[];
    storages: outputs.GetNdbDbserversDbserverVmInfoInfoBpgConfigStorage[];
    vmProperties: outputs.GetNdbDbserversDbserverVmInfoInfoBpgConfigVmProperty[];
}

export interface GetNdbDbserversDbserverVmInfoInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface GetNdbDbserversDbserverVmInfoInfoBpgConfigStorage {
    archiveStorages: outputs.GetNdbDbserversDbserverVmInfoInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.GetNdbDbserversDbserverVmInfoInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.GetNdbDbserversDbserverVmInfoInfoBpgConfigStorageLogDisk[];
}

export interface GetNdbDbserversDbserverVmInfoInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface GetNdbDbserversDbserverVmInfoInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface GetNdbDbserversDbserverVmInfoInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface GetNdbDbserversDbserverVmInfoInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface GetNdbDbserversDbserverVmInfoNetworkInfo {
    accessInfos: outputs.GetNdbDbserversDbserverVmInfoNetworkInfoAccessInfo[];
    defaultGatewayDevice: boolean;
    deviceName: string;
    eraConfigured: boolean;
    flags: string;
    gateway: string;
    hostname: string;
    /**
     * IP addresses of the dbserver vm
     */
    ipAddresses: string[];
    macAddress: string;
    mtu: string;
    subnetMask: string;
    vlanName: string;
    vlanType: string;
    vlanUuid: string;
}

export interface GetNdbDbserversDbserverVmInfoNetworkInfoAccessInfo {
    accessType: string;
    destinationSubnet: string;
}

export interface GetNdbMaintenanceWindowEntityTaskAssoc {
    /**
     * access level
     */
    accessLevel: string;
    /**
     * created date of maintenance window
     */
    dateCreated: string;
    /**
     * modified date of maintenance window
     */
    dateModified: string;
    /**
     * description of maintenance window
     */
    description: string;
    entity: string;
    entityId: string;
    entityType: string;
    /**
     * Maintenance window id.
     */
    id: string;
    maintenanceWindowId: string;
    maintenanceWindowOwnerId: string;
    /**
     * name of maintenance window
     */
    name: string;
    /**
     * owner id of maintenance window
     */
    ownerId: string;
    payloads: outputs.GetNdbMaintenanceWindowEntityTaskAssocPayload[];
    /**
     * properties of maintenance window
     */
    properties: outputs.GetNdbMaintenanceWindowEntityTaskAssocProperty[];
    /**
     * status of maintennace window
     */
    status: string;
    /**
     * tags of maintenance window
     */
    tags: outputs.GetNdbMaintenanceWindowEntityTaskAssocTag[];
    taskType: string;
}

export interface GetNdbMaintenanceWindowEntityTaskAssocPayload {
    prePostCommands: outputs.GetNdbMaintenanceWindowEntityTaskAssocPayloadPrePostCommand[];
}

export interface GetNdbMaintenanceWindowEntityTaskAssocPayloadPrePostCommand {
    postCommand: string;
    preCommand: string;
}

export interface GetNdbMaintenanceWindowEntityTaskAssocProperty {
    /**
     * name of maintenance window
     */
    name: string;
    value: string;
}

export interface GetNdbMaintenanceWindowEntityTaskAssocTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbMaintenanceWindowProperty {
    /**
     * name of maintenance window
     */
    name: string;
    value: string;
}

export interface GetNdbMaintenanceWindowSchedule {
    dayOfWeek: string;
    duration: number;
    hour: number;
    minute: number;
    recurrence: string;
    startTime?: string;
    threshold: string;
    /**
     * timezone
     */
    timezone: string;
    weekOfMonth: number;
}

export interface GetNdbMaintenanceWindowTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbMaintenanceWindowsMaintenanceWindow {
    /**
     * access level
     */
    accessLevel: string;
    /**
     * created date of maintenance window
     */
    dateCreated: string;
    /**
     * modified date of maintenance window
     */
    dateModified: string;
    /**
     * description of maintenance window
     */
    description: string;
    /**
     * entity task association for maintenance window
     */
    entityTaskAssocs: outputs.GetNdbMaintenanceWindowsMaintenanceWindowEntityTaskAssoc[];
    id: string;
    /**
     * name of maintenance window
     */
    name: string;
    /**
     * next run time for maintenance window to trigger
     */
    nextRunTime: string;
    /**
     * owner id of maintenance window
     */
    ownerId: string;
    /**
     * properties of maintenance window
     */
    properties: outputs.GetNdbMaintenanceWindowsMaintenanceWindowProperty[];
    /**
     * schedule of maintenance window
     */
    schedules: outputs.GetNdbMaintenanceWindowsMaintenanceWindowSchedule[];
    /**
     * status of maintennace window
     */
    status: string;
    /**
     * tags of maintenance window
     */
    tags: outputs.GetNdbMaintenanceWindowsMaintenanceWindowTag[];
    /**
     * timezone
     */
    timezone: string;
}

export interface GetNdbMaintenanceWindowsMaintenanceWindowEntityTaskAssoc {
    /**
     * access level
     */
    accessLevel: string;
    /**
     * created date of maintenance window
     */
    dateCreated: string;
    /**
     * modified date of maintenance window
     */
    dateModified: string;
    /**
     * description of maintenance window
     */
    description: string;
    entity: string;
    entityId: string;
    entityType: string;
    id: string;
    maintenanceWindowId: string;
    maintenanceWindowOwnerId: string;
    /**
     * name of maintenance window
     */
    name: string;
    /**
     * owner id of maintenance window
     */
    ownerId: string;
    payloads: outputs.GetNdbMaintenanceWindowsMaintenanceWindowEntityTaskAssocPayload[];
    /**
     * properties of maintenance window
     */
    properties: outputs.GetNdbMaintenanceWindowsMaintenanceWindowEntityTaskAssocProperty[];
    /**
     * status of maintennace window
     */
    status: string;
    /**
     * tags of maintenance window
     */
    tags: outputs.GetNdbMaintenanceWindowsMaintenanceWindowEntityTaskAssocTag[];
    taskType: string;
}

export interface GetNdbMaintenanceWindowsMaintenanceWindowEntityTaskAssocPayload {
    prePostCommands: outputs.GetNdbMaintenanceWindowsMaintenanceWindowEntityTaskAssocPayloadPrePostCommand[];
}

export interface GetNdbMaintenanceWindowsMaintenanceWindowEntityTaskAssocPayloadPrePostCommand {
    postCommand: string;
    preCommand: string;
}

export interface GetNdbMaintenanceWindowsMaintenanceWindowEntityTaskAssocProperty {
    /**
     * name of maintenance window
     */
    name: string;
    value: string;
}

export interface GetNdbMaintenanceWindowsMaintenanceWindowEntityTaskAssocTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbMaintenanceWindowsMaintenanceWindowProperty {
    /**
     * name of maintenance window
     */
    name: string;
    value: string;
}

export interface GetNdbMaintenanceWindowsMaintenanceWindowSchedule {
    dayOfWeek: string;
    duration: number;
    hour: number;
    minute: number;
    recurrence: string;
    startTime?: string;
    threshold: string;
    /**
     * timezone
     */
    timezone: string;
    weekOfMonth: number;
}

export interface GetNdbMaintenanceWindowsMaintenanceWindowTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbNetworkAvailableIpsAvailableIp {
    /**
     * cluster id
     */
    clusterId: string;
    /**
     * cluster name
     */
    clusterName: string;
    /**
     * network profile id
     */
    id: string;
    /**
     * list of available ips in network
     */
    ipAddresses: string[];
    /**
     * managed by ndb or not
     */
    managed: boolean;
    /**
     * Network Name
     */
    name: string;
    /**
     * property name of vlan
     */
    propertyName: string;
    /**
     * type of network
     */
    type: string;
}

export interface GetNdbNetworkIpAddress {
    /**
     * dbserver id
     */
    dbserverId: string;
    /**
     * dbserver name
     */
    dbserverName: string;
    /**
     * ip of pool
     */
    ip: string;
    /**
     * ip status
     */
    status: string;
}

export interface GetNdbNetworkIpPool {
    /**
     * address of ips ranges
     */
    addresses: outputs.GetNdbNetworkIpPoolAddress[];
    /**
     * end ip
     */
    endIp: string;
    /**
     * start ip
     */
    startIp: string;
}

export interface GetNdbNetworkIpPoolAddress {
    /**
     * ip of pool
     */
    ip: string;
    /**
     * ip status
     */
    status: string;
}

export interface GetNdbNetworkPropertiesMap {
    /**
     * gateway of vlan
     */
    vlanGateway: string;
    /**
     * primary dns of vlan
     */
    vlanPrimaryDns: string;
    /**
     * secondary dns of vlan
     */
    vlanSecondaryDns: string;
    /**
     * subnet mask of vlan
     */
    vlanSubnetMask: string;
}

export interface GetNdbNetworkProperty {
    /**
     * name of network
     */
    name: string;
    secure: boolean;
    value: string;
}

export interface GetNdbNetworksNetwork {
    /**
     * cluster id where network is present
     */
    clusterId: string;
    /**
     * network id
     */
    id: string;
    /**
     * IP addresses of network
     */
    ipAddresses: outputs.GetNdbNetworksNetworkIpAddress[];
    /**
     * IP Pools of network
     */
    ipPools: outputs.GetNdbNetworksNetworkIpPool[];
    /**
     * network managed by NDB or not
     */
    managed: boolean;
    /**
     * network name
     */
    name: string;
    /**
     * properties of network
     */
    properties: outputs.GetNdbNetworksNetworkProperty[];
    /**
     * properties map of network
     */
    propertiesMaps: outputs.GetNdbNetworksNetworkPropertiesMap[];
    /**
     * stretched vlan id
     */
    stretchedVlanId: string;
    /**
     * type of network
     */
    type: string;
}

export interface GetNdbNetworksNetworkIpAddress {
    /**
     * dbserver id
     */
    dbserverId: string;
    /**
     * dbserver name
     */
    dbserverName: string;
    /**
     * ip of pool
     */
    ip: string;
    /**
     * ip status
     */
    status: string;
}

export interface GetNdbNetworksNetworkIpPool {
    /**
     * address of ips ranges
     */
    addresses: outputs.GetNdbNetworksNetworkIpPoolAddress[];
    /**
     * end ip
     */
    endIp: string;
    /**
     * start ip
     */
    startIp: string;
}

export interface GetNdbNetworksNetworkIpPoolAddress {
    /**
     * ip of pool
     */
    ip: string;
    /**
     * ip status
     */
    status: string;
}

export interface GetNdbNetworksNetworkPropertiesMap {
    /**
     * gateway of vlan
     */
    vlanGateway: string;
    /**
     * primary dns of vlan
     */
    vlanPrimaryDns: string;
    /**
     * secondary dns of vlan
     */
    vlanSecondaryDns: string;
    /**
     * subnet mask of vlan
     */
    vlanSubnetMask: string;
}

export interface GetNdbNetworksNetworkProperty {
    /**
     * network name
     */
    name: string;
    secure: boolean;
    value: string;
}

export interface GetNdbProfileClusterAvailability {
    dateCreated: string;
    dateModified: string;
    /**
     * - era cluster ID
     */
    nxClusterId: string;
    ownerId: string;
    /**
     * Profile ID for query
     */
    profileId: string;
    /**
     * - status of profile
     */
    status: string;
}

export interface GetNdbProfileVersion {
    /**
     * - database version
     */
    dbVersion: string;
    deprecated: boolean;
    /**
     * - description of profile
     */
    description: string;
    /**
     * - database engine type
     */
    engineType: string;
    /**
     * - id of profile
     */
    id: string;
    /**
     * - profile name
     */
    name: string;
    /**
     * - owner name
     */
    owner: string;
    /**
     * Profile ID for query
     */
    profileId: string;
    properties: outputs.GetNdbProfileVersionProperty[];
    propertiesMap: {[key: string]: string};
    published: boolean;
    /**
     * - status of profile
     */
    status: string;
    /**
     * - if system profile or not
     */
    systemProfile: boolean;
    /**
     * - topology
     */
    topology: string;
    type: string;
    version: string;
    versionClusterAssociations: outputs.GetNdbProfileVersionVersionClusterAssociation[];
}

export interface GetNdbProfileVersionProperty {
    /**
     * - profile name
     */
    name: string;
    secure: boolean;
    value: string;
}

export interface GetNdbProfileVersionVersionClusterAssociation {
    dateCreated: string;
    dateModified: string;
    /**
     * - era cluster ID
     */
    nxClusterId: string;
    optimizedForProvisioning: boolean;
    ownerId: string;
    profileVersionId: string;
    properties: outputs.GetNdbProfileVersionVersionClusterAssociationProperty[];
    /**
     * - status of profile
     */
    status: string;
}

export interface GetNdbProfileVersionVersionClusterAssociationProperty {
    /**
     * - profile name
     */
    name: string;
    secure: boolean;
    value: string;
}

export interface GetNdbProfilesProfile {
    assocDatabases: string[];
    assocDbServers: string[];
    clusterAvailabilities: outputs.GetNdbProfilesProfileClusterAvailability[];
    dbVersion: string;
    description: string;
    engineType: string;
    id: string;
    latestVersion: string;
    latestVersionId: string;
    name: string;
    nxClusterId: string;
    owner: string;
    status: string;
    systemProfile: boolean;
    topology: string;
    type: string;
    versions: outputs.GetNdbProfilesProfileVersion[];
}

export interface GetNdbProfilesProfileClusterAvailability {
    dateCreated: string;
    dateModified: string;
    nxClusterId: string;
    ownerId: string;
    profileId: string;
    status: string;
}

export interface GetNdbProfilesProfileVersion {
    dbVersion: string;
    deprecated: boolean;
    description: string;
    engineType: string;
    id: string;
    name: string;
    owner: string;
    profileId: string;
    properties: outputs.GetNdbProfilesProfileVersionProperty[];
    propertiesMap: {[key: string]: string};
    published: boolean;
    status: string;
    systemProfile: boolean;
    topology: string;
    type: string;
    version: string;
    versionClusterAssociations: outputs.GetNdbProfilesProfileVersionVersionClusterAssociation[];
}

export interface GetNdbProfilesProfileVersionProperty {
    name: string;
    secure: boolean;
    value: string;
}

export interface GetNdbProfilesProfileVersionVersionClusterAssociation {
    dateCreated: string;
    dateModified: string;
    nxClusterId: string;
    optimizedForProvisioning: boolean;
    ownerId: string;
    profileVersionId: string;
    properties: outputs.GetNdbProfilesProfileVersionVersionClusterAssociationProperty[];
    status: string;
}

export interface GetNdbProfilesProfileVersionVersionClusterAssociationProperty {
    name: string;
    secure: boolean;
    value: string;
}

export interface GetNdbSlasSla {
    /**
     * - continuous retention of logs limit
     */
    continuousRetention: number;
    /**
     * - Current active frequency
     */
    currentActiveFrequency: string;
    /**
     * - Daily snapshots retention limit
     */
    dailyRetention: number;
    /**
     * - creation date
     */
    dateCreated: string;
    /**
     * - last modified
     */
    dateModified: string;
    /**
     * - description of sla
     */
    description: string;
    /**
     * - ID of sla
     */
    id: string;
    /**
     * - Monthly snapshots retention limit
     */
    monthlyRetention: number;
    /**
     * - sla name
     */
    name: string;
    /**
     * - owner ID
     */
    ownerId: string;
    /**
     * - If point in time recovery enabled
     */
    pitrEnabled: boolean;
    /**
     * - Daily snapshots retention limit
     */
    quartelyRetention: number;
    /**
     * - Reference count
     */
    referenceCount: number;
    /**
     * - if system sla
     */
    systemSla: boolean;
    /**
     * - unique name
     */
    uniqueName: string;
    /**
     * - weeky snapshots retention limit
     */
    weeklyRetention: number;
    /**
     * - Yearly snapshots retention limit
     */
    yearlyRetention: number;
}

export interface GetNdbSnapshotFilter {
    /**
     * load child snapshots. Default is false
     */
    loadReplicatedChildSnapshots?: string;
    /**
     * Default is UTC
     */
    timezone?: string;
}

export interface GetNdbSnapshotLcmConfig {
    expiryDetails: outputs.GetNdbSnapshotLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.GetNdbSnapshotLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.GetNdbSnapshotLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.GetNdbSnapshotLcmConfigRefreshDetail[];
}

export interface GetNdbSnapshotLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface GetNdbSnapshotLcmConfigPostDeleteCommand {
    command: string;
}

export interface GetNdbSnapshotLcmConfigPreDeleteCommand {
    command: string;
}

export interface GetNdbSnapshotLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface GetNdbSnapshotProperty {
    /**
     * description of snapshot
     */
    description: string;
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbSnapshotTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbSnapshotsFilter {
    /**
     * Fetches all the snapshots for a given time machine
     */
    timeMachineId?: string;
}

export interface GetNdbSnapshotsSnapshot {
    appInfoVersion: string;
    applicableTypes: string[];
    databaseNodeId: string;
    databaseSnapshot: boolean;
    dateCreated: string;
    dateModified: string;
    dbserverId: string;
    dbserverIp: string;
    dbserverName: string;
    dbserverStorageMetadataVersion: number;
    description: string;
    fromTimestamp: string;
    id: string;
    lcmConfigs: outputs.GetNdbSnapshotsSnapshotLcmConfig[];
    name: string;
    nxClusterId: string;
    parentSnapshot: boolean;
    parentSnapshotId: string;
    processed: boolean;
    /**
     * List of all the properties
     */
    properties: outputs.GetNdbSnapshotsSnapshotProperty[];
    protectionDomainId: string;
    replicatedSnapshots: string[];
    santized: boolean;
    santizedFromSnapshotId: string;
    santizedSnapshots: string;
    snapshotFamily: string;
    snapshotSize: number;
    snapshotTimestamp: string;
    snapshotTimestampDate: number;
    snapshotUuid: string;
    softwareDatabaseSnapshot: boolean;
    softwareSnapshot: string;
    softwareSnapshotId: string;
    status: string;
    tags: outputs.GetNdbSnapshotsSnapshotTag[];
    /**
     * Fetches all the snapshots for a given time machine
     */
    timeMachineId: string;
    timezone: string;
    toTimestamp: string;
    type: string;
}

export interface GetNdbSnapshotsSnapshotLcmConfig {
    expiryDetails: outputs.GetNdbSnapshotsSnapshotLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.GetNdbSnapshotsSnapshotLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.GetNdbSnapshotsSnapshotLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.GetNdbSnapshotsSnapshotLcmConfigRefreshDetail[];
}

export interface GetNdbSnapshotsSnapshotLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface GetNdbSnapshotsSnapshotLcmConfigPostDeleteCommand {
    command: string;
}

export interface GetNdbSnapshotsSnapshotLcmConfigPreDeleteCommand {
    command: string;
}

export interface GetNdbSnapshotsSnapshotLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface GetNdbSnapshotsSnapshotProperty {
    description: string;
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbSnapshotsSnapshotTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbTagsTag {
    /**
     * date created of the tag
     */
    dateCreated: string;
    /**
     * modified date of tha tag
     */
    dateModified: string;
    /**
     * description for the tag
     */
    description: string;
    /**
     * entity for the tag to be associated with.
     */
    entityType: string;
    id: string;
    /**
     * name for the tag
     */
    name: string;
    /**
     * owner id of the tag
     */
    owner: string;
    /**
     * tag value for entities.
     */
    required: boolean;
    /**
     * Status of the tag
     */
    status: string;
    /**
     * value for the tag
     */
    values: number;
}

export interface GetNdbTimeMachineProperty {
    /**
     * time machine description
     */
    description: string;
    /**
     * time machine name
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbTimeMachineSchedule {
    continuousSchedules: outputs.GetNdbTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.GetNdbTimeMachineScheduleDailySchedule[];
    /**
     * date created
     */
    dateCreated: string;
    /**
     * date modified
     */
    dateModified: string;
    /**
     * time machine description
     */
    description: string;
    globalPolicy: boolean;
    /**
     * time machine id
     */
    id: string;
    monthlySchedules: outputs.GetNdbTimeMachineScheduleMonthlySchedule[];
    /**
     * time machine name
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.GetNdbTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.GetNdbTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.GetNdbTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.GetNdbTimeMachineScheduleYearlySchedule[];
}

export interface GetNdbTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface GetNdbTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface GetNdbTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface GetNdbTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface GetNdbTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface GetNdbTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface GetNdbTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface GetNdbTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    /**
     * date created
     */
    dateCreated: string;
    /**
     * date modified
     */
    dateModified: string;
    /**
     * time machine description
     */
    description: string;
    /**
     * time machine id
     */
    id: string;
    monthlyRetention: number;
    /**
     * time machine name
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface GetNdbTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbTimeMachinesTimeMachine {
    /**
     * access level to time machines
     */
    accessLevel: string;
    /**
     * clone time machine or not
     */
    clone: boolean;
    /**
     * clone info
     */
    clones: string;
    /**
     * clustered or not
     */
    clustered: boolean;
    /**
     * database info
     */
    database: string;
    /**
     * database id
     */
    databaseId: string;
    /**
     * date created
     */
    dateCreated: string;
    /**
     * date modified
     */
    dateModified: string;
    /**
     * time machine description
     */
    description: string;
    /**
     * ea status of time machine
     */
    eaStatus: string;
    /**
     * time machine id
     */
    id: string;
    /**
     * Metric info
     */
    metric: string;
    /**
     * time machine name
     */
    name: string;
    /**
     * List of all the properties
     */
    properties: outputs.GetNdbTimeMachinesTimeMachineProperty[];
    /**
     * schedule id
     */
    scheduleId: string;
    /**
     * schedule info
     *
     *
     * See detailed information in [NDB Time Machines](https://www.nutanix.dev/api_references/ndb/#/e68ba687086ed-get-list-of-all-time-machines).
     */
    schedules: outputs.GetNdbTimeMachinesTimeMachineSchedule[];
    /**
     * scope
     */
    scope: string;
    /**
     * sla id
     */
    slaId: string;
    /**
     * sla update in progress
     */
    slaUpdateInProgress: boolean;
    /**
     * sla update metadata
     */
    slaUpdateMetadata: string;
    /**
     * sla info
     */
    slas: outputs.GetNdbTimeMachinesTimeMachineSla[];
    /**
     * source clusters
     */
    sourceNxClusters: string[];
    /**
     * status of time machine
     */
    status: string;
    /**
     * tags
     */
    tags: outputs.GetNdbTimeMachinesTimeMachineTag[];
    /**
     * type of time machine
     */
    type: string;
}

export interface GetNdbTimeMachinesTimeMachineProperty {
    /**
     * time machine description
     */
    description: string;
    /**
     * time machine name
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbTimeMachinesTimeMachineSchedule {
    continuousSchedules: outputs.GetNdbTimeMachinesTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.GetNdbTimeMachinesTimeMachineScheduleDailySchedule[];
    /**
     * date created
     */
    dateCreated: string;
    /**
     * date modified
     */
    dateModified: string;
    /**
     * time machine description
     */
    description: string;
    globalPolicy: boolean;
    /**
     * time machine id
     */
    id: string;
    monthlySchedules: outputs.GetNdbTimeMachinesTimeMachineScheduleMonthlySchedule[];
    /**
     * time machine name
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.GetNdbTimeMachinesTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.GetNdbTimeMachinesTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.GetNdbTimeMachinesTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.GetNdbTimeMachinesTimeMachineScheduleYearlySchedule[];
}

export interface GetNdbTimeMachinesTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface GetNdbTimeMachinesTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface GetNdbTimeMachinesTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface GetNdbTimeMachinesTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface GetNdbTimeMachinesTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface GetNdbTimeMachinesTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface GetNdbTimeMachinesTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface GetNdbTimeMachinesTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    /**
     * date created
     */
    dateCreated: string;
    /**
     * date modified
     */
    dateModified: string;
    /**
     * time machine description
     */
    description: string;
    /**
     * time machine id
     */
    id: string;
    monthlyRetention: number;
    /**
     * time machine name
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface GetNdbTimeMachinesTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbTmsCapabilityCapability {
    continuousRegions: outputs.GetNdbTmsCapabilityCapabilityContinuousRegion[];
    databaseIds: string[];
    databasesContinuousRegion: string;
    from: string;
    mode: string;
    snapshots: outputs.GetNdbTmsCapabilityCapabilitySnapshot[];
    timeUnit: string;
    timeUnitNumber: string;
    to: string;
}

export interface GetNdbTmsCapabilityCapabilityContinuousRegion {
    dbLogs: outputs.GetNdbTmsCapabilityCapabilityContinuousRegionDbLog[];
    fromTime: string;
    message: string;
    partialRanges: boolean;
    processedRanges: outputs.GetNdbTmsCapabilityCapabilityContinuousRegionProcessedRange[];
    snapshotIds: string[];
    snapshots: string;
    subRange: boolean;
    timeRangeAndDatabases: string;
    timezone: string;
    toTime: string;
    unknownTimeRanges: string;
    unprocessedRanges: outputs.GetNdbTmsCapabilityCapabilityContinuousRegionUnprocessedRange[];
}

export interface GetNdbTmsCapabilityCapabilityContinuousRegionDbLog {
    databaseId: string;
    databaseNodeId: string;
    dateCreated: string;
    dateModified: string;
    eraLogDriveId: string;
    fromTime: string;
    id: string;
    infos: outputs.GetNdbTmsCapabilityCapabilityContinuousRegionDbLogInfo[];
    logCopyOperationId: string;
    message: string;
    metadatas: outputs.GetNdbTmsCapabilityCapabilityContinuousRegionDbLogMetadata[];
    name: string;
    ownerId: string;
    size: number;
    status: string;
    toTime: string;
    unprocessed: boolean;
}

export interface GetNdbTmsCapabilityCapabilityContinuousRegionDbLogInfo {
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
    unknownTimeRange: boolean;
}

export interface GetNdbTmsCapabilityCapabilityContinuousRegionDbLogMetadata {
    createdDirectly: boolean;
    curationRetryCount: number;
    deregisterInfos: outputs.GetNdbTmsCapabilityCapabilityContinuousRegionDbLogMetadataDeregisterInfo[];
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
    updatedDirectly: boolean;
}

export interface GetNdbTmsCapabilityCapabilityContinuousRegionDbLogMetadataDeregisterInfo {
    message: string;
    operations: string[];
}

export interface GetNdbTmsCapabilityCapabilityContinuousRegionProcessedRange {
    first: string;
    second: string;
}

export interface GetNdbTmsCapabilityCapabilityContinuousRegionUnprocessedRange {
    first: string;
    second: string;
}

export interface GetNdbTmsCapabilityCapabilitySnapshot {
    appInfoVersion: string;
    applicableTypes: string[];
    databaseNodeId: string;
    databaseSnapshot: boolean;
    dateCreated: string;
    dateModified: string;
    dbserverId: string;
    dbserverIp: string;
    dbserverName: string;
    dbserverStorageMetadataVersion: number;
    description: string;
    fromTimestamp: string;
    id: string;
    lcmConfigs: outputs.GetNdbTmsCapabilityCapabilitySnapshotLcmConfig[];
    metadatas: outputs.GetNdbTmsCapabilityCapabilitySnapshotMetadata[];
    name: string;
    nxClusterId: string;
    ownerId: string;
    parentSnapshot: boolean;
    parentSnapshotId: string;
    processed: boolean;
    /**
     * List of all the properties
     */
    properties: outputs.GetNdbTmsCapabilityCapabilitySnapshotProperty[];
    protectionDomainId: string;
    replicatedSnapshots: string[];
    santized: boolean;
    santizedFromSnapshotId: string;
    santizedSnapshots: string;
    snapshotFamily: string;
    snapshotSize: number;
    snapshotTimestamp: string;
    snapshotTimestampDate: number;
    snapshotUuid: string;
    softwareDatabaseSnapshot: boolean;
    softwareSnapshot: string;
    softwareSnapshotId: string;
    status: string;
    tags: outputs.GetNdbTmsCapabilityCapabilitySnapshotTag[];
    timeMachineId: string;
    timezone: string;
    toTimestamp: string;
    type: string;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotLcmConfig {
    expiryDetails: outputs.GetNdbTmsCapabilityCapabilitySnapshotLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.GetNdbTmsCapabilityCapabilitySnapshotLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.GetNdbTmsCapabilityCapabilitySnapshotLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.GetNdbTmsCapabilityCapabilitySnapshotLcmConfigRefreshDetail[];
}

export interface GetNdbTmsCapabilityCapabilitySnapshotLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotLcmConfigPostDeleteCommand {
    command: string;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotLcmConfigPreDeleteCommand {
    command: string;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotMetadata {
    async: boolean;
    curationRetryCount: number;
    deregisterInfo: {[key: string]: string};
    fromTimestamp: string;
    infos: outputs.GetNdbTmsCapabilityCapabilitySnapshotMetadataInfo[];
    lastReplicationRetyrSourceSnapshotId: string;
    operationsUsingSnapshots: string[];
    replicationRetryCount: number;
    secureInfo: {[key: string]: string};
    standBy: boolean;
    toTimestamp: string;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotMetadataInfo {
    bpgConfigs: outputs.GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfig {
    bpgDbParams: outputs.GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigBpgDbParam[];
    storages: outputs.GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigStorage[];
    vmProperties: outputs.GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigVmProperty[];
}

export interface GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigStorage {
    archiveStorages: outputs.GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigStorageLogDisk[];
}

export interface GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotMetadataInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotProperty {
    description: string;
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbTmsCapabilityCapabilitySnapshotTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshot {
    appInfoVersion: string;
    applicableTypes: string[];
    databaseNodeId: string;
    databaseSnapshot: boolean;
    dateCreated: string;
    dateModified: string;
    dbserverId: string;
    dbserverIp: string;
    dbserverName: string;
    dbserverStorageMetadataVersion: number;
    description: string;
    fromTimestamp: string;
    id: string;
    lcmConfigs: outputs.GetNdbTmsCapabilityLastContinuousSnapshotLcmConfig[];
    metadatas: outputs.GetNdbTmsCapabilityLastContinuousSnapshotMetadata[];
    name: string;
    nxClusterId: string;
    ownerId: string;
    parentSnapshot: boolean;
    parentSnapshotId: string;
    processed: boolean;
    /**
     * List of all the properties
     */
    properties: outputs.GetNdbTmsCapabilityLastContinuousSnapshotProperty[];
    protectionDomainId: string;
    replicatedSnapshots: string[];
    santized: boolean;
    santizedFromSnapshotId: string;
    santizedSnapshots: string;
    snapshotFamily: string;
    snapshotSize: number;
    snapshotTimestamp: string;
    snapshotTimestampDate: number;
    snapshotUuid: string;
    softwareDatabaseSnapshot: boolean;
    softwareSnapshot: string;
    softwareSnapshotId: string;
    status: string;
    tags: outputs.GetNdbTmsCapabilityLastContinuousSnapshotTag[];
    timeMachineId: string;
    timezone: string;
    toTimestamp: string;
    type: string;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotLcmConfig {
    expiryDetails: outputs.GetNdbTmsCapabilityLastContinuousSnapshotLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.GetNdbTmsCapabilityLastContinuousSnapshotLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.GetNdbTmsCapabilityLastContinuousSnapshotLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.GetNdbTmsCapabilityLastContinuousSnapshotLcmConfigRefreshDetail[];
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotLcmConfigPostDeleteCommand {
    command: string;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotLcmConfigPreDeleteCommand {
    command: string;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotMetadata {
    async: boolean;
    curationRetryCount: number;
    deregisterInfo: {[key: string]: string};
    fromTimestamp: string;
    infos: outputs.GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfo[];
    lastReplicationRetrySourceSnapshotId: string;
    lastReplicationRetryTimestamp: string;
    operationsUsingSnapshots: string[];
    replicationRetryCount: number;
    secureInfo: {[key: string]: string};
    standBy: boolean;
    toTimestamp: string;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfo {
    bpgConfigs: outputs.GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfig {
    bpgDbParams: outputs.GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigBpgDbParam[];
    storages: outputs.GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigStorage[];
    vmProperties: outputs.GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigVmProperty[];
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigStorage {
    archiveStorages: outputs.GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigStorageLogDisk[];
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotMetadataInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotProperty {
    description: string;
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface GetNdbTmsCapabilityLastContinuousSnapshotTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface GetNdbTmsCapabilityLastDbLog {
    databaseId: string;
    databaseNodeId: string;
    dateCreated: string;
    dateModified: string;
    eraLogDriveId: string;
    fromTime: string;
    id: string;
    logCopyOperationId: string;
    message: string;
    metadatas: outputs.GetNdbTmsCapabilityLastDbLogMetadata[];
    name: string;
    ownerId: string;
    size: number;
    status: string;
    toTime: string;
    unprocessed: boolean;
}

export interface GetNdbTmsCapabilityLastDbLogMetadata {
    createdDirectly: boolean;
    curationRetryCount: number;
    deregisterInfos: outputs.GetNdbTmsCapabilityLastDbLogMetadataDeregisterInfo[];
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
    updatedDirectly: boolean;
}

export interface GetNdbTmsCapabilityLastDbLogMetadataDeregisterInfo {
    message: string;
    operations: string[];
}

export interface GetNetworkSecurityPoliciesV2NetworkPolicy {
    /**
     * created by.
     */
    createdBy: string;
    /**
     * creation time of NSP
     */
    creationTime: string;
    /**
     * A user defined annotation for a policy.
     */
    description: string;
    /**
     * Network security policy UUID.
     */
    extId: string;
    /**
     * If Hitlog is enabled.
     */
    isHitlogEnabled: boolean;
    /**
     * If Ipv6 Traffic is allowed.
     */
    isIpv6TrafficAllowed: boolean;
    /**
     * Is system defined NSP
     */
    isSystemDefined: boolean;
    /**
     * last updated time
     */
    lastUpdateTime: string;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetNetworkSecurityPoliciesV2NetworkPolicyLink[];
    /**
     * Name of the Flow Network Security Policy.
     */
    name: string;
    /**
     * A list of rules that form a policy. For isolation policies, use isolation rules; for application or quarantine policies, use application rules.
     */
    rules: outputs.GetNetworkSecurityPoliciesV2NetworkPolicyRule[];
    /**
     * Defines the scope of the policy. Currently, only ALL_VLAN and VPC_LIST are supported. If scope is not provided, the default is set based on whether vpcReferences field is provided or not.
     */
    scope: string;
    /**
     * Uuids of the secured groups in the NSP.
     */
    securedGroups: string[];
    /**
     * Whether the policy is applied or monitored; can be omitted or set null to save the policy without applying or monitoring it.
     */
    state: string;
    /**
     * A globally unique identifier that represents the tenant that owns this entity
     */
    tenantId: string;
    /**
     * Defines the type of rules that can be used in a policy.
     */
    type: string;
    /**
     * A list of external ids for VPCs, used only when the scope of policy is a list of VPCs.
     */
    vpcReferences: string[];
}

export interface GetNetworkSecurityPoliciesV2NetworkPolicyLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     *
     * See detailed information in [Nutanix List Security Policies v4](https://developers.nutanix.com/api-reference?namespace=microseg&version=v4.0#tag/NetworkSecurityPolicies/operation/listNetworkSecurityPolicies).
     */
    rel: string;
}

export interface GetNetworkSecurityPoliciesV2NetworkPolicyRule {
    /**
     * A user defined annotation for a rule.
     */
    description: string;
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetNetworkSecurityPoliciesV2NetworkPolicyRuleLink[];
    /**
     * Spec for rules.
     */
    specs: outputs.GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpec[];
    /**
     * The type for a rule - the value chosen here restricts which specification can be chosen.
     */
    type: string;
}

export interface GetNetworkSecurityPoliciesV2NetworkPolicyRuleLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     *
     * See detailed information in [Nutanix List Security Policies v4](https://developers.nutanix.com/api-reference?namespace=microseg&version=v4.0#tag/NetworkSecurityPolicies/operation/listNetworkSecurityPolicies).
     */
    rel: string;
}

export interface GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpec {
    /**
     * Application Rule Spec.
     */
    applicationRuleSpecs: outputs.GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecApplicationRuleSpec[];
    /**
     * Intra entity group Rule Spec
     */
    intraEntityGroupRuleSpecs: outputs.GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecIntraEntityGroupRuleSpec[];
    /**
     * Multi Environment Isolation Rule Spec.
     */
    multiEnvIsolationRuleSpecs: outputs.GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecMultiEnvIsolationRuleSpec[];
    /**
     * Two Environment Isolation Rule Spec.
     */
    twoEnvIsolationRuleSpecs: outputs.GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecTwoEnvIsolationRuleSpec[];
}

export interface GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecApplicationRuleSpec {
    /**
     * A list of address group references.
     */
    destAddressGroupReferences: string[];
    /**
     * A specification to how allow mode traffic should be applied, either ALL or NONE.
     */
    destAllowSpec: string;
    /**
     * List of categories that define a set of network endpoints as outbound.
     */
    destCategoryReferences: string[];
    /**
     * destination subnet value
     */
    destSubnets: outputs.GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecApplicationRuleSpecDestSubnet[];
    /**
     * icmp services
     */
    icmpServices: outputs.GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecApplicationRuleSpecIcmpService[];
    /**
     * Denotes if rule allows traffic for all protocol.
     */
    isAllProtocolAllowed: boolean;
    /**
     * A reference to the network function chain in the rule.
     */
    networkFunctionChainReference: string;
    /**
     * A set of network endpoints which is protected by a Network Security Policy and defined as a list of categories.
     */
    securedGroupCategoryReferences: string[];
    /**
     * A list of service group references.
     */
    serviceGroupReferences: string[];
    /**
     * A list of address group references.
     */
    srcAddressGroupReferences: string[];
    /**
     * A specification to how allow mode traffic should be applied, either ALL or NONE.
     */
    srcAllowSpec: string;
    /**
     * List of categories that define a set of network endpoints as inbound.
     */
    srcCategoryReferences: string[];
    /**
     * source subnet value
     */
    srcSubnets: outputs.GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecApplicationRuleSpecSrcSubnet[];
    /**
     * tcp services
     */
    tcpServices: outputs.GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecApplicationRuleSpecTcpService[];
    /**
     * udp services
     */
    udpServices: outputs.GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecApplicationRuleSpecUdpService[];
}

export interface GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecApplicationRuleSpecDestSubnet {
    prefixLength: number;
    value: string;
}

export interface GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecApplicationRuleSpecIcmpService {
    /**
     * Icmp service Code. Ignore this field if Code has to be ANY.
     */
    code: number;
    /**
     * Set this field to true if both Type and Code is ANY.
     */
    isAllAllowed: boolean;
    /**
     * Icmp service Type. Ignore this field if Type has to be ANY.
     */
    type: number;
}

export interface GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecApplicationRuleSpecSrcSubnet {
    prefixLength: number;
    value: string;
}

export interface GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecApplicationRuleSpecTcpService {
    /**
     * end port
     */
    endPort: number;
    /**
     * start port
     */
    startPort: number;
}

export interface GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecApplicationRuleSpecUdpService {
    /**
     * end port
     */
    endPort: number;
    /**
     * start port
     */
    startPort: number;
}

export interface GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecIntraEntityGroupRuleSpec {
    /**
     * List of secured group action.
     */
    securedGroupAction: string;
    /**
     * A specification to whether traffic between intra secured group entities should be allowed or denied.
     */
    securedGroupCategoryReferences: string[];
}

export interface GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecMultiEnvIsolationRuleSpec {
    /**
     * Multi Environment Isolation Rule Spec.
     */
    specs: outputs.GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecMultiEnvIsolationRuleSpecSpec[];
}

export interface GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecMultiEnvIsolationRuleSpecSpec {
    /**
     * all to all isolation group
     */
    allToAllIsolationGroups: outputs.GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroup[];
}

export interface GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroup {
    /**
     * Denotes the list of secured groups that will be used in All to All mutual isolation.
     */
    isolationGroups: outputs.GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupIsolationGroup[];
}

export interface GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupIsolationGroup {
    /**
     * External identifiers of categories belonging to the isolation group.
     */
    groupCategoryReferences: string[];
}

export interface GetNetworkSecurityPoliciesV2NetworkPolicyRuleSpecTwoEnvIsolationRuleSpec {
    /**
     * Denotes the first group of category uuids that will be used in an isolation policy.
     */
    firstIsolationGroups: string[];
    /**
     * Denotes the second group of category uuids that will be used in an isolation policy.
     */
    secondIsolationGroups: string[];
}

export interface GetNetworkSecurityPolicyV2Link {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetNetworkSecurityPolicyV2Rule {
    /**
     * A user defined annotation for a rule.
     */
    description: string;
    /**
     * Network security policy UUID.
     */
    extId: string;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetNetworkSecurityPolicyV2RuleLink[];
    /**
     * Multi Environment Isolation Rule Spec.
     */
    specs: outputs.GetNetworkSecurityPolicyV2RuleSpec[];
    /**
     * Icmp service Type. Ignore this field if Type has to be ANY.
     */
    type: string;
}

export interface GetNetworkSecurityPolicyV2RuleLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetNetworkSecurityPolicyV2RuleSpec {
    /**
     * Application Rule Spec.
     */
    applicationRuleSpecs: outputs.GetNetworkSecurityPolicyV2RuleSpecApplicationRuleSpec[];
    /**
     * Intra entity group Rule Spec
     */
    intraEntityGroupRuleSpecs: outputs.GetNetworkSecurityPolicyV2RuleSpecIntraEntityGroupRuleSpec[];
    /**
     * Multi Environment Isolation Rule Spec.
     */
    multiEnvIsolationRuleSpecs: outputs.GetNetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpec[];
    /**
     * Two Environment Isolation Rule Spec.
     */
    twoEnvIsolationRuleSpecs: outputs.GetNetworkSecurityPolicyV2RuleSpecTwoEnvIsolationRuleSpec[];
}

export interface GetNetworkSecurityPolicyV2RuleSpecApplicationRuleSpec {
    /**
     * A list of address group references.
     */
    destAddressGroupReferences: string[];
    /**
     * A specification to how allow mode traffic should be applied, either ALL or NONE.
     */
    destAllowSpec: string;
    /**
     * List of categories that define a set of network endpoints as outbound.
     */
    destCategoryReferences: string[];
    /**
     * destination subnet value
     */
    destSubnets: outputs.GetNetworkSecurityPolicyV2RuleSpecApplicationRuleSpecDestSubnet[];
    /**
     * icmp services
     */
    icmpServices: outputs.GetNetworkSecurityPolicyV2RuleSpecApplicationRuleSpecIcmpService[];
    /**
     * Denotes if rule allows traffic for all protocol.
     */
    isAllProtocolAllowed: boolean;
    /**
     * A reference to the network function chain in the rule.
     */
    networkFunctionChainReference: string;
    /**
     * A specification to whether traffic between intra secured group entities should be allowed or denied.
     */
    securedGroupCategoryReferences: string[];
    /**
     * A list of service group references.
     */
    serviceGroupReferences: string[];
    /**
     * A list of address group references.
     */
    srcAddressGroupReferences: string[];
    /**
     * A specification to how allow mode traffic should be applied, either ALL or NONE.
     */
    srcAllowSpec: string;
    /**
     * List of categories that define a set of network endpoints as inbound.
     */
    srcCategoryReferences: string[];
    /**
     * source subnet value
     */
    srcSubnets: outputs.GetNetworkSecurityPolicyV2RuleSpecApplicationRuleSpecSrcSubnet[];
    /**
     * tcp services
     */
    tcpServices: outputs.GetNetworkSecurityPolicyV2RuleSpecApplicationRuleSpecTcpService[];
    /**
     * udp services
     */
    udpServices: outputs.GetNetworkSecurityPolicyV2RuleSpecApplicationRuleSpecUdpService[];
}

export interface GetNetworkSecurityPolicyV2RuleSpecApplicationRuleSpecDestSubnet {
    prefixLength: number;
    value: string;
}

export interface GetNetworkSecurityPolicyV2RuleSpecApplicationRuleSpecIcmpService {
    /**
     * Icmp service Code. Ignore this field if Code has to be ANY.
     */
    code: number;
    /**
     * Set this field to true if both Type and Code is ANY.
     */
    isAllAllowed: boolean;
    /**
     * Icmp service Type. Ignore this field if Type has to be ANY.
     */
    type: number;
}

export interface GetNetworkSecurityPolicyV2RuleSpecApplicationRuleSpecSrcSubnet {
    prefixLength: number;
    value: string;
}

export interface GetNetworkSecurityPolicyV2RuleSpecApplicationRuleSpecTcpService {
    /**
     * end port
     */
    endPort: number;
    /**
     * start port
     */
    startPort: number;
}

export interface GetNetworkSecurityPolicyV2RuleSpecApplicationRuleSpecUdpService {
    /**
     * end port
     */
    endPort: number;
    /**
     * start port
     */
    startPort: number;
}

export interface GetNetworkSecurityPolicyV2RuleSpecIntraEntityGroupRuleSpec {
    /**
     * List of secured group action.
     */
    securedGroupAction: string;
    /**
     * A specification to whether traffic between intra secured group entities should be allowed or denied.
     */
    securedGroupCategoryReferences: string[];
}

export interface GetNetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpec {
    /**
     * Multi Environment Isolation Rule Spec.
     */
    specs: outputs.GetNetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpec[];
}

export interface GetNetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpec {
    /**
     * all to all isolation group
     */
    allToAllIsolationGroups: outputs.GetNetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroup[];
}

export interface GetNetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroup {
    /**
     * Denotes the list of secured groups that will be used in All to All mutual isolation.
     */
    isolationGroups: outputs.GetNetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupIsolationGroup[];
}

export interface GetNetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupIsolationGroup {
    /**
     * External identifiers of categories belonging to the isolation group.
     */
    groupCategoryReferences: string[];
}

export interface GetNetworkSecurityPolicyV2RuleSpecTwoEnvIsolationRuleSpec {
    /**
     * Denotes the first group of category uuids that will be used in an isolation policy.
     */
    firstIsolationGroups: string[];
    /**
     * Denotes the second group of category uuids that will be used in an isolation policy.
     */
    secondIsolationGroups: string[];
}

export interface GetNetworkSecurityRuleAdRuleInboundAllowList {
    addressGroupInclusionLists: outputs.GetNetworkSecurityRuleAdRuleInboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.GetNetworkSecurityRuleAdRuleInboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.GetNetworkSecurityRuleAdRuleInboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.GetNetworkSecurityRuleAdRuleInboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.GetNetworkSecurityRuleAdRuleInboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetNetworkSecurityRuleAdRuleInboundAllowListUdpPortRangeList[];
}

export interface GetNetworkSecurityRuleAdRuleInboundAllowListAddressGroupInclusionList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetNetworkSecurityRuleAdRuleInboundAllowListFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleAdRuleInboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetNetworkSecurityRuleAdRuleInboundAllowListServiceGroupList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetNetworkSecurityRuleAdRuleInboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAdRuleInboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAdRuleOutboundAllowList {
    addressGroupInclusionLists: outputs.GetNetworkSecurityRuleAdRuleOutboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.GetNetworkSecurityRuleAdRuleOutboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.GetNetworkSecurityRuleAdRuleOutboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.GetNetworkSecurityRuleAdRuleOutboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.GetNetworkSecurityRuleAdRuleOutboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetNetworkSecurityRuleAdRuleOutboundAllowListUdpPortRangeList[];
}

export interface GetNetworkSecurityRuleAdRuleOutboundAllowListAddressGroupInclusionList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetNetworkSecurityRuleAdRuleOutboundAllowListFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleAdRuleOutboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetNetworkSecurityRuleAdRuleOutboundAllowListServiceGroupList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetNetworkSecurityRuleAdRuleOutboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAdRuleOutboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAdRuleTargetGroupFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleAppRuleInboundAllowList {
    addressGroupInclusionLists: outputs.GetNetworkSecurityRuleAppRuleInboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.GetNetworkSecurityRuleAppRuleInboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.GetNetworkSecurityRuleAppRuleInboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.GetNetworkSecurityRuleAppRuleInboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.GetNetworkSecurityRuleAppRuleInboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetNetworkSecurityRuleAppRuleInboundAllowListUdpPortRangeList[];
}

export interface GetNetworkSecurityRuleAppRuleInboundAllowListAddressGroupInclusionList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetNetworkSecurityRuleAppRuleInboundAllowListFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleAppRuleInboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetNetworkSecurityRuleAppRuleInboundAllowListServiceGroupList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetNetworkSecurityRuleAppRuleInboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAppRuleInboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAppRuleOutboundAllowList {
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.GetNetworkSecurityRuleAppRuleOutboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.GetNetworkSecurityRuleAppRuleOutboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    tcpPortRangeLists: outputs.GetNetworkSecurityRuleAppRuleOutboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetNetworkSecurityRuleAppRuleOutboundAllowListUdpPortRangeList[];
}

export interface GetNetworkSecurityRuleAppRuleOutboundAllowListFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleAppRuleOutboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetNetworkSecurityRuleAppRuleOutboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAppRuleOutboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAppRuleTargetGroupFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleCategory {
    /**
     * - the name.
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetNetworkSecurityRuleIsolationRuleFirstEntityFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleIsolationRuleSecondEntityFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleQuarantineRuleInboundAllowList {
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.GetNetworkSecurityRuleQuarantineRuleInboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.GetNetworkSecurityRuleQuarantineRuleInboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    tcpPortRangeLists: outputs.GetNetworkSecurityRuleQuarantineRuleInboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetNetworkSecurityRuleQuarantineRuleInboundAllowListUdpPortRangeList[];
}

export interface GetNetworkSecurityRuleQuarantineRuleInboundAllowListFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleQuarantineRuleInboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetNetworkSecurityRuleQuarantineRuleInboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleQuarantineRuleInboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleQuarantineRuleOutboundAllowList {
    addressGroupInclusionLists: outputs.GetNetworkSecurityRuleQuarantineRuleOutboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.GetNetworkSecurityRuleQuarantineRuleOutboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.GetNetworkSecurityRuleQuarantineRuleOutboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.GetNetworkSecurityRuleQuarantineRuleOutboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.GetNetworkSecurityRuleQuarantineRuleOutboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetNetworkSecurityRuleQuarantineRuleOutboundAllowListUdpPortRangeList[];
}

export interface GetNetworkSecurityRuleQuarantineRuleOutboundAllowListAddressGroupInclusionList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetNetworkSecurityRuleQuarantineRuleOutboundAllowListFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleQuarantineRuleOutboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetNetworkSecurityRuleQuarantineRuleOutboundAllowListServiceGroupList {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetNetworkSecurityRuleQuarantineRuleOutboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleQuarantineRuleOutboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleQuarantineRuleTargetGroupFilterParam {
    /**
     * - the name.
     */
    name: string;
    values: string[];
}

export interface GetOperationV2AssociatedEndpointList {
    /**
     * Version of the API for the provided associated endpoint.
     */
    apiVersion: string;
    /**
     * Endpoint URL.
     */
    endpointUrl: string;
    /**
     * HTTP method for the provided associated endpoint.
     */
    httpMethod: string;
}

export interface GetOperationsV2Operation {
    /**
     * List of associated endpoint objects for the Operation.
     */
    associatedEndpointLists: outputs.GetOperationsV2OperationAssociatedEndpointList[];
    /**
     * Client that created the entity.
     */
    clientName: string;
    /**
     * Permission creation time
     */
    createdTime: string;
    /**
     * Permission description
     */
    description: string;
    /**
     * Permission name.
     */
    displayName: string;
    /**
     * Type of entity associated with this Operation.
     */
    entityType: string;
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    /**
     * Permission last updated time.
     */
    lastUpdatedTime: string;
    /**
     * The Operation type. Currently we support INTERNAL, EXTERNAL and SYSTEM_DEFINED_ONLY.
     */
    operationType: string;
    /**
     * List of related Operations. These are the Operations which might need to be given access to, along with the current Operation, for certain workflows to succeed.
     */
    relatedOperationLists: string[];
}

export interface GetOperationsV2OperationAssociatedEndpointList {
    /**
     * Version of the API for the provided associated endpoint.
     */
    apiVersion: string;
    /**
     * Endpoint URL.
     */
    endpointUrl: string;
    /**
     * HTTP method for the provided associated endpoint.
     */
    httpMethod: string;
}

export interface GetPbrSpec {
    /**
     * - the name.
     */
    name: string;
    /**
     * PBR resources status
     */
    resources: outputs.GetPbrSpecResource[];
}

export interface GetPbrSpecResource {
    /**
     * Routing policy action
     */
    actions: outputs.GetPbrSpecResourceAction[];
    /**
     * destination address of an IP.
     */
    destinations: outputs.GetPbrSpecResourceDestination[];
    /**
     * Policy in reverse direction.
     */
    isBidirectional: boolean;
    /**
     * priority of routing policy
     */
    priority: number;
    /**
     * Routing policy IP protocol parameters
     */
    protocolParameters: outputs.GetPbrSpecResourceProtocolParameter[];
    /**
     * Protocol type of routing policy
     */
    protocolType: string;
    /**
     * source address of an IP.
     */
    sources: outputs.GetPbrSpecResourceSource[];
    /**
     * Reference to VPC
     */
    vpcReference: {[key: string]: string};
}

export interface GetPbrSpecResourceAction {
    /**
     * Routing policy action
     */
    action: string;
    serviceIpLists: string[];
}

export interface GetPbrSpecResourceDestination {
    addressType: string;
    /**
     * prefix length of provided subnet.
     */
    prefixLength?: number;
    /**
     * IP subnet provided as an address.
     */
    subnetIp?: string;
}

export interface GetPbrSpecResourceProtocolParameter {
    /**
     * ICMP parameters in routing policy.
     */
    icmps: outputs.GetPbrSpecResourceProtocolParameterIcmp[];
    /**
     * Protocol number in routing policy
     */
    protocolNumber: number;
    /**
     * TCP parameters in routing policy
     */
    tcps: outputs.GetPbrSpecResourceProtocolParameterTcp[];
    /**
     * UDP parameters in routing policy
     */
    udps: outputs.GetPbrSpecResourceProtocolParameterUdp[];
}

export interface GetPbrSpecResourceProtocolParameterIcmp {
    icmpCode: number;
    icmpType: number;
}

export interface GetPbrSpecResourceProtocolParameterTcp {
    destinationPortRangeLists: outputs.GetPbrSpecResourceProtocolParameterTcpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrSpecResourceProtocolParameterTcpSourcePortRangeList[];
}

export interface GetPbrSpecResourceProtocolParameterTcpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrSpecResourceProtocolParameterTcpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrSpecResourceProtocolParameterUdp {
    destinationPortRangeLists: outputs.GetPbrSpecResourceProtocolParameterUdpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrSpecResourceProtocolParameterUdpSourcePortRangeList[];
}

export interface GetPbrSpecResourceProtocolParameterUdpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrSpecResourceProtocolParameterUdpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrSpecResourceSource {
    addressType: string;
    /**
     * prefix length of provided subnet.
     */
    prefixLength?: number;
    /**
     * IP subnet provided as an address.
     */
    subnetIp?: string;
}

export interface GetPbrStatus {
    /**
     * Execution Context of PBR.
     */
    executionContexts: outputs.GetPbrStatusExecutionContext[];
    /**
     * - the name.
     */
    name: string;
    /**
     * PBR resources status
     */
    resources: outputs.GetPbrStatusResource[];
    /**
     * The state of the PBR
     */
    state: string;
}

export interface GetPbrStatusExecutionContext {
    taskUuids: string[];
}

export interface GetPbrStatusResource {
    /**
     * Routing policy action
     */
    actions: outputs.GetPbrStatusResourceAction[];
    /**
     * destination address of an IP.
     */
    destinations: outputs.GetPbrStatusResourceDestination[];
    /**
     * Policy in reverse direction.
     */
    isBidirectional: boolean;
    /**
     * priority of routing policy
     */
    priority: number;
    /**
     * Routing policy IP protocol parameters
     */
    protocolParameters: outputs.GetPbrStatusResourceProtocolParameter[];
    /**
     * Protocol type of routing policy
     */
    protocolType: string;
    routingPolicyCounters: outputs.GetPbrStatusResourceRoutingPolicyCounter[];
    /**
     * source address of an IP.
     */
    sources: outputs.GetPbrStatusResourceSource[];
    /**
     * Reference to VPC
     */
    vpcReference: {[key: string]: string};
}

export interface GetPbrStatusResourceAction {
    /**
     * Routing policy action
     */
    action: string;
    serviceIpLists: string[];
}

export interface GetPbrStatusResourceDestination {
    addressType: string;
    /**
     * prefix length of provided subnet.
     */
    prefixLength?: number;
    /**
     * IP subnet provided as an address.
     */
    subnetIp?: string;
}

export interface GetPbrStatusResourceProtocolParameter {
    /**
     * ICMP parameters in routing policy.
     */
    icmps: outputs.GetPbrStatusResourceProtocolParameterIcmp[];
    /**
     * Protocol number in routing policy
     */
    protocolNumber: number;
    /**
     * TCP parameters in routing policy
     */
    tcps: outputs.GetPbrStatusResourceProtocolParameterTcp[];
    /**
     * UDP parameters in routing policy
     */
    udps: outputs.GetPbrStatusResourceProtocolParameterUdp[];
}

export interface GetPbrStatusResourceProtocolParameterIcmp {
    icmpCode: number;
    icmpType: number;
}

export interface GetPbrStatusResourceProtocolParameterTcp {
    destinationPortRangeLists: outputs.GetPbrStatusResourceProtocolParameterTcpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrStatusResourceProtocolParameterTcpSourcePortRangeList[];
}

export interface GetPbrStatusResourceProtocolParameterTcpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrStatusResourceProtocolParameterTcpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrStatusResourceProtocolParameterUdp {
    destinationPortRangeLists: outputs.GetPbrStatusResourceProtocolParameterUdpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrStatusResourceProtocolParameterUdpSourcePortRangeList[];
}

export interface GetPbrStatusResourceProtocolParameterUdpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrStatusResourceProtocolParameterUdpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrStatusResourceRoutingPolicyCounter {
    byteCount: number;
    packetCount: number;
}

export interface GetPbrStatusResourceSource {
    addressType: string;
    /**
     * prefix length of provided subnet.
     */
    prefixLength?: number;
    /**
     * IP subnet provided as an address.
     */
    subnetIp?: string;
}

export interface GetPbrV2Link {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetPbrV2Metadata {
    /**
     * A list of globally unique identifiers that represent all the categories the resource is associated with.
     */
    categoryIds: any[][];
    /**
     * A globally unique identifier that represents the owner of this resource.
     */
    ownerReferenceId: string;
    /**
     * The userName of the owner of this resource.
     */
    ownerUserName: string;
    /**
     * The name of the project this resource belongs to.
     */
    projectName: string;
    /**
     * A globally unique identifier that represents the project this resource belongs to.
     */
    projectReferenceId: string;
}

export interface GetPbrV2Policy {
    /**
     * If True, policies in the reverse direction will be installed with the same action but source and destination will be swapped.
     */
    isBidirectional: boolean;
    /**
     * The action to be taken on the traffic matching the routing policy.
     */
    policyActions: outputs.GetPbrV2PolicyPolicyAction[];
    /**
     * Match condition for the traffic that is entering the VPC.
     */
    policyMatches: outputs.GetPbrV2PolicyPolicyMatch[];
}

export interface GetPbrV2PolicyPolicyAction {
    /**
     * Routing policy action type.
     */
    actionType: string;
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    nexthopIpAddresses: outputs.GetPbrV2PolicyPolicyActionNexthopIpAddress[];
    /**
     * Routing policy Reroute params.
     */
    rerouteParams: outputs.GetPbrV2PolicyPolicyActionRerouteParam[];
}

export interface GetPbrV2PolicyPolicyActionNexthopIpAddress {
    ipv4s: outputs.GetPbrV2PolicyPolicyActionNexthopIpAddressIpv4[];
    ipv6s: outputs.GetPbrV2PolicyPolicyActionNexthopIpAddressIpv6[];
}

export interface GetPbrV2PolicyPolicyActionNexthopIpAddressIpv4 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrV2PolicyPolicyActionNexthopIpAddressIpv6 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrV2PolicyPolicyActionRerouteParam {
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    egressServiceIps: outputs.GetPbrV2PolicyPolicyActionRerouteParamEgressServiceIp[];
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    ingressServiceIps: outputs.GetPbrV2PolicyPolicyActionRerouteParamIngressServiceIp[];
    /**
     * Type of fallback action in reroute case when service VM is down.
     */
    rerouteFallbackAction: string;
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    serviceIps: outputs.GetPbrV2PolicyPolicyActionRerouteParamServiceIp[];
}

export interface GetPbrV2PolicyPolicyActionRerouteParamEgressServiceIp {
    ipv4s: outputs.GetPbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv4[];
    ipv6s: outputs.GetPbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv6[];
}

export interface GetPbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv4 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv6 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrV2PolicyPolicyActionRerouteParamIngressServiceIp {
    ipv4s: outputs.GetPbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv4[];
    ipv6s: outputs.GetPbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv6[];
}

export interface GetPbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv4 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv6 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrV2PolicyPolicyActionRerouteParamServiceIp {
    ipv4s: outputs.GetPbrV2PolicyPolicyActionRerouteParamServiceIpIpv4[];
    ipv6s: outputs.GetPbrV2PolicyPolicyActionRerouteParamServiceIpIpv6[];
}

export interface GetPbrV2PolicyPolicyActionRerouteParamServiceIpIpv4 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrV2PolicyPolicyActionRerouteParamServiceIpIpv6 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrV2PolicyPolicyMatch {
    /**
     * Address Type like "EXTERNAL" or "ANY".
     */
    destinations: outputs.GetPbrV2PolicyPolicyMatchDestination[];
    /**
     * Protocol Params Object.
     */
    protocolParameters: outputs.GetPbrV2PolicyPolicyMatchProtocolParameter[];
    /**
     * Routing Policy IP protocol type.
     */
    protocolType: string;
    /**
     * Address Type like "EXTERNAL" or "ANY".
     */
    sources: outputs.GetPbrV2PolicyPolicyMatchSource[];
}

export interface GetPbrV2PolicyPolicyMatchDestination {
    /**
     * Address Type like "EXTERNAL" or "ANY".
     */
    addressType: string;
    /**
     * Subnet Prefix
     */
    subnetPrefixes: outputs.GetPbrV2PolicyPolicyMatchDestinationSubnetPrefix[];
}

export interface GetPbrV2PolicyPolicyMatchDestinationSubnetPrefix {
    ipv4s: outputs.GetPbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4[];
    ipv6s: outputs.GetPbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6[];
}

export interface GetPbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4 {
    /**
     * IP of address
     */
    ips: outputs.GetPbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4Ip[];
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
}

export interface GetPbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4Ip {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6 {
    /**
     * IP of address
     */
    ips: outputs.GetPbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6Ip[];
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
}

export interface GetPbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6Ip {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrV2PolicyPolicyMatchProtocolParameter {
    /**
     * ICMP object
     */
    icmpObjects: outputs.GetPbrV2PolicyPolicyMatchProtocolParameterIcmpObject[];
    /**
     * Layer Four Protocol Object.
     */
    layerFourProtocolObjects: outputs.GetPbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObject[];
    /**
     * Protocol Number Object.
     */
    protocolNumberObjects: outputs.GetPbrV2PolicyPolicyMatchProtocolParameterProtocolNumberObject[];
}

export interface GetPbrV2PolicyPolicyMatchProtocolParameterIcmpObject {
    /**
     * icmp code
     */
    icmpCode: number;
    /**
     * icmp type
     */
    icmpType: number;
}

export interface GetPbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObject {
    /**
     * Start and end port ranges object.
     */
    destinationPortRanges: outputs.GetPbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectDestinationPortRange[];
    /**
     * Start and end port ranges object.
     */
    sourcePortRanges: outputs.GetPbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectSourcePortRange[];
}

export interface GetPbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectDestinationPortRange {
    endPort: number;
    startPort: number;
}

export interface GetPbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectSourcePortRange {
    endPort: number;
    startPort: number;
}

export interface GetPbrV2PolicyPolicyMatchProtocolParameterProtocolNumberObject {
    /**
     * protocol number
     */
    protocolNumber: number;
}

export interface GetPbrV2PolicyPolicyMatchSource {
    /**
     * Address Type like "EXTERNAL" or "ANY".
     */
    addressType: string;
    /**
     * Subnet Prefix
     */
    subnetPrefixes: outputs.GetPbrV2PolicyPolicyMatchSourceSubnetPrefix[];
}

export interface GetPbrV2PolicyPolicyMatchSourceSubnetPrefix {
    ipv4s: outputs.GetPbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4[];
    ipv6s: outputs.GetPbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6[];
}

export interface GetPbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4 {
    /**
     * IP of address
     */
    ips: outputs.GetPbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4Ip[];
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
}

export interface GetPbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4Ip {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6 {
    /**
     * IP of address
     */
    ips: outputs.GetPbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6Ip[];
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
}

export interface GetPbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6Ip {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrV2Vpc {
    /**
     * Name of the routing policy.
     */
    name: string;
}

export interface GetPbrsEntity {
    /**
     * - The routing policies kind metadata.
     */
    metadata: {[key: string]: string};
    /**
     * PBR spec
     */
    specs: outputs.GetPbrsEntitySpec[];
    /**
     * PBR output status
     */
    statuses: outputs.GetPbrsEntityStatus[];
}

export interface GetPbrsEntitySpec {
    /**
     * - the name.
     */
    name: string;
    /**
     * PBR resources status
     */
    resources: outputs.GetPbrsEntitySpecResource[];
}

export interface GetPbrsEntitySpecResource {
    /**
     * Routing policy action
     */
    actions: outputs.GetPbrsEntitySpecResourceAction[];
    /**
     * destination address of an IP.
     */
    destinations: outputs.GetPbrsEntitySpecResourceDestination[];
    /**
     * Policy in reverse direction.
     */
    isBidirectional: boolean;
    /**
     * priority of routing policy
     */
    priority: number;
    /**
     * Routing policy IP protocol parameters
     */
    protocolParameters: outputs.GetPbrsEntitySpecResourceProtocolParameter[];
    /**
     * Protocol type of routing policy
     */
    protocolType: string;
    /**
     * source address of an IP.
     */
    sources: outputs.GetPbrsEntitySpecResourceSource[];
    /**
     * Reference to VPC
     */
    vpcReference: {[key: string]: string};
}

export interface GetPbrsEntitySpecResourceAction {
    /**
     * Routing policy action
     */
    action: string;
    serviceIpLists: string[];
}

export interface GetPbrsEntitySpecResourceDestination {
    addressType: string;
    /**
     * prefix length of provided subnet.
     */
    prefixLength?: number;
    /**
     * IP subnet provided as an address.
     */
    subnetIp?: string;
}

export interface GetPbrsEntitySpecResourceProtocolParameter {
    /**
     * ICMP parameters in routing policy.
     */
    icmps: outputs.GetPbrsEntitySpecResourceProtocolParameterIcmp[];
    /**
     * Protocol number in routing policy
     */
    protocolNumber: number;
    /**
     * TCP parameters in routing policy
     */
    tcps: outputs.GetPbrsEntitySpecResourceProtocolParameterTcp[];
    /**
     * UDP parameters in routing policy
     */
    udps: outputs.GetPbrsEntitySpecResourceProtocolParameterUdp[];
}

export interface GetPbrsEntitySpecResourceProtocolParameterIcmp {
    icmpCode: number;
    icmpType: number;
}

export interface GetPbrsEntitySpecResourceProtocolParameterTcp {
    destinationPortRangeLists: outputs.GetPbrsEntitySpecResourceProtocolParameterTcpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrsEntitySpecResourceProtocolParameterTcpSourcePortRangeList[];
}

export interface GetPbrsEntitySpecResourceProtocolParameterTcpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntitySpecResourceProtocolParameterTcpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntitySpecResourceProtocolParameterUdp {
    destinationPortRangeLists: outputs.GetPbrsEntitySpecResourceProtocolParameterUdpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrsEntitySpecResourceProtocolParameterUdpSourcePortRangeList[];
}

export interface GetPbrsEntitySpecResourceProtocolParameterUdpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntitySpecResourceProtocolParameterUdpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntitySpecResourceSource {
    addressType: string;
    /**
     * prefix length of provided subnet.
     */
    prefixLength?: number;
    /**
     * IP subnet provided as an address.
     */
    subnetIp?: string;
}

export interface GetPbrsEntityStatus {
    /**
     * Execution Context of PBR.
     */
    executionContexts: outputs.GetPbrsEntityStatusExecutionContext[];
    /**
     * - the name.
     */
    name: string;
    /**
     * PBR resources status
     */
    resources: outputs.GetPbrsEntityStatusResource[];
    /**
     * The state of the PBR
     */
    state: string;
}

export interface GetPbrsEntityStatusExecutionContext {
    taskUuids: string[];
}

export interface GetPbrsEntityStatusResource {
    /**
     * Routing policy action
     */
    actions: outputs.GetPbrsEntityStatusResourceAction[];
    /**
     * destination address of an IP.
     */
    destinations: outputs.GetPbrsEntityStatusResourceDestination[];
    /**
     * Policy in reverse direction.
     */
    isBidirectional: boolean;
    /**
     * priority of routing policy
     */
    priority: number;
    /**
     * Routing policy IP protocol parameters
     */
    protocolParameters: outputs.GetPbrsEntityStatusResourceProtocolParameter[];
    /**
     * Protocol type of routing policy
     */
    protocolType: string;
    routingPolicyCounters: outputs.GetPbrsEntityStatusResourceRoutingPolicyCounter[];
    /**
     * source address of an IP.
     */
    sources: outputs.GetPbrsEntityStatusResourceSource[];
    /**
     * Reference to VPC
     */
    vpcReference: {[key: string]: string};
}

export interface GetPbrsEntityStatusResourceAction {
    /**
     * Routing policy action
     */
    action: string;
    serviceIpLists: string[];
}

export interface GetPbrsEntityStatusResourceDestination {
    addressType: string;
    /**
     * prefix length of provided subnet.
     */
    prefixLength?: number;
    /**
     * IP subnet provided as an address.
     */
    subnetIp?: string;
}

export interface GetPbrsEntityStatusResourceProtocolParameter {
    /**
     * ICMP parameters in routing policy.
     */
    icmps: outputs.GetPbrsEntityStatusResourceProtocolParameterIcmp[];
    /**
     * Protocol number in routing policy
     */
    protocolNumber: number;
    /**
     * TCP parameters in routing policy
     */
    tcps: outputs.GetPbrsEntityStatusResourceProtocolParameterTcp[];
    /**
     * UDP parameters in routing policy
     */
    udps: outputs.GetPbrsEntityStatusResourceProtocolParameterUdp[];
}

export interface GetPbrsEntityStatusResourceProtocolParameterIcmp {
    icmpCode: number;
    icmpType: number;
}

export interface GetPbrsEntityStatusResourceProtocolParameterTcp {
    destinationPortRangeLists: outputs.GetPbrsEntityStatusResourceProtocolParameterTcpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrsEntityStatusResourceProtocolParameterTcpSourcePortRangeList[];
}

export interface GetPbrsEntityStatusResourceProtocolParameterTcpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntityStatusResourceProtocolParameterTcpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntityStatusResourceProtocolParameterUdp {
    destinationPortRangeLists: outputs.GetPbrsEntityStatusResourceProtocolParameterUdpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrsEntityStatusResourceProtocolParameterUdpSourcePortRangeList[];
}

export interface GetPbrsEntityStatusResourceProtocolParameterUdpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntityStatusResourceProtocolParameterUdpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntityStatusResourceRoutingPolicyCounter {
    byteCount: number;
    packetCount: number;
}

export interface GetPbrsEntityStatusResourceSource {
    addressType: string;
    /**
     * prefix length of provided subnet.
     */
    prefixLength?: number;
    /**
     * IP subnet provided as an address.
     */
    subnetIp?: string;
}

export interface GetPbrsMetadata {
    filter: string;
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
    totalMatches: number;
}

export interface GetPbrsV2RoutingPolicy {
    /**
     * A description of the routing policy.
     */
    description: string;
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetPbrsV2RoutingPolicyLink[];
    /**
     * Metadata associated with this resource.
     */
    metadatas: outputs.GetPbrsV2RoutingPolicyMetadata[];
    /**
     * Name of the routing policy.
     */
    name: string;
    /**
     * Routing Policies
     */
    policies: outputs.GetPbrsV2RoutingPolicyPolicy[];
    /**
     * Priority of the routing policy.
     */
    priority: number;
    /**
     * A globally unique identifier that represents the tenant that owns this entity
     */
    tenantId: string;
    /**
     * ExtId of the VPC extId to which the routing policy belongs.
     */
    vpcExtId: string;
    /**
     * VPC name for projections
     */
    vpcs: outputs.GetPbrsV2RoutingPolicyVpc[];
}

export interface GetPbrsV2RoutingPolicyLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetPbrsV2RoutingPolicyMetadata {
    /**
     * A list of globally unique identifiers that represent all the categories the resource is associated with.
     */
    categoryIds: any[][];
    /**
     * A globally unique identifier that represents the owner of this resource.
     */
    ownerReferenceId: string;
    /**
     * The userName of the owner of this resource.
     */
    ownerUserName: string;
    /**
     * The name of the project this resource belongs to.
     */
    projectName: string;
    /**
     * A globally unique identifier that represents the project this resource belongs to.
     */
    projectReferenceId: string;
}

export interface GetPbrsV2RoutingPolicyPolicy {
    /**
     * If True, policies in the reverse direction will be installed with the same action but source and destination will be swapped.
     */
    isBidirectional: boolean;
    /**
     * The action to be taken on the traffic matching the routing policy.
     */
    policyActions: outputs.GetPbrsV2RoutingPolicyPolicyPolicyAction[];
    /**
     * Match condition for the traffic that is entering the VPC.
     */
    policyMatches: outputs.GetPbrsV2RoutingPolicyPolicyPolicyMatch[];
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyAction {
    /**
     * Routing policy action type.
     */
    actionType: string;
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    nexthopIpAddresses: outputs.GetPbrsV2RoutingPolicyPolicyPolicyActionNexthopIpAddress[];
    /**
     * Routing policy Reroute params.
     */
    rerouteParams: outputs.GetPbrsV2RoutingPolicyPolicyPolicyActionRerouteParam[];
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyActionNexthopIpAddress {
    ipv4s: outputs.GetPbrsV2RoutingPolicyPolicyPolicyActionNexthopIpAddressIpv4[];
    ipv6s: outputs.GetPbrsV2RoutingPolicyPolicyPolicyActionNexthopIpAddressIpv6[];
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyActionNexthopIpAddressIpv4 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyActionNexthopIpAddressIpv6 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyActionRerouteParam {
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    egressServiceIps: outputs.GetPbrsV2RoutingPolicyPolicyPolicyActionRerouteParamEgressServiceIp[];
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    ingressServiceIps: outputs.GetPbrsV2RoutingPolicyPolicyPolicyActionRerouteParamIngressServiceIp[];
    /**
     * Type of fallback action in reroute case when service VM is down.
     */
    rerouteFallbackAction: string;
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    serviceIps: outputs.GetPbrsV2RoutingPolicyPolicyPolicyActionRerouteParamServiceIp[];
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyActionRerouteParamEgressServiceIp {
    ipv4s: outputs.GetPbrsV2RoutingPolicyPolicyPolicyActionRerouteParamEgressServiceIpIpv4[];
    ipv6s: outputs.GetPbrsV2RoutingPolicyPolicyPolicyActionRerouteParamEgressServiceIpIpv6[];
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyActionRerouteParamEgressServiceIpIpv4 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyActionRerouteParamEgressServiceIpIpv6 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyActionRerouteParamIngressServiceIp {
    ipv4s: outputs.GetPbrsV2RoutingPolicyPolicyPolicyActionRerouteParamIngressServiceIpIpv4[];
    ipv6s: outputs.GetPbrsV2RoutingPolicyPolicyPolicyActionRerouteParamIngressServiceIpIpv6[];
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyActionRerouteParamIngressServiceIpIpv4 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyActionRerouteParamIngressServiceIpIpv6 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyActionRerouteParamServiceIp {
    ipv4s: outputs.GetPbrsV2RoutingPolicyPolicyPolicyActionRerouteParamServiceIpIpv4[];
    ipv6s: outputs.GetPbrsV2RoutingPolicyPolicyPolicyActionRerouteParamServiceIpIpv6[];
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyActionRerouteParamServiceIpIpv4 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyActionRerouteParamServiceIpIpv6 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyMatch {
    /**
     * Address Type like "EXTERNAL" or "ANY".
     */
    destinations: outputs.GetPbrsV2RoutingPolicyPolicyPolicyMatchDestination[];
    /**
     * Protocol Params Object.
     */
    protocolParameters: outputs.GetPbrsV2RoutingPolicyPolicyPolicyMatchProtocolParameter[];
    /**
     * Routing Policy IP protocol type.
     */
    protocolType: string;
    /**
     * Address Type like "EXTERNAL" or "ANY".
     */
    sources: outputs.GetPbrsV2RoutingPolicyPolicyPolicyMatchSource[];
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyMatchDestination {
    /**
     * Address Type like "EXTERNAL" or "ANY".
     */
    addressType: string;
    /**
     * Subnet Prefix
     */
    subnetPrefixes: outputs.GetPbrsV2RoutingPolicyPolicyPolicyMatchDestinationSubnetPrefix[];
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyMatchDestinationSubnetPrefix {
    ipv4s: outputs.GetPbrsV2RoutingPolicyPolicyPolicyMatchDestinationSubnetPrefixIpv4[];
    ipv6s: outputs.GetPbrsV2RoutingPolicyPolicyPolicyMatchDestinationSubnetPrefixIpv6[];
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyMatchDestinationSubnetPrefixIpv4 {
    /**
     * IP of address
     */
    ips: outputs.GetPbrsV2RoutingPolicyPolicyPolicyMatchDestinationSubnetPrefixIpv4Ip[];
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyMatchDestinationSubnetPrefixIpv4Ip {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyMatchDestinationSubnetPrefixIpv6 {
    /**
     * IP of address
     */
    ips: outputs.GetPbrsV2RoutingPolicyPolicyPolicyMatchDestinationSubnetPrefixIpv6Ip[];
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyMatchDestinationSubnetPrefixIpv6Ip {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyMatchProtocolParameter {
    /**
     * ICMP object
     */
    icmpObjects: outputs.GetPbrsV2RoutingPolicyPolicyPolicyMatchProtocolParameterIcmpObject[];
    /**
     * Layer Four Protocol Object.
     */
    layerFourProtocolObjects: outputs.GetPbrsV2RoutingPolicyPolicyPolicyMatchProtocolParameterLayerFourProtocolObject[];
    /**
     * Protocol Number Object.
     */
    protocolNumberObjects: outputs.GetPbrsV2RoutingPolicyPolicyPolicyMatchProtocolParameterProtocolNumberObject[];
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyMatchProtocolParameterIcmpObject {
    /**
     * icmp code
     */
    icmpCode: number;
    /**
     * icmp type
     */
    icmpType: number;
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyMatchProtocolParameterLayerFourProtocolObject {
    /**
     * Start and end port ranges object.
     */
    destinationPortRanges: outputs.GetPbrsV2RoutingPolicyPolicyPolicyMatchProtocolParameterLayerFourProtocolObjectDestinationPortRange[];
    /**
     * Start and end port ranges object.
     */
    sourcePortRanges: outputs.GetPbrsV2RoutingPolicyPolicyPolicyMatchProtocolParameterLayerFourProtocolObjectSourcePortRange[];
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyMatchProtocolParameterLayerFourProtocolObjectDestinationPortRange {
    endPort: number;
    startPort: number;
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyMatchProtocolParameterLayerFourProtocolObjectSourcePortRange {
    endPort: number;
    startPort: number;
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyMatchProtocolParameterProtocolNumberObject {
    /**
     * protocol number
     */
    protocolNumber: number;
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyMatchSource {
    /**
     * Address Type like "EXTERNAL" or "ANY".
     */
    addressType: string;
    /**
     * Subnet Prefix
     */
    subnetPrefixes: outputs.GetPbrsV2RoutingPolicyPolicyPolicyMatchSourceSubnetPrefix[];
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyMatchSourceSubnetPrefix {
    ipv4s: outputs.GetPbrsV2RoutingPolicyPolicyPolicyMatchSourceSubnetPrefixIpv4[];
    ipv6s: outputs.GetPbrsV2RoutingPolicyPolicyPolicyMatchSourceSubnetPrefixIpv6[];
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyMatchSourceSubnetPrefixIpv4 {
    /**
     * IP of address
     */
    ips: outputs.GetPbrsV2RoutingPolicyPolicyPolicyMatchSourceSubnetPrefixIpv4Ip[];
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyMatchSourceSubnetPrefixIpv4Ip {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyMatchSourceSubnetPrefixIpv6 {
    /**
     * IP of address
     */
    ips: outputs.GetPbrsV2RoutingPolicyPolicyPolicyMatchSourceSubnetPrefixIpv6Ip[];
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
}

export interface GetPbrsV2RoutingPolicyPolicyPolicyMatchSourceSubnetPrefixIpv6Ip {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * ip value
     */
    value: string;
}

export interface GetPbrsV2RoutingPolicyVpc {
    /**
     * Name of the routing policy.
     */
    name: string;
}

export interface GetPcBackupTargetV2Link {
    href: string;
    rel: string;
}

export interface GetPcBackupTargetV2Location {
    /**
     * - A boolean value indicating whether to enable lockdown mode for a cluster.
     */
    clusterLocations: outputs.GetPcBackupTargetV2LocationClusterLocation[];
    /**
     * - Currently representing the build information to be used for the cluster creation.
     */
    objectStoreLocations: outputs.GetPcBackupTargetV2LocationObjectStoreLocation[];
}

export interface GetPcBackupTargetV2LocationClusterLocation {
    /**
     * - Cluster reference of the remote cluster to be connected.
     */
    configs: outputs.GetPcBackupTargetV2LocationClusterLocationConfig[];
}

export interface GetPcBackupTargetV2LocationClusterLocationConfig {
    /**
     * -(Required) A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    /**
     * - Name of the cluster.
     */
    name: string;
}

export interface GetPcBackupTargetV2LocationObjectStoreLocation {
    /**
     * -(Optional) Backup policy for the object store provided.
     */
    backupPolicies: outputs.GetPcBackupTargetV2LocationObjectStoreLocationBackupPolicy[];
    /**
     * -(Required) The base model of S3 object store endpoint where domain manager is backed up.
     */
    providerConfigs: outputs.GetPcBackupTargetV2LocationObjectStoreLocationProviderConfig[];
}

export interface GetPcBackupTargetV2LocationObjectStoreLocationBackupPolicy {
    /**
     * - RPO interval in minutes at which the backup will be taken. The Value should be in the range of 60 to 1440.
     */
    rpoInMinutes: number;
}

export interface GetPcBackupTargetV2LocationObjectStoreLocationProviderConfig {
    /**
     * - The bucket name of the object store endpoint where backup data of domain manager is to be stored.
     */
    bucketName: string;
    /**
     * - Secret credentials model for the object store containing access key ID and secret access key.
     */
    credentials: outputs.GetPcBackupTargetV2LocationObjectStoreLocationProviderConfigCredential[];
    /**
     * - The region name of the object store endpoint where backup data of domain manager is stored. Default is `us-east-1`.
     */
    region: string;
}

export interface GetPcBackupTargetV2LocationObjectStoreLocationProviderConfigCredential {
    /**
     * - Access key ID for the object store provided for backup target.
     */
    accessKeyId: string;
    /**
     * - Secret access key for the object store provided for backup target.
     */
    secretAccessKey: string;
}

export interface GetPcBackupTargetsV2BackupTarget {
    backupPauseReason: string;
    extId: string;
    isBackupPaused: boolean;
    lastSyncTime: string;
    links: outputs.GetPcBackupTargetsV2BackupTargetLink[];
    locations: outputs.GetPcBackupTargetsV2BackupTargetLocation[];
    tenantId: string;
}

export interface GetPcBackupTargetsV2BackupTargetLink {
    href: string;
    rel: string;
}

export interface GetPcBackupTargetsV2BackupTargetLocation {
    clusterLocations: outputs.GetPcBackupTargetsV2BackupTargetLocationClusterLocation[];
    objectStoreLocations: outputs.GetPcBackupTargetsV2BackupTargetLocationObjectStoreLocation[];
}

export interface GetPcBackupTargetsV2BackupTargetLocationClusterLocation {
    configs: outputs.GetPcBackupTargetsV2BackupTargetLocationClusterLocationConfig[];
}

export interface GetPcBackupTargetsV2BackupTargetLocationClusterLocationConfig {
    extId: string;
    name: string;
}

export interface GetPcBackupTargetsV2BackupTargetLocationObjectStoreLocation {
    backupPolicies: outputs.GetPcBackupTargetsV2BackupTargetLocationObjectStoreLocationBackupPolicy[];
    providerConfigs: outputs.GetPcBackupTargetsV2BackupTargetLocationObjectStoreLocationProviderConfig[];
}

export interface GetPcBackupTargetsV2BackupTargetLocationObjectStoreLocationBackupPolicy {
    rpoInMinutes: number;
}

export interface GetPcBackupTargetsV2BackupTargetLocationObjectStoreLocationProviderConfig {
    bucketName: string;
    credentials: outputs.GetPcBackupTargetsV2BackupTargetLocationObjectStoreLocationProviderConfigCredential[];
    region: string;
}

export interface GetPcBackupTargetsV2BackupTargetLocationObjectStoreLocationProviderConfigCredential {
    accessKeyId: string;
    secretAccessKey: string;
}

export interface GetPcRestorePointV2DomainManager {
    /**
     * - Domain manager (Prism Central) cluster configuration details.
     */
    configs: outputs.GetPcRestorePointV2DomainManagerConfig[];
    /**
     * Restore point ID for the backup created in cluster/object store.
     */
    extId: string;
    /**
     * - The external identifier of the cluster hosting the domain manager (Prism Central) instance.
     */
    hostingClusterExtId: string;
    /**
     * - Boolean value indicating if the domain manager (Prism Central) is registered with the hosting cluster, that is, Prism Element.
     */
    isRegisteredWithHostingCluster: boolean;
    /**
     * - Domain manager (Prism Central) network configuration details.
     */
    networks: outputs.GetPcRestorePointV2DomainManagerNetwork[];
    /**
     * - Domain manager (Prism Central) nodes external identifier.
     */
    nodeExtIds: string[];
    /**
     * - This configuration enables Prism Central to be deployed in scale-out mode.
     */
    shouldEnableHighAvailability: boolean;
    /**
     * - A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server).
     */
    tenantId: string;
}

export interface GetPcRestorePointV2DomainManagerConfig {
    /**
     * - Bootstrap configuration details for the domain manager (Prism Central).
     */
    bootstrapConfig: outputs.GetPcRestorePointV2DomainManagerConfigBootstrapConfig;
    /**
     * -Currently representing the build information to be used for the cluster creation.
     */
    buildInfo: outputs.GetPcRestorePointV2DomainManagerConfigBuildInfo;
    credentials?: outputs.GetPcRestorePointV2DomainManagerConfigCredential[];
    /**
     * - Name of the domain manager (Prism Central).
     */
    name: string;
    /**
     * - This configuration is used to provide the resource-related details like container external identifiers, number of VCPUs, memory size, data disk size of the domain manager (Prism Central). In the case of a multi-node setup, the sum of resources like number of VCPUs, memory size and data disk size are provided.
     */
    resourceConfigs: outputs.GetPcRestorePointV2DomainManagerConfigResourceConfig[];
    /**
     * - A boolean value indicating whether to enable lockdown mode for a cluster.
     */
    shouldEnableLockdownMode: boolean;
    /**
     * - Domain manager (Prism Central) size is an enumeration of starter, small, large, or extra large starter values. possible values are:
     * - `SMALL` : Domain manager (Prism Central) of size small.
     * - `LARGE` : Domain manager (Prism Central) of size large.
     * - `EXTRALARGE` : Domain manager (Prism Central) of size extra large.
     * - `STARTER` : Domain manager (Prism Central) of size starter.
     */
    size: string;
}

export interface GetPcRestorePointV2DomainManagerConfigBootstrapConfig {
    cloudInitConfigs?: outputs.GetPcRestorePointV2DomainManagerConfigBootstrapConfigCloudInitConfig[];
    /**
     * - Environment information for the domain manager (Prism Central) cluster.
     */
    environmentInfo: outputs.GetPcRestorePointV2DomainManagerConfigBootstrapConfigEnvironmentInfo;
}

export interface GetPcRestorePointV2DomainManagerConfigBootstrapConfigCloudInitConfig {
    cloudInitScripts: outputs.GetPcRestorePointV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScript[];
    datasourceType?: string;
    metadata: string;
}

export interface GetPcRestorePointV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScript {
    customKeyValues: outputs.GetPcRestorePointV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValue[];
    userDatas: outputs.GetPcRestorePointV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptUserData[];
}

export interface GetPcRestorePointV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValue {
    keyValuePairs: outputs.GetPcRestorePointV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePair[];
}

export interface GetPcRestorePointV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePair {
    /**
     * - Name of the domain manager (Prism Central).
     */
    name: string;
    /**
     * - The fully qualified domain name of the host.
     */
    values: outputs.GetPcRestorePointV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePairValue[];
}

export interface GetPcRestorePointV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePairValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.GetPcRestorePointV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface GetPcRestorePointV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString {
    map: {[key: string]: string};
}

export interface GetPcRestorePointV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptUserData {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerConfigBootstrapConfigEnvironmentInfo {
    /**
     * - Enums denoting the provider type of the PC, that is, AHV or ESXi.
     * Following are the supported provider types:
     * - `VSPHERE` : Vsphere cloud provider.
     * - `AZURE` : Azure cloud provider.
     * - `NTNX` : Nutanix cloud provider.
     * - `GCP` : GCP cloud provider.
     * - `AWS` : AWS cloud provider.
     */
    providerType: string;
    /**
     * - Enums denoting the instance type of the cloud PC. It indicates whether the PC is created on bare-metal or on a cloud-provisioned VM. Hence, it supports two possible values:
     * - `NTNX` : Nutanix instance.
     * - `NATIVE` : Native instance.
     */
    provisioningType: string;
    /**
     * - Enums denoting the environment type of the PC, that is, on-prem PC or cloud PC.
     * Following are the supported entity types:
     * - `ONPREM` : On-prem environment.
     * - `NTNX_CLOUD` : Nutanix cloud environment.
     */
    type: string;
}

export interface GetPcRestorePointV2DomainManagerConfigBuildInfo {
    /**
     * - Software version.
     */
    version: string;
}

export interface GetPcRestorePointV2DomainManagerConfigCredential {
    password: string;
    username: string;
}

export interface GetPcRestorePointV2DomainManagerConfigResourceConfig {
    /**
     * - The external identifier of the container that will be used to create the domain manager (Prism Central) cluster.
     */
    containerExtIds: string[];
    /**
     * - This property is used for readOnly purposes to display Prism Central data disk size allocation at a cluster level.
     */
    dataDiskSizeBytes: number;
    /**
     * - This property is used for readOnly purposes to display Prism Central RAM allocation at the cluster level.
     */
    memorySizeBytes: number;
    /**
     * - This property is used for readOnly purposes to display Prism Central number of VCPUs allocation.
     */
    numVcpus: number;
}

export interface GetPcRestorePointV2DomainManagerNetwork {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    externalAddress?: outputs.GetPcRestorePointV2DomainManagerNetworkExternalAddress;
    /**
     * - This configuration is used to manage Prism Central.
     */
    externalNetworks: outputs.GetPcRestorePointV2DomainManagerNetworkExternalNetwork[];
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdn: string;
    internalNetworks: outputs.GetPcRestorePointV2DomainManagerNetworkInternalNetworks;
    /**
     * - List of name servers on a cluster. This is part of payload for both cluster create & update operations. For create operation, only ipv4 address / fqdn values are supported currently.
     */
    nameServers: outputs.GetPcRestorePointV2DomainManagerNetworkNameServer[];
    /**
     * - List of NTP servers on a cluster. This is part of payload for both cluster create & update operations. For create operation, only ipv4 address / fqdn values are supported currently.
     */
    ntpServers: outputs.GetPcRestorePointV2DomainManagerNetworkNtpServer[];
}

export interface GetPcRestorePointV2DomainManagerNetworkExternalAddress {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetPcRestorePointV2DomainManagerNetworkExternalAddressIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetPcRestorePointV2DomainManagerNetworkExternalAddressIpv6[];
}

export interface GetPcRestorePointV2DomainManagerNetworkExternalAddressIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkExternalAddressIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkExternalNetwork {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    defaultGateway: outputs.GetPcRestorePointV2DomainManagerNetworkExternalNetworkDefaultGateway;
    /**
     * - Range of IPs used for Prism Central network setup.
     */
    ipRanges: outputs.GetPcRestorePointV2DomainManagerNetworkExternalNetworkIpRange[];
    /**
     * - The network external identifier to which Domain Manager (Prism Central) is to be deployed or is already configured.
     */
    networkExtId: string;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    subnetMask: outputs.GetPcRestorePointV2DomainManagerNetworkExternalNetworkSubnetMask;
}

export interface GetPcRestorePointV2DomainManagerNetworkExternalNetworkDefaultGateway {
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.GetPcRestorePointV2DomainManagerNetworkExternalNetworkDefaultGatewayFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetPcRestorePointV2DomainManagerNetworkExternalNetworkDefaultGatewayIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetPcRestorePointV2DomainManagerNetworkExternalNetworkDefaultGatewayIpv6[];
}

export interface GetPcRestorePointV2DomainManagerNetworkExternalNetworkDefaultGatewayFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkExternalNetworkDefaultGatewayIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkExternalNetworkDefaultGatewayIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkExternalNetworkIpRange {
    /**
     * - The beginning IP address of the range.
     */
    begin: outputs.GetPcRestorePointV2DomainManagerNetworkExternalNetworkIpRangeBegin;
    /**
     * - The ending IP address of the range.
     */
    end: outputs.GetPcRestorePointV2DomainManagerNetworkExternalNetworkIpRangeEnd;
}

export interface GetPcRestorePointV2DomainManagerNetworkExternalNetworkIpRangeBegin {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetPcRestorePointV2DomainManagerNetworkExternalNetworkIpRangeBeginIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetPcRestorePointV2DomainManagerNetworkExternalNetworkIpRangeBeginIpv6[];
}

export interface GetPcRestorePointV2DomainManagerNetworkExternalNetworkIpRangeBeginIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkExternalNetworkIpRangeBeginIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkExternalNetworkIpRangeEnd {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetPcRestorePointV2DomainManagerNetworkExternalNetworkIpRangeEndIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetPcRestorePointV2DomainManagerNetworkExternalNetworkIpRangeEndIpv6[];
}

export interface GetPcRestorePointV2DomainManagerNetworkExternalNetworkIpRangeEndIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkExternalNetworkIpRangeEndIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkExternalNetworkSubnetMask {
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.GetPcRestorePointV2DomainManagerNetworkExternalNetworkSubnetMaskFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetPcRestorePointV2DomainManagerNetworkExternalNetworkSubnetMaskIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetPcRestorePointV2DomainManagerNetworkExternalNetworkSubnetMaskIpv6[];
}

export interface GetPcRestorePointV2DomainManagerNetworkExternalNetworkSubnetMaskFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkExternalNetworkSubnetMaskIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkExternalNetworkSubnetMaskIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkInternalNetworks {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    defaultGateway: outputs.GetPcRestorePointV2DomainManagerNetworkInternalNetworksDefaultGateway;
    /**
     * - Range of IPs used for Prism Central network setup.
     */
    ipRanges: outputs.GetPcRestorePointV2DomainManagerNetworkInternalNetworksIpRange[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    subnetMask: outputs.GetPcRestorePointV2DomainManagerNetworkInternalNetworksSubnetMask;
}

export interface GetPcRestorePointV2DomainManagerNetworkInternalNetworksDefaultGateway {
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.GetPcRestorePointV2DomainManagerNetworkInternalNetworksDefaultGatewayFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetPcRestorePointV2DomainManagerNetworkInternalNetworksDefaultGatewayIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetPcRestorePointV2DomainManagerNetworkInternalNetworksDefaultGatewayIpv6[];
}

export interface GetPcRestorePointV2DomainManagerNetworkInternalNetworksDefaultGatewayFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkInternalNetworksDefaultGatewayIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkInternalNetworksDefaultGatewayIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkInternalNetworksIpRange {
    /**
     * - The beginning IP address of the range.
     */
    begin: outputs.GetPcRestorePointV2DomainManagerNetworkInternalNetworksIpRangeBegin;
    /**
     * - The ending IP address of the range.
     */
    end: outputs.GetPcRestorePointV2DomainManagerNetworkInternalNetworksIpRangeEnd;
}

export interface GetPcRestorePointV2DomainManagerNetworkInternalNetworksIpRangeBegin {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetPcRestorePointV2DomainManagerNetworkInternalNetworksIpRangeBeginIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetPcRestorePointV2DomainManagerNetworkInternalNetworksIpRangeBeginIpv6[];
}

export interface GetPcRestorePointV2DomainManagerNetworkInternalNetworksIpRangeBeginIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkInternalNetworksIpRangeBeginIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkInternalNetworksIpRangeEnd {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetPcRestorePointV2DomainManagerNetworkInternalNetworksIpRangeEndIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetPcRestorePointV2DomainManagerNetworkInternalNetworksIpRangeEndIpv6[];
}

export interface GetPcRestorePointV2DomainManagerNetworkInternalNetworksIpRangeEndIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkInternalNetworksIpRangeEndIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkInternalNetworksSubnetMask {
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.GetPcRestorePointV2DomainManagerNetworkInternalNetworksSubnetMaskFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetPcRestorePointV2DomainManagerNetworkInternalNetworksSubnetMaskIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetPcRestorePointV2DomainManagerNetworkInternalNetworksSubnetMaskIpv6[];
}

export interface GetPcRestorePointV2DomainManagerNetworkInternalNetworksSubnetMaskFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkInternalNetworksSubnetMaskIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkInternalNetworksSubnetMaskIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkNameServer {
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.GetPcRestorePointV2DomainManagerNetworkNameServerFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetPcRestorePointV2DomainManagerNetworkNameServerIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetPcRestorePointV2DomainManagerNetworkNameServerIpv6[];
}

export interface GetPcRestorePointV2DomainManagerNetworkNameServerFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkNameServerIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkNameServerIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkNtpServer {
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.GetPcRestorePointV2DomainManagerNetworkNtpServerFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetPcRestorePointV2DomainManagerNetworkNtpServerIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetPcRestorePointV2DomainManagerNetworkNtpServerIpv6[];
}

export interface GetPcRestorePointV2DomainManagerNetworkNtpServerFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkNtpServerIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2DomainManagerNetworkNtpServerIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcRestorePointV2Link {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetPcRestorePointsV2RestorePoint {
    creationTime: string;
    domainManagers: outputs.GetPcRestorePointsV2RestorePointDomainManager[];
    extId: string;
    /**
     * - `tenantId`
     */
    links: outputs.GetPcRestorePointsV2RestorePointLink[];
    /**
     * A unique identifier for the domain manager.
     */
    restorableDomainManagerExtId: string;
    /**
     * A unique identifier obtained from the restore source API that corresponds to the details provided for the restore source.
     */
    restoreSourceExtId: string;
    tenantId: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManager {
    configs: outputs.GetPcRestorePointsV2RestorePointDomainManagerConfig[];
    extId: string;
    hostingClusterExtId: string;
    isRegisteredWithHostingCluster: boolean;
    networks: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetwork[];
    nodeExtIds: string[];
    shouldEnableHighAvailability: boolean;
    tenantId: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerConfig {
    bootstrapConfig: outputs.GetPcRestorePointsV2RestorePointDomainManagerConfigBootstrapConfig;
    buildInfo: outputs.GetPcRestorePointsV2RestorePointDomainManagerConfigBuildInfo;
    credentials?: outputs.GetPcRestorePointsV2RestorePointDomainManagerConfigCredential[];
    name: string;
    resourceConfigs: outputs.GetPcRestorePointsV2RestorePointDomainManagerConfigResourceConfig[];
    shouldEnableLockdownMode: boolean;
    size: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerConfigBootstrapConfig {
    cloudInitConfigs?: outputs.GetPcRestorePointsV2RestorePointDomainManagerConfigBootstrapConfigCloudInitConfig[];
    environmentInfo: outputs.GetPcRestorePointsV2RestorePointDomainManagerConfigBootstrapConfigEnvironmentInfo;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerConfigBootstrapConfigCloudInitConfig {
    cloudInitScripts: outputs.GetPcRestorePointsV2RestorePointDomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScript[];
    datasourceType?: string;
    metadata: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScript {
    customKeyValues: outputs.GetPcRestorePointsV2RestorePointDomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValue[];
    userDatas: outputs.GetPcRestorePointsV2RestorePointDomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptUserData[];
}

export interface GetPcRestorePointsV2RestorePointDomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValue {
    keyValuePairs: outputs.GetPcRestorePointsV2RestorePointDomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePair[];
}

export interface GetPcRestorePointsV2RestorePointDomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePair {
    name: string;
    values: outputs.GetPcRestorePointsV2RestorePointDomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePairValue[];
}

export interface GetPcRestorePointsV2RestorePointDomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePairValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.GetPcRestorePointsV2RestorePointDomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface GetPcRestorePointsV2RestorePointDomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString {
    map: {[key: string]: string};
}

export interface GetPcRestorePointsV2RestorePointDomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptUserData {
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerConfigBootstrapConfigEnvironmentInfo {
    providerType: string;
    provisioningType: string;
    type: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerConfigBuildInfo {
    version: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerConfigCredential {
    password: string;
    username: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerConfigResourceConfig {
    containerExtIds: string[];
    dataDiskSizeBytes: number;
    memorySizeBytes: number;
    numVcpus: number;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetwork {
    externalAddress?: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalAddress;
    externalNetworks: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetwork[];
    fqdn: string;
    internalNetworks: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworks;
    nameServers: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkNameServer[];
    ntpServers: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkNtpServer[];
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalAddress {
    ipv4s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalAddressIpv4[];
    ipv6s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalAddressIpv6[];
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalAddressIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalAddressIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetwork {
    defaultGateway: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkDefaultGateway;
    ipRanges: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkIpRange[];
    networkExtId: string;
    subnetMask: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkSubnetMask;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkDefaultGateway {
    fqdns: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkDefaultGatewayFqdn[];
    ipv4s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkDefaultGatewayIpv4[];
    ipv6s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkDefaultGatewayIpv6[];
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkDefaultGatewayFqdn {
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkDefaultGatewayIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkDefaultGatewayIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkIpRange {
    begin: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkIpRangeBegin;
    end: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkIpRangeEnd;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkIpRangeBegin {
    ipv4s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkIpRangeBeginIpv4[];
    ipv6s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkIpRangeBeginIpv6[];
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkIpRangeBeginIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkIpRangeBeginIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkIpRangeEnd {
    ipv4s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkIpRangeEndIpv4[];
    ipv6s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkIpRangeEndIpv6[];
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkIpRangeEndIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkIpRangeEndIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkSubnetMask {
    fqdns: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkSubnetMaskFqdn[];
    ipv4s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkSubnetMaskIpv4[];
    ipv6s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkSubnetMaskIpv6[];
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkSubnetMaskFqdn {
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkSubnetMaskIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkExternalNetworkSubnetMaskIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworks {
    defaultGateway: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksDefaultGateway;
    ipRanges: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksIpRange[];
    subnetMask: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksSubnetMask;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksDefaultGateway {
    fqdns: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksDefaultGatewayFqdn[];
    ipv4s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksDefaultGatewayIpv4[];
    ipv6s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksDefaultGatewayIpv6[];
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksDefaultGatewayFqdn {
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksDefaultGatewayIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksDefaultGatewayIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksIpRange {
    begin: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksIpRangeBegin;
    end: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksIpRangeEnd;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksIpRangeBegin {
    ipv4s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksIpRangeBeginIpv4[];
    ipv6s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksIpRangeBeginIpv6[];
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksIpRangeBeginIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksIpRangeBeginIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksIpRangeEnd {
    ipv4s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksIpRangeEndIpv4[];
    ipv6s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksIpRangeEndIpv6[];
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksIpRangeEndIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksIpRangeEndIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksSubnetMask {
    fqdns: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksSubnetMaskFqdn[];
    ipv4s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksSubnetMaskIpv4[];
    ipv6s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksSubnetMaskIpv6[];
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksSubnetMaskFqdn {
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksSubnetMaskIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkInternalNetworksSubnetMaskIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkNameServer {
    fqdns: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkNameServerFqdn[];
    ipv4s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkNameServerIpv4[];
    ipv6s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkNameServerIpv6[];
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkNameServerFqdn {
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkNameServerIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkNameServerIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkNtpServer {
    fqdns: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkNtpServerFqdn[];
    ipv4s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkNtpServerIpv4[];
    ipv6s: outputs.GetPcRestorePointsV2RestorePointDomainManagerNetworkNtpServerIpv6[];
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkNtpServerFqdn {
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkNtpServerIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointDomainManagerNetworkNtpServerIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetPcRestorePointsV2RestorePointLink {
    href: string;
    rel: string;
}

export interface GetPcRestoreSourceV2Link {
    href: string;
    rel: string;
}

export interface GetPcRestoreSourceV2Location {
    /**
     * - A boolean value indicating whether to enable lockdown mode for a cluster.
     */
    clusterLocations: outputs.GetPcRestoreSourceV2LocationClusterLocation[];
    /**
     * - Currently representing the build information to be used for the cluster creation.
     */
    objectStoreLocations: outputs.GetPcRestoreSourceV2LocationObjectStoreLocation[];
}

export interface GetPcRestoreSourceV2LocationClusterLocation {
    /**
     * - Cluster reference of the remote cluster to be connected.
     */
    configs: outputs.GetPcRestoreSourceV2LocationClusterLocationConfig[];
}

export interface GetPcRestoreSourceV2LocationClusterLocationConfig {
    /**
     * -(Required) A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
}

export interface GetPcRestoreSourceV2LocationObjectStoreLocation {
    /**
     * - Backup policy for the object store provided.
     */
    backupPolicies: outputs.GetPcRestoreSourceV2LocationObjectStoreLocationBackupPolicy[];
    /**
     * - The base model of S3 object store endpoint where domain manager is backed up.
     */
    providerConfigs: outputs.GetPcRestoreSourceV2LocationObjectStoreLocationProviderConfig[];
}

export interface GetPcRestoreSourceV2LocationObjectStoreLocationBackupPolicy {
    /**
     * - RPO interval in minutes at which the backup will be taken. The Value should be in the range of 60 to 1440.
     */
    rpoInMinutes: number;
}

export interface GetPcRestoreSourceV2LocationObjectStoreLocationProviderConfig {
    /**
     * - The bucket name of the object store endpoint where backup data of domain manager is to be stored.
     */
    bucketName: string;
    /**
     * - Secret credentials model for the object store containing access key ID and secret access key.
     */
    credentials: outputs.GetPcRestoreSourceV2LocationObjectStoreLocationProviderConfigCredential[];
    /**
     * - The region name of the object store endpoint where backup data of domain manager is stored. Default is `us-east-1`.
     */
    region: string;
}

export interface GetPcRestoreSourceV2LocationObjectStoreLocationProviderConfigCredential {
    /**
     * - Access key ID for the object store provided for backup target.
     */
    accessKeyId: string;
    /**
     * - Secret access key for the object store provided for backup target.
     */
    secretAccessKey: string;
}

export interface GetPcV2Config {
    /**
     * - Bootstrap configuration details for the domain manager (Prism Central).
     */
    bootstrapConfigs: outputs.GetPcV2ConfigBootstrapConfig[];
    /**
     * -Currently representing the build information to be used for the cluster creation.
     */
    buildInfos: outputs.GetPcV2ConfigBuildInfo[];
    /**
     * - Name of the domain manager (Prism Central).
     */
    name: string;
    /**
     * - This configuration is used to provide the resource-related details like container external identifiers, number of VCPUs, memory size, data disk size of the domain manager (Prism Central). In the case of a multi-node setup, the sum of resources like number of VCPUs, memory size and data disk size are provided.
     */
    resourceConfigs: outputs.GetPcV2ConfigResourceConfig[];
    /**
     * - A boolean value indicating whether to enable lockdown mode for a cluster.
     */
    shouldEnableLockdownMode: boolean;
    /**
     * - Domain manager (Prism Central) size is an enumeration of starter, small, large, or extra large starter values. possible values are:
     * * `SMALL` : Domain manager (Prism Central) of size small.
     * * `LARGE` : Domain manager (Prism Central) of size large.
     * * `EXTRALARGE` : Domain manager (Prism Central) of size extra large.
     * * `STARTER` : Domain manager (Prism Central) of size starter.
     */
    size: string;
}

export interface GetPcV2ConfigBootstrapConfig {
    /**
     * - Environment information for the domain manager (Prism Central) cluster.
     */
    environmentInfos: outputs.GetPcV2ConfigBootstrapConfigEnvironmentInfo[];
}

export interface GetPcV2ConfigBootstrapConfigEnvironmentInfo {
    /**
     * - Enums denoting the provider type of the PC, that is, AHV or ESXi.
     * Following are the supported provider types:
     * * `VSPHERE` : Vsphere cloud provider.
     * * `AZURE` : Azure cloud provider.
     * * `NTNX` : Nutanix cloud provider.
     * * `GCP` : GCP cloud provider.
     * * `AWS` : AWS cloud provider.
     */
    providerType: string;
    /**
     * - Enums denoting the instance type of the cloud PC. It indicates whether the PC is created on bare-metal or on a cloud-provisioned VM. Hence, it supports two possible values:
     * * `NTNX` : Nutanix instance.
     * * `NATIVE` : Native instance.
     */
    provisioningType: string;
    /**
     * - Enums denoting the environment type of the PC, that is, on-prem PC or cloud PC.
     * Following are the supported entity types:
     * * `ONPREM` : On-prem environment.
     * * `NTNX_CLOUD` : Nutanix cloud environment.
     */
    type: string;
}

export interface GetPcV2ConfigBuildInfo {
    /**
     * - Software version.
     */
    version: string;
}

export interface GetPcV2ConfigResourceConfig {
    /**
     * - The external identifier of the container that will be used to create the domain manager (Prism Central) cluster.
     */
    containerExtIds: string[];
    /**
     * - This property is used for readOnly purposes to display Prism Central data disk size allocation at a cluster level.
     */
    dataDiskSizeBytes: number;
    /**
     * - This property is used for readOnly purposes to display Prism Central RAM allocation at the cluster level.
     */
    memorySizeBytes: number;
    /**
     * - This property is used for readOnly purposes to display Prism Central number of VCPUs allocation.
     */
    numVcpus: number;
}

export interface GetPcV2Link {
    href: string;
    rel: string;
}

export interface GetPcV2Network {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    externalAddresses: outputs.GetPcV2NetworkExternalAddress[];
    /**
     * - This configuration is used to manage Prism Central.
     */
    externalNetworks: outputs.GetPcV2NetworkExternalNetwork[];
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdn: string;
    /**
     * - List of name servers on a cluster. This is part of payload for both cluster create & update operations. For create operation, only ipv4 address / fqdn values are supported currently.
     */
    nameServers: outputs.GetPcV2NetworkNameServer[];
    /**
     * - List of NTP servers on a cluster. This is part of payload for both cluster create & update operations. For create operation, only ipv4 address / fqdn values are supported currently.
     */
    ntpServers: outputs.GetPcV2NetworkNtpServer[];
}

export interface GetPcV2NetworkExternalAddress {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetPcV2NetworkExternalAddressIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetPcV2NetworkExternalAddressIpv6[];
}

export interface GetPcV2NetworkExternalAddressIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcV2NetworkExternalAddressIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcV2NetworkExternalNetwork {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    defaultGateways: outputs.GetPcV2NetworkExternalNetworkDefaultGateway[];
    /**
     * - Range of IPs used for Prism Central network setup.
     */
    ipRanges: outputs.GetPcV2NetworkExternalNetworkIpRange[];
    /**
     * - The network external identifier to which Domain Manager (Prism Central) is to be deployed or is already configured.
     */
    networkExtId: string;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    subnetMasks: outputs.GetPcV2NetworkExternalNetworkSubnetMask[];
}

export interface GetPcV2NetworkExternalNetworkDefaultGateway {
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.GetPcV2NetworkExternalNetworkDefaultGatewayFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetPcV2NetworkExternalNetworkDefaultGatewayIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetPcV2NetworkExternalNetworkDefaultGatewayIpv6[];
}

export interface GetPcV2NetworkExternalNetworkDefaultGatewayFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcV2NetworkExternalNetworkDefaultGatewayIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcV2NetworkExternalNetworkDefaultGatewayIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcV2NetworkExternalNetworkIpRange {
    /**
     * - The beginning IP address of the range.
     */
    begins: outputs.GetPcV2NetworkExternalNetworkIpRangeBegin[];
    /**
     * - The ending IP address of the range.
     */
    ends: outputs.GetPcV2NetworkExternalNetworkIpRangeEnd[];
}

export interface GetPcV2NetworkExternalNetworkIpRangeBegin {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetPcV2NetworkExternalNetworkIpRangeBeginIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetPcV2NetworkExternalNetworkIpRangeBeginIpv6[];
}

export interface GetPcV2NetworkExternalNetworkIpRangeBeginIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcV2NetworkExternalNetworkIpRangeBeginIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcV2NetworkExternalNetworkIpRangeEnd {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetPcV2NetworkExternalNetworkIpRangeEndIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetPcV2NetworkExternalNetworkIpRangeEndIpv6[];
}

export interface GetPcV2NetworkExternalNetworkIpRangeEndIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcV2NetworkExternalNetworkIpRangeEndIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcV2NetworkExternalNetworkSubnetMask {
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.GetPcV2NetworkExternalNetworkSubnetMaskFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetPcV2NetworkExternalNetworkSubnetMaskIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetPcV2NetworkExternalNetworkSubnetMaskIpv6[];
}

export interface GetPcV2NetworkExternalNetworkSubnetMaskFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcV2NetworkExternalNetworkSubnetMaskIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcV2NetworkExternalNetworkSubnetMaskIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcV2NetworkNameServer {
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.GetPcV2NetworkNameServerFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetPcV2NetworkNameServerIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetPcV2NetworkNameServerIpv6[];
}

export interface GetPcV2NetworkNameServerFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcV2NetworkNameServerIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcV2NetworkNameServerIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcV2NetworkNtpServer {
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.GetPcV2NetworkNtpServerFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetPcV2NetworkNtpServerIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetPcV2NetworkNtpServerIpv6[];
}

export interface GetPcV2NetworkNtpServerFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcV2NetworkNtpServerIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcV2NetworkNtpServerIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface GetPcsV2Pc {
    /**
     * * `extId`
     */
    configs: outputs.GetPcsV2PcConfig[];
    extId: string;
    hostingClusterExtId: string;
    isRegisteredWithHostingCluster: boolean;
    links: outputs.GetPcsV2PcLink[];
    networks: outputs.GetPcsV2PcNetwork[];
    nodeExtIds: string[];
    shouldEnableHighAvailability?: boolean;
    tenantId: string;
}

export interface GetPcsV2PcConfig {
    bootstrapConfigs: outputs.GetPcsV2PcConfigBootstrapConfig[];
    buildInfos: outputs.GetPcsV2PcConfigBuildInfo[];
    name: string;
    resourceConfigs: outputs.GetPcsV2PcConfigResourceConfig[];
    shouldEnableLockdownMode: boolean;
    size: string;
}

export interface GetPcsV2PcConfigBootstrapConfig {
    environmentInfos: outputs.GetPcsV2PcConfigBootstrapConfigEnvironmentInfo[];
}

export interface GetPcsV2PcConfigBootstrapConfigEnvironmentInfo {
    providerType: string;
    provisioningType: string;
    type: string;
}

export interface GetPcsV2PcConfigBuildInfo {
    version: string;
}

export interface GetPcsV2PcConfigResourceConfig {
    containerExtIds: string[];
    dataDiskSizeBytes: number;
    memorySizeBytes: number;
    numVcpus: number;
}

export interface GetPcsV2PcLink {
    href: string;
    rel: string;
}

export interface GetPcsV2PcNetwork {
    externalAddresses: outputs.GetPcsV2PcNetworkExternalAddress[];
    externalNetworks: outputs.GetPcsV2PcNetworkExternalNetwork[];
    fqdn: string;
    nameServers: outputs.GetPcsV2PcNetworkNameServer[];
    ntpServers: outputs.GetPcsV2PcNetworkNtpServer[];
}

export interface GetPcsV2PcNetworkExternalAddress {
    ipv4s: outputs.GetPcsV2PcNetworkExternalAddressIpv4[];
    ipv6s: outputs.GetPcsV2PcNetworkExternalAddressIpv6[];
}

export interface GetPcsV2PcNetworkExternalAddressIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetPcsV2PcNetworkExternalAddressIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetPcsV2PcNetworkExternalNetwork {
    defaultGateways: outputs.GetPcsV2PcNetworkExternalNetworkDefaultGateway[];
    ipRanges: outputs.GetPcsV2PcNetworkExternalNetworkIpRange[];
    networkExtId: string;
    subnetMasks: outputs.GetPcsV2PcNetworkExternalNetworkSubnetMask[];
}

export interface GetPcsV2PcNetworkExternalNetworkDefaultGateway {
    fqdns: outputs.GetPcsV2PcNetworkExternalNetworkDefaultGatewayFqdn[];
    ipv4s: outputs.GetPcsV2PcNetworkExternalNetworkDefaultGatewayIpv4[];
    ipv6s: outputs.GetPcsV2PcNetworkExternalNetworkDefaultGatewayIpv6[];
}

export interface GetPcsV2PcNetworkExternalNetworkDefaultGatewayFqdn {
    value: string;
}

export interface GetPcsV2PcNetworkExternalNetworkDefaultGatewayIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetPcsV2PcNetworkExternalNetworkDefaultGatewayIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetPcsV2PcNetworkExternalNetworkIpRange {
    begins: outputs.GetPcsV2PcNetworkExternalNetworkIpRangeBegin[];
    ends: outputs.GetPcsV2PcNetworkExternalNetworkIpRangeEnd[];
}

export interface GetPcsV2PcNetworkExternalNetworkIpRangeBegin {
    ipv4s: outputs.GetPcsV2PcNetworkExternalNetworkIpRangeBeginIpv4[];
    ipv6s: outputs.GetPcsV2PcNetworkExternalNetworkIpRangeBeginIpv6[];
}

export interface GetPcsV2PcNetworkExternalNetworkIpRangeBeginIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetPcsV2PcNetworkExternalNetworkIpRangeBeginIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetPcsV2PcNetworkExternalNetworkIpRangeEnd {
    ipv4s: outputs.GetPcsV2PcNetworkExternalNetworkIpRangeEndIpv4[];
    ipv6s: outputs.GetPcsV2PcNetworkExternalNetworkIpRangeEndIpv6[];
}

export interface GetPcsV2PcNetworkExternalNetworkIpRangeEndIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetPcsV2PcNetworkExternalNetworkIpRangeEndIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetPcsV2PcNetworkExternalNetworkSubnetMask {
    fqdns: outputs.GetPcsV2PcNetworkExternalNetworkSubnetMaskFqdn[];
    ipv4s: outputs.GetPcsV2PcNetworkExternalNetworkSubnetMaskIpv4[];
    ipv6s: outputs.GetPcsV2PcNetworkExternalNetworkSubnetMaskIpv6[];
}

export interface GetPcsV2PcNetworkExternalNetworkSubnetMaskFqdn {
    value: string;
}

export interface GetPcsV2PcNetworkExternalNetworkSubnetMaskIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetPcsV2PcNetworkExternalNetworkSubnetMaskIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetPcsV2PcNetworkNameServer {
    fqdns: outputs.GetPcsV2PcNetworkNameServerFqdn[];
    ipv4s: outputs.GetPcsV2PcNetworkNameServerIpv4[];
    ipv6s: outputs.GetPcsV2PcNetworkNameServerIpv6[];
}

export interface GetPcsV2PcNetworkNameServerFqdn {
    value: string;
}

export interface GetPcsV2PcNetworkNameServerIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetPcsV2PcNetworkNameServerIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetPcsV2PcNetworkNtpServer {
    fqdns: outputs.GetPcsV2PcNetworkNtpServerFqdn[];
    ipv4s: outputs.GetPcsV2PcNetworkNtpServerIpv4[];
    ipv6s: outputs.GetPcsV2PcNetworkNtpServerIpv6[];
}

export interface GetPcsV2PcNetworkNtpServerFqdn {
    value: string;
}

export interface GetPcsV2PcNetworkNtpServerIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetPcsV2PcNetworkNtpServerIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetPermissionCategory {
    /**
     * the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetPermissionField {
    /**
     * Allow or disallow the fields mentioned.
     */
    fieldMode: string;
    /**
     * The list of fields.
     */
    fieldNameLists: string[];
}

export interface GetPermissionsEntity {
    /**
     * version of the API
     */
    apiVersion: string;
    /**
     * The categories for this resource.
     */
    categories: outputs.GetPermissionsEntityCategory[];
    /**
     * A description for the permission.
     */
    description: string;
    /**
     * . The fields that can/cannot be accessed during the specified operation. fieldNameList will be a list of fields. e.g. if fieldMode = disallowed, fieldNameList = [xyz] then the list of allowed fields is ALL fields minus xyz. Seee Field for more info.
     */
    fields: outputs.GetPermissionsEntityField[];
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The permission kind metadata.
     */
    metadata: {[key: string]: string};
    /**
     * the name.
     */
    name: string;
    /**
     * The operation that is being performed on a given kind.
     */
    operation: string;
    /**
     * The reference to a user.
     */
    ownerReference: {[key: string]: string};
    /**
     * The reference to a project.
     */
    projectReference: {[key: string]: string};
    /**
     * The state of the permission.
     */
    state: string;
}

export interface GetPermissionsEntityCategory {
    /**
     * the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetPermissionsEntityField {
    /**
     * Allow or disallow the fields mentioned.
     */
    fieldMode: string;
    /**
     * The list of fields.
     */
    fieldNameLists: string[];
}

export interface GetPermissionsMetadata {
    filter: string;
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetProjectAccountReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectAcp {
    /**
     * The list of context filters. These are OR filters. The scope-expression-list defines the context, and the filter works in conjunction with the entity-expression-list.
     */
    contextFilterLists: outputs.GetProjectAcpContextFilterList[];
    /**
     * Description of ACP
     */
    description: string;
    metadata: {[key: string]: string};
    /**
     * the name.
     */
    name: string;
    /**
     * Reference to role.
     */
    roleReferences: outputs.GetProjectAcpRoleReference[];
    /**
     * List of Reference of users groups.
     */
    userGroupReferenceLists: outputs.GetProjectAcpUserGroupReferenceList[];
    /**
     * List of Reference of users.
     */
    userReferenceLists: outputs.GetProjectAcpUserReferenceList[];
}

export interface GetProjectAcpContextFilterList {
    /**
     * (Required) A list of Entity filter expressions.
     */
    entityFilterExpressionLists: outputs.GetProjectAcpContextFilterListEntityFilterExpressionList[];
    /**
     * - (Optional) Filter the scope of an Access Control Policy.
     */
    scopeFilterExpressionLists?: outputs.GetProjectAcpContextFilterListScopeFilterExpressionList[];
}

export interface GetProjectAcpContextFilterListEntityFilterExpressionList {
    /**
     * - (Optional)  The LHS of the filter expression - the entity type.
     */
    leftHandSideEntityType: string;
    /**
     * - (Required) The operator in the filter expression.
     */
    operator: string;
    /**
     * - (Required) The right hand side (RHS) of an scope expression.
     */
    rightHandSides: outputs.GetProjectAcpContextFilterListEntityFilterExpressionListRightHandSide[];
}

export interface GetProjectAcpContextFilterListEntityFilterExpressionListRightHandSide {
    /**
     * - (Optional) The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.GetProjectAcpContextFilterListEntityFilterExpressionListRightHandSideCategory[];
    /**
     * - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
     */
    collection: string;
    /**
     * - (Optional) The explicit list of UUIDs for the given kind.
     */
    uuidLists: string[];
}

export interface GetProjectAcpContextFilterListEntityFilterExpressionListRightHandSideCategory {
    /**
     * the name.
     */
    name: string;
    /**
     * value of the key.
     */
    values: string[];
}

export interface GetProjectAcpContextFilterListScopeFilterExpressionList {
    /**
     * - (Optional)  The LHS of the filter expression - the scope type.
     */
    leftHandSide: string;
    /**
     * - (Required) The operator in the filter expression.
     */
    operator: string;
    /**
     * - (Required) The right hand side (RHS) of an scope expression.
     */
    rightHandSides: outputs.GetProjectAcpContextFilterListScopeFilterExpressionListRightHandSide[];
}

export interface GetProjectAcpContextFilterListScopeFilterExpressionListRightHandSide {
    /**
     * - (Optional) The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.GetProjectAcpContextFilterListScopeFilterExpressionListRightHandSideCategory[];
    /**
     * - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
     */
    collection: string;
    /**
     * - (Optional) The explicit list of UUIDs for the given kind.
     */
    uuidLists: string[];
}

export interface GetProjectAcpContextFilterListScopeFilterExpressionListRightHandSideCategory {
    /**
     * the name.
     */
    name: string;
    /**
     * value of the key.
     */
    values: string[];
}

export interface GetProjectAcpRoleReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectAcpUserGroupReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectAcpUserReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectCategory {
    /**
     * the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetProjectClusterReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectDefaultEnvironmentReference {
    /**
     * (Optional) The kind name. Default value is `environment`
     */
    kind: string;
    /**
     * (Optional/Computed) The name of a environment.
     */
    name: string;
    /**
     * (Required) The UUID of a environment
     */
    uuid: string;
}

export interface GetProjectEnvironmentReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectExternalNetworkList {
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectExternalUserGroupReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectResourceDomain {
    /**
     * Array of the utilization/limit for resource types
     * * `resource_domain.resources.#.limit` The resource consumption limit (unspecified is unlimited)
     * * `resource_domain.resources.#.resource_type` The type of resource (for example storage, CPUs)
     * * `resource_domain.resources.#.units` - The units of the resource type
     * * `resource_domain.resources.#.value` - The amount of resource consumed
     */
    resources: outputs.GetProjectResourceDomainResource[];
}

export interface GetProjectResourceDomainResource {
    limit: number;
    resourceType: string;
    units: string;
    /**
     * value of the key.
     */
    value: number;
}

export interface GetProjectSubnetReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectTunnelReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectUserReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectVpcReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectsEntity {
    /**
     * List of accounts associated with the project.
     * * `account_reference_list.#.kind` - The kind name. Default value is `account`
     * * `account_reference_list.#.uuid` - The UUID of an account.
     * * `account_reference_list.#.name` - The name of an account.
     */
    accountReferenceLists: outputs.GetProjectsEntityAccountReferenceList[];
    /**
     * version of the API
     */
    apiVersion: string;
    categories: outputs.GetProjectsEntityCategory[];
    /**
     * Reference to a subnet.
     */
    defaultSubnetReference: {[key: string]: string};
    /**
     * A description for project.
     */
    description: string;
    /**
     * List of environments associated with the project.
     * * `environment_reference_list.#.kind` - The kind name. Default value is `environment`
     * * `environment_reference_list.#.uuid` - The UUID of an environment.
     * * `environment_reference_list.#.name` - The name of an environment.
     */
    environmentReferenceLists: outputs.GetProjectsEntityEnvironmentReferenceList[];
    /**
     * List of external networks associated with the project.
     * * `external_network_list.#.uuid` - The UUID of a network.
     * * `external_network_list.#.name` - The name of a network.
     */
    externalNetworkLists: outputs.GetProjectsEntityExternalNetworkList[];
    /**
     * List of directory service user groups. These groups are not managed by Nutanix.
     * * `external_user_group_reference_list.#.kind` - The kind name. Default value is `userGroup`
     * * `external_user_group_reference_list.#.uuid` - The UUID of a userGroup
     * * `external_user_group_reference_list.#.name` - The name of a user_group
     */
    externalUserGroupReferenceLists: outputs.GetProjectsEntityExternalUserGroupReferenceList[];
    isDefault: boolean;
    metadata: {[key: string]: string};
    /**
     * (Optional) the name.
     */
    name: string;
    ownerReference: {[key: string]: string};
    projectReference: {[key: string]: string};
    /**
     * The status for a resource domain (limits and values)
     */
    resourceDomains: outputs.GetProjectsEntityResourceDomain[];
    state: string;
    /**
     * List of subnets for the project.
     * * `subnet_reference_list.#.kind` - The kind name. Default value is `subnet`
     * * `subnet_reference_list.#.uuid` - The UUID of a subnet
     * * `subnet_reference_list.#.name` - The name of a subnet.
     */
    subnetReferenceLists: outputs.GetProjectsEntitySubnetReferenceList[];
    /**
     * List of users in the project.
     * * `user_reference_list.#.kind` - The kind name. Default value is `user`
     * * `user_reference_list.#.uuid` - The UUID of a user
     * * `user_reference_list.#.name` - The name of a user.
     */
    userReferenceLists: outputs.GetProjectsEntityUserReferenceList[];
}

export interface GetProjectsEntityAccountReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectsEntityCategory {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetProjectsEntityEnvironmentReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectsEntityExternalNetworkList {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectsEntityExternalUserGroupReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectsEntityResourceDomain {
    /**
     * Array of the utilization/limit for resource types
     * * `resource_domain.resources.#.limit` The resource consumption limit (unspecified is unlimited)
     * * `resource_domain.resources.#.resource_type` The type of resource (for example storage, CPUs)
     * * `resource_domain.resources.#.units` - The units of the resource type
     * * `resource_domain.resources.#.value` - The amount of resource consumed
     */
    resources: outputs.GetProjectsEntityResourceDomainResource[];
}

export interface GetProjectsEntityResourceDomainResource {
    limit: number;
    resourceType: string;
    units: string;
    /**
     * value of the key.
     */
    value: number;
}

export interface GetProjectsEntitySubnetReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectsEntityUserReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProtectedResourceV2Link {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetProtectedResourceV2ReplicationState {
    /**
     * The external identifier of the Protection policy associated with the protected resource.
     */
    protectionPolicyExtId: string;
    /**
     * The recovery point objective of the schedule in seconds.
     */
    recoveryPointObjectiveSeconds: number;
    /**
     * Status of replication to a specified target site. Possible values are:
     * - `IN_SYNC`: The specified recovery point objective is met on the target site and failover can be performed.
     * - `SYNCING`: The system is trying to meet the specified recovery point objective for the target site via ongoing replications and failover can't yet be performed.
     * - `OUT_OF_SYNC`: The replication schedule is disabled and there are no ongoing replications. Manual action might be needed by the user to meet the recovery point objective.
     */
    replicationStatus: string;
    /**
     * Details about the data protection site in the Prism Central.
     */
    targetSiteReferences: outputs.GetProtectedResourceV2ReplicationStateTargetSiteReference[];
}

export interface GetProtectedResourceV2ReplicationStateTargetSiteReference {
    /**
     * External identifier of the cluster.
     */
    clusterExtId: string;
    /**
     * External identifier of the Prism Central.
     */
    mgmtClusterExtId: string;
}

export interface GetProtectedResourceV2SiteProtectionInfo {
    /**
     * Details about the data protection site in the Prism Central.
     */
    locationReferences: outputs.GetProtectedResourceV2SiteProtectionInfoLocationReference[];
    /**
     * The restorable time range details that can be used to recover the protected resource.
     */
    recoveryInfos: outputs.GetProtectedResourceV2SiteProtectionInfoRecoveryInfo[];
    /**
     * Synchronous Replication role related information of the protected resource. Possible values are:
     * - `DECOUPLED`: VM is no longer in Synchronous Replication, and all the actions are blocked on VM, except a delete operation.
     * - `SECONDARY`: This is the target site for VM in Synchronous Replication.
     * - `INDEPENDENT`: VM is no longer in Synchronous Replication, and not replicating to the configured recovery cluster.
     * - `PRIMARY`: VM is in Synchronous Replication, and is active on the primary site.
     */
    synchronousReplicationRole: string;
}

export interface GetProtectedResourceV2SiteProtectionInfoLocationReference {
    /**
     * External identifier of the cluster.
     */
    clusterExtId: string;
    /**
     * External identifier of the Prism Central.
     */
    mgmtClusterExtId: string;
}

export interface GetProtectedResourceV2SiteProtectionInfoRecoveryInfo {
    /**
     * The restorable time range details that can be used to recover the protected resource.
     */
    restorableTimeRanges: outputs.GetProtectedResourceV2SiteProtectionInfoRecoveryInfoRestorableTimeRange[];
}

export interface GetProtectedResourceV2SiteProtectionInfoRecoveryInfoRestorableTimeRange {
    /**
     * UTC date and time in ISO 8601 format representing the time when the restorable time range for the entity starts.
     */
    endTime: string;
    /**
     * UTC date and time in ISO 8601 format representing the time when the restorable time range for the entity starts.
     */
    startTime: string;
}

export interface GetProtectedResourceV2SourceSiteReference {
    /**
     * External identifier of the cluster.
     */
    clusterExtId: string;
    /**
     * External identifier of the Prism Central.
     */
    mgmtClusterExtId: string;
}

export interface GetProtectionPoliciesV2ProtectionPolicy {
    categoryIds: string[];
    description: string;
    extId: string;
    isApprovalPolicyNeeded: boolean;
    links: outputs.GetProtectionPoliciesV2ProtectionPolicyLink[];
    name: string;
    ownerExtId: string;
    replicationConfigurations: outputs.GetProtectionPoliciesV2ProtectionPolicyReplicationConfiguration[];
    replicationLocations: outputs.GetProtectionPoliciesV2ProtectionPolicyReplicationLocation[];
    tenantId: string;
}

export interface GetProtectionPoliciesV2ProtectionPolicyLink {
    href: string;
    rel: string;
}

export interface GetProtectionPoliciesV2ProtectionPolicyReplicationConfiguration {
    remoteLocationLabel?: string;
    schedule: outputs.GetProtectionPoliciesV2ProtectionPolicyReplicationConfigurationSchedule;
    sourceLocationLabel: string;
}

export interface GetProtectionPoliciesV2ProtectionPolicyReplicationConfigurationSchedule {
    recoveryPointObjectiveTimeSeconds?: number;
    recoveryPointType?: string;
    retention?: outputs.GetProtectionPoliciesV2ProtectionPolicyReplicationConfigurationScheduleRetention;
    startTime?: string;
    syncReplicationAutoSuspendTimeoutSeconds?: number;
}

export interface GetProtectionPoliciesV2ProtectionPolicyReplicationConfigurationScheduleRetention {
    autoRollupRetention?: outputs.GetProtectionPoliciesV2ProtectionPolicyReplicationConfigurationScheduleRetentionAutoRollupRetention;
    linearRetention?: outputs.GetProtectionPoliciesV2ProtectionPolicyReplicationConfigurationScheduleRetentionLinearRetention;
}

export interface GetProtectionPoliciesV2ProtectionPolicyReplicationConfigurationScheduleRetentionAutoRollupRetention {
    local: outputs.GetProtectionPoliciesV2ProtectionPolicyReplicationConfigurationScheduleRetentionAutoRollupRetentionLocal;
    remote?: outputs.GetProtectionPoliciesV2ProtectionPolicyReplicationConfigurationScheduleRetentionAutoRollupRetentionRemote;
}

export interface GetProtectionPoliciesV2ProtectionPolicyReplicationConfigurationScheduleRetentionAutoRollupRetentionLocal {
    frequency: number;
    snapshotIntervalType?: string;
}

export interface GetProtectionPoliciesV2ProtectionPolicyReplicationConfigurationScheduleRetentionAutoRollupRetentionRemote {
    frequency: number;
    snapshotIntervalType?: string;
}

export interface GetProtectionPoliciesV2ProtectionPolicyReplicationConfigurationScheduleRetentionLinearRetention {
    local: number;
    remote?: number;
}

export interface GetProtectionPoliciesV2ProtectionPolicyReplicationLocation {
    domainManagerExtId: string;
    isPrimary?: boolean;
    label: string;
    replicationSubLocation?: outputs.GetProtectionPoliciesV2ProtectionPolicyReplicationLocationReplicationSubLocation;
}

export interface GetProtectionPoliciesV2ProtectionPolicyReplicationLocationReplicationSubLocation {
    clusterExtIds: outputs.GetProtectionPoliciesV2ProtectionPolicyReplicationLocationReplicationSubLocationClusterExtIds;
}

export interface GetProtectionPoliciesV2ProtectionPolicyReplicationLocationReplicationSubLocationClusterExtIds {
    clusterExtIds: string[];
}

export interface GetProtectionPolicyV2Link {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetProtectionPolicyV2ReplicationConfiguration {
    /**
     * - Label of the source location from the replication locations list, where the entity will be replicated.
     */
    remoteLocationLabel?: string;
    /**
     * - Schedule for protection. The schedule specifies the recovery point objective and the retention policy for the participating locations.
     */
    schedule: outputs.GetProtectionPolicyV2ReplicationConfigurationSchedule;
    /**
     * - Label of the source location from the replication locations list, where the entity is running. The location of type MST can not be specified as the replication source.
     */
    sourceLocationLabel: string;
}

export interface GetProtectionPolicyV2ReplicationConfigurationSchedule {
    /**
     * - The Recovery point objective of the schedule in seconds and specified in multiple of 60 seconds. Only following RPO values can be provided for rollup retention type:
     * - Minute(s): 1, 2, 3, 4, 5, 6, 10, 12, 15
     * - Hour(s): 1, 2, 3, 4, 6, 8, 12
     * - Day(s): 1
     * - Week(s): 1, 2
     */
    recoveryPointObjectiveTimeSeconds?: number;
    /**
     * - Type of recovery point.
     * * `CRASH_CONSISTENT`: Crash-consistent Recovery points capture all the VM and application level details.
     * * `APP_CONSISTENT`: Application-consistent Recovery points can capture all the data stored in the memory and also the in-progress transaction details.
     */
    recoveryPointType?: string;
    /**
     * - Specifies the retention policy for the recovery point schedule.
     */
    retention?: outputs.GetProtectionPolicyV2ReplicationConfigurationScheduleRetention;
    /**
     * - Represents the protection start time for the new entities added to the policy after the policy is created in h:m format. The values must be between 00h:00m and 23h:59m and in UTC timezone. It specifies the time when the first snapshot is taken and replicated for any entity added to the policy. If this is not specified, the snapshot is taken immediately and replicated for any new entity added to the policy.
     */
    startTime?: string;
    /**
     * - Auto suspend timeout if there is a connection failure between locations for synchronous replication. If this value is not set, then the policy will not be suspended.
     */
    syncReplicationAutoSuspendTimeoutSeconds?: number;
}

export interface GetProtectionPolicyV2ReplicationConfigurationScheduleRetention {
    /**
     * - Auto rollup retention policy.
     */
    autoRollupRetention?: outputs.GetProtectionPolicyV2ReplicationConfigurationScheduleRetentionAutoRollupRetention;
    /**
     * - Linear retention policy.
     */
    linearRetention?: outputs.GetProtectionPolicyV2ReplicationConfigurationScheduleRetentionLinearRetention;
}

export interface GetProtectionPolicyV2ReplicationConfigurationScheduleRetentionAutoRollupRetention {
    /**
     * - Specifies the auto rollup retention details.
     */
    local: outputs.GetProtectionPolicyV2ReplicationConfigurationScheduleRetentionAutoRollupRetentionLocal;
    /**
     * - Specifies the auto rollup retention details.
     */
    remote?: outputs.GetProtectionPolicyV2ReplicationConfigurationScheduleRetentionAutoRollupRetentionRemote;
}

export interface GetProtectionPolicyV2ReplicationConfigurationScheduleRetentionAutoRollupRetentionLocal {
    /**
     * - Multiplier to 'snapshotIntervalType'. For example, if 'snapshotIntervalType' is 'YEARLY' and 'multiple' is 5, then 5 years worth of rollup snapshots will be retained.
     */
    frequency: number;
    /**
     * - Snapshot interval period.
     * * `YEARLY`: Specifies the number of latest yearly recovery points to retain.
     * * `WEEKLY`: Specifies the number of latest weekly recovery points to retain.
     * * `DAILY`: Specifies the number of latest daily recovery points to retain.
     * * `MONTHLY`: Specifies the number of latest monthly recovery points to retain.
     * * `HOURLY`: Specifies the number of latest hourly recovery points to retain.
     */
    snapshotIntervalType?: string;
}

export interface GetProtectionPolicyV2ReplicationConfigurationScheduleRetentionAutoRollupRetentionRemote {
    /**
     * - Multiplier to 'snapshotIntervalType'. For example, if 'snapshotIntervalType' is 'YEARLY' and 'multiple' is 5, then 5 years worth of rollup snapshots will be retained.
     */
    frequency: number;
    /**
     * - Snapshot interval period.
     * * `YEARLY`: Specifies the number of latest yearly recovery points to retain.
     * * `WEEKLY`: Specifies the number of latest weekly recovery points to retain.
     * * `DAILY`: Specifies the number of latest daily recovery points to retain.
     * * `MONTHLY`: Specifies the number of latest monthly recovery points to retain.
     * * `HOURLY`: Specifies the number of latest hourly recovery points to retain.
     */
    snapshotIntervalType?: string;
}

export interface GetProtectionPolicyV2ReplicationConfigurationScheduleRetentionLinearRetention {
    /**
     * - Specifies the auto rollup retention details.
     */
    local: number;
    /**
     * - Specifies the auto rollup retention details.
     */
    remote?: number;
}

export interface GetProtectionPolicyV2ReplicationLocation {
    /**
     * - External identifier of the domain manager.
     */
    domainManagerExtId: string;
    /**
     * - One of the locations must be specified as the primary location. All the other locations must be connected to the primary location.
     */
    isPrimary?: boolean;
    /**
     * - This is a unique user defined label of the replication location. It is used to identify the location in the replication configurations.
     */
    label: string;
    /**
     * - Specifies the replication sub-locations where recovery points can be created or replicated.
     */
    replicationSubLocation?: outputs.GetProtectionPolicyV2ReplicationLocationReplicationSubLocation;
}

export interface GetProtectionPolicyV2ReplicationLocationReplicationSubLocation {
    /**
     * - External identifier of the clusters.
     */
    clusterExtIds: outputs.GetProtectionPolicyV2ReplicationLocationReplicationSubLocationClusterExtIds;
}

export interface GetProtectionPolicyV2ReplicationLocationReplicationSubLocationClusterExtIds {
    /**
     * - External identifier of the clusters.
     */
    clusterExtIds: string[];
}

export interface GetProtectionRuleAvailabilityZoneConnectivityList {
    /**
     * (Optional/Computed) Index of the availability zone.
     */
    destinationAvailabilityZoneIndex: number;
    /**
     * (Optional/Computed) Snapshot schedules for the pair of the availability zones.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.recovery_point_objective_secs` - (Required) "A recovery point objective (RPO) is the maximum acceptable amount of data loss.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.local_snapshot_retention_policy` - (Optional/Computed) This describes the snapshot retention policy for this availability zone.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.local_snapshot_retention_policy.0.num_snapshots` - (Optional/Computed) Number of snapshots need to be retained.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.local_snapshot_retention_policy.0.rollup_retention_policy_multiple` - (Optional/Computed) Multiplier to 'snapshot_interval_type'.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.local_snapshot_retention_policy.0.rollup_retention_policy_snapshot_interval_type` - (Optional/Computed)
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.auto_suspend_timeout_secs` - (Optional/Computed) Auto suspend timeout in case of connection failure between the sites.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.snapshot_type` - (Optional/Computed) Crash consistent or Application Consistent snapshot.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.remote_snapshot_retention_policy` - (Optional/Computed) This describes the snapshot retention policy for this availability zone.
     */
    snapshotScheduleLists: outputs.GetProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleList[];
    /**
     * (Optional/Computed) Index of the availability zone.
     */
    sourceAvailabilityZoneIndex: number;
}

export interface GetProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleList {
    autoSuspendTimeoutSecs: number;
    localSnapshotRetentionPolicies: outputs.GetProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicy[];
    recoveryPointObjectiveSecs: number;
    remoteSnapshotRetentionPolicies: outputs.GetProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicy[];
    snapshotType: string;
}

export interface GetProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicy {
    numSnapshots: number;
    rollupRetentionPolicyMultiple: number;
    rollupRetentionPolicySnapshotIntervalType: string;
}

export interface GetProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicy {
    numSnapshots: number;
    rollupRetentionPolicyMultiple: number;
    rollupRetentionPolicySnapshotIntervalType: string;
}

export interface GetProtectionRuleCategory {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetProtectionRuleCategoryFilter {
    /**
     * (Optional/Computed) List of kinds associated with this filter.
     */
    kindLists: string[];
    /**
     * (Optional/Computed) A list of category key and list of values.
     */
    params: outputs.GetProtectionRuleCategoryFilterParam[];
    /**
     * (Optional/Computed) The type of the filter being used.
     */
    type: string;
}

export interface GetProtectionRuleCategoryFilterParam {
    /**
     * (Optional) the name.
     */
    name: string;
    values: string[];
}

export interface GetProtectionRuleOrderedAvailabilityZoneList {
    availabilityZoneUrl: string;
    clusterUuid: string;
}

export interface GetProtectionRuleOwnerReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProtectionRuleProjectReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProtectionRulesEntity {
    /**
     * version of the API
     */
    apiVersion: string;
    /**
     * (Required) This encodes the datapipes between various availability zones and\nthe backup policy of the pipes.
     */
    availabilityZoneConnectivityLists: outputs.GetProtectionRulesEntityAvailabilityZoneConnectivityList[];
    categories: outputs.GetProtectionRulesEntityCategory[];
    /**
     * (Optional/Computed)
     */
    categoryFilters: outputs.GetProtectionRulesEntityCategoryFilter[];
    /**
     * A description for protection rule.
     */
    description: string;
    metadata: {[key: string]: string};
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) A list of availability zones, each of which, receives a replica\nof the data for the entities protected by this protection rule.
     * * `ordered_availability_zone_list.#.cluster_uuid` - (Optional/Computed) UUID of specific cluster to which we will be replicating.
     * * `ordered_availability_zone_list.#.availability_zone_url` - (Optional/Computed) The FQDN or IP address of the availability zone.
     */
    orderedAvailabilityZoneLists: outputs.GetProtectionRulesEntityOrderedAvailabilityZoneList[];
    ownerReferences: outputs.GetProtectionRulesEntityOwnerReference[];
    projectReferences: outputs.GetProtectionRulesEntityProjectReference[];
    startTime: string;
    state: string;
}

export interface GetProtectionRulesEntityAvailabilityZoneConnectivityList {
    /**
     * (Optional/Computed) Index of the availability zone.
     */
    destinationAvailabilityZoneIndex: number;
    /**
     * (Optional/Computed) Snapshot schedules for the pair of the availability zones.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.recovery_point_objective_secs` - (Required) "A recovery point objective (RPO) is the maximum acceptable amount of data loss.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.local_snapshot_retention_policy` - (Optional/Computed) This describes the snapshot retention policy for this availability zone.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.local_snapshot_retention_policy.0.num_snapshots` - (Optional/Computed) Number of snapshots need to be retained.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.local_snapshot_retention_policy.0.rollup_retention_policy_multiple` - (Optional/Computed) Multiplier to 'snapshot_interval_type'.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.local_snapshot_retention_policy.0.rollup_retention_policy_snapshot_interval_type` - (Optional/Computed)
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.auto_suspend_timeout_secs` - (Optional/Computed) Auto suspend timeout in case of connection failure between the sites.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.snapshot_type` - (Optional/Computed) Crash consistent or Application Consistent snapshot.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.remote_snapshot_retention_policy` - (Optional/Computed) This describes the snapshot retention policy for this availability zone.
     */
    snapshotScheduleLists: outputs.GetProtectionRulesEntityAvailabilityZoneConnectivityListSnapshotScheduleList[];
    /**
     * (Optional/Computed) Index of the availability zone.
     */
    sourceAvailabilityZoneIndex: number;
}

export interface GetProtectionRulesEntityAvailabilityZoneConnectivityListSnapshotScheduleList {
    autoSuspendTimeoutSecs: number;
    localSnapshotRetentionPolicies: outputs.GetProtectionRulesEntityAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicy[];
    recoveryPointObjectiveSecs: number;
    remoteSnapshotRetentionPolicies: outputs.GetProtectionRulesEntityAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicy[];
    snapshotType: string;
}

export interface GetProtectionRulesEntityAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicy {
    numSnapshots: number;
    rollupRetentionPolicyMultiple: number;
    rollupRetentionPolicySnapshotIntervalType: string;
}

export interface GetProtectionRulesEntityAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicy {
    numSnapshots: number;
    rollupRetentionPolicyMultiple: number;
    rollupRetentionPolicySnapshotIntervalType: string;
}

export interface GetProtectionRulesEntityCategory {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetProtectionRulesEntityCategoryFilter {
    /**
     * (Optional/Computed) List of kinds associated with this filter.
     */
    kindLists: string[];
    /**
     * (Optional/Computed) A list of category key and list of values.
     */
    params: outputs.GetProtectionRulesEntityCategoryFilterParam[];
    /**
     * (Optional/Computed) The type of the filter being used.
     */
    type: string;
}

export interface GetProtectionRulesEntityCategoryFilterParam {
    /**
     * (Optional) the name.
     */
    name: string;
    values: string[];
}

export interface GetProtectionRulesEntityOrderedAvailabilityZoneList {
    availabilityZoneUrl: string;
    clusterUuid: string;
}

export interface GetProtectionRulesEntityOwnerReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProtectionRulesEntityProjectReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanCategory {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetRecoveryPlanOwnerReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameter {
    /**
     * (Optional/Computed) Floating IP assignment for VMs upon recovery in an Availability Zone. This is applicable only for the public cloud Availability Zones.
     * * `parameters.0.floating_ip_assignment_list.#.availability_zone_url` - (Required) URL of the Availability Zone.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list` - (Required) IP assignment for VMs upon recovery in the specified Availability Zone.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.test_floating_ip_config` - (Optional/Computed) Configuration for assigning floating IP to a VM on the execution of the Recovery Plan.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.test_floating_ip_config.ip` - (Optional/Computed) IP to be assigned to VM, in case of failover.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.test_floating_ip_config.should_allocate_dynamically` - (Optional/Computed) Whether to allocate the floating IPs for the VMs dynamically.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.recovery_floating_ip_config` - (Optional/Computed) Configuration for assigning floating IP to a VM on the execution of the Recovery Plan.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.recovery_floating_ip_config.ip` - (Optional/Computed) IP to be assigned to VM, in case of failover.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.recovery_floating_ip_config.should_allocate_dynamically` - (Optional/Computed) Whether to allocate the floating IPs for the VMs dynamically.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_reference` - (Required) Reference to a vm.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_reference.kind` - (Required) The kind name.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_reference.uuid` - (Required) The uuid.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_nic_information` - (Required) Information about vnic to which floating IP has to be assigned.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_nic_information.ip` - (Optional/Computed) IP address associated with vnic for which floating IP has to be assigned on failover.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_nic_information.uuid` - (Required) Uuid of the vnic of the VM to which floating IP has to be assigned.
     */
    floatingIpAssignmentLists: outputs.GetRecoveryPlanParameterFloatingIpAssignmentList[];
    /**
     * (Required) Network mappings to be used for the Recovery Plan. This will be represented by array of network mappings across the Availability Zones.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list` - (Required) Mapping of networks across the Availability Zones.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.availability_zone_url` - (Optional/Computed) URL of the Availability Zone.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network` - (Optional/Computed) Network configuration to be used for performing network mapping and IP preservation/mapping on Recovery Plan execution.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.virtual_network_reference` - (Optional/Computed) The reference to a virtual_network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.virtual_network_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.virtual_network_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.virtual_network_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.use_vpc_reference` - (Optional/Computed) The reference to a VPC.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.vpc_reference` - (Optional/Computed) The reference to a VPC.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.vpc_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.vpc_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.vpc_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.subnet_list` - (Optional/Computed) List of subnets for the network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.subnet_list.#.gateway_ip` - (Required) Gateway IP address for the subnet.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.subnet_list.#.external_connectivity_state` - (Optional/Computed) External connectivity state of the subnet. This is applicable only for the subnet to be created in public cloud Availability Zone.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.subnet_list.#.prefix_length` - (Required) Prefix length for the subnet.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.name` - (Required) Name of the network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network` - (Optional/Computed) Network configuration to be used for performing network mapping and IP preservation/mapping on Recovery Plan execution.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.virtual_network_reference` - (Optional/Computed) The reference to a virtual_network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.virtual_network_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.virtual_network_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.virtual_network_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.subnet_list` - (Optional/Computed) List of subnets for the network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.subnet_list.#.gateway_ip` - (Required) Gateway IP address for the subnet.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.subnet_list.#.external_connectivity_state` - (Optional/Computed) External connectivity state of the subnet. This is applicable only for the subnet to be created in public cloud Availability Zone.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.subnet_list.#.prefix_length` - (Required) Prefix length for the subnet.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.name` - (Required) Name of the network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list` - (Optional/Computed) Static IP configuration for the VMs to be applied post recovery in the recovery network for migrate/ failover action on the Recovery Plan.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.vm_reference` - (Optional/Computed) The reference to a vm.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.vm_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.vm_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.vm_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.ip_config_list` - (Optional/Computed) List of IP configurations for a VM.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.ip_config_list.#.ip_address` - (Required) IP address.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list` - (Optional/Computed) Static IP configuration for the VMs to be applied post recovery in the test network for test failover action on the Recovery Plan.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.vm_reference` - (Optional/Computed) The reference to a vm.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.vm_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.vm_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.vm_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.ip_config_list` - (Optional/Computed) List of IP configurations for a VM.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.ip_config_list.#.ip_address` - (Required) IP address.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.cluster_reference_list` - (Optional/Computed) The clusters where the recovery and test networks reside. This is required to specify network mapping across clusters for a Recovery Plan created to handle failover within the same Availability Zone.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.cluster_reference_list.0.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.cluster_reference_list.0.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.name` - (Optional/Computed) The name.
     */
    networkMappingLists: outputs.GetRecoveryPlanParameterNetworkMappingList[];
}

export interface GetRecoveryPlanParameterFloatingIpAssignmentList {
    availabilityZoneUrl: string;
    vmIpAssignmentLists: outputs.GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentList[];
}

export interface GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentList {
    recoveryFloatingIpConfigs: outputs.GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfig[];
    testFloatingIpConfigs: outputs.GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfig[];
    vmNicInformations: outputs.GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListVmNicInformation[];
    vmReferences: outputs.GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListVmReference[];
}

export interface GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfig {
    ip: string;
    shouldAllocateDynamically: boolean;
}

export interface GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfig {
    ip: string;
    shouldAllocateDynamically: boolean;
}

export interface GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListVmNicInformation {
    ip: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterNetworkMappingList {
    areNetworksStretched: boolean;
    availabilityZoneNetworkMappingLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingList[];
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingList {
    availabilityZoneUrl: string;
    clusterReferenceLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceList[];
    recoveryIpAssignmentLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentList[];
    recoveryNetworks: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetwork[];
    testIpAssignmentLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentList[];
    testNetworks: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetwork[];
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentList {
    ipConfigLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigList[];
    vmReference: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReference;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigList {
    ipAddress: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetwork {
    /**
     * (Optional) the name.
     */
    name: string;
    subnetLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetList[];
    useVpcReference: boolean;
    virtualNetworkReferences: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReference[];
    vpcReferences: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReference[];
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetList {
    externalConnectivityState: string;
    gatewayIp: string;
    prefixLength: number;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentList {
    ipConfigLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigList[];
    vmReference: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReference;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigList {
    ipAddress: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetwork {
    /**
     * (Optional) the name.
     */
    name: string;
    subnetLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetList[];
    useVpcReference: boolean;
    virtualNetworkReferences: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReference[];
    vpcReferences: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReference[];
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetList {
    externalConnectivityState: string;
    gatewayIp: string;
    prefixLength: number;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanProjectReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanStageList {
    /**
     * (Optional/Computed) Amount of time in seconds to delay the execution of next stage after execution of current stage.
     */
    delayTimeSecs: number;
    /**
     * (Optional/Computed) UUID of stage.
     */
    stageUuid: string;
    /**
     * (Required) A stage specifies the work to be performed when the Recovery Plan is executed.
     */
    stageWorks: outputs.GetRecoveryPlanStageListStageWork[];
}

export interface GetRecoveryPlanStageListStageWork {
    /**
     * (Optional/Computed) Information about entities to be recovered.
     */
    recoverEntities: outputs.GetRecoveryPlanStageListStageWorkRecoverEntity[];
}

export interface GetRecoveryPlanStageListStageWorkRecoverEntity {
    /**
     * (Optional/Computed) Information about entities to be recovered as part of this stage. For VM, entity information will include set of scripts to be executed after recovery of VM. Only one of categories or anyEntityReference has to be provided.
     * * `stage_list.stage_work.0.recover_entities.0.entity_info_list.#.any_entity_reference_kind` - (Optional/Computed) Reference to a kind.
     * * `stage_list.stage_work.0.recover_entities.0.entity_info_list.#.any_entity_reference_uuid` - (Optional/Computed) Reference to a uuid.
     * * `stage_list.stage_work.0.recover_entities.0.entity_info_list.#.any_entity_reference_name` - (Optional/Computed) Reference to a name.
     * * `stage_list.stage_work.0.recover_entities.0.entity_info_list.#.categories` - (Optional/Computed)  Categories for filtering entities.
     */
    entityInfoLists: outputs.GetRecoveryPlanStageListStageWorkRecoverEntityEntityInfoList[];
}

export interface GetRecoveryPlanStageListStageWorkRecoverEntityEntityInfoList {
    anyEntityReferenceKind: string;
    anyEntityReferenceName: string;
    anyEntityReferenceUuid: string;
    categories: outputs.GetRecoveryPlanStageListStageWorkRecoverEntityEntityInfoListCategory[];
    scriptLists: outputs.GetRecoveryPlanStageListStageWorkRecoverEntityEntityInfoListScriptList[];
}

export interface GetRecoveryPlanStageListStageWorkRecoverEntityEntityInfoListCategory {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetRecoveryPlanStageListStageWorkRecoverEntityEntityInfoListScriptList {
    enableScriptExec: boolean;
    timeout: string;
}

export interface GetRecoveryPlansEntity {
    /**
     * version of the API
     */
    apiVersion: string;
    categories: outputs.GetRecoveryPlansEntityCategory[];
    /**
     * A description for recovery plan.
     */
    description: string;
    metadata: {[key: string]: string};
    /**
     * (Optional) the name.
     */
    name: string;
    ownerReferences: outputs.GetRecoveryPlansEntityOwnerReference[];
    /**
     * (Required) Parameters for the Recovery Plan.
     */
    parameters: outputs.GetRecoveryPlansEntityParameter[];
    projectReferences: outputs.GetRecoveryPlansEntityProjectReference[];
    /**
     * (Required) Input for the stages of the Recovery Plan. Each stage will perform a predefined type of task.
     */
    stageLists: outputs.GetRecoveryPlansEntityStageList[];
    state: string;
}

export interface GetRecoveryPlansEntityCategory {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetRecoveryPlansEntityOwnerReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameter {
    /**
     * (Optional/Computed) Floating IP assignment for VMs upon recovery in an Availability Zone. This is applicable only for the public cloud Availability Zones.
     * * `parameters.0.floating_ip_assignment_list.#.availability_zone_url` - (Required) URL of the Availability Zone.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list` - (Required) IP assignment for VMs upon recovery in the specified Availability Zone.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.test_floating_ip_config` - (Optional/Computed) Configuration for assigning floating IP to a VM on the execution of the Recovery Plan.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.test_floating_ip_config.ip` - (Optional/Computed) IP to be assigned to VM, in case of failover.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.test_floating_ip_config.should_allocate_dynamically` - (Optional/Computed) Whether to allocate the floating IPs for the VMs dynamically.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.recovery_floating_ip_config` - (Optional/Computed) Configuration for assigning floating IP to a VM on the execution of the Recovery Plan.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.recovery_floating_ip_config.ip` - (Optional/Computed) IP to be assigned to VM, in case of failover.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.recovery_floating_ip_config.should_allocate_dynamically` - (Optional/Computed) Whether to allocate the floating IPs for the VMs dynamically.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_reference` - (Required) Reference to a vm.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_reference.kind` - (Required) The kind name.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_reference.uuid` - (Required) The uuid.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_nic_information` - (Required) Information about vnic to which floating IP has to be assigned.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_nic_information.ip` - (Optional/Computed) IP address associated with vnic for which floating IP has to be assigned on failover.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_nic_information.uuid` - (Required) Uuid of the vnic of the VM to which floating IP has to be assigned.
     */
    floatingIpAssignmentLists: outputs.GetRecoveryPlansEntityParameterFloatingIpAssignmentList[];
    /**
     * (Required) Network mappings to be used for the Recovery Plan. This will be represented by array of network mappings across the Availability Zones.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list` - (Required) Mapping of networks across the Availability Zones.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.availability_zone_url` - (Optional/Computed) URL of the Availability Zone.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network` - (Optional/Computed) Network configuration to be used for performing network mapping and IP preservation/mapping on Recovery Plan execution.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.virtual_network_reference` - (Optional/Computed) The reference to a virtual_network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.virtual_network_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.virtual_network_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.virtual_network_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.use_vpc_reference` - (Optional/Computed) The reference to a VPC.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.vpc_reference` - (Optional/Computed) The reference to a VPC.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.vpc_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.vpc_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.vpc_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.subnet_list` - (Optional/Computed) List of subnets for the network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.subnet_list.#.gateway_ip` - (Required) Gateway IP address for the subnet.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.subnet_list.#.external_connectivity_state` - (Optional/Computed) External connectivity state of the subnet. This is applicable only for the subnet to be created in public cloud Availability Zone.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.subnet_list.#.prefix_length` - (Required) Prefix length for the subnet.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.name` - (Required) Name of the network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network` - (Optional/Computed) Network configuration to be used for performing network mapping and IP preservation/mapping on Recovery Plan execution.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.virtual_network_reference` - (Optional/Computed) The reference to a virtual_network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.virtual_network_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.virtual_network_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.virtual_network_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.subnet_list` - (Optional/Computed) List of subnets for the network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.subnet_list.#.gateway_ip` - (Required) Gateway IP address for the subnet.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.subnet_list.#.external_connectivity_state` - (Optional/Computed) External connectivity state of the subnet. This is applicable only for the subnet to be created in public cloud Availability Zone.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.subnet_list.#.prefix_length` - (Required) Prefix length for the subnet.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.name` - (Required) Name of the network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list` - (Optional/Computed) Static IP configuration for the VMs to be applied post recovery in the recovery network for migrate/ failover action on the Recovery Plan.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.vm_reference` - (Optional/Computed) The reference to a vm.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.vm_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.vm_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.vm_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.ip_config_list` - (Optional/Computed) List of IP configurations for a VM.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.ip_config_list.#.ip_address` - (Required) IP address.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list` - (Optional/Computed) Static IP configuration for the VMs to be applied post recovery in the test network for test failover action on the Recovery Plan.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.vm_reference` - (Optional/Computed) The reference to a vm.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.vm_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.vm_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.vm_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.ip_config_list` - (Optional/Computed) List of IP configurations for a VM.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.ip_config_list.#.ip_address` - (Required) IP address.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.cluster_reference_list` - (Optional/Computed) The clusters where the recovery and test networks reside. This is required to specify network mapping across clusters for a Recovery Plan created to handle failover within the same Availability Zone.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.cluster_reference_list.0.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.cluster_reference_list.0.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.name` - (Optional/Computed) The name.
     */
    networkMappingLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingList[];
}

export interface GetRecoveryPlansEntityParameterFloatingIpAssignmentList {
    availabilityZoneUrl: string;
    vmIpAssignmentLists: outputs.GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentList[];
}

export interface GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentList {
    recoveryFloatingIpConfigs: outputs.GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfig[];
    testFloatingIpConfigs: outputs.GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfig[];
    vmNicInformations: outputs.GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListVmNicInformation[];
    vmReferences: outputs.GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListVmReference[];
}

export interface GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfig {
    ip: string;
    shouldAllocateDynamically: boolean;
}

export interface GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfig {
    ip: string;
    shouldAllocateDynamically: boolean;
}

export interface GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListVmNicInformation {
    ip: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingList {
    areNetworksStretched: boolean;
    availabilityZoneNetworkMappingLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingList[];
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingList {
    availabilityZoneUrl: string;
    clusterReferenceLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceList[];
    recoveryIpAssignmentLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentList[];
    recoveryNetworks: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetwork[];
    testIpAssignmentLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentList[];
    testNetworks: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetwork[];
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentList {
    ipConfigLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigList[];
    vmReference: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReference;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigList {
    ipAddress: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetwork {
    /**
     * (Optional) the name.
     */
    name: string;
    subnetLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetList[];
    useVpcReference: boolean;
    virtualNetworkReferences: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReference[];
    vpcReferences: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReference[];
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetList {
    externalConnectivityState: string;
    gatewayIp: string;
    prefixLength: number;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentList {
    ipConfigLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigList[];
    vmReference: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReference;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigList {
    ipAddress: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetwork {
    /**
     * (Optional) the name.
     */
    name: string;
    subnetLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetList[];
    useVpcReference: boolean;
    virtualNetworkReferences: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReference[];
    vpcReferences: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReference[];
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetList {
    externalConnectivityState: string;
    gatewayIp: string;
    prefixLength: number;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityProjectReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityStageList {
    /**
     * (Optional/Computed) Amount of time in seconds to delay the execution of next stage after execution of current stage.
     */
    delayTimeSecs: number;
    /**
     * (Optional/Computed) UUID of stage.
     */
    stageUuid: string;
    /**
     * (Required) A stage specifies the work to be performed when the Recovery Plan is executed.
     */
    stageWorks: outputs.GetRecoveryPlansEntityStageListStageWork[];
}

export interface GetRecoveryPlansEntityStageListStageWork {
    /**
     * (Optional/Computed) Information about entities to be recovered.
     */
    recoverEntities: outputs.GetRecoveryPlansEntityStageListStageWorkRecoverEntity[];
}

export interface GetRecoveryPlansEntityStageListStageWorkRecoverEntity {
    /**
     * (Optional/Computed) Information about entities to be recovered as part of this stage. For VM, entity information will include set of scripts to be executed after recovery of VM. Only one of categories or anyEntityReference has to be provided.
     * * `stage_list.stage_work.0.recover_entities.0.entity_info_list.#.any_entity_reference_kind` - (Optional/Computed) Reference to a kind.
     * * `stage_list.stage_work.0.recover_entities.0.entity_info_list.#.any_entity_reference_uuid` - (Optional/Computed) Reference to a uuid.
     * * `stage_list.stage_work.0.recover_entities.0.entity_info_list.#.any_entity_reference_name` - (Optional/Computed) Reference to a name.
     * * `stage_list.stage_work.0.recover_entities.0.entity_info_list.#.categories` - (Optional/Computed)  Categories for filtering entities.
     */
    entityInfoLists: outputs.GetRecoveryPlansEntityStageListStageWorkRecoverEntityEntityInfoList[];
}

export interface GetRecoveryPlansEntityStageListStageWorkRecoverEntityEntityInfoList {
    anyEntityReferenceKind: string;
    anyEntityReferenceName: string;
    anyEntityReferenceUuid: string;
    categories: outputs.GetRecoveryPlansEntityStageListStageWorkRecoverEntityEntityInfoListCategory[];
    scriptLists: outputs.GetRecoveryPlansEntityStageListStageWorkRecoverEntityEntityInfoListScriptList[];
}

export interface GetRecoveryPlansEntityStageListStageWorkRecoverEntityEntityInfoListCategory {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetRecoveryPlansEntityStageListStageWorkRecoverEntityEntityInfoListScriptList {
    enableScriptExec: boolean;
    timeout: string;
}

export interface GetRecoveryPointV2Link {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetRecoveryPointV2LocationReference {
    /**
     * External identifier of the cluster where the recovery point is present.
     */
    locationExtId: string;
}

export interface GetRecoveryPointV2VmRecoveryPoint {
    /**
     * User-defined application-consistent properties for the recovery point.
     */
    applicationConsistentProperties: outputs.GetRecoveryPointV2VmRecoveryPointApplicationConsistentProperty[];
    /**
     * External identifier of the Consistency group which the entity was part of at the time of recovery point creation.
     */
    consistencyGroupExtId: string;
    /**
     * The UTC date and time in ISO-8601 format when the Recovery point is created.
     */
    creationTime: string;
    /**
     * array of disk recovery points.
     */
    diskRecoveryPoints: outputs.GetRecoveryPointV2VmRecoveryPointDiskRecoveryPoint[];
    /**
     * The UTC date and time in ISO-8601 format when the current Recovery point expires and will be garbage collected.
     */
    expirationTime: string;
    /**
     * recovery point UUID
     */
    extId: string;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetRecoveryPointV2VmRecoveryPointLink[];
    /**
     * Location agnostic identifier of the recovery point. This identifier is used to identify the same instances of a recovery point across different sites.
     */
    locationAgnosticId: string;
    /**
     * The name of the Recovery point.
     */
    name: string;
    /**
     * Type of the Recovery point.
     */
    recoveryPointType: string;
    /**
     * The status of the Recovery point, which indicates whether this Recovery point is fit to be consumed.
     * * supported values:
     * * `COMPLETE`: -  The Recovery point is in a complete state and ready to be consumed.
     */
    status: string;
    /**
     * A globally unique identifier that represents the tenant that owns this entity
     */
    tenantId: string;
    /**
     * Category key-value pairs associated with the VM at the time of recovery point creation. The category key and value are separated by '/'. For example, a category with key 'dept' and value 'hr' is displayed as 'dept/hr'.
     */
    vmCategories: string[];
    /**
     * VM external identifier which is captured as a part of this recovery point.
     */
    vmExtId: string;
}

export interface GetRecoveryPointV2VmRecoveryPointApplicationConsistentProperty {
    /**
     * The backup type specifies the criteria for identifying the files to be backed up. This property should be specified to the application-consistent recovery points for Windows VMs/agents. The following backup types are supported for the application-consistent recovery points:
     * * supported values:
     * * `FULL_BACKUP`: -  All the files are backed up irrespective of their last backup date/time or state. Also, this backup type updates the backup history of each file that participated in the recovery point. If not explicitly specified, this is the default backup type.
     * * `COPY_BACKUP`: -  this backup type does not update the backup history of individual files involved in the recovery point.
     */
    backupType: string;
    /**
     * value: `dataprotection.v4.common.VssProperties`
     */
    objectType: string;
    /**
     * Indicates whether the given set of VSS writers' UUIDs should be included or excluded from the application consistent recovery point. By default, the value is set to false, indicating that all listed VSS writers' UUIDs will be excluded.
     */
    shouldIncludeWriters: boolean;
    /**
     * Indicates whether to store the VSS metadata if the user is interested in application-specific backup/restore. The VSS metadata consists of VSS writers and requester metadata details. These are compressed into a cabinet file(.cab file) during a VSS backup operation. This cabinet file must be saved to the backup media during a backup operation, as it is required during the restore operation.
     */
    shouldStoreVssMetadata: boolean;
    /**
     * List of VSS writer UUIDs that are used in an application consistent recovery point. The default values are the system and the registry writer UUIDs.
     */
    writers: string[];
}

export interface GetRecoveryPointV2VmRecoveryPointDiskRecoveryPoint {
    /**
     * External identifier of the disk.
     */
    diskExtId: string;
    /**
     * External identifier of the disk recovery point.
     */
    diskRecoveryPointExtId: string;
}

export interface GetRecoveryPointV2VmRecoveryPointLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetRecoveryPointV2VolumeGroupRecoveryPoint {
    /**
     * External identifier of the Consistency group which the entity was part of at the time of recovery point creation.
     */
    consistencyGroupExtId: string;
    /**
     * array of disk recovery points.
     */
    diskRecoveryPoints: outputs.GetRecoveryPointV2VolumeGroupRecoveryPointDiskRecoveryPoint[];
    /**
     * recovery point UUID
     */
    extId: string;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetRecoveryPointV2VolumeGroupRecoveryPointLink[];
    /**
     * Location agnostic identifier of the recovery point. This identifier is used to identify the same instances of a recovery point across different sites.
     */
    locationAgnosticId: string;
    /**
     * A globally unique identifier that represents the tenant that owns this entity
     */
    tenantId: string;
    /**
     * Category key-value pairs associated with the volume group at the time of recovery point creation. The category key and value are separated by '/'. For example, a category with key 'dept' and value 'hr' will be represented as 'dept/hr'.
     */
    volumeGroupCategories: string[];
    /**
     * Volume Group external identifier which is captured as part of this recovery point.
     */
    volumeGroupExtId: string;
}

export interface GetRecoveryPointV2VolumeGroupRecoveryPointDiskRecoveryPoint {
    /**
     * External identifier of the disk.
     */
    diskExtId: string;
    /**
     * External identifier of the disk recovery point.
     */
    diskRecoveryPointExtId: string;
}

export interface GetRecoveryPointV2VolumeGroupRecoveryPointLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetRecoveryPointsV2RecoveryPoint {
    creationTime: string;
    expirationTime: string;
    extId: string;
    links: outputs.GetRecoveryPointsV2RecoveryPointLink[];
    locationAgnosticId: string;
    locationReferences: outputs.GetRecoveryPointsV2RecoveryPointLocationReference[];
    name: string;
    ownerExtId: string;
    recoveryPointType: string;
    status: string;
    tenantId: string;
    vmRecoveryPoints: outputs.GetRecoveryPointsV2RecoveryPointVmRecoveryPoint[];
    volumeGroupRecoveryPoints: outputs.GetRecoveryPointsV2RecoveryPointVolumeGroupRecoveryPoint[];
}

export interface GetRecoveryPointsV2RecoveryPointLink {
    href: string;
    rel: string;
}

export interface GetRecoveryPointsV2RecoveryPointLocationReference {
    locationExtId: string;
}

export interface GetRecoveryPointsV2RecoveryPointVmRecoveryPoint {
    applicationConsistentProperties: outputs.GetRecoveryPointsV2RecoveryPointVmRecoveryPointApplicationConsistentProperty[];
    consistencyGroupExtId: string;
    creationTime: string;
    diskRecoveryPoints: outputs.GetRecoveryPointsV2RecoveryPointVmRecoveryPointDiskRecoveryPoint[];
    expirationTime: string;
    extId: string;
    links: outputs.GetRecoveryPointsV2RecoveryPointVmRecoveryPointLink[];
    locationAgnosticId: string;
    name: string;
    recoveryPointType: string;
    status: string;
    tenantId: string;
    vmCategories: string[];
    vmExtId: string;
}

export interface GetRecoveryPointsV2RecoveryPointVmRecoveryPointApplicationConsistentProperty {
    backupType: string;
    objectType: string;
    shouldIncludeWriters: boolean;
    shouldStoreVssMetadata: boolean;
    writers: string[];
}

export interface GetRecoveryPointsV2RecoveryPointVmRecoveryPointDiskRecoveryPoint {
    diskExtId: string;
    diskRecoveryPointExtId: string;
}

export interface GetRecoveryPointsV2RecoveryPointVmRecoveryPointLink {
    href: string;
    rel: string;
}

export interface GetRecoveryPointsV2RecoveryPointVolumeGroupRecoveryPoint {
    consistencyGroupExtId: string;
    diskRecoveryPoints: outputs.GetRecoveryPointsV2RecoveryPointVolumeGroupRecoveryPointDiskRecoveryPoint[];
    extId: string;
    links: outputs.GetRecoveryPointsV2RecoveryPointVolumeGroupRecoveryPointLink[];
    locationAgnosticId: string;
    tenantId: string;
    volumeGroupCategories: string[];
    volumeGroupExtId: string;
}

export interface GetRecoveryPointsV2RecoveryPointVolumeGroupRecoveryPointDiskRecoveryPoint {
    diskExtId: string;
    diskRecoveryPointExtId: string;
}

export interface GetRecoveryPointsV2RecoveryPointVolumeGroupRecoveryPointLink {
    href: string;
    rel: string;
}

export interface GetRestorablePcsV2RestorablePc {
    /**
     * * `extId`
     */
    configs: outputs.GetRestorablePcsV2RestorablePcConfig[];
    extId: string;
    hostingClusterExtId: string;
    isRegisteredWithHostingCluster: boolean;
    links: outputs.GetRestorablePcsV2RestorablePcLink[];
    networks: outputs.GetRestorablePcsV2RestorablePcNetwork[];
    nodeExtIds: string[];
    shouldEnableHighAvailability?: boolean;
    tenantId: string;
}

export interface GetRestorablePcsV2RestorablePcConfig {
    bootstrapConfigs: outputs.GetRestorablePcsV2RestorablePcConfigBootstrapConfig[];
    buildInfos: outputs.GetRestorablePcsV2RestorablePcConfigBuildInfo[];
    name: string;
    resourceConfigs: outputs.GetRestorablePcsV2RestorablePcConfigResourceConfig[];
    shouldEnableLockdownMode: boolean;
    size: string;
}

export interface GetRestorablePcsV2RestorablePcConfigBootstrapConfig {
    environmentInfos: outputs.GetRestorablePcsV2RestorablePcConfigBootstrapConfigEnvironmentInfo[];
}

export interface GetRestorablePcsV2RestorablePcConfigBootstrapConfigEnvironmentInfo {
    providerType: string;
    provisioningType: string;
    type: string;
}

export interface GetRestorablePcsV2RestorablePcConfigBuildInfo {
    version: string;
}

export interface GetRestorablePcsV2RestorablePcConfigResourceConfig {
    containerExtIds: string[];
    dataDiskSizeBytes: number;
    memorySizeBytes: number;
    numVcpus: number;
}

export interface GetRestorablePcsV2RestorablePcLink {
    href: string;
    rel: string;
}

export interface GetRestorablePcsV2RestorablePcNetwork {
    externalAddresses: outputs.GetRestorablePcsV2RestorablePcNetworkExternalAddress[];
    externalNetworks: outputs.GetRestorablePcsV2RestorablePcNetworkExternalNetwork[];
    fqdn: string;
    nameServers: outputs.GetRestorablePcsV2RestorablePcNetworkNameServer[];
    ntpServers: outputs.GetRestorablePcsV2RestorablePcNetworkNtpServer[];
}

export interface GetRestorablePcsV2RestorablePcNetworkExternalAddress {
    ipv4s: outputs.GetRestorablePcsV2RestorablePcNetworkExternalAddressIpv4[];
    ipv6s: outputs.GetRestorablePcsV2RestorablePcNetworkExternalAddressIpv6[];
}

export interface GetRestorablePcsV2RestorablePcNetworkExternalAddressIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetRestorablePcsV2RestorablePcNetworkExternalAddressIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetRestorablePcsV2RestorablePcNetworkExternalNetwork {
    defaultGateways: outputs.GetRestorablePcsV2RestorablePcNetworkExternalNetworkDefaultGateway[];
    ipRanges: outputs.GetRestorablePcsV2RestorablePcNetworkExternalNetworkIpRange[];
    networkExtId: string;
    subnetMasks: outputs.GetRestorablePcsV2RestorablePcNetworkExternalNetworkSubnetMask[];
}

export interface GetRestorablePcsV2RestorablePcNetworkExternalNetworkDefaultGateway {
    fqdns: outputs.GetRestorablePcsV2RestorablePcNetworkExternalNetworkDefaultGatewayFqdn[];
    ipv4s: outputs.GetRestorablePcsV2RestorablePcNetworkExternalNetworkDefaultGatewayIpv4[];
    ipv6s: outputs.GetRestorablePcsV2RestorablePcNetworkExternalNetworkDefaultGatewayIpv6[];
}

export interface GetRestorablePcsV2RestorablePcNetworkExternalNetworkDefaultGatewayFqdn {
    value: string;
}

export interface GetRestorablePcsV2RestorablePcNetworkExternalNetworkDefaultGatewayIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetRestorablePcsV2RestorablePcNetworkExternalNetworkDefaultGatewayIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetRestorablePcsV2RestorablePcNetworkExternalNetworkIpRange {
    begins: outputs.GetRestorablePcsV2RestorablePcNetworkExternalNetworkIpRangeBegin[];
    ends: outputs.GetRestorablePcsV2RestorablePcNetworkExternalNetworkIpRangeEnd[];
}

export interface GetRestorablePcsV2RestorablePcNetworkExternalNetworkIpRangeBegin {
    ipv4s: outputs.GetRestorablePcsV2RestorablePcNetworkExternalNetworkIpRangeBeginIpv4[];
    ipv6s: outputs.GetRestorablePcsV2RestorablePcNetworkExternalNetworkIpRangeBeginIpv6[];
}

export interface GetRestorablePcsV2RestorablePcNetworkExternalNetworkIpRangeBeginIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetRestorablePcsV2RestorablePcNetworkExternalNetworkIpRangeBeginIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetRestorablePcsV2RestorablePcNetworkExternalNetworkIpRangeEnd {
    ipv4s: outputs.GetRestorablePcsV2RestorablePcNetworkExternalNetworkIpRangeEndIpv4[];
    ipv6s: outputs.GetRestorablePcsV2RestorablePcNetworkExternalNetworkIpRangeEndIpv6[];
}

export interface GetRestorablePcsV2RestorablePcNetworkExternalNetworkIpRangeEndIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetRestorablePcsV2RestorablePcNetworkExternalNetworkIpRangeEndIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetRestorablePcsV2RestorablePcNetworkExternalNetworkSubnetMask {
    fqdns: outputs.GetRestorablePcsV2RestorablePcNetworkExternalNetworkSubnetMaskFqdn[];
    ipv4s: outputs.GetRestorablePcsV2RestorablePcNetworkExternalNetworkSubnetMaskIpv4[];
    ipv6s: outputs.GetRestorablePcsV2RestorablePcNetworkExternalNetworkSubnetMaskIpv6[];
}

export interface GetRestorablePcsV2RestorablePcNetworkExternalNetworkSubnetMaskFqdn {
    value: string;
}

export interface GetRestorablePcsV2RestorablePcNetworkExternalNetworkSubnetMaskIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetRestorablePcsV2RestorablePcNetworkExternalNetworkSubnetMaskIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetRestorablePcsV2RestorablePcNetworkNameServer {
    fqdns: outputs.GetRestorablePcsV2RestorablePcNetworkNameServerFqdn[];
    ipv4s: outputs.GetRestorablePcsV2RestorablePcNetworkNameServerIpv4[];
    ipv6s: outputs.GetRestorablePcsV2RestorablePcNetworkNameServerIpv6[];
}

export interface GetRestorablePcsV2RestorablePcNetworkNameServerFqdn {
    value: string;
}

export interface GetRestorablePcsV2RestorablePcNetworkNameServerIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetRestorablePcsV2RestorablePcNetworkNameServerIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetRestorablePcsV2RestorablePcNetworkNtpServer {
    fqdns: outputs.GetRestorablePcsV2RestorablePcNetworkNtpServerFqdn[];
    ipv4s: outputs.GetRestorablePcsV2RestorablePcNetworkNtpServerIpv4[];
    ipv6s: outputs.GetRestorablePcsV2RestorablePcNetworkNtpServerIpv6[];
}

export interface GetRestorablePcsV2RestorablePcNetworkNtpServerFqdn {
    value: string;
}

export interface GetRestorablePcsV2RestorablePcNetworkNtpServerIpv4 {
    prefixLength?: number;
    value: string;
}

export interface GetRestorablePcsV2RestorablePcNetworkNtpServerIpv6 {
    prefixLength?: number;
    value: string;
}

export interface GetRoleCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetRolePermissionReferenceList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetRoleV2Link {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetRolesEntity {
    /**
     * The version of the API.
     */
    apiVersion: string;
    /**
     * - Categories for the role.
     */
    categories: outputs.GetRolesEntityCategory[];
    /**
     * - The description of the role.
     */
    description: string;
    /**
     * - The role kind metadata.
     */
    metadata: {[key: string]: string};
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - The reference to a user.
     */
    ownerReference: {[key: string]: string};
    /**
     * - (Required) List of permission references.
     */
    permissionReferenceLists: outputs.GetRolesEntityPermissionReferenceList[];
    /**
     * - The reference to a project.
     */
    projectReference: {[key: string]: string};
    roleId: string;
    /**
     * - The state of the role.
     */
    state: string;
}

export interface GetRolesEntityCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetRolesEntityPermissionReferenceList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetRolesMetadata {
    filter: string;
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetRolesV2Role {
    /**
     * - List of Accessible Clients for the Role.
     */
    accessibleClients: string[];
    /**
     * - List of Accessible Entity Types for the Role.
     */
    accessibleEntityTypes: string[];
    /**
     * - Number of Users assigned to given Role.
     */
    assignedUsersCount: number;
    /**
     * - Number of User Groups assigned to given Role.
     */
    assignedUsersGroupsCount: number;
    /**
     * - Client that created the entity.
     */
    clientName: string;
    /**
     * - User or Service Name that created the Role.
     */
    createdBy: string;
    /**
     * - The creation time of the Role.
     */
    createdTime: string;
    /**
     * - Description of the Role.
     */
    description: string;
    /**
     * - The display name for the Role.
     */
    displayName: string;
    /**
     * - A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    /**
     * - Flag identifying if the Role is system defined or not.
     */
    isSystemDefined: boolean;
    /**
     * - The time when the Role was last updated.
     */
    lastUpdatedTime: string;
    /**
     * - A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetRolesV2RoleLink[];
    /**
     * - List of operations for the role.
     */
    operations: string[];
    /**
     * - A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server).
     */
    tenantId: string;
}

export interface GetRolesV2RoleLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetRouteTableV2Link {
    href: string;
    rel: string;
}

export interface GetRouteTableV2Metadata {
    /**
     * A list of globally unique identifiers that represent all the categories the resource is associated with.
     */
    categoryIds: string[];
    /**
     * A globally unique identifier that represents the owner of this resource.
     */
    ownerReferenceId: string;
    /**
     * The userName of the owner of this resource.
     */
    ownerUserName: string;
    /**
     * The name of the project this resource belongs to.
     */
    projectName: string;
    /**
     * A globally unique identifier that represents the project this resource belongs to.
     */
    projectReferenceId: string;
}

export interface GetRouteTablesV2RouteTable {
    /**
     * Route UUID
     */
    extId: string;
    /**
     * External routing domain associated with this route table.
     */
    externalRoutingDomainReference: string;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetRouteTablesV2RouteTableLink[];
    /**
     * Metadata associated with this resource.
     */
    metadatas: outputs.GetRouteTablesV2RouteTableMetadata[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity
     */
    tenantId: string;
    /**
     * VPC reference.
     */
    vpcReference: string;
}

export interface GetRouteTablesV2RouteTableLink {
    href: string;
    rel: string;
}

export interface GetRouteTablesV2RouteTableMetadata {
    /**
     * A list of globally unique identifiers that represent all the categories the resource is associated with.
     */
    categoryIds: string[];
    /**
     * A globally unique identifier that represents the owner of this resource.
     */
    ownerReferenceId: string;
    /**
     * The userName of the owner of this resource.
     */
    ownerUserName: string;
    /**
     * The name of the project this resource belongs to.
     */
    projectName: string;
    /**
     * A globally unique identifier that represents the project this resource belongs to.
     */
    projectReferenceId: string;
}

export interface GetRouteV2Destination {
    /**
     * IPv4 Address
     */
    ipv4: outputs.GetRouteV2DestinationIpv4;
    /**
     * IPv6 Address
     */
    ipv6: outputs.GetRouteV2DestinationIpv6;
}

export interface GetRouteV2DestinationIpv4 {
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ip: outputs.GetRouteV2DestinationIpv4Ip;
    /**
     * The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength: number;
}

export interface GetRouteV2DestinationIpv4Ip {
    /**
     * The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength: number;
    /**
     * The IPv4 address of the host.
     */
    value: string;
}

export interface GetRouteV2DestinationIpv6 {
    /**
     * IP address format
     */
    ip: outputs.GetRouteV2DestinationIpv6Ip;
    /**
     * The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength: number;
}

export interface GetRouteV2DestinationIpv6Ip {
    /**
     * The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * The IPv6 address of the host.
     */
    value: string;
}

export interface GetRouteV2Link {
    href: string;
    rel: string;
}

export interface GetRouteV2Metadata {
    /**
     * A list of globally unique identifiers that represent all the categories the resource is associated with.
     */
    categoryIds: string[];
    /**
     * A globally unique identifier that represents the owner of this resource.
     */
    ownerReferenceId: string;
    /**
     * The userName of the owner of this resource.
     */
    ownerUserName: string;
    /**
     * The name of the project this resource belongs to.
     */
    projectName: string;
    /**
     * A globally unique identifier that represents the project this resource belongs to.
     */
    projectReferenceId: string;
}

export interface GetRouteV2NextHop {
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    nextHopIpAddresses: outputs.GetRouteV2NextHopNextHopIpAddress[];
    nextHopName: string;
    /**
     * The reference to a link, such as a VPN connection or a subnet.
     */
    nextHopReference: string;
    /**
     * Nexthop type.
     * - supported values:
     * - `LOCAL_SUBNET`: - Next hop is an internal subnet.
     * - `DIRECT_CONNECT_VIF`: - Next hop is a direct connect VIF.
     * - `VPN_CONNECTION`: - Next hop is a VPN connection.
     * - `IP_ADDRESS`: - Next hop is an IP address.
     * - `EXTERNAL_SUBNET`: - Next hop is an external subnet.
     */
    nextHopType: string;
}

export interface GetRouteV2NextHopNextHopIpAddress {
    /**
     * IPv4 Address
     */
    ipv4: outputs.GetRouteV2NextHopNextHopIpAddressIpv4;
    /**
     * IPv6 Address
     */
    ipv6: outputs.GetRouteV2NextHopNextHopIpAddressIpv6;
}

export interface GetRouteV2NextHopNextHopIpAddressIpv4 {
    /**
     * The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength: number;
    /**
     * value of IP address
     */
    value: string;
}

export interface GetRouteV2NextHopNextHopIpAddressIpv6 {
    /**
     * The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of IP address
     */
    value: string;
}

export interface GetRoutesV2Route {
    /**
     * BGP session description.
     */
    description: string;
    /**
     * Destination IP Subnet Configuration.
     */
    destinations: outputs.GetRoutesV2RouteDestination[];
    /**
     * Route UUID
     */
    extId: string;
    /**
     * External routing domain associated with this route table.
     */
    externalRoutingDomainReference: string;
    /**
     * Indicates whether the route is active in the forwarding plane.
     */
    isActive: boolean;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetRoutesV2RouteLink[];
    /**
     * Metadata associated with this resource.
     */
    metadatas: outputs.GetRoutesV2RouteMetadata[];
    /**
     * Route name.
     */
    name: string;
    /**
     * Route nexthop.
     */
    nextHops: outputs.GetRoutesV2RouteNextHop[];
    /**
     * Route priority. A higher value implies greater preference is assigned to the route.
     */
    priority: number;
    /**
     * Route table UUID
     */
    routeTableExtId: string;
    /**
     * Route table reference.
     */
    routeTableReference: string;
    /**
     * Route type. Acceptable values are "STATIC", "LOCAL", "DYNAMIC"
     */
    routeType: string;
    /**
     * A globally unique identifier that represents the tenant that owns this entity
     */
    tenantId: string;
    /**
     * VPC reference.
     */
    vpcReference: string;
}

export interface GetRoutesV2RouteDestination {
    /**
     * IPv4 Address
     */
    ipv4: outputs.GetRoutesV2RouteDestinationIpv4;
    /**
     * IPv6 Address
     */
    ipv6: outputs.GetRoutesV2RouteDestinationIpv6;
}

export interface GetRoutesV2RouteDestinationIpv4 {
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ip: outputs.GetRoutesV2RouteDestinationIpv4Ip;
    /**
     * The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength: number;
}

export interface GetRoutesV2RouteDestinationIpv4Ip {
    /**
     * The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength: number;
    /**
     * The IPv4 address of the host.
     */
    value: string;
}

export interface GetRoutesV2RouteDestinationIpv6 {
    /**
     * IP address format
     */
    ip: outputs.GetRoutesV2RouteDestinationIpv6Ip;
    /**
     * The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength: number;
}

export interface GetRoutesV2RouteDestinationIpv6Ip {
    /**
     * The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * The IPv6 address of the host.
     */
    value: string;
}

export interface GetRoutesV2RouteLink {
    href: string;
    rel: string;
}

export interface GetRoutesV2RouteMetadata {
    /**
     * A list of globally unique identifiers that represent all the categories the resource is associated with.
     */
    categoryIds: string[];
    /**
     * A globally unique identifier that represents the owner of this resource.
     */
    ownerReferenceId: string;
    /**
     * The userName of the owner of this resource.
     */
    ownerUserName: string;
    /**
     * The name of the project this resource belongs to.
     */
    projectName: string;
    /**
     * A globally unique identifier that represents the project this resource belongs to.
     */
    projectReferenceId: string;
}

export interface GetRoutesV2RouteNextHop {
    nextHopIpAddresses: outputs.GetRoutesV2RouteNextHopNextHopIpAddress[];
    nextHopName: string;
    nextHopReference: string;
    nextHopType: string;
}

export interface GetRoutesV2RouteNextHopNextHopIpAddress {
    /**
     * IPv4 Address
     */
    ipv4: outputs.GetRoutesV2RouteNextHopNextHopIpAddressIpv4;
    /**
     * IPv6 Address
     */
    ipv6: outputs.GetRoutesV2RouteNextHopNextHopIpAddressIpv6;
}

export interface GetRoutesV2RouteNextHopNextHopIpAddressIpv4 {
    /**
     * The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength: number;
    /**
     * value of IP address
     */
    value: string;
}

export interface GetRoutesV2RouteNextHopNextHopIpAddressIpv6 {
    /**
     * The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of IP address
     */
    value: string;
}

export interface GetSamlIdentityProviderV2IdpMetadata {
    certificate: string;
    entityId: string;
    errorUrl: string;
    loginUrl: string;
    logoutUrl: string;
    nameIdPolicyFormat: string;
}

export interface GetSamlIdentityProvidersV2IdentityProvider {
    createdBy: string;
    createdTime: string;
    customAttributes: string[];
    emailAttribute: string;
    entityIssuer: string;
    extId: string;
    groupsAttribute: string;
    groupsDelim: string;
    idpMetadatas: outputs.GetSamlIdentityProvidersV2IdentityProviderIdpMetadata[];
    isSignedAuthnReqEnabled: boolean;
    lastUpdatedTime: string;
    name: string;
    usernameAttribute: string;
}

export interface GetSamlIdentityProvidersV2IdentityProviderIdpMetadata {
    certificate: string;
    entityId: string;
    errorUrl: string;
    loginUrl: string;
    logoutUrl: string;
    nameIdPolicyFormat: string;
}

export interface GetSelfServiceAppAction {
    /**
     * A description of the action.
     */
    description: string;
    /**
     * The name of the action.
     */
    name: string;
    /**
     * The UUID of the action.
     */
    uuid: string;
}

export interface GetSelfServiceAppAppSummary {
    /**
     * The profile assigned to the application.
     */
    applicationProfile: string;
    /**
     * The UUID of the application.
     */
    applicationUuid: string;
    /**
     * The blueprint associated with the application.
     */
    blueprint: string;
    /**
     * The timestamp when the application was created.
     */
    createdOn: string;
    /**
     * The timestamp when the application was last updated.
     */
    lastUpdatedOn: string;
    /**
     * The owner of the application.
     */
    owner: string;
    /**
     * The project associated with the application.
     */
    project: string;
}

export interface GetSelfServiceAppSnapshotsEntity {
    /**
     * - The name of the action to run to create the snapshot.
     */
    actionName: string;
    /**
     * - The API version used to retrieve the snapshot data.
     */
    apiVersion: string;
    /**
     * -  The creation time of the snapshot.
     */
    creationTime: string;
    /**
     * - The description of the snapshot.
     */
    description: string;
    /**
     * -  The type of resource represented by the snapshot specification.
     */
    kind: string;
    /**
     * - The last update time of the snapshot.
     */
    lastUpdateTime: string;
    /**
     * - The name of the recovery point.
     */
    name: string;
    /**
     * - The recoveryPointInfoList contains information about recovery points for the snapshots. Each recovery point has the following attributes:
     */
    recoveryPointInfoLists: outputs.GetSelfServiceAppSnapshotsEntityRecoveryPointInfoList[];
    /**
     * -  The spec block contains the specification details for the snapshot
     */
    spec: {[key: string]: string};
    /**
     * - The version of the snapshot specification.
     */
    specVersion: number;
    /**
     * -  The type of the snapshot.
     */
    type: string;
    /**
     * -  The UUID of the snapshot.
     */
    uuid: string;
}

export interface GetSelfServiceAppSnapshotsEntityRecoveryPointInfoList {
    /**
     * -  A map containing configuration specification references for the recovery point.
     */
    configSpecReference: {[key: string]: string};
    /**
     * -  The creation time of the snapshot.
     */
    creationTime: number;
    /**
     * -  The expiration time of the recovery point.
     */
    expirationTime: number;
    /**
     * -  The ID of the recovery point.
     */
    id: string;
    /**
     * -  The type of resource represented by the snapshot specification.
     */
    kind: string;
    /**
     * - The UUID for the location-agnostic reference of the recovery point.
     */
    locationAgnosticUuid: string;
    /**
     * - The name of the recovery point.
     */
    name: string;
    /**
     * -  The type of recovery point.
     */
    recoveryPointType: string;
    /**
     * -  A list of service references related to the recovery point.
     */
    serviceReferences: string[];
    /**
     * - The ID of the snapshot associated with the recovery point.
     */
    snapshotId: string;
}

export interface GetSelfServiceAppVm {
    /**
     * -  A map of categories applied to the VM. Each key is a category name, and the value is the category value.
     */
    categories: {[key: string]: string};
    /**
     * -  Cluster-related information for the VM.
     */
    clusterInfos: outputs.GetSelfServiceAppVmClusterInfo[];
    /**
     * -  Configuration details for the VM.
     */
    configurations: outputs.GetSelfServiceAppVmConfiguration[];
    /**
     * -  A list of network interfaces attached to the VM.
     */
    nics: outputs.GetSelfServiceAppVmNic[];
}

export interface GetSelfServiceAppVmClusterInfo {
    /**
     * -   The name of the cluster.
     */
    clusterName: string;
    /**
     * -   The UUID of the cluster.
     */
    clusterUuid: string;
}

export interface GetSelfServiceAppVmConfiguration {
    /**
     * -   Number of CPU cores.
     */
    cores: number;
    /**
     * -   The VM image used.
     */
    image: string;
    /**
     * -   IP address of the VM.
     */
    ipAddress: string;
    /**
     * -  Memory allocated to the VM.
     */
    memory: number;
    /**
     * The name of the action.
     */
    name: string;
    /**
     * -   Number of virtual CPUs assigned to the VM.
     */
    vcpus: number;
    /**
     * -   The UUID of the VM.
     */
    vmUuid: string;
}

export interface GetSelfServiceAppVmNic {
    /**
     * -   The MAC address of the VM's network interface.
     */
    macAddress: string;
    /**
     * -   The subnet the VM's network interface is attached to.
     */
    subnet: string;
    /**
     * -   The type of network interface.
     */
    type: string;
}

export interface GetSelfServiceSnapshotPolicyListPolicyList {
    /**
     * -  The number of days after which the snapshot policy expires.
     */
    policyExpiryDays: number;
    /**
     * -  The name of the snapshot policy.
     */
    policyName: string;
    /**
     * - The UUID of the snapshot policy.
     */
    policyUuid: string;
    /**
     * - The name of the associated snapshot configuration.
     */
    snapshotConfigName: string;
    /**
     * - The UUID of the associated snapshot configuration.
     */
    snapshotConfigUuid: string;
}

export interface GetServiceGroupServiceList {
    icmpTypeCodeLists: outputs.GetServiceGroupServiceListIcmpTypeCodeList[];
    protocol: string;
    tcpPortRangeLists: outputs.GetServiceGroupServiceListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetServiceGroupServiceListUdpPortRangeList[];
}

export interface GetServiceGroupServiceListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetServiceGroupServiceListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetServiceGroupServiceListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetServiceGroupV2IcmpService {
    /**
     * Icmp service Code. Ignore this field if Code has to be ANY
     */
    code: number;
    /**
     * Set this field to true if both Type and Code is ANY.
     */
    isAllAllowed: boolean;
    /**
     * Icmp service Type. Ignore this field if Type has to be ANY.
     */
    type: number;
}

export interface GetServiceGroupV2Link {
    href: string;
    rel: string;
}

export interface GetServiceGroupV2TcpService {
    /**
     * end port
     */
    endPort: number;
    /**
     * start port
     */
    startPort: number;
}

export interface GetServiceGroupV2UdpService {
    /**
     * end port
     */
    endPort: number;
    /**
     * start port
     */
    startPort: number;
}

export interface GetServiceGroupsEntity {
    associatedPoliciesLists: outputs.GetServiceGroupsEntityAssociatedPoliciesList[];
    serviceGroups: outputs.GetServiceGroupsEntityServiceGroup[];
    uuid: string;
}

export interface GetServiceGroupsEntityAssociatedPoliciesList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetServiceGroupsEntityServiceGroup {
    description: string;
    /**
     * specifying whether it is a system defined service group
     */
    isSystemDefined: boolean;
    name: string;
    serviceLists: outputs.GetServiceGroupsEntityServiceGroupServiceList[];
}

export interface GetServiceGroupsEntityServiceGroupServiceList {
    icmpTypeCodeLists: outputs.GetServiceGroupsEntityServiceGroupServiceListIcmpTypeCodeList[];
    protocol: string;
    tcpPortRangeLists: outputs.GetServiceGroupsEntityServiceGroupServiceListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetServiceGroupsEntityServiceGroupServiceListUdpPortRangeList[];
}

export interface GetServiceGroupsEntityServiceGroupServiceListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetServiceGroupsEntityServiceGroupServiceListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetServiceGroupsEntityServiceGroupServiceListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetServiceGroupsMetadata {
    filter: string;
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetServiceGroupsV2ServiceGroup {
    /**
     * created by.
     */
    createdBy: string;
    /**
     * A user defined annotation for an service Group.
     */
    description: string;
    /**
     * service group UUID.
     */
    extId: string;
    /**
     * Icmp Type Code List.
     */
    icmpServices: outputs.GetServiceGroupsV2ServiceGroupIcmpService[];
    /**
     * Service Group is system defined or not.
     */
    isSystemDefined: boolean;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetServiceGroupsV2ServiceGroupLink[];
    /**
     * A short identifier for an service Group.
     */
    name: string;
    /**
     * Reference to policy associated with Service Group.
     */
    policyReferences: string[];
    /**
     * List of TCP ports in the service.
     */
    tcpServices: outputs.GetServiceGroupsV2ServiceGroupTcpService[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity.
     */
    tenantId: string;
    /**
     * List of UDP ports in the service.
     */
    udpServices: outputs.GetServiceGroupsV2ServiceGroupUdpService[];
}

export interface GetServiceGroupsV2ServiceGroupIcmpService {
    /**
     * Icmp service Code. Ignore this field if Code has to be ANY
     */
    code: number;
    /**
     * Set this field to true if both Type and Code is ANY.
     */
    isAllAllowed: boolean;
    /**
     * Icmp service Type. Ignore this field if Type has to be ANY.
     */
    type: number;
}

export interface GetServiceGroupsV2ServiceGroupLink {
    href: string;
    rel: string;
}

export interface GetServiceGroupsV2ServiceGroupTcpService {
    /**
     * end port
     */
    endPort: number;
    /**
     * start port
     */
    startPort: number;
}

export interface GetServiceGroupsV2ServiceGroupUdpService {
    /**
     * end port
     */
    endPort: number;
    /**
     * start port
     */
    startPort: number;
}

export interface GetStaticRoutesSpec {
    /**
     * - the name.
     */
    name: string;
    /**
     * VPC route table resources status
     */
    resources: outputs.GetStaticRoutesSpecResource[];
}

export interface GetStaticRoutesSpecResource {
    /**
     * default routes (present in spec resource)
     */
    defaultRouteNexthops: outputs.GetStaticRoutesSpecResourceDefaultRouteNexthop[];
    /**
     * list of static routes
     */
    staticRoutesLists: outputs.GetStaticRoutesSpecResourceStaticRoutesList[];
}

export interface GetStaticRoutesSpecResourceDefaultRouteNexthop {
    /**
     * The reference to a direct_connect_virtual_interface
     */
    directConnectVirtualInterfaceReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    localSubnetReference: {[key: string]: string};
    /**
     * The reference to a vpn_connection
     */
    vpnConnectionReference: {[key: string]: string};
}

export interface GetStaticRoutesSpecResourceStaticRoutesList {
    /**
     * destination ip address with prefix.
     */
    destination: string;
    /**
     * Targeted link to use as the nexthop in a route.
     */
    nexthops: outputs.GetStaticRoutesSpecResourceStaticRoutesListNexthop[];
}

export interface GetStaticRoutesSpecResourceStaticRoutesListNexthop {
    /**
     * The reference to a direct_connect_virtual_interface
     */
    directConnectVirtualInterfaceReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    localSubnetReference: {[key: string]: string};
    /**
     * The reference to a vpn_connection
     */
    vpnConnectionReference: {[key: string]: string};
}

export interface GetStaticRoutesStatus {
    /**
     * Execution Context of VPC.
     */
    executionContexts: outputs.GetStaticRoutesStatusExecutionContext[];
    /**
     * VPC route table resources status
     */
    resources: outputs.GetStaticRoutesStatusResource[];
    /**
     * The state of the vpc_route_table.
     */
    state: string;
}

export interface GetStaticRoutesStatusExecutionContext {
    taskUuids: string[];
}

export interface GetStaticRoutesStatusResource {
    /**
     * default route. (present in status resource only )
     */
    defaultRoutes: outputs.GetStaticRoutesStatusResourceDefaultRoute[];
    /**
     * list of dynamic routes (present in status resource only)
     */
    dynamicRoutesLists: outputs.GetStaticRoutesStatusResourceDynamicRoutesList[];
    /**
     * list of local routes (present in status resource only )
     */
    localRoutesLists: outputs.GetStaticRoutesStatusResourceLocalRoutesList[];
    /**
     * list of static routes
     */
    staticRoutesLists: outputs.GetStaticRoutesStatusResourceStaticRoutesList[];
}

export interface GetStaticRoutesStatusResourceDefaultRoute {
    /**
     * destination ip address with prefix.
     */
    destination: string;
    /**
     * Whether this route is currently active. Present in Status Resources.
     */
    isActive: boolean;
    /**
     * Targeted link to use as the nexthop in a route.
     */
    nexthops: outputs.GetStaticRoutesStatusResourceDefaultRouteNexthop[];
    /**
     * The preference value assigned to this route. A higher value means greater preference. Present in Status Resource.
     */
    priority: number;
}

export interface GetStaticRoutesStatusResourceDefaultRouteNexthop {
    /**
     * The reference to a direct_connect_virtual_interface
     */
    directConnectVirtualInterfaceReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    localSubnetReference: {[key: string]: string};
    nexthopIpAddress: string;
    /**
     * The reference to a vpn_connection
     */
    vpnConnectionReference: {[key: string]: string};
}

export interface GetStaticRoutesStatusResourceDynamicRoutesList {
    /**
     * destination ip address with prefix.
     */
    destination: string;
    /**
     * Whether this route is currently active. Present in Status Resources.
     */
    isActive: boolean;
    /**
     * Targeted link to use as the nexthop in a route.
     */
    nexthops: outputs.GetStaticRoutesStatusResourceDynamicRoutesListNexthop[];
    /**
     * The preference value assigned to this route. A higher value means greater preference. Present in Status Resource.
     */
    priority: number;
}

export interface GetStaticRoutesStatusResourceDynamicRoutesListNexthop {
    /**
     * The reference to a direct_connect_virtual_interface
     */
    directConnectVirtualInterfaceReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    localSubnetReference: {[key: string]: string};
    nexthopIpAddress: string;
    /**
     * The reference to a vpn_connection
     */
    vpnConnectionReference: {[key: string]: string};
}

export interface GetStaticRoutesStatusResourceLocalRoutesList {
    /**
     * destination ip address with prefix.
     */
    destination: string;
    /**
     * Whether this route is currently active. Present in Status Resources.
     */
    isActive: boolean;
    /**
     * Targeted link to use as the nexthop in a route.
     */
    nexthops: outputs.GetStaticRoutesStatusResourceLocalRoutesListNexthop[];
    /**
     * The preference value assigned to this route. A higher value means greater preference. Present in Status Resource.
     */
    priority: number;
}

export interface GetStaticRoutesStatusResourceLocalRoutesListNexthop {
    /**
     * The reference to a direct_connect_virtual_interface
     */
    directConnectVirtualInterfaceReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    localSubnetReference: {[key: string]: string};
    nexthopIpAddress: string;
    /**
     * The reference to a vpn_connection
     */
    vpnConnectionReference: {[key: string]: string};
}

export interface GetStaticRoutesStatusResourceStaticRoutesList {
    /**
     * destination ip address with prefix.
     */
    destination: string;
    /**
     * Whether this route is currently active. Present in Status Resources.
     */
    isActive: boolean;
    /**
     * Targeted link to use as the nexthop in a route.
     */
    nexthops: outputs.GetStaticRoutesStatusResourceStaticRoutesListNexthop[];
    /**
     * The preference value assigned to this route. A higher value means greater preference. Present in Status Resource.
     */
    priority: number;
}

export interface GetStaticRoutesStatusResourceStaticRoutesListNexthop {
    /**
     * The reference to a direct_connect_virtual_interface
     */
    directConnectVirtualInterfaceReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    localSubnetReference: {[key: string]: string};
    nexthopIpAddress: string;
    /**
     * The reference to a vpn_connection
     */
    vpnConnectionReference: {[key: string]: string};
}

export interface GetStorageContainerStatsInfoV2ControllerAvgIoLatencyuSec {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2ControllerAvgReadIoLatencyuSec {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2ControllerAvgWriteIoLatencyuSec {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2ControllerIoBandwidthKbp {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2ControllerNumIop {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2ControllerNumReadIop {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2ControllerNumWriteIop {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2ControllerReadIoBandwidthKbp {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2ControllerReadIoRatioPpm {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2ControllerWriteIoBandwidthKbp {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2ControllerWriteIoRatioPpm {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2DataReductionCloneSavingRatioPpm {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2DataReductionCompressionSavingRatioPpm {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2DataReductionDedupSavingRatioPpm {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2DataReductionErasureCodingSavingRatioPpm {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2DataReductionOverallPostReductionByte {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2DataReductionOverallPreReductionByte {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2DataReductionSavedByte {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2DataReductionSavingRatioPpm {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2DataReductionSnapshotSavingRatioPpm {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2DataReductionThinProvisionSavingRatioPpm {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2DataReductionTotalSavingRatioPpm {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2DataReductionZeroWriteSavingsByte {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2Health {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2Link {
    href: string;
    rel: string;
}

export interface GetStorageContainerStatsInfoV2StorageActualPhysicalUsageByte {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2StorageCapacityByte {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2StorageFreeByte {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2StorageReplicationFactor {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2StorageReservedCapacityByte {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2StorageTierDasSataUsageByte {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2StorageTierSsdUsageByte {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerStatsInfoV2StorageUsageByte {
    timestamp: string;
    value: number;
}

export interface GetStorageContainerV2Link {
    href: string;
    rel: string;
}

export interface GetStorageContainerV2NfsWhitelistAddress {
    /**
     * Reference to address configuration
     */
    fqdns: outputs.GetStorageContainerV2NfsWhitelistAddressFqdn[];
    /**
     * Reference to address configuration
     */
    ipv4s: outputs.GetStorageContainerV2NfsWhitelistAddressIpv4[];
    /**
     * Reference to address configuration
     */
    ipv6s: outputs.GetStorageContainerV2NfsWhitelistAddressIpv6[];
}

export interface GetStorageContainerV2NfsWhitelistAddressFqdn {
    /**
     * value of fqdn address
     */
    value: string;
}

export interface GetStorageContainerV2NfsWhitelistAddressIpv4 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of fqdn address
     */
    value: string;
}

export interface GetStorageContainerV2NfsWhitelistAddressIpv6 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of fqdn address
     */
    value: string;
}

export interface GetStorageContainersV2StorageContainer {
    affinityHostExtId: string;
    cacheDeduplication: string;
    clusterExtId: string;
    clusterName: string;
    compressionDelaySecs: number;
    containerExtId: string;
    erasureCode: string;
    erasureCodeDelaySecs: number;
    extId: string;
    hasHigherEcFaultDomainPreference: boolean;
    isCompressionEnabled: boolean;
    isEncrypted: boolean;
    isInlineEcEnabled: boolean;
    isInternal: boolean;
    isMarkedForRemoval: boolean;
    isNfsWhitelistInherited: boolean;
    isSoftwareEncryptionEnabled: boolean;
    links: outputs.GetStorageContainersV2StorageContainerLink[];
    logicalAdvertisedCapacityBytes: number;
    logicalExplicitReservedCapacityBytes: number;
    logicalImplicitReservedCapacityBytes: number;
    maxCapacityBytes: number;
    name: string;
    nfsWhitelistAddresses: outputs.GetStorageContainersV2StorageContainerNfsWhitelistAddress[];
    onDiskDedup: string;
    ownerExtId: string;
    replicationFactor: number;
    storagePoolExtId: string;
    tenantId: string;
}

export interface GetStorageContainersV2StorageContainerLink {
    href: string;
    rel: string;
}

export interface GetStorageContainersV2StorageContainerNfsWhitelistAddress {
    fqdns: outputs.GetStorageContainersV2StorageContainerNfsWhitelistAddressFqdn[];
    ipv4s: outputs.GetStorageContainersV2StorageContainerNfsWhitelistAddressIpv4[];
    ipv6s: outputs.GetStorageContainersV2StorageContainerNfsWhitelistAddressIpv6[];
}

export interface GetStorageContainersV2StorageContainerNfsWhitelistAddressFqdn {
    value: string;
}

export interface GetStorageContainersV2StorageContainerNfsWhitelistAddressIpv4 {
    prefixLength: number;
    value: string;
}

export interface GetStorageContainersV2StorageContainerNfsWhitelistAddressIpv6 {
    prefixLength: number;
    value: string;
}

export interface GetSubnetAdditionalFilter {
    /**
     * - the name(Optional).
     */
    name: string;
    values: string[];
}

export interface GetSubnetCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetSubnetMessageList {
    details: {[key: string]: string};
    message: string;
    reason: string;
}

export interface GetSubnetV2DhcpOption {
    /**
     * Boot file name
     */
    bootFileName: string;
    /**
     * The DNS domain name of the client.
     */
    domainName: string;
    /**
     * List of Domain Name Server addresses.
     */
    domainNameServers: outputs.GetSubnetV2DhcpOptionDomainNameServer[];
    /**
     * List of NTP server addresses
     */
    ntpServers: outputs.GetSubnetV2DhcpOptionNtpServer[];
    /**
     * The DNS domain search list.
     */
    searchDomains: string[];
    /**
     * TFTP server name
     */
    tftpServerName: string;
}

export interface GetSubnetV2DhcpOptionDomainNameServer {
    /**
     * IP V4 configuration.
     */
    ipv4s: outputs.GetSubnetV2DhcpOptionDomainNameServerIpv4[];
    /**
     * IP V6 configuration
     */
    ipv6s: outputs.GetSubnetV2DhcpOptionDomainNameServerIpv6[];
}

export interface GetSubnetV2DhcpOptionDomainNameServerIpv4 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2DhcpOptionDomainNameServerIpv6 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2DhcpOptionNtpServer {
    /**
     * IP V4 configuration.
     */
    ipv4s: outputs.GetSubnetV2DhcpOptionNtpServerIpv4[];
    /**
     * IP V6 configuration
     */
    ipv6s: outputs.GetSubnetV2DhcpOptionNtpServerIpv6[];
}

export interface GetSubnetV2DhcpOptionNtpServerIpv4 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2DhcpOptionNtpServerIpv6 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2DynamicIpAddress {
    /**
     * IP V4 configuration.
     */
    ipv4s: outputs.GetSubnetV2DynamicIpAddressIpv4[];
    /**
     * IP V6 configuration
     */
    ipv6s: outputs.GetSubnetV2DynamicIpAddressIpv6[];
}

export interface GetSubnetV2DynamicIpAddressIpv4 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2DynamicIpAddressIpv6 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2IpConfig {
    /**
     * IP V4 configuration.
     */
    ipv4s: outputs.GetSubnetV2IpConfigIpv4[];
    /**
     * IP V6 configuration
     */
    ipv6s: outputs.GetSubnetV2IpConfigIpv6[];
}

export interface GetSubnetV2IpConfigIpv4 {
    /**
     * Reference to address configuration
     */
    defaultGatewayIps: outputs.GetSubnetV2IpConfigIpv4DefaultGatewayIp[];
    /**
     * Reference to address configuration
     */
    dhcpServerAddresses: outputs.GetSubnetV2IpConfigIpv4DhcpServerAddress[];
    /**
     * subnet ip
     */
    ipSubnets: outputs.GetSubnetV2IpConfigIpv4IpSubnet[];
    /**
     * Pool of IP addresses from where IPs are allocated.
     */
    poolLists: outputs.GetSubnetV2IpConfigIpv4PoolList[];
}

export interface GetSubnetV2IpConfigIpv4DefaultGatewayIp {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2IpConfigIpv4DhcpServerAddress {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2IpConfigIpv4IpSubnet {
    /**
     * Reference to address configuration
     */
    ips: outputs.GetSubnetV2IpConfigIpv4IpSubnetIp[];
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
}

export interface GetSubnetV2IpConfigIpv4IpSubnetIp {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2IpConfigIpv4PoolList {
    /**
     * Reference to address configuration
     */
    endIps: outputs.GetSubnetV2IpConfigIpv4PoolListEndIp[];
    /**
     * Reference to address configuration
     */
    startIps: outputs.GetSubnetV2IpConfigIpv4PoolListStartIp[];
}

export interface GetSubnetV2IpConfigIpv4PoolListEndIp {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2IpConfigIpv4PoolListStartIp {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2IpConfigIpv6 {
    /**
     * Reference to address configuration
     */
    defaultGatewayIps: outputs.GetSubnetV2IpConfigIpv6DefaultGatewayIp[];
    /**
     * Reference to address configuration
     */
    dhcpServerAddresses: outputs.GetSubnetV2IpConfigIpv6DhcpServerAddress[];
    /**
     * subnet ip
     */
    ipSubnets: outputs.GetSubnetV2IpConfigIpv6IpSubnet[];
    /**
     * Pool of IP addresses from where IPs are allocated.
     */
    poolLists: outputs.GetSubnetV2IpConfigIpv6PoolList[];
}

export interface GetSubnetV2IpConfigIpv6DefaultGatewayIp {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2IpConfigIpv6DhcpServerAddress {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2IpConfigIpv6IpSubnet {
    /**
     * Reference to address configuration
     */
    ips: outputs.GetSubnetV2IpConfigIpv6IpSubnetIp[];
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
}

export interface GetSubnetV2IpConfigIpv6IpSubnetIp {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2IpConfigIpv6PoolList {
    /**
     * Reference to address configuration
     */
    endIps: outputs.GetSubnetV2IpConfigIpv6PoolListEndIp[];
    /**
     * Reference to address configuration
     */
    startIps: outputs.GetSubnetV2IpConfigIpv6PoolListStartIp[];
}

export interface GetSubnetV2IpConfigIpv6PoolListEndIp {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2IpConfigIpv6PoolListStartIp {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2IpUsage {
    /**
     * IP Pool usages
     */
    ipPoolUsages: outputs.GetSubnetV2IpUsageIpPoolUsage[];
    /**
     * Number of assigned IPs.
     */
    numAssignedIps: number;
    /**
     * Number of free IPs
     */
    numFreeIps: number;
    /**
     * Number of MAC addresses.
     */
    numMacs: number;
}

export interface GetSubnetV2IpUsageIpPoolUsage {
    /**
     * Number of free IPs
     */
    numFreeIps: number;
    /**
     * Total number of IPs in this pool.
     */
    numTotalIps: number;
    /**
     * Start/end IP address range.
     */
    ranges: outputs.GetSubnetV2IpUsageIpPoolUsageRange[];
}

export interface GetSubnetV2IpUsageIpPoolUsageRange {
    /**
     * Reference to address configuration
     */
    endIps: outputs.GetSubnetV2IpUsageIpPoolUsageRangeEndIp[];
    /**
     * Reference to address configuration
     */
    startIps: outputs.GetSubnetV2IpUsageIpPoolUsageRangeStartIp[];
}

export interface GetSubnetV2IpUsageIpPoolUsageRangeEndIp {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2IpUsageIpPoolUsageRangeStartIp {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2Link {
    href: string;
    rel: string;
}

export interface GetSubnetV2ReservedIpAddress {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2VirtualSwitch {
    bondMode: boolean;
    clusters: outputs.GetSubnetV2VirtualSwitchCluster[];
    /**
     * Description of the subnet.
     */
    description: string;
    /**
     * - (Required) The UUID of the subnet.
     */
    extId: string;
    hasDeploymentError: boolean;
    isDefault: boolean;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetSubnetV2VirtualSwitchLink[];
    metadatas: outputs.GetSubnetV2VirtualSwitchMetadata[];
    mtu: number;
    /**
     * Name of the subnet.
     */
    name: string;
    tenantId: string;
}

export interface GetSubnetV2VirtualSwitchCluster {
    /**
     * - (Required) The UUID of the subnet.
     */
    extId: string;
    gatewayIpAddresses: outputs.GetSubnetV2VirtualSwitchClusterGatewayIpAddress[];
    hosts: outputs.GetSubnetV2VirtualSwitchClusterHost[];
}

export interface GetSubnetV2VirtualSwitchClusterGatewayIpAddress {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2VirtualSwitchClusterHost {
    /**
     * - (Required) The UUID of the subnet.
     */
    extId: string;
    hostNics: string[];
    internalBridgeName: string;
    ipAddresses: outputs.GetSubnetV2VirtualSwitchClusterHostIpAddress[];
    routeTable: number;
}

export interface GetSubnetV2VirtualSwitchClusterHostIpAddress {
    /**
     * Reference to address configuration
     */
    ips: outputs.GetSubnetV2VirtualSwitchClusterHostIpAddressIp[];
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
}

export interface GetSubnetV2VirtualSwitchClusterHostIpAddressIp {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2VirtualSwitchLink {
    href: string;
    rel: string;
}

export interface GetSubnetV2VirtualSwitchMetadata {
    categoryIds: any[][];
    ownerReferenceId: string;
    ownerUserName: string;
    projectName: string;
    projectReferenceId: string;
}

export interface GetSubnetV2Vpc {
    commonDhcpOptions: outputs.GetSubnetV2VpcCommonDhcpOption[];
    /**
     * Description of the subnet.
     */
    description: string;
    /**
     * - (Required) The UUID of the subnet.
     */
    extId: string;
    externalRoutingDomainReference: string;
    externalSubnets: outputs.GetSubnetV2VpcExternalSubnet[];
    externallyRoutablePrefixes: outputs.GetSubnetV2VpcExternallyRoutablePrefix[];
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetSubnetV2VpcLink[];
    metadatas: outputs.GetSubnetV2VpcMetadata[];
    /**
     * Name of the subnet.
     */
    name: string;
    snatIps: outputs.GetSubnetV2VpcSnatIp[];
    tenantId: string;
    vpcType: string;
}

export interface GetSubnetV2VpcCommonDhcpOption {
    /**
     * List of Domain Name Server addresses.
     */
    domainNameServers: outputs.GetSubnetV2VpcCommonDhcpOptionDomainNameServer[];
}

export interface GetSubnetV2VpcCommonDhcpOptionDomainNameServer {
    /**
     * IP V4 configuration.
     */
    ipv4s: outputs.GetSubnetV2VpcCommonDhcpOptionDomainNameServerIpv4[];
    /**
     * IP V6 configuration
     */
    ipv6s: outputs.GetSubnetV2VpcCommonDhcpOptionDomainNameServerIpv6[];
}

export interface GetSubnetV2VpcCommonDhcpOptionDomainNameServerIpv4 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2VpcCommonDhcpOptionDomainNameServerIpv6 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2VpcExternalSubnet {
    activeGatewayCount: number;
    activeGatewayNodes: outputs.GetSubnetV2VpcExternalSubnetActiveGatewayNode[];
    externalIps: outputs.GetSubnetV2VpcExternalSubnetExternalIp[];
    gatewayNodes: string[];
    subnetReference: string;
}

export interface GetSubnetV2VpcExternalSubnetActiveGatewayNode {
    nodeId: string;
    nodeIpAddresses: outputs.GetSubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddress[];
}

export interface GetSubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddress {
    /**
     * IP V4 configuration.
     */
    ipv4s: outputs.GetSubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4[];
    /**
     * IP V6 configuration
     */
    ipv6s: outputs.GetSubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6[];
}

export interface GetSubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2VpcExternalSubnetExternalIp {
    /**
     * IP V4 configuration.
     */
    ipv4s: outputs.GetSubnetV2VpcExternalSubnetExternalIpIpv4[];
    /**
     * IP V6 configuration
     */
    ipv6s: outputs.GetSubnetV2VpcExternalSubnetExternalIpIpv6[];
}

export interface GetSubnetV2VpcExternalSubnetExternalIpIpv4 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2VpcExternalSubnetExternalIpIpv6 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2VpcExternallyRoutablePrefix {
    /**
     * IP V4 configuration.
     */
    ipv4s: outputs.GetSubnetV2VpcExternallyRoutablePrefixIpv4[];
    /**
     * IP V6 configuration
     */
    ipv6s: outputs.GetSubnetV2VpcExternallyRoutablePrefixIpv6[];
}

export interface GetSubnetV2VpcExternallyRoutablePrefixIpv4 {
    /**
     * Reference to address configuration
     */
    ips: outputs.GetSubnetV2VpcExternallyRoutablePrefixIpv4Ip[];
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
}

export interface GetSubnetV2VpcExternallyRoutablePrefixIpv4Ip {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2VpcExternallyRoutablePrefixIpv6 {
    /**
     * Reference to address configuration
     */
    ips: outputs.GetSubnetV2VpcExternallyRoutablePrefixIpv6Ip[];
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
}

export interface GetSubnetV2VpcExternallyRoutablePrefixIpv6Ip {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2VpcLink {
    href: string;
    rel: string;
}

export interface GetSubnetV2VpcMetadata {
    categoryIds: any[][];
    ownerReferenceId: string;
    ownerUserName: string;
    projectName: string;
    projectReferenceId: string;
}

export interface GetSubnetV2VpcSnatIp {
    /**
     * IP V4 configuration.
     */
    ipv4s: outputs.GetSubnetV2VpcSnatIpIpv4[];
    /**
     * IP V6 configuration
     */
    ipv6s: outputs.GetSubnetV2VpcSnatIpIpv6[];
}

export interface GetSubnetV2VpcSnatIpIpv4 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetV2VpcSnatIpIpv6 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetSubnetsEntity {
    /**
     * version of the API
     */
    apiVersion: string;
    /**
     * The reference to a availability_zone.
     */
    availabilityZoneReference: {[key: string]: string};
    /**
     * The API Version.
     */
    categories: outputs.GetSubnetsEntityCategory[];
    /**
     * The name of a cluster.
     */
    clusterName: string;
    /**
     * The reference to a cluster.
     */
    clusterReference: {[key: string]: string};
    clusterUuid: string;
    /**
     * Default gateway IP address.
     */
    defaultGatewayIp: string;
    /**
     * A description for subnet.
     */
    description: string;
    dhcpDomainNameServerLists: string[];
    /**
     * DHCP domain search list for a subnet.
     */
    dhcpDomainSearchLists: string[];
    /**
     * Spec for defining DHCP options.
     */
    dhcpOptions: {[key: string]: string};
    /**
     * Host address.
     */
    dhcpServerAddress: {[key: string]: string};
    /**
     * Port Number.
     */
    dhcpServerAddressPort: number;
    enableNat: boolean;
    ipConfigPoolListRanges: string[];
    isExternal: boolean;
    messageLists: outputs.GetSubnetsEntityMessageList[];
    /**
     * The subnet kind metadata.
     */
    metadata: {[key: string]: string};
    /**
     * the name.
     */
    name: string;
    /**
     * The reference to a network_function_chain.
     */
    networkFunctionChainReference: {[key: string]: string};
    /**
     * The reference to a user.
     */
    ownerReference: {[key: string]: string};
    /**
     * -. IP prefix length of the Subnet.
     */
    prefixLength: number;
    /**
     * The reference to a project.
     */
    projectReference: {[key: string]: string};
    /**
     * The state of the subnet.
     */
    state: string;
    subnetId: string;
    /**
     * Subnet IP address.
     */
    subnetIp: string;
    subnetName: string;
    /**
     * The type of the subnet.
     */
    subnetType: string;
    /**
     * VLAN assigned to the subnet.
     */
    vlanId: number;
    vpcReference: {[key: string]: string};
    /**
     * The name of the vswitch.
     */
    vswitchName: string;
}

export interface GetSubnetsEntityCategory {
    /**
     * the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetSubnetsEntityMessageList {
    details: {[key: string]: string};
    message: string;
    reason: string;
}

export interface GetSubnetsMetadata {
    filter: string;
    /**
     * The kind name (Default value: project.
     */
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetSubnetsV2Subnet {
    bridgeName: string;
    clusterName: string;
    clusterReference: string;
    description: string;
    dhcpOptions: outputs.GetSubnetsV2SubnetDhcpOption[];
    dynamicIpAddresses: outputs.GetSubnetsV2SubnetDynamicIpAddress[];
    extId: string;
    hypervisorType: string;
    ipConfigs: outputs.GetSubnetsV2SubnetIpConfig[];
    ipPrefix: string;
    ipUsages: outputs.GetSubnetsV2SubnetIpUsage[];
    isAdvancedNetworking: boolean;
    isExternal: boolean;
    isNatEnabled: boolean;
    links: outputs.GetSubnetsV2SubnetLink[];
    migrationState: string;
    name: string;
    networkFunctionChainReference: string;
    networkId: number;
    reservedIpAddresses: outputs.GetSubnetsV2SubnetReservedIpAddress[];
    subnetType: string;
    virtualSwitchReference: string;
    virtualSwitches: outputs.GetSubnetsV2SubnetVirtualSwitch[];
    vpcReference: string;
    vpcs: outputs.GetSubnetsV2SubnetVpc[];
}

export interface GetSubnetsV2SubnetDhcpOption {
    bootFileName: string;
    domainName: string;
    domainNameServers: outputs.GetSubnetsV2SubnetDhcpOptionDomainNameServer[];
    ntpServers: outputs.GetSubnetsV2SubnetDhcpOptionNtpServer[];
    searchDomains: string[];
    tftpServerName: string;
}

export interface GetSubnetsV2SubnetDhcpOptionDomainNameServer {
    ipv4s: outputs.GetSubnetsV2SubnetDhcpOptionDomainNameServerIpv4[];
    ipv6s: outputs.GetSubnetsV2SubnetDhcpOptionDomainNameServerIpv6[];
}

export interface GetSubnetsV2SubnetDhcpOptionDomainNameServerIpv4 {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetDhcpOptionDomainNameServerIpv6 {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetDhcpOptionNtpServer {
    ipv4s: outputs.GetSubnetsV2SubnetDhcpOptionNtpServerIpv4[];
    ipv6s: outputs.GetSubnetsV2SubnetDhcpOptionNtpServerIpv6[];
}

export interface GetSubnetsV2SubnetDhcpOptionNtpServerIpv4 {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetDhcpOptionNtpServerIpv6 {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetDynamicIpAddress {
    ipv4s: outputs.GetSubnetsV2SubnetDynamicIpAddressIpv4[];
    ipv6s: outputs.GetSubnetsV2SubnetDynamicIpAddressIpv6[];
}

export interface GetSubnetsV2SubnetDynamicIpAddressIpv4 {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetDynamicIpAddressIpv6 {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetIpConfig {
    ipv4s: outputs.GetSubnetsV2SubnetIpConfigIpv4[];
    ipv6s: outputs.GetSubnetsV2SubnetIpConfigIpv6[];
}

export interface GetSubnetsV2SubnetIpConfigIpv4 {
    defaultGatewayIps: outputs.GetSubnetsV2SubnetIpConfigIpv4DefaultGatewayIp[];
    dhcpServerAddresses: outputs.GetSubnetsV2SubnetIpConfigIpv4DhcpServerAddress[];
    ipSubnets: outputs.GetSubnetsV2SubnetIpConfigIpv4IpSubnet[];
    poolLists: outputs.GetSubnetsV2SubnetIpConfigIpv4PoolList[];
}

export interface GetSubnetsV2SubnetIpConfigIpv4DefaultGatewayIp {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetIpConfigIpv4DhcpServerAddress {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetIpConfigIpv4IpSubnet {
    ips: outputs.GetSubnetsV2SubnetIpConfigIpv4IpSubnetIp[];
    prefixLength: number;
}

export interface GetSubnetsV2SubnetIpConfigIpv4IpSubnetIp {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetIpConfigIpv4PoolList {
    endIps: outputs.GetSubnetsV2SubnetIpConfigIpv4PoolListEndIp[];
    startIps: outputs.GetSubnetsV2SubnetIpConfigIpv4PoolListStartIp[];
}

export interface GetSubnetsV2SubnetIpConfigIpv4PoolListEndIp {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetIpConfigIpv4PoolListStartIp {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetIpConfigIpv6 {
    defaultGatewayIps: outputs.GetSubnetsV2SubnetIpConfigIpv6DefaultGatewayIp[];
    dhcpServerAddresses: outputs.GetSubnetsV2SubnetIpConfigIpv6DhcpServerAddress[];
    ipSubnets: outputs.GetSubnetsV2SubnetIpConfigIpv6IpSubnet[];
    poolLists: outputs.GetSubnetsV2SubnetIpConfigIpv6PoolList[];
}

export interface GetSubnetsV2SubnetIpConfigIpv6DefaultGatewayIp {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetIpConfigIpv6DhcpServerAddress {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetIpConfigIpv6IpSubnet {
    ips: outputs.GetSubnetsV2SubnetIpConfigIpv6IpSubnetIp[];
    prefixLength: number;
}

export interface GetSubnetsV2SubnetIpConfigIpv6IpSubnetIp {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetIpConfigIpv6PoolList {
    endIps: outputs.GetSubnetsV2SubnetIpConfigIpv6PoolListEndIp[];
    startIps: outputs.GetSubnetsV2SubnetIpConfigIpv6PoolListStartIp[];
}

export interface GetSubnetsV2SubnetIpConfigIpv6PoolListEndIp {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetIpConfigIpv6PoolListStartIp {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetIpUsage {
    ipPoolUsages: outputs.GetSubnetsV2SubnetIpUsageIpPoolUsage[];
    numAssignedIps: number;
    numFreeIps: number;
    numMacs: number;
}

export interface GetSubnetsV2SubnetIpUsageIpPoolUsage {
    numFreeIps: number;
    numTotalIps: number;
    ranges: outputs.GetSubnetsV2SubnetIpUsageIpPoolUsageRange[];
}

export interface GetSubnetsV2SubnetIpUsageIpPoolUsageRange {
    endIps: outputs.GetSubnetsV2SubnetIpUsageIpPoolUsageRangeEndIp[];
    startIps: outputs.GetSubnetsV2SubnetIpUsageIpPoolUsageRangeStartIp[];
}

export interface GetSubnetsV2SubnetIpUsageIpPoolUsageRangeEndIp {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetIpUsageIpPoolUsageRangeStartIp {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetLink {
    href: string;
    rel: string;
}

export interface GetSubnetsV2SubnetReservedIpAddress {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetVirtualSwitch {
    bondMode: boolean;
    clusters: outputs.GetSubnetsV2SubnetVirtualSwitchCluster[];
    description: string;
    extId: string;
    hasDeploymentError: boolean;
    isDefault: boolean;
    links: outputs.GetSubnetsV2SubnetVirtualSwitchLink[];
    metadatas: outputs.GetSubnetsV2SubnetVirtualSwitchMetadata[];
    mtu: number;
    name: string;
    tenantId: string;
}

export interface GetSubnetsV2SubnetVirtualSwitchCluster {
    extId: string;
    gatewayIpAddresses: outputs.GetSubnetsV2SubnetVirtualSwitchClusterGatewayIpAddress[];
    hosts: outputs.GetSubnetsV2SubnetVirtualSwitchClusterHost[];
}

export interface GetSubnetsV2SubnetVirtualSwitchClusterGatewayIpAddress {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetVirtualSwitchClusterHost {
    extId: string;
    hostNics: string[];
    internalBridgeName: string;
    ipAddresses: outputs.GetSubnetsV2SubnetVirtualSwitchClusterHostIpAddress[];
    routeTable: number;
}

export interface GetSubnetsV2SubnetVirtualSwitchClusterHostIpAddress {
    ips: outputs.GetSubnetsV2SubnetVirtualSwitchClusterHostIpAddressIp[];
    prefixLength: number;
}

export interface GetSubnetsV2SubnetVirtualSwitchClusterHostIpAddressIp {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetVirtualSwitchLink {
    href: string;
    rel: string;
}

export interface GetSubnetsV2SubnetVirtualSwitchMetadata {
    categoryIds: any[][];
    ownerReferenceId: string;
    ownerUserName: string;
    projectName: string;
    projectReferenceId: string;
}

export interface GetSubnetsV2SubnetVpc {
    commonDhcpOptions: outputs.GetSubnetsV2SubnetVpcCommonDhcpOption[];
    description: string;
    extId: string;
    externalRoutingDomainReference: string;
    externalSubnets: outputs.GetSubnetsV2SubnetVpcExternalSubnet[];
    externallyRoutablePrefixes: outputs.GetSubnetsV2SubnetVpcExternallyRoutablePrefix[];
    links: outputs.GetSubnetsV2SubnetVpcLink[];
    metadatas: outputs.GetSubnetsV2SubnetVpcMetadata[];
    name: string;
    snatIps: outputs.GetSubnetsV2SubnetVpcSnatIp[];
    tenantId: string;
    vpcType: string;
}

export interface GetSubnetsV2SubnetVpcCommonDhcpOption {
    domainNameServers: outputs.GetSubnetsV2SubnetVpcCommonDhcpOptionDomainNameServer[];
}

export interface GetSubnetsV2SubnetVpcCommonDhcpOptionDomainNameServer {
    ipv4s: outputs.GetSubnetsV2SubnetVpcCommonDhcpOptionDomainNameServerIpv4[];
    ipv6s: outputs.GetSubnetsV2SubnetVpcCommonDhcpOptionDomainNameServerIpv6[];
}

export interface GetSubnetsV2SubnetVpcCommonDhcpOptionDomainNameServerIpv4 {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetVpcCommonDhcpOptionDomainNameServerIpv6 {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetVpcExternalSubnet {
    activeGatewayCount: number;
    activeGatewayNodes: outputs.GetSubnetsV2SubnetVpcExternalSubnetActiveGatewayNode[];
    externalIps: outputs.GetSubnetsV2SubnetVpcExternalSubnetExternalIp[];
    gatewayNodes: string[];
    subnetReference: string;
}

export interface GetSubnetsV2SubnetVpcExternalSubnetActiveGatewayNode {
    nodeId: string;
    nodeIpAddresses: outputs.GetSubnetsV2SubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddress[];
}

export interface GetSubnetsV2SubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddress {
    ipv4s: outputs.GetSubnetsV2SubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4[];
    ipv6s: outputs.GetSubnetsV2SubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6[];
}

export interface GetSubnetsV2SubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4 {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6 {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetVpcExternalSubnetExternalIp {
    ipv4s: outputs.GetSubnetsV2SubnetVpcExternalSubnetExternalIpIpv4[];
    ipv6s: outputs.GetSubnetsV2SubnetVpcExternalSubnetExternalIpIpv6[];
}

export interface GetSubnetsV2SubnetVpcExternalSubnetExternalIpIpv4 {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetVpcExternalSubnetExternalIpIpv6 {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetVpcExternallyRoutablePrefix {
    ipv4s: outputs.GetSubnetsV2SubnetVpcExternallyRoutablePrefixIpv4[];
    ipv6s: outputs.GetSubnetsV2SubnetVpcExternallyRoutablePrefixIpv6[];
}

export interface GetSubnetsV2SubnetVpcExternallyRoutablePrefixIpv4 {
    ips: outputs.GetSubnetsV2SubnetVpcExternallyRoutablePrefixIpv4Ip[];
    prefixLength: number;
}

export interface GetSubnetsV2SubnetVpcExternallyRoutablePrefixIpv4Ip {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetVpcExternallyRoutablePrefixIpv6 {
    ips: outputs.GetSubnetsV2SubnetVpcExternallyRoutablePrefixIpv6Ip[];
    prefixLength: number;
}

export interface GetSubnetsV2SubnetVpcExternallyRoutablePrefixIpv6Ip {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetVpcLink {
    href: string;
    rel: string;
}

export interface GetSubnetsV2SubnetVpcMetadata {
    categoryIds: any[][];
    ownerReferenceId: string;
    ownerUserName: string;
    projectName: string;
    projectReferenceId: string;
}

export interface GetSubnetsV2SubnetVpcSnatIp {
    ipv4s: outputs.GetSubnetsV2SubnetVpcSnatIpIpv4[];
    ipv6s: outputs.GetSubnetsV2SubnetVpcSnatIpIpv6[];
}

export interface GetSubnetsV2SubnetVpcSnatIpIpv4 {
    prefixLength: number;
    value: string;
}

export interface GetSubnetsV2SubnetVpcSnatIpIpv6 {
    prefixLength: number;
    value: string;
}

export interface GetTemplateV2CreatedBy {
    /**
     * Any additional attribute for the User.
     */
    additionalAttributes: outputs.GetTemplateV2CreatedByAdditionalAttribute[];
    creationType: string;
    /**
     * VM description
     */
    description: string;
    /**
     * Display name for the User.
     */
    displayName: string;
    /**
     * Email Id for the User.
     */
    emailId: string;
    /**
     * The identifier of a Template.
     */
    extId: string;
    /**
     * First name for the User.
     */
    firstName: string;
    /**
     * Identifier of the IDP for the User.
     */
    idpId: string;
    /**
     * Flag to force the User to reset password.
     */
    isForceResetPasswordEnabled: boolean;
    /**
     * Last name for the User.
     */
    lastName: string;
    /**
     * Default locale for the User.
     */
    locale: string;
    /**
     * Middle name for the User.
     */
    middleInitial: string;
    password: string;
    /**
     * Default Region for the User.
     */
    region: string;
    /**
     * Status of the User.
     */
    status: string;
    /**
     * Type of the User.
     */
    userType: string;
    /**
     * Identifier for the User in the form an email address.
     */
    username: string;
}

export interface GetTemplateV2CreatedByAdditionalAttribute {
    /**
     * Name of the GPU resource.
     */
    name: string;
    values: outputs.GetTemplateV2CreatedByAdditionalAttributeValue[];
}

export interface GetTemplateV2CreatedByAdditionalAttributeValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.GetTemplateV2CreatedByAdditionalAttributeValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface GetTemplateV2CreatedByAdditionalAttributeValueMapOfString {
    map: {[key: string]: string};
}

export interface GetTemplateV2GuestUpdateStatus {
    /**
     * The identifier of the temporary VM created on initiating Guest OS Update.
     */
    deployedVmReference: string;
}

export interface GetTemplateV2Link {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetTemplateV2TemplateVersionSpec {
    /**
     * VM creation time
     */
    createTime: string;
    /**
     * User or Service who created the User.
     */
    createdBies: outputs.GetTemplateV2TemplateVersionSpecCreatedBy[];
    /**
     * The identifier of a Template.
     */
    extId: string;
    /**
     * Specify whether to mark the Template Version as active or not. The newly created Version during Template Creation, Updating or Guest OS Updating is set to Active by default unless specified otherwise.
     */
    isActiveVersion: boolean;
    /**
     * Allow or disallow override of the Guest Customization during Template deployment.
     */
    isGcOverrideEnabled: boolean;
    /**
     * - A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetTemplateV2TemplateVersionSpecLink[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server).
     */
    tenantId: string;
    /**
     * The user defined description of a Template Version.
     */
    versionDescription: string;
    /**
     * The user defined name of a Template Version.
     */
    versionName: string;
    /**
     * VM configuration.
     */
    vmSpecs: outputs.GetTemplateV2TemplateVersionSpecVmSpec[];
}

export interface GetTemplateV2TemplateVersionSpecCreatedBy {
    /**
     * Any additional attribute for the User.
     */
    additionalAttributes: outputs.GetTemplateV2TemplateVersionSpecCreatedByAdditionalAttribute[];
    creationType: string;
    /**
     * VM description
     */
    description: string;
    /**
     * Display name for the User.
     */
    displayName: string;
    /**
     * Email Id for the User.
     */
    emailId: string;
    /**
     * The identifier of a Template.
     */
    extId: string;
    /**
     * First name for the User.
     */
    firstName: string;
    /**
     * Identifier of the IDP for the User.
     */
    idpId: string;
    /**
     * Flag to force the User to reset password.
     */
    isForceResetPasswordEnabled: boolean;
    /**
     * Last name for the User.
     */
    lastName: string;
    /**
     * Default locale for the User.
     */
    locale: string;
    /**
     * Middle name for the User.
     */
    middleInitial: string;
    password: string;
    /**
     * Default Region for the User.
     */
    region: string;
    /**
     * Status of the User.
     */
    status: string;
    /**
     * Type of the User.
     */
    userType: string;
    /**
     * Identifier for the User in the form an email address.
     */
    username: string;
}

export interface GetTemplateV2TemplateVersionSpecCreatedByAdditionalAttribute {
    /**
     * Name of the GPU resource.
     */
    name: string;
    values: outputs.GetTemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValue[];
}

export interface GetTemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.GetTemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface GetTemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueMapOfString {
    map: {[key: string]: string};
}

export interface GetTemplateV2TemplateVersionSpecLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpec {
    /**
     * Advanced Processor Compatibility configuration for the VM. Enabling this retains the CPU model for the VM across power cycles and migrations.
     */
    apcConfigs: outputs.GetTemplateV2TemplateVersionSpecVmSpecApcConfig[];
    availabilityZones: outputs.GetTemplateV2TemplateVersionSpecVmSpecAvailabilityZone[];
    /**
     * BIOS UUID of the VM. It should be of type UUID.
     */
    biosUuid: string;
    /**
     * Indicates the order of device types in which the VM should try to boot from. If the boot device order is not provided the system will decide an appropriate boot device order.
     */
    bootConfigs: outputs.GetTemplateV2TemplateVersionSpecVmSpecBootConfig[];
    /**
     * Categories for the VM.
     */
    categories: outputs.GetTemplateV2TemplateVersionSpecVmSpecCategory[];
    /**
     * CD-ROMs attached to the VM.
     */
    cdRoms: outputs.GetTemplateV2TemplateVersionSpecVmSpecCdRom[];
    /**
     * Reference to a cluster.
     */
    clusters: outputs.GetTemplateV2TemplateVersionSpecVmSpecCluster[];
    /**
     * VM creation time
     */
    createTime: string;
    /**
     * VM description
     */
    description: string;
    /**
     * Disks attached to the VM.
     */
    disks: outputs.GetTemplateV2TemplateVersionSpecVmSpecDisk[];
    /**
     * The list of additional CPU features to be enabled. HardwareVirtualization: Indicates whether hardware assisted virtualization should be enabled for the Guest OS or not. Once enabled, the Guest OS can deploy a nested hypervisor
     */
    enabledCpuFeatures: string[];
    /**
     * The identifier of a Template.
     */
    extId: string;
    /**
     * Generation UUID of the VM. It should be of type UUID.
     */
    generationUuid: string;
    /**
     * GPUs attached to the VM.
     */
    gpuses: outputs.GetTemplateV2TemplateVersionSpecVmSpecGpus[];
    /**
     * Stage a Sysprep or cloud-init configuration file to be used by the guest for the next boot. Note that the Sysprep command must be used to generalize the Windows VMs before triggering this API call.
     */
    guestCustomizations: outputs.GetTemplateV2TemplateVersionSpecVmSpecGuestCustomization[];
    /**
     * The details about Nutanix Guest Tools for a VM.
     */
    guestTools: outputs.GetTemplateV2TemplateVersionSpecVmSpecGuestTool[];
    /**
     * VM hardware clock timezone in IANA TZDB format (America/Los_Angeles).
     */
    hardwareClockTimezone: string;
    /**
     * Reference to the host, the VM is running on.
     */
    hosts: outputs.GetTemplateV2TemplateVersionSpecVmSpecHost[];
    /**
     * Indicates whether the VM is an agent VM or not. When their host enters maintenance mode, once the normal VMs are evacuated, the agent VMs are powered off. When the host is restored, agent VMs are powered on before the normal VMs are restored. In other words, agent VMs cannot be HA-protected or live migrated.
     */
    isAgentVm: boolean;
    /**
     * Indicates whether to remove AHV branding from VM firmware tables or not.
     */
    isBrandingEnabled: boolean;
    isCpuHotplugEnabled: boolean;
    /**
     * Indicates whether to passthrough the host CPU features to the guest or not. Enabling this will make VM incapable of live migration.
     */
    isCpuPassthroughEnabled: boolean;
    isCrossClusterMigrationInProgress: boolean;
    /**
     * Indicates whether the vGPU console is enabled or not.
     */
    isGpuConsoleEnabled: boolean;
    isLiveMigrateCapable: boolean;
    /**
     * Indicates whether the memory overcommit feature should be enabled for the VM or not. If enabled, parts of the VM memory may reside outside of the hypervisor physical memory. Once enabled, it should be expected that the VM may suffer performance degradation.
     */
    isMemoryOvercommitEnabled: boolean;
    isScsiControllerEnabled: boolean;
    /**
     * Indicates whether the vCPUs should be hard pinned to specific pCPUs or not.
     */
    isVcpuHardPinningEnabled: boolean;
    /**
     * Indicates whether the VGA console should be disabled or not.
     */
    isVgaConsoleEnabled: boolean;
    /**
     * - A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetTemplateV2TemplateVersionSpecVmSpecLink[];
    /**
     * Machine type for the VM. Machine type Q35 is required for secure boot and does not support IDE disks.
     */
    machineType: string;
    /**
     * Memory size in bytes.
     */
    memorySizeBytes: number;
    /**
     * Name of the GPU resource.
     */
    name: string;
    /**
     * NICs attached to the VM.
     */
    nics: outputs.GetTemplateV2TemplateVersionSpecVmSpecNic[];
    /**
     * Number of cores per socket.
     */
    numCoresPerSocket: number;
    /**
     * Number of NUMA nodes. 0 means NUMA is disabled.
     */
    numNumaNodes: number;
    /**
     * Number of vCPU sockets.
     */
    numSockets: number;
    /**
     * Number of threads per core
     */
    numThreadsPerCore: number;
    /**
     * Ownership information for the VM.
     */
    ownershipInfos: outputs.GetTemplateV2TemplateVersionSpecVmSpecOwnershipInfo[];
    pciDevices: outputs.GetTemplateV2TemplateVersionSpecVmSpecPciDevice[];
    powerState: string;
    /**
     * Status of protection policy applied to this VM.
     */
    protectionPolicyStates: outputs.GetTemplateV2TemplateVersionSpecVmSpecProtectionPolicyState[];
    /**
     * The type of protection applied on a VM. PD_PROTECTED indicates a VM is protected using the Prism Element. RULE_PROTECTED indicates a VM protection using the Prism Central.
     */
    protectionType: string;
    /**
     * Serial ports configured on the VM.
     */
    serialPorts: outputs.GetTemplateV2TemplateVersionSpecVmSpecSerialPort[];
    /**
     * Reference to an entity that the VM should be cloned or created from
     */
    sources: outputs.GetTemplateV2TemplateVersionSpecVmSpecSource[];
    /**
     * Storage configuration for VM disks
     */
    storageConfigs: outputs.GetTemplateV2TemplateVersionSpecVmSpecStorageConfig[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server).
     */
    tenantId: string;
    /**
     * VM last updated time.
     */
    updateTime: string;
    /**
     * Indicates how the vTPM for the VM should be configured.
     */
    vtpmConfigs: outputs.GetTemplateV2TemplateVersionSpecVmSpecVtpmConfig[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecApcConfig {
    /**
     * CPU model associated with the VM if Advanced Processor Compatibility(APC) is enabled. If APC is enabled and no CPU model is explicitly set, a default baseline CPU model is picked by the system. See the APC documentation for more information
     */
    cpuModels: outputs.GetTemplateV2TemplateVersionSpecVmSpecApcConfigCpuModel[];
    /**
     * If enabled, the selected CPU model will be retained across live and cold migrations of the VM.
     */
    isApcEnabled: boolean;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecApcConfigCpuModel {
    /**
     * The identifier of a Template.
     */
    extId: string;
    /**
     * Name of the CPU model associated with the VM.
     */
    name: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecAvailabilityZone {
    /**
     * The identifier of a Template.
     */
    extId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecBootConfig {
    /**
     * LegacyBoot config Object
     */
    legacyBoots: outputs.GetTemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBoot[];
    /**
     * UefiBoot config Object
     */
    uefiBoots: outputs.GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBoot[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBoot {
    /**
     * Boot Device object
     */
    bootDevices: outputs.GetTemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDevice[];
    /**
     * Indicates the order of device types in which the VM should try to boot from. If the boot device order is not provided the system will decide an appropriate boot device order.
     */
    bootOrders: string[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDevice {
    /**
     * Disk address.
     */
    bootDeviceDisks: outputs.GetTemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDisk[];
    /**
     * Disk Nic address.
     */
    bootDeviceNics: outputs.GetTemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceNic[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDisk {
    /**
     * Virtual Machine disk (VM disk).
     */
    diskAddresses: outputs.GetTemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddress[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddress {
    /**
     * Bus type for the device
     */
    busType: string;
    /**
     * Device index on the bus. This field is ignored unless the bus details are specified.
     */
    index: number;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceNic {
    /**
     * mac address
     */
    macAddress: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBoot {
    /**
     * Boot Device object
     */
    bootDevices: outputs.GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDevice[];
    /**
     * Indicates the order of device types in which the VM should try to boot from. If the boot device order is not provided the system will decide an appropriate boot device order.
     */
    bootOrders: string[];
    /**
     * Indicate whether to enable secure boot or not
     */
    isSecureBootEnabled: boolean;
    /**
     * Configuration for NVRAM to be presented to the VM.
     */
    nvramDevices: outputs.GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDevice[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDevice {
    /**
     * Disk address.
     */
    bootDeviceDisks: outputs.GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDisk[];
    /**
     * Disk Nic address.
     */
    bootDeviceNics: outputs.GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceNic[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDisk {
    /**
     * Virtual Machine disk (VM disk).
     */
    diskAddresses: outputs.GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskDiskAddress[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskDiskAddress {
    /**
     * Bus type for the device
     */
    busType: string;
    /**
     * Device index on the bus. This field is ignored unless the bus details are specified.
     */
    index: number;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceNic {
    /**
     * mac address
     */
    macAddress: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDevice {
    /**
     * Storage provided by Nutanix ADSF
     */
    backingStorageInfos: outputs.GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfo[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfo {
    /**
     * A reference to a disk or image that contains the contents of a disk.
     */
    dataSources: outputs.GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSource[];
    /**
     * The globally unique identifier of a VM disk. It should be of type UUID.
     */
    diskExtId: string;
    /**
     * Size of the disk in Bytes
     */
    diskSizeBytes: number;
    /**
     * Indicates if the disk is undergoing migration to another container.
     */
    isMigrationInProgress: boolean;
    /**
     * Storage configuration for VM disks
     */
    storageConfigs: outputs.GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfig[];
    /**
     * This reference is for disk level storage container preference. This preference specifies the storage container to which this disk belongs.
     */
    storageContainers: outputs.GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainer[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSource {
    /**
     * Reference to image or vm disk
     */
    references: outputs.GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReference[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReference {
    /**
     * Image Reference
     */
    imageReferences: outputs.GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReference[];
    /**
     * Vm Disk Reference
     */
    vmDiskReferences: outputs.GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReference[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReference {
    /**
     * The globally unique identifier of an image. It should be of type UUID.
     */
    imageExtId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReference {
    /**
     * Disk address.
     */
    diskAddresses: outputs.GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddress[];
    /**
     * The globally unique identifier of a VM disk. It should be of type UUID.
     */
    diskExtId: string;
    /**
     * This is a reference to a VM.
     */
    vmReferences: outputs.GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddress {
    /**
     * Bus type for the device. The acceptable values are: SCSI, IDE, PCI, SATA, SPAPR (only PPC).
     */
    busType: string;
    /**
     * Device index on the bus. This field is ignored unless the bus details are specified.
     */
    index: number;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReference {
    /**
     * The identifier of a Template.
     */
    extId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfig {
    /**
     * Indicates whether the virtual disk is pinned to the hot tier or not.
     */
    isFlashModeEnabled: boolean;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainer {
    /**
     * The identifier of a Template.
     */
    extId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecCategory {
    /**
     * The identifier of a Template.
     */
    extId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecCdRom {
    /**
     * Defines a NIC emulated by the hypervisor
     */
    backingInfos: outputs.GetTemplateV2TemplateVersionSpecVmSpecCdRomBackingInfo[];
    /**
     * Virtual Machine disk (VM disk).
     */
    diskAddresses: outputs.GetTemplateV2TemplateVersionSpecVmSpecCdRomDiskAddress[];
    /**
     * The identifier of a Template.
     */
    extId: string;
    /**
     * Type of ISO image inserted in CD-ROM
     */
    isoType: string;
    /**
     * - A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetTemplateV2TemplateVersionSpecVmSpecCdRomLink[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server).
     */
    tenantId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecCdRomBackingInfo {
    /**
     * A reference to a disk or image that contains the contents of a disk.
     */
    dataSources: outputs.GetTemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSource[];
    /**
     * The globally unique identifier of a VM disk. It should be of type UUID.
     */
    diskExtId: string;
    /**
     * Size of the disk in Bytes
     */
    diskSizeBytes: number;
    /**
     * Indicates if the disk is undergoing migration to another container.
     */
    isMigrationInProgress: boolean;
    /**
     * Storage configuration for VM disks
     */
    storageConfigs: outputs.GetTemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageConfig[];
    /**
     * This reference is for disk level storage container preference. This preference specifies the storage container to which this disk belongs.
     */
    storageContainers: outputs.GetTemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageContainer[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSource {
    /**
     * Reference to image or vm disk
     */
    references: outputs.GetTemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReference[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReference {
    /**
     * Image Reference
     */
    imageReferences: outputs.GetTemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceImageReference[];
    /**
     * Vm Disk Reference
     */
    vmDiskReferences: outputs.GetTemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReference[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceImageReference {
    /**
     * The globally unique identifier of an image. It should be of type UUID.
     */
    imageExtId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReference {
    /**
     * Disk address.
     */
    diskAddresses: outputs.GetTemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddress[];
    /**
     * The globally unique identifier of a VM disk. It should be of type UUID.
     */
    diskExtId: string;
    /**
     * This is a reference to a VM.
     */
    vmReferences: outputs.GetTemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddress {
    /**
     * Bus type for the device. The acceptable values are: SCSI, IDE, PCI, SATA, SPAPR (only PPC).
     */
    busType: string;
    /**
     * Device index on the bus. This field is ignored unless the bus details are specified.
     */
    index: number;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReference {
    /**
     * The identifier of a Template.
     */
    extId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageConfig {
    /**
     * Indicates whether the virtual disk is pinned to the hot tier or not.
     */
    isFlashModeEnabled: boolean;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageContainer {
    /**
     * The identifier of a Template.
     */
    extId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecCdRomDiskAddress {
    /**
     * Bus type for the device. The acceptable values are: SCSI, IDE, PCI, SATA, SPAPR (only PPC).
     */
    busType: string;
    /**
     * Device index on the bus. This field is ignored unless the bus details are specified.
     */
    index: number;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecCdRomLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecCluster {
    /**
     * The identifier of a Template.
     */
    extId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecDisk {
    /**
     * Defines a NIC emulated by the hypervisor
     */
    backingInfos: outputs.GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfo[];
    /**
     * Virtual Machine disk (VM disk).
     */
    diskAddresses: outputs.GetTemplateV2TemplateVersionSpecVmSpecDiskDiskAddress[];
    /**
     * The identifier of a Template.
     */
    extId: string;
    /**
     * - A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetTemplateV2TemplateVersionSpecVmSpecDiskLink[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server).
     */
    tenantId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfo {
    /**
     * Volume Group Reference
     */
    adfsVolumeGroupReferences: outputs.GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfoAdfsVolumeGroupReference[];
    /**
     * backing Info for vmDisk
     */
    vmDisks: outputs.GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDisk[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfoAdfsVolumeGroupReference {
    /**
     * The globally unique identifier of an ADSF volume group. It should be of type UUID.
     */
    volumeGroupExtId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDisk {
    /**
     * A reference to a disk or image that contains the contents of a disk.
     */
    dataSources: outputs.GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSource[];
    /**
     * The globally unique identifier of a VM disk. It should be of type UUID.
     */
    diskExtId: string;
    /**
     * Size of the disk in Bytes
     */
    diskSizeBytes: number;
    /**
     * Indicates if the disk is undergoing migration to another container.
     */
    isMigrationInProgress: boolean;
    /**
     * Storage configuration for VM disks
     */
    storageConfigs: outputs.GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageConfig[];
    /**
     * This reference is for disk level storage container preference. This preference specifies the storage container to which this disk belongs.
     */
    storageContainers: outputs.GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageContainer[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSource {
    /**
     * Reference to image or vm disk
     */
    references: outputs.GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReference[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReference {
    /**
     * Image Reference
     */
    imageReferences: outputs.GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceImageReference[];
    /**
     * Vm Disk Reference
     */
    vmDiskReferences: outputs.GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReference[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceImageReference {
    /**
     * The globally unique identifier of an image. It should be of type UUID.
     */
    imageExtId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReference {
    /**
     * Disk address.
     */
    diskAddresses: outputs.GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddress[];
    /**
     * The globally unique identifier of a VM disk. It should be of type UUID.
     */
    diskExtId: string;
    /**
     * This is a reference to a VM.
     */
    vmReferences: outputs.GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddress {
    /**
     * Bus type for the device. The acceptable values are: SCSI, IDE, PCI, SATA, SPAPR (only PPC).
     */
    busType: string;
    /**
     * Device index on the bus. This field is ignored unless the bus details are specified.
     */
    index: number;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReference {
    /**
     * The identifier of a Template.
     */
    extId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageConfig {
    /**
     * Indicates whether the virtual disk is pinned to the hot tier or not.
     */
    isFlashModeEnabled: boolean;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageContainer {
    /**
     * The identifier of a Template.
     */
    extId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecDiskDiskAddress {
    /**
     * Bus type for the device. The acceptable values are: SCSI, IDE, PCI, SATA, SPAPR (only PPC).
     */
    busType: string;
    /**
     * Device index on the bus. This field is ignored unless the bus details are specified.
     */
    index: number;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecDiskLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecGpus {
    /**
     * The device Id of the GPU.
     */
    deviceId: number;
    /**
     * The identifier of a Template.
     */
    extId: string;
    /**
     * Fraction of the physical GPU assigned.
     */
    fraction: number;
    /**
     * GPU frame buffer size in bytes.
     */
    frameBufferSizeBytes: number;
    /**
     * Last determined guest driver version.
     */
    guestDriverVersion: string;
    /**
     * - A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetTemplateV2TemplateVersionSpecVmSpecGpusLink[];
    /**
     * The mode of this GPU.
     */
    mode: string;
    /**
     * Name of the GPU resource.
     */
    name: string;
    /**
     * Number of supported virtual display heads.
     */
    numVirtualDisplayHeads: number;
    /**
     * The (S)egment:(B)us:(D)evice.(F)unction hardware address. See
     */
    pciAddresses: outputs.GetTemplateV2TemplateVersionSpecVmSpecGpusPciAddress[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server).
     */
    tenantId: string;
    /**
     * The vendor of the GPU.
     */
    vendor: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecGpusLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecGpusPciAddress {
    bus: number;
    device: number;
    func: number;
    segment: number;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecGuestCustomization {
    /**
     * The Nutanix Guest Tools customization settings.
     */
    configs: outputs.GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfig[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfig {
    /**
     * CloudInit Config
     */
    cloudInits: outputs.GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInit[];
    /**
     * Sysprep config
     */
    syspreps: outputs.GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprep[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInit {
    /**
     * The script to use for cloud-init.
     */
    cloudInitScripts: outputs.GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScript[];
    /**
     * Type of datasource. Default: CONFIG_DRIVE_V2
     */
    datasourceType: string;
    /**
     * The contents of the metaData configuration for cloud-init. This can be formatted as YAML or JSON. The value must be base64 encoded.
     */
    metadata: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScript {
    customKeyValues: outputs.GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValue[];
    /**
     * user data object
     */
    userDatas: outputs.GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptUserData[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValue {
    keyValuePairs: outputs.GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePair[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePair {
    /**
     * Name of the GPU resource.
     */
    name: string;
    values: outputs.GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValue[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString {
    map: {[key: string]: string};
}

export interface GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptUserData {
    value: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprep {
    /**
     * Indicates whether the guest will be freshly installed using this unattend configuration, or this unattend configuration will be applied to a pre-prepared image. Default is 'PREPARED'.
     */
    installType: string;
    /**
     * Object either UnattendXml or CustomKeyValues
     */
    sysprepScripts: outputs.GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScript[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScript {
    /**
     * The list of the individual KeyValuePair elements.
     */
    customKeyValues: outputs.GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValue[];
    /**
     * xml object
     */
    unattendXmls: outputs.GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptUnattendXml[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValue {
    keyValuePairs: outputs.GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePair[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePair {
    /**
     * Name of the GPU resource.
     */
    name: string;
    values: outputs.GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValue[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfString {
    map: {[key: string]: string};
}

export interface GetTemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptUnattendXml {
    value: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecGuestTool {
    /**
     * Version of Nutanix Guest Tools available on the cluster.
     */
    availableVersion: string;
    /**
     * The list of the application names that are enabled on the guest VM.
     */
    capabilities: string[];
    /**
     * Version of the operating system on the VM
     */
    guestOsVersion: string;
    /**
     * Indicates whether Nutanix Guest Tools is enabled or not.
     */
    isEnabled: boolean;
    /**
     * Indicates whether Nutanix Guest Tools is installed on the VM or not.
     */
    isInstalled: boolean;
    /**
     * Indicates whether Nutanix Guest Tools ISO is inserted or not.
     */
    isIsoInserted: boolean;
    /**
     * Indicates whether the communication from VM to CVM is active or not.
     */
    isReachable: boolean;
    /**
     * Indicates whether the VM mobility drivers are installed on the VM or not.
     */
    isVmMobilityDriversInstalled: boolean;
    /**
     * Indicates whether the VM is configured to take VSS snapshots through NGT or not.
     */
    isVssSnapshotCapable: boolean;
    /**
     * Virtual trusted platform module version.
     */
    version: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecHost {
    /**
     * The identifier of a Template.
     */
    extId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecNic {
    /**
     * Defines a NIC emulated by the hypervisor
     */
    backingInfos: outputs.GetTemplateV2TemplateVersionSpecVmSpecNicBackingInfo[];
    /**
     * The identifier of a Template.
     */
    extId: string;
    /**
     * - A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetTemplateV2TemplateVersionSpecVmSpecNicLink[];
    /**
     * Network information for a NIC.
     */
    networkInfos: outputs.GetTemplateV2TemplateVersionSpecVmSpecNicNetworkInfo[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server).
     */
    tenantId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecNicBackingInfo {
    /**
     * Indicates whether the serial port is connected or not.
     */
    isConnected?: boolean;
    /**
     * MAC address of the emulated NIC.
     */
    macAddress: string;
    /**
     * Options for the NIC emulation.
     */
    model: string;
    /**
     * The number of Tx/Rx queue pairs for this NIC
     */
    numQueues?: number;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecNicLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecNicNetworkInfo {
    /**
     * The IP address configurations.
     */
    ipv4Configs: outputs.GetTemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4Config[];
    ipv4Infos: outputs.GetTemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4Info[];
    /**
     * The network function chain associates with the NIC. Only valid if nicType is NORMAL_NIC.
     */
    networkFunctionChains: outputs.GetTemplateV2TemplateVersionSpecVmSpecNicNetworkInfoNetworkFunctionChain[];
    /**
     * The type of this Network function NIC. Defaults to INGRESS.
     */
    networkFunctionNicType: string;
    /**
     * NIC type. Defaults to NORMAL_NIC.
     */
    nicType: string;
    /**
     * Indicates whether an unknown unicast traffic is forwarded to this NIC or not. This is applicable only for the NICs on the overlay subnets.
     */
    shouldAllowUnknownMacs: boolean;
    /**
     * Network identifier for this adapter. Only valid if nicType is NORMAL_NIC or DIRECT_NIC
     */
    subnets: outputs.GetTemplateV2TemplateVersionSpecVmSpecNicNetworkInfoSubnet[];
    /**
     * List of networks to trunk if VLAN mode is marked as TRUNKED. If empty and VLAN mode is set to TRUNKED, all the VLANs are trunked.
     */
    trunkedVlans: number[];
    /**
     * all the virtual NICs are created in ACCESS mode, which permits only one VLAN per virtual network. TRUNKED mode allows multiple VLANs on a single VM NIC for network-aware user VMs.
     */
    vlanMode: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4Config {
    ipAddresses: outputs.GetTemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigIpAddress[];
    secondaryIpAddressLists: outputs.GetTemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigSecondaryIpAddressList[];
    shouldAssignIp: boolean;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigIpAddress {
    prefixLength?: number;
    value: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigSecondaryIpAddressList {
    prefixLength?: number;
    value: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4Info {
    learnedIpAddresses: outputs.GetTemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoLearnedIpAddress[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoLearnedIpAddress {
    prefixLength?: number;
    value: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecNicNetworkInfoNetworkFunctionChain {
    /**
     * The identifier of a Template.
     */
    extId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecNicNetworkInfoSubnet {
    /**
     * The identifier of a Template.
     */
    extId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecOwnershipInfo {
    /**
     * Owner reference
     */
    owners: outputs.GetTemplateV2TemplateVersionSpecVmSpecOwnershipInfoOwner[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecOwnershipInfoOwner {
    /**
     * The identifier of a Template.
     */
    extId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecPciDevice {
    assignedDeviceInfos: outputs.GetTemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfo[];
    /**
     * Defines a NIC emulated by the hypervisor
     */
    backingInfos: outputs.GetTemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfo[];
    /**
     * The identifier of a Template.
     */
    extId: string;
    /**
     * - A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetTemplateV2TemplateVersionSpecVmSpecPciDeviceLink[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server).
     */
    tenantId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfo {
    devices: outputs.GetTemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoDevice[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoDevice {
    deviceExtId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfo {
    pcieDeviceReferences: outputs.GetTemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoPcieDeviceReference[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoPcieDeviceReference {
    deviceExtId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecPciDeviceLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecProtectionPolicyState {
    /**
     * Reference to the policy object in use.
     */
    policies: outputs.GetTemplateV2TemplateVersionSpecVmSpecProtectionPolicyStatePolicy[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecProtectionPolicyStatePolicy {
    /**
     * The identifier of a Template.
     */
    extId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecSerialPort {
    /**
     * The identifier of a Template.
     */
    extId: string;
    /**
     * Index of the serial port.
     */
    index: number;
    /**
     * Indicates whether the serial port is connected or not.
     */
    isConnected: boolean;
    /**
     * - A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetTemplateV2TemplateVersionSpecVmSpecSerialPortLink[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server).
     */
    tenantId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecSerialPortLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecSource {
    /**
     * Entity Type of source
     */
    entityType: string;
    /**
     * The identifier of a Template.
     */
    extId: string;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecStorageConfig {
    /**
     * Indicates whether the virtual disk is pinned to the hot tier or not.
     */
    isFlashModeEnabled: boolean;
    /**
     * QoS parameters to be enforced.
     */
    qosConfigs: outputs.GetTemplateV2TemplateVersionSpecVmSpecStorageConfigQosConfig[];
}

export interface GetTemplateV2TemplateVersionSpecVmSpecStorageConfigQosConfig {
    /**
     * Throttled IOPS for the governed entities. The block size for the I/O is 32 kB.
     */
    throttledIops: number;
}

export interface GetTemplateV2TemplateVersionSpecVmSpecVtpmConfig {
    /**
     * Indicates whether the virtual trusted platform module is enabled for the Guest OS or not.
     */
    isVtpmEnabled: boolean;
    /**
     * Virtual trusted platform module version.
     */
    version: string;
}

export interface GetTemplateV2UpdatedBy {
    /**
     * Any additional attribute for the User.
     */
    additionalAttributes: outputs.GetTemplateV2UpdatedByAdditionalAttribute[];
    creationType: string;
    /**
     * VM description
     */
    description: string;
    /**
     * Display name for the User.
     */
    displayName: string;
    /**
     * Email Id for the User.
     */
    emailId: string;
    /**
     * The identifier of a Template.
     */
    extId: string;
    /**
     * First name for the User.
     */
    firstName: string;
    /**
     * Identifier of the IDP for the User.
     */
    idpId: string;
    /**
     * Flag to force the User to reset password.
     */
    isForceResetPasswordEnabled: boolean;
    /**
     * Last name for the User.
     */
    lastName: string;
    /**
     * Default locale for the User.
     */
    locale: string;
    /**
     * Middle name for the User.
     */
    middleInitial: string;
    password: string;
    /**
     * Default Region for the User.
     */
    region: string;
    /**
     * Status of the User.
     */
    status: string;
    /**
     * Type of the User.
     */
    userType: string;
    /**
     * Identifier for the User in the form an email address.
     */
    username: string;
}

export interface GetTemplateV2UpdatedByAdditionalAttribute {
    /**
     * Name of the GPU resource.
     */
    name: string;
    values: outputs.GetTemplateV2UpdatedByAdditionalAttributeValue[];
}

export interface GetTemplateV2UpdatedByAdditionalAttributeValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.GetTemplateV2UpdatedByAdditionalAttributeValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface GetTemplateV2UpdatedByAdditionalAttributeValueMapOfString {
    map: {[key: string]: string};
}

export interface GetTemplatesV2Template {
    createTime: string;
    createdBies: outputs.GetTemplatesV2TemplateCreatedBy[];
    extId: string;
    guestUpdateStatuses: outputs.GetTemplatesV2TemplateGuestUpdateStatus[];
    links: outputs.GetTemplatesV2TemplateLink[];
    templateDescription: string;
    templateName: string;
    templateVersionSpecs: outputs.GetTemplatesV2TemplateTemplateVersionSpec[];
    tenantId: string;
    updateTime: string;
    updatedBies: outputs.GetTemplatesV2TemplateUpdatedBy[];
}

export interface GetTemplatesV2TemplateCreatedBy {
    additionalAttributes: outputs.GetTemplatesV2TemplateCreatedByAdditionalAttribute[];
    creationType: string;
    description: string;
    displayName: string;
    emailId: string;
    extId: string;
    firstName: string;
    idpId: string;
    isForceResetPasswordEnabled: boolean;
    lastName: string;
    locale: string;
    middleInitial: string;
    password: string;
    region: string;
    status: string;
    userType: string;
    username: string;
}

export interface GetTemplatesV2TemplateCreatedByAdditionalAttribute {
    name: string;
    values: outputs.GetTemplatesV2TemplateCreatedByAdditionalAttributeValue[];
}

export interface GetTemplatesV2TemplateCreatedByAdditionalAttributeValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.GetTemplatesV2TemplateCreatedByAdditionalAttributeValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface GetTemplatesV2TemplateCreatedByAdditionalAttributeValueMapOfString {
    map: {[key: string]: string};
}

export interface GetTemplatesV2TemplateGuestUpdateStatus {
    deployedVmReference: string;
}

export interface GetTemplatesV2TemplateLink {
    href: string;
    rel: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpec {
    createTime: string;
    createdBies: outputs.GetTemplatesV2TemplateTemplateVersionSpecCreatedBy[];
    extId: string;
    isActiveVersion: boolean;
    isGcOverrideEnabled: boolean;
    links: outputs.GetTemplatesV2TemplateTemplateVersionSpecLink[];
    tenantId: string;
    versionDescription: string;
    versionName: string;
    vmSpecs: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpec[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecCreatedBy {
    additionalAttributes: outputs.GetTemplatesV2TemplateTemplateVersionSpecCreatedByAdditionalAttribute[];
    creationType: string;
    description: string;
    displayName: string;
    emailId: string;
    extId: string;
    firstName: string;
    idpId: string;
    isForceResetPasswordEnabled: boolean;
    lastName: string;
    locale: string;
    middleInitial: string;
    password: string;
    region: string;
    status: string;
    userType: string;
    username: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecCreatedByAdditionalAttribute {
    name: string;
    values: outputs.GetTemplatesV2TemplateTemplateVersionSpecCreatedByAdditionalAttributeValue[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecCreatedByAdditionalAttributeValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.GetTemplatesV2TemplateTemplateVersionSpecCreatedByAdditionalAttributeValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecCreatedByAdditionalAttributeValueMapOfString {
    map: {[key: string]: string};
}

export interface GetTemplatesV2TemplateTemplateVersionSpecLink {
    href: string;
    rel: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpec {
    apcConfigs: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecApcConfig[];
    availabilityZones: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecAvailabilityZone[];
    biosUuid: string;
    bootConfigs: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfig[];
    categories: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecCategory[];
    cdRoms: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRom[];
    clusters: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecCluster[];
    createTime: string;
    description: string;
    disks: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecDisk[];
    enabledCpuFeatures: string[];
    extId: string;
    generationUuid: string;
    gpuses: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecGpus[];
    guestCustomizations: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomization[];
    guestTools: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestTool[];
    hardwareClockTimezone: string;
    hosts: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecHost[];
    isAgentVm: boolean;
    isBrandingEnabled: boolean;
    isCpuHotplugEnabled: boolean;
    isCpuPassthroughEnabled: boolean;
    isCrossClusterMigrationInProgress: boolean;
    isGpuConsoleEnabled: boolean;
    isLiveMigrateCapable: boolean;
    isMemoryOvercommitEnabled: boolean;
    isScsiControllerEnabled: boolean;
    isVcpuHardPinningEnabled: boolean;
    isVgaConsoleEnabled: boolean;
    links: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecLink[];
    machineType: string;
    memorySizeBytes: number;
    name: string;
    nics: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecNic[];
    numCoresPerSocket: number;
    numNumaNodes: number;
    numSockets: number;
    numThreadsPerCore: number;
    ownershipInfos: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecOwnershipInfo[];
    pciDevices: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecPciDevice[];
    powerState: string;
    protectionPolicyStates: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecProtectionPolicyState[];
    protectionType: string;
    serialPorts: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecSerialPort[];
    sources: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecSource[];
    storageConfigs: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecStorageConfig[];
    tenantId: string;
    updateTime: string;
    vtpmConfigs: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecVtpmConfig[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecApcConfig {
    cpuModels: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecApcConfigCpuModel[];
    isApcEnabled: boolean;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecApcConfigCpuModel {
    extId: string;
    name: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecAvailabilityZone {
    extId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfig {
    legacyBoots: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigLegacyBoot[];
    uefiBoots: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBoot[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigLegacyBoot {
    bootDevices: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigLegacyBootBootDevice[];
    bootOrders: string[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigLegacyBootBootDevice {
    bootDeviceDisks: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDisk[];
    bootDeviceNics: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceNic[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDisk {
    diskAddresses: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddress[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddress {
    busType: string;
    index: number;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceNic {
    macAddress: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBoot {
    bootDevices: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootBootDevice[];
    bootOrders: string[];
    isSecureBootEnabled: boolean;
    nvramDevices: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootNvramDevice[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootBootDevice {
    bootDeviceDisks: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDisk[];
    bootDeviceNics: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceNic[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDisk {
    diskAddresses: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskDiskAddress[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskDiskAddress {
    busType: string;
    index: number;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceNic {
    macAddress: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootNvramDevice {
    backingStorageInfos: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfo[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfo {
    dataSources: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSource[];
    diskExtId: string;
    diskSizeBytes: number;
    isMigrationInProgress: boolean;
    storageConfigs: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfig[];
    storageContainers: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainer[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSource {
    references: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReference[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReference {
    imageReferences: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReference[];
    vmDiskReferences: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReference[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReference {
    imageExtId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReference {
    diskAddresses: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddress[];
    diskExtId: string;
    vmReferences: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddress {
    busType: string;
    index: number;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReference {
    extId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfig {
    isFlashModeEnabled: boolean;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainer {
    extId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecCategory {
    extId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRom {
    backingInfos: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomBackingInfo[];
    diskAddresses: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomDiskAddress[];
    extId: string;
    isoType: string;
    links: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomLink[];
    tenantId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomBackingInfo {
    dataSources: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomBackingInfoDataSource[];
    diskExtId: string;
    diskSizeBytes: number;
    isMigrationInProgress: boolean;
    storageConfigs: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomBackingInfoStorageConfig[];
    storageContainers: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomBackingInfoStorageContainer[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomBackingInfoDataSource {
    references: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReference[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReference {
    imageReferences: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceImageReference[];
    vmDiskReferences: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReference[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceImageReference {
    imageExtId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReference {
    diskAddresses: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddress[];
    diskExtId: string;
    vmReferences: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddress {
    busType: string;
    index: number;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReference {
    extId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomBackingInfoStorageConfig {
    isFlashModeEnabled: boolean;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomBackingInfoStorageContainer {
    extId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomDiskAddress {
    busType: string;
    index: number;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecCdRomLink {
    href: string;
    rel: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecCluster {
    extId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecDisk {
    backingInfos: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfo[];
    diskAddresses: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskDiskAddress[];
    extId: string;
    links: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskLink[];
    tenantId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfo {
    adfsVolumeGroupReferences: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfoAdfsVolumeGroupReference[];
    vmDisks: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfoVmDisk[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfoAdfsVolumeGroupReference {
    volumeGroupExtId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfoVmDisk {
    dataSources: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSource[];
    diskExtId: string;
    diskSizeBytes: number;
    isMigrationInProgress: boolean;
    storageConfigs: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageConfig[];
    storageContainers: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageContainer[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSource {
    references: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReference[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReference {
    imageReferences: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceImageReference[];
    vmDiskReferences: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReference[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceImageReference {
    imageExtId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReference {
    diskAddresses: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddress[];
    diskExtId: string;
    vmReferences: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddress {
    busType: string;
    index: number;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReference {
    extId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageConfig {
    isFlashModeEnabled: boolean;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageContainer {
    extId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskDiskAddress {
    busType: string;
    index: number;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecDiskLink {
    href: string;
    rel: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecGpus {
    deviceId: number;
    extId: string;
    fraction: number;
    frameBufferSizeBytes: number;
    guestDriverVersion: string;
    links: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecGpusLink[];
    mode: string;
    name: string;
    numVirtualDisplayHeads: number;
    pciAddresses: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecGpusPciAddress[];
    tenantId: string;
    vendor: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecGpusLink {
    href: string;
    rel: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecGpusPciAddress {
    bus: number;
    device: number;
    func: number;
    segment: number;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomization {
    configs: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfig[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfig {
    cloudInits: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigCloudInit[];
    syspreps: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigSysprep[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigCloudInit {
    cloudInitScripts: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScript[];
    datasourceType: string;
    metadata: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScript {
    customKeyValues: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValue[];
    userDatas: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptUserData[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValue {
    keyValuePairs: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePair[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePair {
    name: string;
    values: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValue[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString {
    map: {[key: string]: string};
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptUserData {
    value: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigSysprep {
    installType: string;
    sysprepScripts: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScript[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScript {
    customKeyValues: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValue[];
    unattendXmls: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptUnattendXml[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValue {
    keyValuePairs: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePair[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePair {
    name: string;
    values: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValue[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfString {
    map: {[key: string]: string};
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptUnattendXml {
    value: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecGuestTool {
    availableVersion: string;
    capabilities: string[];
    guestOsVersion: string;
    isEnabled: boolean;
    isInstalled: boolean;
    isIsoInserted: boolean;
    isReachable: boolean;
    isVmMobilityDriversInstalled: boolean;
    isVssSnapshotCapable: boolean;
    version: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecHost {
    extId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecLink {
    href: string;
    rel: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecNic {
    backingInfos: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecNicBackingInfo[];
    extId: string;
    links: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecNicLink[];
    networkInfos: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecNicNetworkInfo[];
    tenantId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecNicBackingInfo {
    isConnected?: boolean;
    macAddress: string;
    model: string;
    numQueues?: number;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecNicLink {
    href: string;
    rel: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecNicNetworkInfo {
    ipv4Configs: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecNicNetworkInfoIpv4Config[];
    ipv4Infos: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecNicNetworkInfoIpv4Info[];
    networkFunctionChains: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecNicNetworkInfoNetworkFunctionChain[];
    networkFunctionNicType: string;
    nicType: string;
    shouldAllowUnknownMacs: boolean;
    subnets: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecNicNetworkInfoSubnet[];
    trunkedVlans: number[];
    vlanMode: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecNicNetworkInfoIpv4Config {
    ipAddresses: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigIpAddress[];
    secondaryIpAddressLists: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigSecondaryIpAddressList[];
    shouldAssignIp: boolean;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigIpAddress {
    prefixLength?: number;
    value: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigSecondaryIpAddressList {
    prefixLength?: number;
    value: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecNicNetworkInfoIpv4Info {
    learnedIpAddresses: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoLearnedIpAddress[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoLearnedIpAddress {
    prefixLength?: number;
    value: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecNicNetworkInfoNetworkFunctionChain {
    extId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecNicNetworkInfoSubnet {
    extId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecOwnershipInfo {
    owners: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecOwnershipInfoOwner[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecOwnershipInfoOwner {
    extId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecPciDevice {
    assignedDeviceInfos: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfo[];
    backingInfos: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecPciDeviceBackingInfo[];
    extId: string;
    links: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecPciDeviceLink[];
    tenantId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfo {
    devices: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoDevice[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoDevice {
    deviceExtId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecPciDeviceBackingInfo {
    pcieDeviceReferences: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecPciDeviceBackingInfoPcieDeviceReference[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecPciDeviceBackingInfoPcieDeviceReference {
    deviceExtId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecPciDeviceLink {
    href: string;
    rel: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecProtectionPolicyState {
    policies: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecProtectionPolicyStatePolicy[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecProtectionPolicyStatePolicy {
    extId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecSerialPort {
    extId: string;
    index: number;
    isConnected: boolean;
    links: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecSerialPortLink[];
    tenantId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecSerialPortLink {
    href: string;
    rel: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecSource {
    entityType: string;
    extId: string;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecStorageConfig {
    isFlashModeEnabled: boolean;
    qosConfigs: outputs.GetTemplatesV2TemplateTemplateVersionSpecVmSpecStorageConfigQosConfig[];
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecStorageConfigQosConfig {
    throttledIops: number;
}

export interface GetTemplatesV2TemplateTemplateVersionSpecVmSpecVtpmConfig {
    isVtpmEnabled: boolean;
    version: string;
}

export interface GetTemplatesV2TemplateUpdatedBy {
    additionalAttributes: outputs.GetTemplatesV2TemplateUpdatedByAdditionalAttribute[];
    creationType: string;
    description: string;
    displayName: string;
    emailId: string;
    extId: string;
    firstName: string;
    idpId: string;
    isForceResetPasswordEnabled: boolean;
    lastName: string;
    locale: string;
    middleInitial: string;
    password: string;
    region: string;
    status: string;
    userType: string;
    username: string;
}

export interface GetTemplatesV2TemplateUpdatedByAdditionalAttribute {
    name: string;
    values: outputs.GetTemplatesV2TemplateUpdatedByAdditionalAttributeValue[];
}

export interface GetTemplatesV2TemplateUpdatedByAdditionalAttributeValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.GetTemplatesV2TemplateUpdatedByAdditionalAttributeValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface GetTemplatesV2TemplateUpdatedByAdditionalAttributeValueMapOfString {
    map: {[key: string]: string};
}

export interface GetUserAccessControlPolicyReferenceList {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - (Optional) The name for the user
     */
    name: string;
    /**
     * - (Optional) The UUID for the user.
     */
    uuid: string;
}

export interface GetUserCategory {
    /**
     * - (Optional) The name for the user
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetUserDirectoryServiceUser {
    defaultUserPrincipalName: string;
    /**
     * - (Optional) The reference to a directory service. See #reference for to look the supported attributes.
     */
    directoryServiceReferences: outputs.GetUserDirectoryServiceUserDirectoryServiceReference[];
    /**
     * - (Optional) The UserPrincipalName of the user from the directory service.
     */
    userPrincipalName: string;
}

export interface GetUserDirectoryServiceUserDirectoryServiceReference {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - (Optional) The name for the user
     */
    name: string;
    /**
     * - (Optional) The UUID for the user.
     */
    uuid: string;
}

export interface GetUserGroupAccessControlPolicyReferenceList {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetUserGroupCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetUserGroupDirectoryServiceUserGroup {
    defaultUserPrincipalName: string;
    /**
     * - The reference to a directory service. See #reference for to look the supported attributes.
     */
    directoryServiceReferences: outputs.GetUserGroupDirectoryServiceUserGroupDirectoryServiceReference[];
    /**
     * - The Distinguished name for the user group
     */
    distinguishedName: string;
}

export interface GetUserGroupDirectoryServiceUserGroupDirectoryServiceReference {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetUserGroupProjectReferenceList {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetUserGroupsEntity {
    /**
     * - List of ACP references. See #reference for more details.
     */
    accessControlPolicyReferenceLists: outputs.GetUserGroupsEntityAccessControlPolicyReferenceList[];
    /**
     * The version of the API.
     */
    apiVersion: string;
    /**
     * - The Categories for the user group.
     */
    categories: outputs.GetUserGroupsEntityCategory[];
    /**
     * - A Directory Service User Group.
     */
    directoryServiceUserGroups: outputs.GetUserGroupsEntityDirectoryServiceUserGroup[];
    /**
     * - The display name of the user group.
     */
    displayName: string;
    /**
     * - The user group kind metadata.
     */
    metadata: {[key: string]: string};
    /**
     * - The reference to a user.
     */
    ownerReference: {[key: string]: string};
    /**
     * - The reference to a project.
     */
    projectReference?: {[key: string]: string};
    /**
     * - A list of projects the user is part of. See #reference for more details.
     */
    projectReferenceLists: outputs.GetUserGroupsEntityProjectReferenceList[];
    /**
     * - The state of the entity.
     */
    state: string;
    /**
     * - The type of the user group.
     */
    userGroupType: string;
}

export interface GetUserGroupsEntityAccessControlPolicyReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetUserGroupsEntityCategory {
    /**
     * - the key name.
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetUserGroupsEntityDirectoryServiceUserGroup {
    defaultUserPrincipalName: string;
    /**
     * - The reference to a directory service. See #reference for to look the supported attributes.
     */
    directoryServiceReferences: outputs.GetUserGroupsEntityDirectoryServiceUserGroupDirectoryServiceReference[];
    /**
     * - The Distinguished name for the user group
     */
    distinguishedName: string;
}

export interface GetUserGroupsEntityDirectoryServiceUserGroupDirectoryServiceReference {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     *
     * For `accessControlPolicyReferenceList` and `projectReferenceList` are the same as reference but used as list.
     *
     * See detailed information in [Nutanix Users](https://www.nutanix.dev/api_references/prism-central-v3/#/6016c890e9122-get-a-list-of-existing-user-groups).
     */
    uuid: string;
}

export interface GetUserGroupsEntityProjectReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetUserGroupsMetadata {
    filter: string;
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetUserGroupsV2UserGroup {
    /**
     * - User or Service who created the User Group.
     */
    createdBy: string;
    /**
     * - Creation time of the User Group.
     */
    createdTime: string;
    /**
     * - Identifier for the User Group in the form of a distinguished name.
     */
    distinguishedName: string;
    /**
     * The External Identifier of the User Group.
     */
    extId: string;
    /**
     * - Type of the User Group. LDAP (User Group belonging to a Directory Service (Open LDAP/AD)),  SAML (User Group belonging to a SAML IDP.)
     */
    groupType: string;
    /**
     * - Identifier of the IDP for the User Group.
     */
    idpId: string;
    /**
     * - Last updated time of the User Group.
     */
    lastUpdatedTime: string;
    /**
     * - Common Name of the User Group.
     */
    name: string;
}

export interface GetUserIdentityProviderUser {
    /**
     * - (Optional) The reference to a identity provider. See #reference for to look the supported attributes.
     */
    identityProviderReferences: outputs.GetUserIdentityProviderUserIdentityProviderReference[];
    /**
     * - (Optional) The username from identity provider. Name ID for SAML Identity Provider.
     */
    username: string;
}

export interface GetUserIdentityProviderUserIdentityProviderReference {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - (Optional) The name for the user
     */
    name: string;
    /**
     * - (Optional) The UUID for the user.
     */
    uuid: string;
}

export interface GetUserProjectReferenceList {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - (Optional) The name for the user
     */
    name: string;
    /**
     * - (Optional) The UUID for the user.
     */
    uuid: string;
}

export interface GetUserV2AdditionalAttribute {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    name: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    value: number;
}

export interface GetUserV2BucketsAccessKey {
    /**
     * - Name of the Bucket Access Key.
     */
    accessKeyName: string;
    /**
     * - Creation time for the Bucket Access Key.
     */
    createdTime: string;
    /**
     * - A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    /**
     * - A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetUserV2BucketsAccessKeyLink[];
    /**
     * - Secret Access Key, it will be returned only during Bucket Access Key creation.
     */
    secretAccessKey: string;
    /**
     * - User Identifier who owns the Bucket Access Key.
     */
    userId: string;
}

export interface GetUserV2BucketsAccessKeyLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetUserV2Link {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetUsersEntity {
    /**
     * - List of ACP references. See #reference for more details.
     */
    accessControlPolicyReferenceLists: outputs.GetUsersEntityAccessControlPolicyReferenceList[];
    /**
     * The version of the API.
     */
    apiVersion: string;
    /**
     * - (Optional) Categories for the user.
     */
    categories: outputs.GetUsersEntityCategory[];
    /**
     * - (Optional) The directory service user configuration. See below for more information.
     */
    directoryServiceUsers: outputs.GetUsersEntityDirectoryServiceUser[];
    /**
     * - The display name of the user (common name) provided by the directory service.
     */
    displayName: string;
    /**
     * - (Optional) (Optional) The identity provider user configuration. See below for more information.
     */
    identityProviderUsers: outputs.GetUsersEntityIdentityProviderUser[];
    /**
     * - The user kind metadata.
     */
    metadata: {[key: string]: string};
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - (Optional) The reference to a user.
     */
    ownerReference: {[key: string]: string};
    /**
     * - (Optional) The reference to a project.
     */
    projectReference?: {[key: string]: string};
    /**
     * - A list of projects the user is part of. See #reference for more details.
     */
    projectReferenceLists: outputs.GetUsersEntityProjectReferenceList[];
    /**
     * - The state of the entity.
     */
    state: string;
    /**
     * - The name of the user.
     */
    userType: string;
}

export interface GetUsersEntityAccessControlPolicyReferenceList {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetUsersEntityCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetUsersEntityDirectoryServiceUser {
    defaultUserPrincipalName: string;
    /**
     * - (Optional) The reference to a directory service. See #reference for to look the supported attributes.
     */
    directoryServiceReferences: outputs.GetUsersEntityDirectoryServiceUserDirectoryServiceReference[];
    /**
     * - (Optional) The UserPrincipalName of the user from the directory service.
     */
    userPrincipalName: string;
}

export interface GetUsersEntityDirectoryServiceUserDirectoryServiceReference {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetUsersEntityIdentityProviderUser {
    /**
     * - (Optional) The reference to a identity provider. See #reference for to look the supported attributes.
     */
    identityProviderReferences: outputs.GetUsersEntityIdentityProviderUserIdentityProviderReference[];
    /**
     * - (Optional) The username from identity provider. Name ID for SAML Identity Provider.
     */
    username: string;
}

export interface GetUsersEntityIdentityProviderUserIdentityProviderReference {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetUsersEntityProjectReferenceList {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface GetUsersMetadata {
    filter: string;
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetUsersV2User {
    /**
     * -  Any additional attribute for the User.
     */
    additionalAttributes: outputs.GetUsersV2UserAdditionalAttribute[];
    /**
     * - Bucket Access Keys for the User.
     */
    bucketsAccessKeys: outputs.GetUsersV2UserBucketsAccessKey[];
    /**
     * - User or Service who created the User.
     */
    createdBy: string;
    /**
     * - Creation time for the Bucket Access Key.
     */
    createdTime: string;
    /**
     * - Display name for the User.
     */
    displayName: string;
    /**
     * - Email Id for the User.
     */
    emailId: string;
    /**
     * - A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    /**
     * - First name for the User.
     */
    firstName: string;
    /**
     * - Identifier of the IDP for the User.
     */
    idpId: string;
    /**
     * - Flag to force the User to reset password.
     */
    isForceResetPassword: boolean;
    /**
     * - Last successful logged in time for the User.
     */
    lastLoginTime: string;
    /**
     * - Last name for the User.
     */
    lastName: string;
    /**
     * - Last updated by this User ID.
     */
    lastUpdatedBy: string;
    /**
     * - Last updated time of the User.
     */
    lastUpdatedTime: string;
    /**
     * - A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetUsersV2UserLink[];
    /**
     * - Default locale for the User.
     */
    locale: string;
    /**
     * - Middle name for the User.
     */
    middleInitial: string;
    /**
     * - Default Region for the User.
     */
    region: string;
    /**
     * - Status of the User. `ACTIVE`: Denotes that the local User is active. `INACTIVE`: Denotes that the local User is inactive and needs to be reactivated.
     */
    status: string;
    /**
     * - A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server).
     */
    tenantId: string;
    /**
     * - Enum: `$UNKNOWN` `$REDACTED` `LOCAL` `SAML` `LDAP` `EXTERNAL`
     * Type of the User.
     */
    userType: string;
    /**
     * - Identifier for the User in the form an email address.
     */
    username: string;
}

export interface GetUsersV2UserAdditionalAttribute {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    name: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    value: number;
}

export interface GetUsersV2UserBucketsAccessKey {
    /**
     * - Name of the Bucket Access Key.
     */
    accessKeyName: string;
    /**
     * - Creation time for the Bucket Access Key.
     */
    createdTime: string;
    /**
     * - A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    /**
     * - A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetUsersV2UserBucketsAccessKeyLink[];
    /**
     * - Secret Access Key, it will be returned only during Bucket Access Key creation.
     */
    secretAccessKey: string;
    /**
     * - User Identifier who owns the Bucket Access Key.
     */
    userId: string;
}

export interface GetUsersV2UserBucketsAccessKeyLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetUsersV2UserLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetVirtualMachineCategory {
    /**
     * - the name.
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface GetVirtualMachineDiskList {
    /**
     * Reference to a data source.
     */
    dataSourceReference: {[key: string]: string};
    /**
     * Properties to a device.
     */
    deviceProperties: outputs.GetVirtualMachineDiskListDeviceProperty[];
    /**
     * Size of the disk in Bytes.
     */
    diskSizeBytes: number;
    /**
     * Size of the disk in MiB. Must match the size specified in 'disk_size_bytes' - rounded up to the nearest MiB - when that field is present.
     */
    diskSizeMib: number;
    storageConfigs: outputs.GetVirtualMachineDiskListStorageConfig[];
    /**
     * - the UUID.
     */
    uuid: string;
    /**
     * Reference to a volume group.
     */
    volumeGroupReference: {[key: string]: string};
}

export interface GetVirtualMachineDiskListDeviceProperty {
    /**
     * - A Disk type (default: DISK).
     */
    deviceType: string;
    /**
     * - Address of disk to boot from.
     */
    diskAddress: {[key: string]: string};
}

export interface GetVirtualMachineDiskListStorageConfig {
    /**
     * - State of the storage policy to pin virtual disks to the hot tier. When specified as a VM attribute, the storage policy applies to all virtual disks of the VM unless overridden by the same attribute specified for a virtual disk.
     */
    flashMode: string;
    /**
     * - Reference to a kind. Either one of (kind, uuid) or url needs to be specified.
     * * `storage_container_reference.#.url`: - GET query on the URL will provide information on the source.
     * * `storage_container_reference.#.kind`: - kind of the container reference
     * * `storage_container_reference.#.name`: - name of the container reference
     * * `storage_container_reference.#.uuid`: - uiid of the container reference
     */
    storageContainerReferences: outputs.GetVirtualMachineDiskListStorageConfigStorageContainerReference[];
}

export interface GetVirtualMachineDiskListStorageConfigStorageContainerReference {
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    /**
     * - the name.
     */
    name: string;
    url: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetVirtualMachineGpuList {
    /**
     * - (Computed) The device ID of the GPU.
     */
    deviceId: number;
    /**
     * Fraction of the physical GPU assigned.
     */
    fraction: number;
    /**
     * - GPU frame buffer size in MiB.
     */
    frameBufferSizeMib: number;
    /**
     * - Last determined guest driver version.
     */
    guestDriverVersion: string;
    /**
     * - The mode of this GPU.
     */
    mode: string;
    /**
     * - the name.
     */
    name: string;
    /**
     * - Number of supported virtual display heads.
     */
    numVirtualDisplayHeads: number;
    /**
     * GPU {segment:bus:device:function} (sbdf) address if assigned.
     */
    pciAddress: string;
    /**
     * - the UUID.
     */
    uuid: string;
    /**
     * - The vendor of the GPU.
     * * `UUID`: - UUID of the GPU.
     */
    vendor: string;
}

export interface GetVirtualMachineMessageList {
    details: {[key: string]: string};
    message: string;
    reason: string;
}

export interface GetVirtualMachineNicList {
    /**
     * -  The Floating IP associated with the vnic.
     */
    floatingIp: string;
    /**
     * - IP endpoints for the adapter. Currently, IPv4 addresses are supported.
     */
    ipEndpointLists: outputs.GetVirtualMachineNicListIpEndpointList[];
    /**
     * - Indicates whether the serial port connection is connected or not (`true` or `false`).
     */
    isConnected: string;
    /**
     * - The MAC address for the adapter.
     */
    macAddress: string;
    /**
     * - The model of this NIC. (Options : VIRTIO , E1000).
     */
    model: string;
    /**
     * - The reference to a network_function_chain.
     */
    networkFunctionChainReference: {[key: string]: string};
    /**
     * - The type of this Network function NIC. Defaults to INGRESS. (Options : INGRESS , EGRESS , TAP).
     */
    networkFunctionNicType: string;
    /**
     * - The type of this NIC. Defaults to NORMAL_NIC. (Options : NORMAL_NIC , DIRECT_NIC , NETWORK_FUNCTION_NIC).
     */
    nicType: string;
    /**
     * - The number of tx/rx queue pairs for this NIC.
     */
    numQueues: number;
    /**
     * - The name of the subnet reference to.
     */
    subnetName: string;
    /**
     * - The reference to a subnet.
     */
    subnetUuid: string;
    /**
     * - the UUID.
     */
    uuid: string;
}

export interface GetVirtualMachineNicListIpEndpointList {
    /**
     * - Address string.
     */
    ip: string;
    /**
     * - Address type. It can only be "ASSIGNED" in the spec. If no type is specified in the spec, the default type is set to "ASSIGNED". (Options : ASSIGNED , LEARNED)
     */
    type: string;
}

export interface GetVirtualMachineSerialPortList {
    /**
     * - Index of the serial port (int).
     */
    index: number;
    /**
     * - Indicates whether the serial port connection is connected or not (`true` or `false`).
     */
    isConnected: boolean;
}

export interface GetVirtualMachineV2ApcConfig {
    /**
     * CPU model associated with the VM if Advanced Processor Compatibility(APC) is enabled. If APC is enabled and no CPU model is explicitly set, a default baseline CPU model is picked by the system. See the APC documentation for more information
     */
    cpuModels: outputs.GetVirtualMachineV2ApcConfigCpuModel[];
    /**
     * If enabled, the selected CPU model will be retained across live and cold migrations of the VM.
     */
    isApcEnabled: boolean;
}

export interface GetVirtualMachineV2ApcConfigCpuModel {
    /**
     * Represents virtual machine UUID
     */
    extId: string;
    /**
     * Name of the CPU model associated with the VM.
     */
    name: string;
}

export interface GetVirtualMachineV2AvailabilityZone {
    /**
     * Represents virtual machine UUID
     */
    extId: string;
}

export interface GetVirtualMachineV2BootConfig {
    /**
     * LegacyBoot config Object
     */
    legacyBoots: outputs.GetVirtualMachineV2BootConfigLegacyBoot[];
    /**
     * UefiBoot config Object
     */
    uefiBoots: outputs.GetVirtualMachineV2BootConfigUefiBoot[];
}

export interface GetVirtualMachineV2BootConfigLegacyBoot {
    /**
     * Boot Device object
     */
    bootDevices: outputs.GetVirtualMachineV2BootConfigLegacyBootBootDevice[];
    /**
     * Indicates the order of device types in which the VM should try to boot from. If the boot device order is not provided the system will decide an appropriate boot device order.
     */
    bootOrders: string[];
}

export interface GetVirtualMachineV2BootConfigLegacyBootBootDevice {
    /**
     * Disk address.
     */
    bootDeviceDisks: outputs.GetVirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDisk[];
    /**
     * Disk Nic address.
     */
    bootDeviceNics: outputs.GetVirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceNic[];
}

export interface GetVirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDisk {
    /**
     * Virtual Machine disk (VM disk).
     */
    diskAddresses: outputs.GetVirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddress[];
}

export interface GetVirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddress {
    /**
     * Bus type for the device
     */
    busType: string;
    /**
     * Device index on the bus. This field is ignored unless the bus details are specified.
     */
    index: number;
}

export interface GetVirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceNic {
    /**
     * mac address
     */
    macAddress: string;
}

export interface GetVirtualMachineV2BootConfigUefiBoot {
    /**
     * Boot Device object
     */
    bootDevices: outputs.GetVirtualMachineV2BootConfigUefiBootBootDevice[];
    /**
     * Indicates the order of device types in which the VM should try to boot from. If the boot device order is not provided the system will decide an appropriate boot device order.
     */
    bootOrders: string[];
    /**
     * Indicate whether to enable secure boot or not
     */
    isSecureBootEnabled: boolean;
    /**
     * Configuration for NVRAM to be presented to the VM.
     */
    nvramDevices: outputs.GetVirtualMachineV2BootConfigUefiBootNvramDevice[];
}

export interface GetVirtualMachineV2BootConfigUefiBootBootDevice {
    /**
     * Disk address.
     */
    bootDeviceDisks: outputs.GetVirtualMachineV2BootConfigUefiBootBootDeviceBootDeviceDisk[];
    /**
     * Disk Nic address.
     */
    bootDeviceNics: outputs.GetVirtualMachineV2BootConfigUefiBootBootDeviceBootDeviceNic[];
}

export interface GetVirtualMachineV2BootConfigUefiBootBootDeviceBootDeviceDisk {
    /**
     * Virtual Machine disk (VM disk).
     */
    diskAddresses: outputs.GetVirtualMachineV2BootConfigUefiBootBootDeviceBootDeviceDiskDiskAddress[];
}

export interface GetVirtualMachineV2BootConfigUefiBootBootDeviceBootDeviceDiskDiskAddress {
    /**
     * Bus type for the device
     */
    busType: string;
    /**
     * Device index on the bus. This field is ignored unless the bus details are specified.
     */
    index: number;
}

export interface GetVirtualMachineV2BootConfigUefiBootBootDeviceBootDeviceNic {
    /**
     * mac address
     */
    macAddress: string;
}

export interface GetVirtualMachineV2BootConfigUefiBootNvramDevice {
    /**
     * Storage provided by Nutanix ADSF
     */
    backingStorageInfos: outputs.GetVirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfo[];
}

export interface GetVirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfo {
    /**
     * A reference to a disk or image that contains the contents of a disk.
     */
    dataSources: outputs.GetVirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSource[];
    /**
     * The globally unique identifier of a VM disk. It should be of type UUID.
     */
    diskExtId: string;
    /**
     * Size of the disk in Bytes
     */
    diskSizeBytes: number;
    /**
     * Indicates if the disk is undergoing migration to another container.
     */
    isMigrationInProgress: boolean;
    /**
     * Storage configuration for VM disks
     */
    storageConfigs: outputs.GetVirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfig[];
    /**
     * This reference is for disk level storage container preference. This preference specifies the storage container to which this disk belongs.
     */
    storageContainers: outputs.GetVirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainer[];
}

export interface GetVirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSource {
    /**
     * Reference to image or vm disk
     */
    references: outputs.GetVirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReference[];
}

export interface GetVirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReference {
    /**
     * Image Reference
     */
    imageReferences: outputs.GetVirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReference[];
    /**
     * Vm Disk Reference
     */
    vmDiskReferences: outputs.GetVirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReference[];
}

export interface GetVirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReference {
    /**
     * The globally unique identifier of an image. It should be of type UUID.
     */
    imageExtId: string;
}

export interface GetVirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReference {
    /**
     * Disk address.
     */
    diskAddresses: outputs.GetVirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddress[];
    /**
     * The globally unique identifier of a VM disk. It should be of type UUID.
     */
    diskExtId: string;
    /**
     * This is a reference to a VM.
     */
    vmReferences: outputs.GetVirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface GetVirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddress {
    /**
     * Bus type for the device. The acceptable values are: SCSI, IDE, PCI, SATA, SPAPR (only PPC).
     */
    busType: string;
    /**
     * Device index on the bus. This field is ignored unless the bus details are specified.
     */
    index: number;
}

export interface GetVirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReference {
    /**
     * Represents virtual machine UUID
     */
    extId: string;
}

export interface GetVirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfig {
    /**
     * Indicates whether the virtual disk is pinned to the hot tier or not.
     */
    isFlashModeEnabled: boolean;
}

export interface GetVirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainer {
    /**
     * Represents virtual machine UUID
     */
    extId: string;
}

export interface GetVirtualMachineV2Category {
    /**
     * Represents virtual machine UUID
     */
    extId: string;
}

export interface GetVirtualMachineV2CdRom {
    /**
     * Defines a NIC emulated by the hypervisor
     */
    backingInfos: outputs.GetVirtualMachineV2CdRomBackingInfo[];
    /**
     * Virtual Machine disk (VM disk).
     */
    diskAddresses: outputs.GetVirtualMachineV2CdRomDiskAddress[];
    /**
     * Represents virtual machine UUID
     */
    extId: string;
    /**
     * Type of ISO image inserted in CD-ROM
     */
    isoType: string;
}

export interface GetVirtualMachineV2CdRomBackingInfo {
    /**
     * A reference to a disk or image that contains the contents of a disk.
     */
    dataSources: outputs.GetVirtualMachineV2CdRomBackingInfoDataSource[];
    /**
     * The globally unique identifier of a VM disk. It should be of type UUID.
     */
    diskExtId: string;
    /**
     * Size of the disk in Bytes
     */
    diskSizeBytes: number;
    /**
     * Indicates if the disk is undergoing migration to another container.
     */
    isMigrationInProgress: boolean;
    /**
     * Storage configuration for VM disks
     */
    storageConfigs: outputs.GetVirtualMachineV2CdRomBackingInfoStorageConfig[];
    /**
     * This reference is for disk level storage container preference. This preference specifies the storage container to which this disk belongs.
     */
    storageContainers: outputs.GetVirtualMachineV2CdRomBackingInfoStorageContainer[];
}

export interface GetVirtualMachineV2CdRomBackingInfoDataSource {
    /**
     * Reference to image or vm disk
     */
    references: outputs.GetVirtualMachineV2CdRomBackingInfoDataSourceReference[];
}

export interface GetVirtualMachineV2CdRomBackingInfoDataSourceReference {
    /**
     * Image Reference
     */
    imageReferences: outputs.GetVirtualMachineV2CdRomBackingInfoDataSourceReferenceImageReference[];
    /**
     * Vm Disk Reference
     */
    vmDiskReferences: outputs.GetVirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReference[];
}

export interface GetVirtualMachineV2CdRomBackingInfoDataSourceReferenceImageReference {
    /**
     * The globally unique identifier of an image. It should be of type UUID.
     */
    imageExtId: string;
}

export interface GetVirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReference {
    /**
     * Disk address.
     */
    diskAddresses: outputs.GetVirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddress[];
    /**
     * The globally unique identifier of a VM disk. It should be of type UUID.
     */
    diskExtId: string;
    /**
     * This is a reference to a VM.
     */
    vmReferences: outputs.GetVirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface GetVirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddress {
    /**
     * Bus type for the device. The acceptable values are: SCSI, IDE, PCI, SATA, SPAPR (only PPC).
     */
    busType: string;
    /**
     * Device index on the bus. This field is ignored unless the bus details are specified.
     */
    index: number;
}

export interface GetVirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReference {
    /**
     * Represents virtual machine UUID
     */
    extId: string;
}

export interface GetVirtualMachineV2CdRomBackingInfoStorageConfig {
    /**
     * Indicates whether the virtual disk is pinned to the hot tier or not.
     */
    isFlashModeEnabled: boolean;
}

export interface GetVirtualMachineV2CdRomBackingInfoStorageContainer {
    /**
     * Represents virtual machine UUID
     */
    extId: string;
}

export interface GetVirtualMachineV2CdRomDiskAddress {
    /**
     * Bus type for the device. The acceptable values are: SCSI, IDE, PCI, SATA, SPAPR (only PPC).
     */
    busType: string;
    /**
     * Device index on the bus. This field is ignored unless the bus details are specified.
     */
    index: number;
}

export interface GetVirtualMachineV2Cluster {
    /**
     * Represents virtual machine UUID
     */
    extId: string;
}

export interface GetVirtualMachineV2Disk {
    /**
     * Defines a NIC emulated by the hypervisor
     */
    backingInfos: outputs.GetVirtualMachineV2DiskBackingInfo[];
    /**
     * Virtual Machine disk (VM disk).
     */
    diskAddresses: outputs.GetVirtualMachineV2DiskDiskAddress[];
    /**
     * Represents virtual machine UUID
     */
    extId: string;
}

export interface GetVirtualMachineV2DiskBackingInfo {
    /**
     * Volume Group Reference
     */
    adfsVolumeGroupReferences: outputs.GetVirtualMachineV2DiskBackingInfoAdfsVolumeGroupReference[];
    /**
     * backing Info for vmDisk
     */
    vmDisks: outputs.GetVirtualMachineV2DiskBackingInfoVmDisk[];
}

export interface GetVirtualMachineV2DiskBackingInfoAdfsVolumeGroupReference {
    /**
     * The globally unique identifier of an ADSF volume group. It should be of type UUID.
     */
    volumeGroupExtId: string;
}

export interface GetVirtualMachineV2DiskBackingInfoVmDisk {
    /**
     * A reference to a disk or image that contains the contents of a disk.
     */
    dataSources: outputs.GetVirtualMachineV2DiskBackingInfoVmDiskDataSource[];
    /**
     * The globally unique identifier of a VM disk. It should be of type UUID.
     */
    diskExtId: string;
    /**
     * Size of the disk in Bytes
     */
    diskSizeBytes: number;
    /**
     * Indicates if the disk is undergoing migration to another container.
     */
    isMigrationInProgress: boolean;
    /**
     * Storage configuration for VM disks
     */
    storageConfigs: outputs.GetVirtualMachineV2DiskBackingInfoVmDiskStorageConfig[];
    /**
     * This reference is for disk level storage container preference. This preference specifies the storage container to which this disk belongs.
     */
    storageContainers: outputs.GetVirtualMachineV2DiskBackingInfoVmDiskStorageContainer[];
}

export interface GetVirtualMachineV2DiskBackingInfoVmDiskDataSource {
    /**
     * Reference to image or vm disk
     */
    references: outputs.GetVirtualMachineV2DiskBackingInfoVmDiskDataSourceReference[];
}

export interface GetVirtualMachineV2DiskBackingInfoVmDiskDataSourceReference {
    /**
     * Image Reference
     */
    imageReferences: outputs.GetVirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceImageReference[];
    /**
     * Vm Disk Reference
     */
    vmDiskReferences: outputs.GetVirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReference[];
}

export interface GetVirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceImageReference {
    /**
     * The globally unique identifier of an image. It should be of type UUID.
     */
    imageExtId: string;
}

export interface GetVirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReference {
    /**
     * Disk address.
     */
    diskAddresses: outputs.GetVirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddress[];
    /**
     * The globally unique identifier of a VM disk. It should be of type UUID.
     */
    diskExtId: string;
    /**
     * This is a reference to a VM.
     */
    vmReferences: outputs.GetVirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface GetVirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddress {
    /**
     * Bus type for the device. The acceptable values are: SCSI, IDE, PCI, SATA, SPAPR (only PPC).
     */
    busType: string;
    /**
     * Device index on the bus. This field is ignored unless the bus details are specified.
     */
    index: number;
}

export interface GetVirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReference {
    /**
     * Represents virtual machine UUID
     */
    extId: string;
}

export interface GetVirtualMachineV2DiskBackingInfoVmDiskStorageConfig {
    /**
     * Indicates whether the virtual disk is pinned to the hot tier or not.
     */
    isFlashModeEnabled: boolean;
}

export interface GetVirtualMachineV2DiskBackingInfoVmDiskStorageContainer {
    /**
     * Represents virtual machine UUID
     */
    extId: string;
}

export interface GetVirtualMachineV2DiskDiskAddress {
    /**
     * Bus type for the device. The acceptable values are: SCSI, IDE, PCI, SATA, SPAPR (only PPC).
     */
    busType: string;
    /**
     * Device index on the bus. This field is ignored unless the bus details are specified.
     */
    index: number;
}

export interface GetVirtualMachineV2Gpus {
    /**
     * The device Id of the GPU.
     */
    deviceId: number;
    /**
     * Represents virtual machine UUID
     */
    extId: string;
    /**
     * Fraction of the physical GPU assigned.
     */
    fraction: number;
    /**
     * GPU frame buffer size in bytes.
     */
    frameBufferSizeBytes: number;
    /**
     * Last determined guest driver version.
     */
    guestDriverVersion: string;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetVirtualMachineV2GpusLink[];
    /**
     * The mode of this GPU.
     */
    mode: string;
    /**
     * Name of the GPU resource.
     */
    name: string;
    /**
     * Number of supported virtual display heads.
     */
    numVirtualDisplayHeads: number;
    /**
     * The (S)egment:(B)us:(D)evice.(F)unction hardware address. See
     */
    pciAddresses: outputs.GetVirtualMachineV2GpusPciAddress[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server).
     */
    tenantId: string;
    /**
     * The vendor of the GPU.
     */
    vendor: string;
}

export interface GetVirtualMachineV2GpusLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetVirtualMachineV2GpusPciAddress {
    bus: number;
    device: number;
    func: number;
    segment: number;
}

export interface GetVirtualMachineV2GuestCustomization {
    /**
     * The Nutanix Guest Tools customization settings.
     */
    configs: outputs.GetVirtualMachineV2GuestCustomizationConfig[];
}

export interface GetVirtualMachineV2GuestCustomizationConfig {
    /**
     * CloudInit Config
     */
    cloudInits: outputs.GetVirtualMachineV2GuestCustomizationConfigCloudInit[];
    /**
     * Sysprep config
     */
    syspreps: outputs.GetVirtualMachineV2GuestCustomizationConfigSysprep[];
}

export interface GetVirtualMachineV2GuestCustomizationConfigCloudInit {
    /**
     * The script to use for cloud-init.
     */
    cloudInitScripts: outputs.GetVirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScript[];
    /**
     * Type of datasource. Default: CONFIG_DRIVE_V2
     */
    datasourceType: string;
    /**
     * The contents of the metaData configuration for cloud-init. This can be formatted as YAML or JSON. The value must be base64 encoded.
     */
    metadata: string;
}

export interface GetVirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScript {
    /**
     * The list of the individual KeyValuePair elements.
     */
    customKeys: outputs.GetVirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKey[];
    /**
     * user data object
     */
    userDatas: outputs.GetVirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptUserData[];
}

export interface GetVirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKey {
    keyValuePairs: outputs.GetVirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyKeyValuePair[];
}

export interface GetVirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyKeyValuePair {
    /**
     * Name of the GPU resource.
     */
    name: string;
    /**
     * The IPv4 address of the host.
     */
    value: string;
}

export interface GetVirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptUserData {
    /**
     * The IPv4 address of the host.
     */
    value: string;
}

export interface GetVirtualMachineV2GuestCustomizationConfigSysprep {
    /**
     * Indicates whether the guest will be freshly installed using this unattend configuration, or this unattend configuration will be applied to a pre-prepared image. Default is 'PREPARED'.
     */
    installType: string;
    /**
     * Object either UnattendXml or CustomKeyValues
     */
    sysprepScripts: outputs.GetVirtualMachineV2GuestCustomizationConfigSysprepSysprepScript[];
}

export interface GetVirtualMachineV2GuestCustomizationConfigSysprepSysprepScript {
    /**
     * The list of the individual KeyValuePair elements.
     */
    customKeyValues: outputs.GetVirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValue[];
    /**
     * xml object
     */
    unattendXmls: outputs.GetVirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptUnattendXml[];
}

export interface GetVirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValue {
    keyValuePairs: outputs.GetVirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePair[];
}

export interface GetVirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePair {
    /**
     * Name of the GPU resource.
     */
    name: string;
    /**
     * The IPv4 address of the host.
     */
    value: string;
}

export interface GetVirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptUnattendXml {
    /**
     * The IPv4 address of the host.
     */
    value: string;
}

export interface GetVirtualMachineV2GuestTool {
    /**
     * Version of Nutanix Guest Tools available on the cluster.
     */
    availableVersion: string;
    /**
     * The list of the application names that are enabled on the guest VM.
     */
    capabilities: string[];
    /**
     * Version of the operating system on the VM
     */
    guestOsVersion: string;
    /**
     * Indicates whether Nutanix Guest Tools is enabled or not.
     */
    isEnabled: boolean;
    /**
     * Indicates whether Nutanix Guest Tools is installed on the VM or not.
     */
    isInstalled: boolean;
    /**
     * Indicates whether Nutanix Guest Tools ISO is inserted or not.
     */
    isIsoInserted: boolean;
    /**
     * Indicates whether the communication from VM to CVM is active or not.
     */
    isReachable: boolean;
    /**
     * Indicates whether the VM mobility drivers are installed on the VM or not.
     */
    isVmMobilityDriversInstalled: boolean;
    /**
     * Indicates whether the VM is configured to take VSS snapshots through NGT or not.
     */
    isVssSnapshotCapable: boolean;
    /**
     * Virtual trusted platform module version.
     */
    version: string;
}

export interface GetVirtualMachineV2Host {
    /**
     * Represents virtual machine UUID
     */
    extId: string;
}

export interface GetVirtualMachineV2Nic {
    /**
     * Defines a NIC emulated by the hypervisor
     */
    backingInfos: outputs.GetVirtualMachineV2NicBackingInfo[];
    /**
     * Represents virtual machine UUID
     */
    extId: string;
    /**
     * Network information for a NIC.
     */
    networkInfos: outputs.GetVirtualMachineV2NicNetworkInfo[];
}

export interface GetVirtualMachineV2NicBackingInfo {
    /**
     * Indicates whether the serial port is connected or not.
     */
    isConnected: boolean;
    /**
     * MAC address of the emulated NIC.
     */
    macAddress: string;
    /**
     * Options for the NIC emulation.
     */
    model: string;
    /**
     * The number of Tx/Rx queue pairs for this NIC
     */
    numQueues: number;
}

export interface GetVirtualMachineV2NicNetworkInfo {
    /**
     * The IP address configurations.
     */
    ipv4Configs: outputs.GetVirtualMachineV2NicNetworkInfoIpv4Config[];
    /**
     * The runtime IP address information of the NIC.
     */
    ipv4Infos: outputs.GetVirtualMachineV2NicNetworkInfoIpv4Info[];
    /**
     * The network function chain associates with the NIC. Only valid if nicType is NORMAL_NIC.
     */
    networkFunctionChains: outputs.GetVirtualMachineV2NicNetworkInfoNetworkFunctionChain[];
    /**
     * The type of this Network function NIC. Defaults to INGRESS.  values are: TAP, EGRESS, INGRESS.
     */
    networkFunctionNicType: string;
    /**
     * NIC type. Defaults to NORMAL_NIC. The acceptable values are: SPAN_DESTINATION_NIC, NORMAL_NIC, DIRECT_NIC, NETWORK_FUNCTION_NIC.
     */
    nicType: string;
    /**
     * Indicates whether an unknown unicast traffic is forwarded to this NIC or not. This is applicable only for the NICs on the overlay subnets.
     */
    shouldAllowUnknownMacs: boolean;
    /**
     * Network identifier for this adapter. Only valid if nicType is NORMAL_NIC or DIRECT_NIC.
     */
    subnets: outputs.GetVirtualMachineV2NicNetworkInfoSubnet[];
    /**
     * List of networks to trunk if VLAN mode is marked as TRUNKED. If empty and VLAN mode is set to TRUNKED, all the VLANs are trunked.
     */
    trunkedVlans: number[];
    /**
     * all the virtual NICs are created in ACCESS mode, which permits only one VLAN per virtual network. TRUNKED mode allows multiple VLANs on a single VM NIC for network-aware user VMs. values are: ACCESS, TRUNKED.
     */
    vlanMode: string;
}

export interface GetVirtualMachineV2NicNetworkInfoIpv4Config {
    /**
     * The IP address of the NIC.
     */
    ipAddresses: outputs.GetVirtualMachineV2NicNetworkInfoIpv4ConfigIpAddress[];
    /**
     * Secondary IP addresses for the NIC.
     */
    secondaryIpAddressLists: outputs.GetVirtualMachineV2NicNetworkInfoIpv4ConfigSecondaryIpAddressList[];
    /**
     * If set to true (default value), an IP address must be assigned to the VM NIC - either the one explicitly specified by the user or allocated automatically by the IPAM service by not specifying the IP address. If false, then no IP assignment is required for this VM NIC.
     */
    shouldAssignIp: boolean;
}

export interface GetVirtualMachineV2NicNetworkInfoIpv4ConfigIpAddress {
    /**
     * The prefix length of the IP address.
     */
    prefixLength: number;
    /**
     * The IPv4 address of the host.
     */
    value: string;
}

export interface GetVirtualMachineV2NicNetworkInfoIpv4ConfigSecondaryIpAddressList {
    /**
     * The prefix length of the IP address.
     */
    prefixLength: number;
    /**
     * The IPv4 address of the host.
     */
    value: string;
}

export interface GetVirtualMachineV2NicNetworkInfoIpv4Info {
    /**
     * The list of IP addresses learned by the NIC.
     */
    learnedIpAddresses: outputs.GetVirtualMachineV2NicNetworkInfoIpv4InfoLearnedIpAddress[];
}

export interface GetVirtualMachineV2NicNetworkInfoIpv4InfoLearnedIpAddress {
    /**
     * The prefix length of the IP address.
     */
    prefixLength: number;
    /**
     * The IPv4 address of the host.
     */
    value: string;
}

export interface GetVirtualMachineV2NicNetworkInfoNetworkFunctionChain {
    /**
     * Represents virtual machine UUID
     */
    extId: string;
}

export interface GetVirtualMachineV2NicNetworkInfoSubnet {
    /**
     * Represents virtual machine UUID
     */
    extId: string;
}

export interface GetVirtualMachineV2OwnershipInfo {
    /**
     * Reference to the owner.
     */
    owners: outputs.GetVirtualMachineV2OwnershipInfoOwner[];
}

export interface GetVirtualMachineV2OwnershipInfoOwner {
    /**
     * Represents virtual machine UUID
     */
    extId: string;
}

export interface GetVirtualMachineV2ProtectionPolicyState {
    /**
     * Reference to the policy object in use.
     */
    policies: outputs.GetVirtualMachineV2ProtectionPolicyStatePolicy[];
}

export interface GetVirtualMachineV2ProtectionPolicyStatePolicy {
    /**
     * Represents virtual machine UUID
     */
    extId: string;
}

export interface GetVirtualMachineV2SerialPort {
    /**
     * Represents virtual machine UUID
     */
    extId: string;
    /**
     * Index of the serial port.
     */
    index: number;
    /**
     * Indicates whether the serial port is connected or not.
     */
    isConnected: boolean;
}

export interface GetVirtualMachineV2Source {
    /**
     * Reference to an entity from which the VM should be cloned or created. Values are:
     * - VM_RECOVERY_POINT: Reference to the recovery point entity from which the VM should be cloned or created.
     * - VM: Reference to an entity from which the VM should be cloned or created.
     */
    entityType: string;
    /**
     * Represents virtual machine UUID
     */
    extId: string;
}

export interface GetVirtualMachineV2StorageConfig {
    /**
     * Indicates whether the virtual disk is pinned to the hot tier or not.
     */
    isFlashModeEnabled: boolean;
    /**
     * QoS parameters to be enforced.
     */
    qosConfigs: outputs.GetVirtualMachineV2StorageConfigQosConfig[];
}

export interface GetVirtualMachineV2StorageConfigQosConfig {
    /**
     * Throttled IOPS for the governed entities. The block size for the I/O is 32 kB.
     */
    throttledIops: number;
}

export interface GetVirtualMachineV2VtpmConfig {
    /**
     * Indicates whether the virtual trusted platform module is enabled for the Guest OS or not.
     */
    isVtpmEnabled: boolean;
    /**
     * Virtual trusted platform module version.
     */
    version: string;
}

export interface GetVirtualMachinesV2Vm {
    apcConfigs: outputs.GetVirtualMachinesV2VmApcConfig[];
    availabilityZones: outputs.GetVirtualMachinesV2VmAvailabilityZone[];
    biosUuid: string;
    bootConfigs: outputs.GetVirtualMachinesV2VmBootConfig[];
    categories: outputs.GetVirtualMachinesV2VmCategory[];
    cdRoms: outputs.GetVirtualMachinesV2VmCdRom[];
    clusters: outputs.GetVirtualMachinesV2VmCluster[];
    createTime: string;
    description: string;
    disks: outputs.GetVirtualMachinesV2VmDisk[];
    enabledCpuFeatures: string[];
    extId: string;
    generationUuid: string;
    gpuses: outputs.GetVirtualMachinesV2VmGpus[];
    guestCustomizations: outputs.GetVirtualMachinesV2VmGuestCustomization[];
    guestTools: outputs.GetVirtualMachinesV2VmGuestTool[];
    hardwareClockTimezone: string;
    hosts: outputs.GetVirtualMachinesV2VmHost[];
    isAgentVm: boolean;
    isBrandingEnabled: boolean;
    isCpuHotplugEnabled: boolean;
    isCpuPassthroughEnabled: boolean;
    isGpuConsoleEnabled: boolean;
    isMemoryOvercommitEnabled: boolean;
    isScsiControllerEnabled: boolean;
    isVcpuHardPinningEnabled: boolean;
    isVgaConsoleEnabled: boolean;
    machineType: string;
    memorySizeBytes: number;
    name: string;
    nics: outputs.GetVirtualMachinesV2VmNic[];
    numCoresPerSocket: number;
    numNumaNodes: number;
    numSockets: number;
    numThreadsPerCore: number;
    ownershipInfos: outputs.GetVirtualMachinesV2VmOwnershipInfo[];
    powerState: string;
    protectionPolicyStates: outputs.GetVirtualMachinesV2VmProtectionPolicyState[];
    protectionType: string;
    serialPorts: outputs.GetVirtualMachinesV2VmSerialPort[];
    sources: outputs.GetVirtualMachinesV2VmSource[];
    storageConfigs: outputs.GetVirtualMachinesV2VmStorageConfig[];
    updateTime: string;
    vtpmConfigs: outputs.GetVirtualMachinesV2VmVtpmConfig[];
}

export interface GetVirtualMachinesV2VmApcConfig {
    cpuModels: outputs.GetVirtualMachinesV2VmApcConfigCpuModel[];
    isApcEnabled: boolean;
}

export interface GetVirtualMachinesV2VmApcConfigCpuModel {
    extId: string;
    name: string;
}

export interface GetVirtualMachinesV2VmAvailabilityZone {
    extId: string;
}

export interface GetVirtualMachinesV2VmBootConfig {
    legacyBoots: outputs.GetVirtualMachinesV2VmBootConfigLegacyBoot[];
    uefiBoots: outputs.GetVirtualMachinesV2VmBootConfigUefiBoot[];
}

export interface GetVirtualMachinesV2VmBootConfigLegacyBoot {
    bootDevices: outputs.GetVirtualMachinesV2VmBootConfigLegacyBootBootDevice[];
    bootOrders: string[];
}

export interface GetVirtualMachinesV2VmBootConfigLegacyBootBootDevice {
    bootDeviceDisks: outputs.GetVirtualMachinesV2VmBootConfigLegacyBootBootDeviceBootDeviceDisk[];
    bootDeviceNics: outputs.GetVirtualMachinesV2VmBootConfigLegacyBootBootDeviceBootDeviceNic[];
}

export interface GetVirtualMachinesV2VmBootConfigLegacyBootBootDeviceBootDeviceDisk {
    diskAddresses: outputs.GetVirtualMachinesV2VmBootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddress[];
}

export interface GetVirtualMachinesV2VmBootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddress {
    busType: string;
    index: number;
}

export interface GetVirtualMachinesV2VmBootConfigLegacyBootBootDeviceBootDeviceNic {
    macAddress: string;
}

export interface GetVirtualMachinesV2VmBootConfigUefiBoot {
    bootDevices: outputs.GetVirtualMachinesV2VmBootConfigUefiBootBootDevice[];
    bootOrders: string[];
    isSecureBootEnabled: boolean;
    nvramDevices: outputs.GetVirtualMachinesV2VmBootConfigUefiBootNvramDevice[];
}

export interface GetVirtualMachinesV2VmBootConfigUefiBootBootDevice {
    bootDeviceDisks: outputs.GetVirtualMachinesV2VmBootConfigUefiBootBootDeviceBootDeviceDisk[];
    bootDeviceNics: outputs.GetVirtualMachinesV2VmBootConfigUefiBootBootDeviceBootDeviceNic[];
}

export interface GetVirtualMachinesV2VmBootConfigUefiBootBootDeviceBootDeviceDisk {
    diskAddresses: outputs.GetVirtualMachinesV2VmBootConfigUefiBootBootDeviceBootDeviceDiskDiskAddress[];
}

export interface GetVirtualMachinesV2VmBootConfigUefiBootBootDeviceBootDeviceDiskDiskAddress {
    busType: string;
    index: number;
}

export interface GetVirtualMachinesV2VmBootConfigUefiBootBootDeviceBootDeviceNic {
    macAddress: string;
}

export interface GetVirtualMachinesV2VmBootConfigUefiBootNvramDevice {
    backingStorageInfos: outputs.GetVirtualMachinesV2VmBootConfigUefiBootNvramDeviceBackingStorageInfo[];
}

export interface GetVirtualMachinesV2VmBootConfigUefiBootNvramDeviceBackingStorageInfo {
    dataSources: outputs.GetVirtualMachinesV2VmBootConfigUefiBootNvramDeviceBackingStorageInfoDataSource[];
    diskExtId: string;
    diskSizeBytes: number;
    isMigrationInProgress: boolean;
    storageConfigs: outputs.GetVirtualMachinesV2VmBootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfig[];
    storageContainers: outputs.GetVirtualMachinesV2VmBootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainer[];
}

export interface GetVirtualMachinesV2VmBootConfigUefiBootNvramDeviceBackingStorageInfoDataSource {
    references: outputs.GetVirtualMachinesV2VmBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReference[];
}

export interface GetVirtualMachinesV2VmBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReference {
    imageReferences: outputs.GetVirtualMachinesV2VmBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReference[];
    vmDiskReferences: outputs.GetVirtualMachinesV2VmBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReference[];
}

export interface GetVirtualMachinesV2VmBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReference {
    imageExtId: string;
}

export interface GetVirtualMachinesV2VmBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReference {
    diskAddresses: outputs.GetVirtualMachinesV2VmBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddress[];
    diskExtId: string;
    vmReferences: outputs.GetVirtualMachinesV2VmBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface GetVirtualMachinesV2VmBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddress {
    busType: string;
    index: number;
}

export interface GetVirtualMachinesV2VmBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReference {
    extId: string;
}

export interface GetVirtualMachinesV2VmBootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfig {
    isFlashModeEnabled: boolean;
}

export interface GetVirtualMachinesV2VmBootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainer {
    extId: string;
}

export interface GetVirtualMachinesV2VmCategory {
    extId: string;
}

export interface GetVirtualMachinesV2VmCdRom {
    backingInfos: outputs.GetVirtualMachinesV2VmCdRomBackingInfo[];
    diskAddresses: outputs.GetVirtualMachinesV2VmCdRomDiskAddress[];
    extId: string;
    isoType: string;
}

export interface GetVirtualMachinesV2VmCdRomBackingInfo {
    dataSources: outputs.GetVirtualMachinesV2VmCdRomBackingInfoDataSource[];
    diskExtId: string;
    diskSizeBytes: number;
    isMigrationInProgress: boolean;
    storageConfigs: outputs.GetVirtualMachinesV2VmCdRomBackingInfoStorageConfig[];
    storageContainers: outputs.GetVirtualMachinesV2VmCdRomBackingInfoStorageContainer[];
}

export interface GetVirtualMachinesV2VmCdRomBackingInfoDataSource {
    references: outputs.GetVirtualMachinesV2VmCdRomBackingInfoDataSourceReference[];
}

export interface GetVirtualMachinesV2VmCdRomBackingInfoDataSourceReference {
    imageReferences: outputs.GetVirtualMachinesV2VmCdRomBackingInfoDataSourceReferenceImageReference[];
    vmDiskReferences: outputs.GetVirtualMachinesV2VmCdRomBackingInfoDataSourceReferenceVmDiskReference[];
}

export interface GetVirtualMachinesV2VmCdRomBackingInfoDataSourceReferenceImageReference {
    imageExtId: string;
}

export interface GetVirtualMachinesV2VmCdRomBackingInfoDataSourceReferenceVmDiskReference {
    diskAddresses: outputs.GetVirtualMachinesV2VmCdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddress[];
    diskExtId: string;
    vmReferences: outputs.GetVirtualMachinesV2VmCdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface GetVirtualMachinesV2VmCdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddress {
    busType: string;
    index: number;
}

export interface GetVirtualMachinesV2VmCdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReference {
    extId: string;
}

export interface GetVirtualMachinesV2VmCdRomBackingInfoStorageConfig {
    isFlashModeEnabled: boolean;
}

export interface GetVirtualMachinesV2VmCdRomBackingInfoStorageContainer {
    extId: string;
}

export interface GetVirtualMachinesV2VmCdRomDiskAddress {
    busType: string;
    index: number;
}

export interface GetVirtualMachinesV2VmCluster {
    extId: string;
}

export interface GetVirtualMachinesV2VmDisk {
    backingInfos: outputs.GetVirtualMachinesV2VmDiskBackingInfo[];
    diskAddresses: outputs.GetVirtualMachinesV2VmDiskDiskAddress[];
    extId: string;
}

export interface GetVirtualMachinesV2VmDiskBackingInfo {
    adfsVolumeGroupReferences: outputs.GetVirtualMachinesV2VmDiskBackingInfoAdfsVolumeGroupReference[];
    vmDisks: outputs.GetVirtualMachinesV2VmDiskBackingInfoVmDisk[];
}

export interface GetVirtualMachinesV2VmDiskBackingInfoAdfsVolumeGroupReference {
    volumeGroupExtId: string;
}

export interface GetVirtualMachinesV2VmDiskBackingInfoVmDisk {
    dataSources: outputs.GetVirtualMachinesV2VmDiskBackingInfoVmDiskDataSource[];
    diskExtId: string;
    diskSizeBytes: number;
    isMigrationInProgress: boolean;
    storageConfigs: outputs.GetVirtualMachinesV2VmDiskBackingInfoVmDiskStorageConfig[];
    storageContainers: outputs.GetVirtualMachinesV2VmDiskBackingInfoVmDiskStorageContainer[];
}

export interface GetVirtualMachinesV2VmDiskBackingInfoVmDiskDataSource {
    references: outputs.GetVirtualMachinesV2VmDiskBackingInfoVmDiskDataSourceReference[];
}

export interface GetVirtualMachinesV2VmDiskBackingInfoVmDiskDataSourceReference {
    imageReferences: outputs.GetVirtualMachinesV2VmDiskBackingInfoVmDiskDataSourceReferenceImageReference[];
    vmDiskReferences: outputs.GetVirtualMachinesV2VmDiskBackingInfoVmDiskDataSourceReferenceVmDiskReference[];
}

export interface GetVirtualMachinesV2VmDiskBackingInfoVmDiskDataSourceReferenceImageReference {
    imageExtId: string;
}

export interface GetVirtualMachinesV2VmDiskBackingInfoVmDiskDataSourceReferenceVmDiskReference {
    diskAddresses: outputs.GetVirtualMachinesV2VmDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddress[];
    diskExtId: string;
    vmReferences: outputs.GetVirtualMachinesV2VmDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface GetVirtualMachinesV2VmDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddress {
    busType: string;
    index: number;
}

export interface GetVirtualMachinesV2VmDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReference {
    extId: string;
}

export interface GetVirtualMachinesV2VmDiskBackingInfoVmDiskStorageConfig {
    isFlashModeEnabled: boolean;
}

export interface GetVirtualMachinesV2VmDiskBackingInfoVmDiskStorageContainer {
    extId: string;
}

export interface GetVirtualMachinesV2VmDiskDiskAddress {
    busType: string;
    index: number;
}

export interface GetVirtualMachinesV2VmGpus {
    deviceId: number;
    extId: string;
    fraction: number;
    frameBufferSizeBytes: number;
    guestDriverVersion: string;
    links: outputs.GetVirtualMachinesV2VmGpusLink[];
    mode: string;
    name: string;
    numVirtualDisplayHeads: number;
    pciAddresses: outputs.GetVirtualMachinesV2VmGpusPciAddress[];
    tenantId: string;
    vendor: string;
}

export interface GetVirtualMachinesV2VmGpusLink {
    href: string;
    rel: string;
}

export interface GetVirtualMachinesV2VmGpusPciAddress {
    bus: number;
    device: number;
    func: number;
    segment: number;
}

export interface GetVirtualMachinesV2VmGuestCustomization {
    configs: outputs.GetVirtualMachinesV2VmGuestCustomizationConfig[];
}

export interface GetVirtualMachinesV2VmGuestCustomizationConfig {
    cloudInits: outputs.GetVirtualMachinesV2VmGuestCustomizationConfigCloudInit[];
    syspreps: outputs.GetVirtualMachinesV2VmGuestCustomizationConfigSysprep[];
}

export interface GetVirtualMachinesV2VmGuestCustomizationConfigCloudInit {
    cloudInitScripts: outputs.GetVirtualMachinesV2VmGuestCustomizationConfigCloudInitCloudInitScript[];
    datasourceType: string;
    metadata: string;
}

export interface GetVirtualMachinesV2VmGuestCustomizationConfigCloudInitCloudInitScript {
    customKeys: outputs.GetVirtualMachinesV2VmGuestCustomizationConfigCloudInitCloudInitScriptCustomKey[];
    userDatas: outputs.GetVirtualMachinesV2VmGuestCustomizationConfigCloudInitCloudInitScriptUserData[];
}

export interface GetVirtualMachinesV2VmGuestCustomizationConfigCloudInitCloudInitScriptCustomKey {
    keyValuePairs: outputs.GetVirtualMachinesV2VmGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyKeyValuePair[];
}

export interface GetVirtualMachinesV2VmGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyKeyValuePair {
    name: string;
    value: string;
}

export interface GetVirtualMachinesV2VmGuestCustomizationConfigCloudInitCloudInitScriptUserData {
    value: string;
}

export interface GetVirtualMachinesV2VmGuestCustomizationConfigSysprep {
    installType: string;
    sysprepScripts: outputs.GetVirtualMachinesV2VmGuestCustomizationConfigSysprepSysprepScript[];
}

export interface GetVirtualMachinesV2VmGuestCustomizationConfigSysprepSysprepScript {
    customKeyValues: outputs.GetVirtualMachinesV2VmGuestCustomizationConfigSysprepSysprepScriptCustomKeyValue[];
    unattendXmls: outputs.GetVirtualMachinesV2VmGuestCustomizationConfigSysprepSysprepScriptUnattendXml[];
}

export interface GetVirtualMachinesV2VmGuestCustomizationConfigSysprepSysprepScriptCustomKeyValue {
    keyValuePairs: outputs.GetVirtualMachinesV2VmGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePair[];
}

export interface GetVirtualMachinesV2VmGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePair {
    name: string;
    value: string;
}

export interface GetVirtualMachinesV2VmGuestCustomizationConfigSysprepSysprepScriptUnattendXml {
    value: string;
}

export interface GetVirtualMachinesV2VmGuestTool {
    availableVersion: string;
    capabilities: string[];
    guestOsVersion: string;
    isEnabled: boolean;
    isInstalled: boolean;
    isIsoInserted: boolean;
    isReachable: boolean;
    isVmMobilityDriversInstalled: boolean;
    isVssSnapshotCapable: boolean;
    version: string;
}

export interface GetVirtualMachinesV2VmHost {
    extId: string;
}

export interface GetVirtualMachinesV2VmNic {
    backingInfos: outputs.GetVirtualMachinesV2VmNicBackingInfo[];
    extId: string;
    networkInfos: outputs.GetVirtualMachinesV2VmNicNetworkInfo[];
}

export interface GetVirtualMachinesV2VmNicBackingInfo {
    isConnected: boolean;
    macAddress: string;
    model: string;
    numQueues: number;
}

export interface GetVirtualMachinesV2VmNicNetworkInfo {
    ipv4Configs: outputs.GetVirtualMachinesV2VmNicNetworkInfoIpv4Config[];
    ipv4Infos: outputs.GetVirtualMachinesV2VmNicNetworkInfoIpv4Info[];
    networkFunctionChains: outputs.GetVirtualMachinesV2VmNicNetworkInfoNetworkFunctionChain[];
    networkFunctionNicType: string;
    nicType: string;
    shouldAllowUnknownMacs: boolean;
    subnets: outputs.GetVirtualMachinesV2VmNicNetworkInfoSubnet[];
    trunkedVlans: number[];
    vlanMode: string;
}

export interface GetVirtualMachinesV2VmNicNetworkInfoIpv4Config {
    ipAddresses: outputs.GetVirtualMachinesV2VmNicNetworkInfoIpv4ConfigIpAddress[];
    secondaryIpAddressLists: outputs.GetVirtualMachinesV2VmNicNetworkInfoIpv4ConfigSecondaryIpAddressList[];
    shouldAssignIp: boolean;
}

export interface GetVirtualMachinesV2VmNicNetworkInfoIpv4ConfigIpAddress {
    prefixLength: number;
    value: string;
}

export interface GetVirtualMachinesV2VmNicNetworkInfoIpv4ConfigSecondaryIpAddressList {
    prefixLength: number;
    value: string;
}

export interface GetVirtualMachinesV2VmNicNetworkInfoIpv4Info {
    learnedIpAddresses: outputs.GetVirtualMachinesV2VmNicNetworkInfoIpv4InfoLearnedIpAddress[];
}

export interface GetVirtualMachinesV2VmNicNetworkInfoIpv4InfoLearnedIpAddress {
    prefixLength: number;
    value: string;
}

export interface GetVirtualMachinesV2VmNicNetworkInfoNetworkFunctionChain {
    extId: string;
}

export interface GetVirtualMachinesV2VmNicNetworkInfoSubnet {
    extId: string;
}

export interface GetVirtualMachinesV2VmOwnershipInfo {
    owners: outputs.GetVirtualMachinesV2VmOwnershipInfoOwner[];
}

export interface GetVirtualMachinesV2VmOwnershipInfoOwner {
    extId: string;
}

export interface GetVirtualMachinesV2VmProtectionPolicyState {
    policies: outputs.GetVirtualMachinesV2VmProtectionPolicyStatePolicy[];
}

export interface GetVirtualMachinesV2VmProtectionPolicyStatePolicy {
    extId: string;
}

export interface GetVirtualMachinesV2VmSerialPort {
    extId: string;
    index: number;
    isConnected: boolean;
}

export interface GetVirtualMachinesV2VmSource {
    entityType: string;
    extId: string;
}

export interface GetVirtualMachinesV2VmStorageConfig {
    isFlashModeEnabled: boolean;
    qosConfigs: outputs.GetVirtualMachinesV2VmStorageConfigQosConfig[];
}

export interface GetVirtualMachinesV2VmStorageConfigQosConfig {
    throttledIops: number;
}

export interface GetVirtualMachinesV2VmVtpmConfig {
    isVtpmEnabled: boolean;
    version: string;
}

export interface GetVmRecoveryPointInfoV2ApplicationConsistentProperty {
    /**
     * The backup type specifies the criteria for identifying the files to be backed up. This property should be specified to the application-consistent recovery points for Windows VMs/agents. The following backup types are supported for the application-consistent recovery points:
     * * supported values:
     * * `FULL_BACKUP`: -  All the files are backed up irrespective of their last backup date/time or state. Also, this backup type updates the backup history of each file that participated in the recovery point. If not explicitly specified, this is the default backup type.
     * * `COPY_BACKUP`: -  this backup type does not update the backup history of individual files involved in the recovery point.
     */
    backupType: string;
    /**
     * value: `dataprotection.v4.common.VssProperties`
     */
    objectType: string;
    /**
     * Indicates whether the given set of VSS writers' UUIDs should be included or excluded from the application consistent recovery point. By default, the value is set to false, indicating that all listed VSS writers' UUIDs will be excluded.
     */
    shouldIncludeWriters: boolean;
    /**
     * Indicates whether to store the VSS metadata if the user is interested in application-specific backup/restore. The VSS metadata consists of VSS writers and requester metadata details. These are compressed into a cabinet file(.cab file) during a VSS backup operation. This cabinet file must be saved to the backup media during a backup operation, as it is required during the restore operation.
     */
    shouldStoreVssMetadata: boolean;
    /**
     * List of VSS writer UUIDs that are used in an application consistent recovery point. The default values are the system and the registry writer UUIDs.
     */
    writers: string[];
}

export interface GetVmRecoveryPointInfoV2DiskRecoveryPoint {
    /**
     * External identifier of the disk.
     */
    diskExtId: string;
    /**
     * External identifier of the disk recovery point.
     */
    diskRecoveryPointExtId: string;
}

export interface GetVmRecoveryPointInfoV2Link {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetVolumeGroupDiskV2DiskDataSourceReference {
    /**
     * - The Entity Type of the Data Source Reference.
     */
    entityType: string;
    /**
     * - The external identifier of the Data Source Reference.
     */
    extId: string;
    /**
     * - The name of the Data Source Reference.bled for the Volume Group.
     */
    name: string;
    /**
     * - The uri list of the Data Source Reference.
     */
    uris: any[][];
}

export interface GetVolumeGroupDiskV2DiskStorageFeature {
    /**
     * - this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
     */
    flashModes: outputs.GetVolumeGroupDiskV2DiskStorageFeatureFlashMode[];
}

export interface GetVolumeGroupDiskV2DiskStorageFeatureFlashMode {
    /**
     * - Indicates whether the flash mode is enabled for the Volume Group Disk.
     */
    isEnabled: boolean;
}

export interface GetVolumeGroupDiskV2Link {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetVolumeGroupDisksV2Disk {
    /**
     * - Volume Disk description.
     */
    description: string;
    /**
     * - Disk Data Source Reference.
     */
    diskDataSourceReferences: outputs.GetVolumeGroupDisksV2DiskDiskDataSourceReference[];
    /**
     * - ize of the disk in bytes. This field is mandatory during Volume Group creation if a new disk is being created on the storage container.
     */
    diskSizeBytes: number;
    /**
     * - Storage optimization features which must be enabled on the Volume Disks. This is an optional field. If omitted, the disks will honor the Volume Group specific storage features setting.
     */
    diskStorageFeatures: outputs.GetVolumeGroupDisksV2DiskDiskStorageFeature[];
    /**
     * - The external identifier of the Data Source Reference.
     */
    extId: string;
    /**
     * - Index of the disk in a Volume Group. This field is optional and immutable.
     */
    index: number;
    /**
     * - A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetVolumeGroupDisksV2DiskLink[];
    /**
     * - Storage container on which the disk must be created. This is a read-only field.
     */
    storageContainerId: string;
    /**
     * - A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server).
     */
    tenantId: string;
}

export interface GetVolumeGroupDisksV2DiskDiskDataSourceReference {
    /**
     * - The Entity Type of the Data Source Reference.
     */
    entityType: string;
    /**
     * - The external identifier of the Data Source Reference.
     */
    extId: string;
    /**
     * - The name of the Data Source Reference.bled for the Volume Group.
     */
    name: string;
    /**
     * - The uri list of the Data Source Reference.
     */
    uris: any[][];
}

export interface GetVolumeGroupDisksV2DiskDiskStorageFeature {
    /**
     * - this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
     */
    flashModes: outputs.GetVolumeGroupDisksV2DiskDiskStorageFeatureFlashMode[];
}

export interface GetVolumeGroupDisksV2DiskDiskStorageFeatureFlashMode {
    /**
     * - Indicates whether the flash mode is enabled for the Volume Group Disk.
     */
    isEnabled: boolean;
}

export interface GetVolumeGroupDisksV2DiskLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetVolumeGroupV2IscsiFeature {
    /**
     * - The authentication type enabled for the Volume Group.
     */
    enabledAuthentications: string;
}

export interface GetVolumeGroupV2Link {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetVolumeGroupV2StorageFeature {
    /**
     * - this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
     */
    flashModes: outputs.GetVolumeGroupV2StorageFeatureFlashMode[];
}

export interface GetVolumeGroupV2StorageFeatureFlashMode {
    /**
     * - Indicates whether the flash mode is enabled for the Volume Group.
     */
    isEnabled: boolean;
}

export interface GetVolumeGroupsV2Volume {
    /**
     * The UUID of the cluster that will host the Volume Group. This is a mandatory field for creating a Volume Group on Prism Central.
     */
    clusterReference: string;
    /**
     * Service/user who created this Volume Group. This is an optional field.
     */
    createdBy: string;
    /**
     * Volume Group description. This is an optional field.
     */
    description: string;
    /**
     * The authentication type enabled for the Volume Group. This is an optional field. If omitted, authentication is not configured for the Volume Group. If this is set to CHAP, the target/client secret must be provided.
     */
    enabledAuthentications: string;
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    /**
     * Indicates whether the Volume Group is meant to be hidden or not. This is an optional field. If omitted, the VG will not be hidden.
     */
    isHidden: boolean;
    /**
     * iSCSI specific settings for the Volume Group. This is an optional field.
     */
    iscsiFeatures: outputs.GetVolumeGroupsV2VolumeIscsiFeature[];
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetVolumeGroupsV2VolumeLink[];
    /**
     * Volume Group name. This is an optional field.
     */
    name: string;
    /**
     * Indicates whether the Volume Group can be shared across multiple iSCSI initiators. The mode cannot be changed from SHARED to NOT_SHARED on a Volume Group with multiple attachments. Similarly, a Volume Group cannot be associated with more than one attachment as long as it is in exclusive mode. This is an optional field
     */
    sharingStatus: string;
    /**
     * Indicates whether to enable Volume Group load balancing for VM attachments. This cannot be enabled if there are iSCSI client attachments already associated with the Volume Group, and vice-versa. This is an optional field.
     */
    shouldLoadBalanceVmAttachments: boolean;
    /**
     * Storage optimization features which must be enabled on the Volume Group. This is an optional field.
     */
    storageFeatures: outputs.GetVolumeGroupsV2VolumeStorageFeature[];
    /**
     * Name of the external client target that will be visible and accessible to the client. This is an optional field.
     */
    targetName: string;
    /**
     * A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server).
     */
    tenantId: string;
    /**
     * Expected usage type for the Volume Group. This is an indicative hint on how the caller will consume the Volume Group. This is an optional field.
     */
    usageType: string;
}

export interface GetVolumeGroupsV2VolumeIscsiFeature {
    /**
     * The authentication type enabled for the Volume Group. This is an optional field. If omitted, authentication is not configured for the Volume Group. If this is set to CHAP, the target/client secret must be provided.
     */
    enabledAuthentications: string;
}

export interface GetVolumeGroupsV2VolumeLink {
    /**
     * The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetVolumeGroupsV2VolumeStorageFeature {
    /**
     * Once configured, this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
     */
    flashModes: outputs.GetVolumeGroupsV2VolumeStorageFeatureFlashMode[];
}

export interface GetVolumeGroupsV2VolumeStorageFeatureFlashMode {
    /**
     * Indicates whether the flash mode is enabled for the Volume Group.
     */
    isEnabled: boolean;
}

export interface GetVolumeIscsiClientV2AttachedTarget {
    /**
     * - Name of the iSCSI target that the iSCSI client is connected to. This is a read-only field.
     */
    iscsiTargetName: string;
    /**
     * - Number of virtual targets generated for the iSCSI target. This field is immutable.
     */
    numVirtualTargets: number;
}

export interface GetVolumeIscsiClientV2IscsiInitiatorNetworkId {
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.GetVolumeIscsiClientV2IscsiInitiatorNetworkIdFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv6[];
}

export interface GetVolumeIscsiClientV2IscsiInitiatorNetworkIdFqdn {
    /**
     * - The fully qualified domain name.
     */
    value: string;
}

export interface GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv4 {
    /**
     * - The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * - The fully qualified domain name.
     */
    value: string;
}

export interface GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv6 {
    /**
     * - The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * - The fully qualified domain name.
     */
    value: string;
}

export interface GetVolumeIscsiClientV2Link {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetVolumeIscsiClientsV2IscsiClient {
    /**
     * associated with each iSCSI target corresponding to the iSCSI client)
     */
    attachedTargets: outputs.GetVolumeIscsiClientsV2IscsiClientAttachedTarget[];
    /**
     * The site where the Volume Group attach operation should be processed. This is an optional field. This field may only be set if Metro DR has been configured for this Volume Group.
     */
    attachmentSite: string;
    /**
     * The UUID of the cluster that will host the iSCSI client. This field is read-only.
     */
    clusterReference: string;
    /**
     * The authentication type enabled for the Volume Group. This is an optional field. If omitted, authentication is not configured for the Volume Group. If this is set to CHAP, the target/client secret must be provided.
     */
    enabledAuthentications: string;
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    /**
     * iSCSI initiator name. During the attach operation, exactly one of iscsiInitiatorName and iscsiInitiatorNetworkId must be specified. This field is immutable.
     */
    iscsiInitiatorName: string;
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    iscsiInitiatorNetworkIds?: outputs.GetVolumeIscsiClientsV2IscsiClientIscsiInitiatorNetworkId[];
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.GetVolumeIscsiClientsV2IscsiClientLink[];
    /**
     * A globally unique identifier that represents the tenant that owns this entity. The system automatically assigns it, and it and is immutable from an API consumer perspective (some use cases may cause this Id to change - For instance, a use case may require the transfer of ownership of the entity, but these cases are handled automatically on the server).
     */
    tenantId: string;
}

export interface GetVolumeIscsiClientsV2IscsiClientAttachedTarget {
    /**
     * Name of the iSCSI target that the iSCSI client is connected to. This is a read-only field.
     */
    iscsiTargetName: string;
    /**
     * Number of virtual targets generated for the iSCSI target. This field is immutable.
     */
    numVirtualTargets: number;
}

export interface GetVolumeIscsiClientsV2IscsiClientIscsiInitiatorNetworkId {
    /**
     * A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.GetVolumeIscsiClientsV2IscsiClientIscsiInitiatorNetworkIdFqdn[];
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.GetVolumeIscsiClientsV2IscsiClientIscsiInitiatorNetworkIdIpv4[];
    /**
     * An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.GetVolumeIscsiClientsV2IscsiClientIscsiInitiatorNetworkIdIpv6[];
}

export interface GetVolumeIscsiClientsV2IscsiClientIscsiInitiatorNetworkIdFqdn {
    /**
     * The fully qualified domain name.
     */
    value: string;
}

export interface GetVolumeIscsiClientsV2IscsiClientIscsiInitiatorNetworkIdIpv4 {
    /**
     * The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength: number;
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    value: string;
}

export interface GetVolumeIscsiClientsV2IscsiClientIscsiInitiatorNetworkIdIpv6 {
    /**
     * The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    value: string;
}

export interface GetVolumeIscsiClientsV2IscsiClientLink {
    /**
     * The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface GetVpcSpec {
    /**
     * - the name.
     */
    name: string;
    /**
     * VPC resources status
     */
    resources: outputs.GetVpcSpecResource[];
}

export interface GetVpcSpecResource {
    /**
     * List of domain name server IPs.
     */
    commonDomainNameServerIpLists: outputs.GetVpcSpecResourceCommonDomainNameServerIpList[];
    /**
     * List of external subnets attached to this VPC.
     */
    externalSubnetLists: outputs.GetVpcSpecResourceExternalSubnetList[];
    /**
     * List of external routable ip and prefix .
     */
    externallyRoutablePrefixLists: outputs.GetVpcSpecResourceExternallyRoutablePrefixList[];
}

export interface GetVpcSpecResourceCommonDomainNameServerIpList {
    /**
     * ip address of domain name server.
     */
    ip: string;
}

export interface GetVpcSpecResourceExternalSubnetList {
    /**
     * Reference to a subnet.
     */
    externalSubnetReference: {[key: string]: string};
}

export interface GetVpcSpecResourceExternallyRoutablePrefixList {
    /**
     * ip address of domain name server.
     */
    ip: string;
    /**
     * prefix length of routable ip .
     */
    prefixLength: number;
}

export interface GetVpcStatus {
    /**
     * Execution Context of VPC.
     */
    executionContexts: outputs.GetVpcStatusExecutionContext[];
    /**
     * - the name.
     */
    name: string;
    /**
     * VPC resources status
     */
    resources: outputs.GetVpcStatusResource[];
    /**
     * The state of the VPC
     */
    state: string;
}

export interface GetVpcStatusExecutionContext {
    taskUuids: string[];
}

export interface GetVpcStatusResource {
    /**
     * List of domain name server IPs.
     */
    commonDomainNameServerIpLists: outputs.GetVpcStatusResourceCommonDomainNameServerIpList[];
    /**
     * List of external subnets attached to this VPC.
     */
    externalSubnetLists: outputs.GetVpcStatusResourceExternalSubnetList[];
    /**
     * List of external routable ip and prefix .
     */
    externallyRoutablePrefixLists: outputs.GetVpcStatusResourceExternallyRoutablePrefixList[];
}

export interface GetVpcStatusResourceCommonDomainNameServerIpList {
    /**
     * ip address of domain name server.
     */
    ip: string;
}

export interface GetVpcStatusResourceExternalSubnetList {
    /**
     * Active Gateway Node. Only present in VPC Status Resources.
     */
    activeGatewayNodes: outputs.GetVpcStatusResourceExternalSubnetListActiveGatewayNode[];
    /**
     * List of external subnets attached to this VPC. Only present in VPC Status Resources .
     */
    externalIpLists: string[];
    /**
     * Reference to a subnet.
     */
    externalSubnetReference: {[key: string]: string};
}

export interface GetVpcStatusResourceExternalSubnetListActiveGatewayNode {
    /**
     * Reference to host.
     */
    hostReference: {[key: string]: string};
    /**
     * ip address.
     */
    ipAddress: string;
}

export interface GetVpcStatusResourceExternallyRoutablePrefixList {
    /**
     * ip address of domain name server.
     */
    ip: string;
    /**
     * prefix length of routable ip .
     */
    prefixLength: number;
}

export interface GetVpcV2CommonDhcpOption {
    /**
     * List of Domain Name Server addresses
     */
    domainNameServers: outputs.GetVpcV2CommonDhcpOptionDomainNameServer[];
}

export interface GetVpcV2CommonDhcpOptionDomainNameServer {
    /**
     * Reference to address configuration
     */
    ipv4s: outputs.GetVpcV2CommonDhcpOptionDomainNameServerIpv4[];
    /**
     * Reference to address configuration
     */
    ipv6s: outputs.GetVpcV2CommonDhcpOptionDomainNameServerIpv6[];
}

export interface GetVpcV2CommonDhcpOptionDomainNameServerIpv4 {
    /**
     * The prefix length of the network
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetVpcV2CommonDhcpOptionDomainNameServerIpv6 {
    /**
     * The prefix length of the network
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetVpcV2ExternalSubnet {
    /**
     * Maximum number of active gateway nodes for the VPC external subnet association.
     */
    activeGatewayCount: number;
    /**
     * Reference of gateway nodes
     */
    activeGatewayNodes: outputs.GetVpcV2ExternalSubnetActiveGatewayNode[];
    /**
     * List of IP Addresses used for SNAT, if NAT is enabled on the external subnet. If NAT is not enabled, this specifies the IP address of the VPC port connected to the external gateway.
     */
    externalIps: outputs.GetVpcV2ExternalSubnetExternalIp[];
    /**
     * List of gateway nodes that can be used for external connectivity.
     */
    gatewayNodes: string[];
    /**
     * External subnet reference.
     */
    subnetReference: string;
}

export interface GetVpcV2ExternalSubnetActiveGatewayNode {
    nodeId: string;
    nodeIpAddresses: outputs.GetVpcV2ExternalSubnetActiveGatewayNodeNodeIpAddress[];
}

export interface GetVpcV2ExternalSubnetActiveGatewayNodeNodeIpAddress {
    /**
     * IP V4 Configuration
     */
    ipv4s: outputs.GetVpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv4[];
    /**
     * IP V6 Configuration
     */
    ipv6s: outputs.GetVpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv6[];
}

export interface GetVpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv4 {
    /**
     * The prefix length of the network
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetVpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv6 {
    /**
     * The prefix length of the network
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetVpcV2ExternalSubnetExternalIp {
    /**
     * IP V4 Configuration
     */
    ipv4s: outputs.GetVpcV2ExternalSubnetExternalIpIpv4[];
    /**
     * IP V6 Configuration
     */
    ipv6s: outputs.GetVpcV2ExternalSubnetExternalIpIpv6[];
}

export interface GetVpcV2ExternalSubnetExternalIpIpv4 {
    /**
     * The prefix length of the network
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetVpcV2ExternalSubnetExternalIpIpv6 {
    /**
     * The prefix length of the network
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetVpcV2ExternallyRoutablePrefix {
    /**
     * IP V4 Configuration
     */
    ipv4s: outputs.GetVpcV2ExternallyRoutablePrefixIpv4[];
    /**
     * IP V6 Configuration
     */
    ipv6s: outputs.GetVpcV2ExternallyRoutablePrefixIpv6[];
}

export interface GetVpcV2ExternallyRoutablePrefixIpv4 {
    /**
     * Reference to address configuration
     */
    ips: outputs.GetVpcV2ExternallyRoutablePrefixIpv4Ip[];
    /**
     * The prefix length of the network
     */
    prefixLength: number;
}

export interface GetVpcV2ExternallyRoutablePrefixIpv4Ip {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetVpcV2ExternallyRoutablePrefixIpv6 {
    /**
     * Reference to address configuration
     */
    ips: outputs.GetVpcV2ExternallyRoutablePrefixIpv6Ip[];
    /**
     * The prefix length of the network
     */
    prefixLength: number;
}

export interface GetVpcV2ExternallyRoutablePrefixIpv6Ip {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetVpcV2Link {
    href: string;
    rel: string;
}

export interface GetVpcV2Metadata {
    categoryIds: any[][];
    ownerReferenceId: string;
    ownerUserName: string;
    projectName: string;
    projectReferenceId: string;
}

export interface GetVpcV2SnatIp {
    /**
     * IP V4 Configuration
     */
    ipv4s: outputs.GetVpcV2SnatIpIpv4[];
    /**
     * IP V6 Configuration
     */
    ipv6s: outputs.GetVpcV2SnatIpIpv6[];
}

export interface GetVpcV2SnatIpIpv4 {
    /**
     * The prefix length of the network
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetVpcV2SnatIpIpv6 {
    /**
     * The prefix length of the network
     */
    prefixLength: number;
    /**
     * value of address
     */
    value: string;
}

export interface GetVpcsEntity {
    /**
     * - The vpc kind metadata.
     */
    metadata: {[key: string]: string};
    /**
     * VPC input spec
     */
    specs: outputs.GetVpcsEntitySpec[];
    /**
     * VPC output status
     */
    statuses: outputs.GetVpcsEntityStatus[];
}

export interface GetVpcsEntitySpec {
    /**
     * - the name.
     */
    name: string;
    /**
     * VPC resources status
     */
    resources: outputs.GetVpcsEntitySpecResource[];
}

export interface GetVpcsEntitySpecResource {
    /**
     * List of domain name server IPs.
     */
    commonDomainNameServerIpLists: outputs.GetVpcsEntitySpecResourceCommonDomainNameServerIpList[];
    /**
     * List of external subnets attached to this VPC.
     */
    externalSubnetLists: outputs.GetVpcsEntitySpecResourceExternalSubnetList[];
    /**
     * List of external routable ip and prefix .
     */
    externallyRoutablePrefixLists: outputs.GetVpcsEntitySpecResourceExternallyRoutablePrefixList[];
}

export interface GetVpcsEntitySpecResourceCommonDomainNameServerIpList {
    /**
     * ip address of domain name server.
     */
    ip: string;
}

export interface GetVpcsEntitySpecResourceExternalSubnetList {
    /**
     * Reference to a subnet.
     */
    externalSubnetReference: {[key: string]: string};
}

export interface GetVpcsEntitySpecResourceExternallyRoutablePrefixList {
    /**
     * ip address of domain name server.
     */
    ip: string;
    /**
     * prefix length of routable ip .
     */
    prefixLength: number;
}

export interface GetVpcsEntityStatus {
    /**
     * Execution Context of VPC.
     */
    executionContexts: outputs.GetVpcsEntityStatusExecutionContext[];
    /**
     * - the name.
     */
    name: string;
    /**
     * VPC resources status
     */
    resources: outputs.GetVpcsEntityStatusResource[];
    /**
     * The state of the VPC
     */
    state: string;
}

export interface GetVpcsEntityStatusExecutionContext {
    taskUuids: string[];
}

export interface GetVpcsEntityStatusResource {
    /**
     * List of domain name server IPs.
     */
    commonDomainNameServerIpLists: outputs.GetVpcsEntityStatusResourceCommonDomainNameServerIpList[];
    /**
     * List of external subnets attached to this VPC.
     */
    externalSubnetLists: outputs.GetVpcsEntityStatusResourceExternalSubnetList[];
    /**
     * List of external routable ip and prefix .
     */
    externallyRoutablePrefixLists: outputs.GetVpcsEntityStatusResourceExternallyRoutablePrefixList[];
}

export interface GetVpcsEntityStatusResourceCommonDomainNameServerIpList {
    /**
     * ip address of domain name server.
     */
    ip: string;
}

export interface GetVpcsEntityStatusResourceExternalSubnetList {
    activeGatewayCount: number;
    /**
     * Active Gateway Node. Only present in VPC Status Resources.
     */
    activeGatewayNodes: outputs.GetVpcsEntityStatusResourceExternalSubnetListActiveGatewayNode[];
    /**
     * List of external subnets attached to this VPC. Only present in VPC Status Resources .
     */
    externalIpLists: string[];
    /**
     * Reference to a subnet.
     */
    externalSubnetReference: {[key: string]: string};
}

export interface GetVpcsEntityStatusResourceExternalSubnetListActiveGatewayNode {
    /**
     * Reference to host.
     */
    hostReference: {[key: string]: string};
    /**
     * ip address.
     */
    ipAddress: string;
}

export interface GetVpcsEntityStatusResourceExternallyRoutablePrefixList {
    /**
     * ip address of domain name server.
     */
    ip: string;
    /**
     * prefix length of routable ip .
     */
    prefixLength: number;
}

export interface GetVpcsMetadata {
    filter: string;
    /**
     * - The kind name (Default value: project).
     */
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
    totalMatches: number;
}

export interface GetVpcsV2Vpc {
    commonDhcpOptions: outputs.GetVpcsV2VpcCommonDhcpOption[];
    /**
     * - `extId`
     * - `externalRoutingDomainReference`
     */
    description: string;
    extId: string;
    externalRoutingDomainReference: string;
    externalSubnets: outputs.GetVpcsV2VpcExternalSubnet[];
    externallyRoutablePrefixes: outputs.GetVpcsV2VpcExternallyRoutablePrefix[];
    links: outputs.GetVpcsV2VpcLink[];
    metadatas: outputs.GetVpcsV2VpcMetadata[];
    name: string;
    snatIps: outputs.GetVpcsV2VpcSnatIp[];
    tenantId: string;
    vpcType: string;
}

export interface GetVpcsV2VpcCommonDhcpOption {
    domainNameServers: outputs.GetVpcsV2VpcCommonDhcpOptionDomainNameServer[];
}

export interface GetVpcsV2VpcCommonDhcpOptionDomainNameServer {
    ipv4s: outputs.GetVpcsV2VpcCommonDhcpOptionDomainNameServerIpv4[];
    ipv6s: outputs.GetVpcsV2VpcCommonDhcpOptionDomainNameServerIpv6[];
}

export interface GetVpcsV2VpcCommonDhcpOptionDomainNameServerIpv4 {
    prefixLength: number;
    value: string;
}

export interface GetVpcsV2VpcCommonDhcpOptionDomainNameServerIpv6 {
    prefixLength: number;
    value: string;
}

export interface GetVpcsV2VpcExternalSubnet {
    activeGatewayCount: number;
    activeGatewayNodes: outputs.GetVpcsV2VpcExternalSubnetActiveGatewayNode[];
    externalIps: outputs.GetVpcsV2VpcExternalSubnetExternalIp[];
    gatewayNodes: string[];
    subnetReference: string;
}

export interface GetVpcsV2VpcExternalSubnetActiveGatewayNode {
    nodeId: string;
    nodeIpAddresses: outputs.GetVpcsV2VpcExternalSubnetActiveGatewayNodeNodeIpAddress[];
}

export interface GetVpcsV2VpcExternalSubnetActiveGatewayNodeNodeIpAddress {
    ipv4s: outputs.GetVpcsV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4[];
    ipv6s: outputs.GetVpcsV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6[];
}

export interface GetVpcsV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4 {
    prefixLength: number;
    value: string;
}

export interface GetVpcsV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6 {
    prefixLength: number;
    value: string;
}

export interface GetVpcsV2VpcExternalSubnetExternalIp {
    ipv4s: outputs.GetVpcsV2VpcExternalSubnetExternalIpIpv4[];
    ipv6s: outputs.GetVpcsV2VpcExternalSubnetExternalIpIpv6[];
}

export interface GetVpcsV2VpcExternalSubnetExternalIpIpv4 {
    prefixLength: number;
    value: string;
}

export interface GetVpcsV2VpcExternalSubnetExternalIpIpv6 {
    prefixLength: number;
    value: string;
}

export interface GetVpcsV2VpcExternallyRoutablePrefix {
    ipv4s: outputs.GetVpcsV2VpcExternallyRoutablePrefixIpv4[];
    ipv6s: outputs.GetVpcsV2VpcExternallyRoutablePrefixIpv6[];
}

export interface GetVpcsV2VpcExternallyRoutablePrefixIpv4 {
    ips: outputs.GetVpcsV2VpcExternallyRoutablePrefixIpv4Ip[];
    prefixLength: number;
}

export interface GetVpcsV2VpcExternallyRoutablePrefixIpv4Ip {
    prefixLength: number;
    value: string;
}

export interface GetVpcsV2VpcExternallyRoutablePrefixIpv6 {
    ips: outputs.GetVpcsV2VpcExternallyRoutablePrefixIpv6Ip[];
    prefixLength: number;
}

export interface GetVpcsV2VpcExternallyRoutablePrefixIpv6Ip {
    prefixLength: number;
    value: string;
}

export interface GetVpcsV2VpcLink {
    href: string;
    rel: string;
}

export interface GetVpcsV2VpcMetadata {
    categoryIds: any[][];
    ownerReferenceId: string;
    ownerUserName: string;
    projectName: string;
    projectReferenceId: string;
}

export interface GetVpcsV2VpcSnatIp {
    ipv4s: outputs.GetVpcsV2VpcSnatIpIpv4[];
    ipv6s: outputs.GetVpcsV2VpcSnatIpIpv6[];
}

export interface GetVpcsV2VpcSnatIpIpv4 {
    prefixLength: number;
    value: string;
}

export interface GetVpcsV2VpcSnatIpIpv6 {
    prefixLength: number;
    value: string;
}

export interface ImageCategory {
    /**
     * - (Required) The name for the image.
     */
    name: string;
    value: string;
}

export interface ImageClusterReference {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Required) The name for the image.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface ImageCurrentClusterReferenceList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Required) The name for the image.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface ImagePlacementPolicyV2ClusterEntityFilter {
    /**
     * Array of strings
     *
     *
     * See detailed information in [Nutanix Create Image Placement Policies V4](https://developers.nutanix.com/api-reference?namespace=vmm&version=v4.0#tag/ImagePlacementPolicies/operation/createPlacementPolicy)
     */
    categoryExtIds: string[];
    /**
     * Filter matching type. Valid values "CATEGORIES_MATCH_ALL", "CATEGORIES_MATCH_ANY"
     */
    type: string;
}

export interface ImagePlacementPolicyV2ImageEntityFilter {
    /**
     * Array of strings
     */
    categoryExtIds: string[];
    /**
     * Filter matching type. Valid values "CATEGORIES_MATCH_ALL", "CATEGORIES_MATCH_ANY"
     */
    type: string;
}

export interface ImagesV2Checksum {
    hexDigest: string;
    objectType: string;
}

export interface ImagesV2PlacementPolicyStatus {
    complianceStatus: string;
    conflictingPolicyExtIds: string[];
    enforcedClusterExtIds: string[];
    enforcementMode: string;
    placementPolicyExtId: string;
    policyClusterExtIds: string[];
}

export interface ImagesV2Source {
    objectLiteSources?: outputs.ImagesV2SourceObjectLiteSource[];
    urlSources?: outputs.ImagesV2SourceUrlSource[];
    vmDiskSources?: outputs.ImagesV2SourceVmDiskSource[];
}

export interface ImagesV2SourceObjectLiteSource {
    key: string;
}

export interface ImagesV2SourceUrlSource {
    basicAuths?: outputs.ImagesV2SourceUrlSourceBasicAuth[];
    shouldAllowInsecureUrl?: boolean;
    url: string;
}

export interface ImagesV2SourceUrlSourceBasicAuth {
    password: string;
    username: string;
}

export interface ImagesV2SourceVmDiskSource {
    extId: string;
}

export interface KarbonClusterActivePassiveConfig {
    externalIpv4Address: string;
}

export interface KarbonClusterCniConfig {
    /**
     * - (Optional) Configuration of the calico CNI provider.
     * * `calico_config.ip_pool_config`: - (Optional) List of IP pools to be configured/managed by calico.
     * * `calico_config.ip_pool_config.cidr`: - (Optional) IP range to use for this pool, it should fall within pod cidr.
     */
    calicoConfig?: outputs.KarbonClusterCniConfigCalicoConfig;
    /**
     * - (Optional) Configuration of the flannel container network interface (CNI) provider.
     */
    flannelConfigs?: outputs.KarbonClusterCniConfigFlannelConfig[];
    /**
     * - (Optional) The size of the subnet from the podIpv4Cidr assigned to each host. A value of 24 would allow up to 255 pods per node.
     */
    nodeCidrMaskSize?: number;
    /**
     * - (Optional) CIDR for pods in the cluster.
     */
    podIpv4Cidr?: string;
    /**
     * - (Optional) Classless inter-domain routing (CIDR) for k8s services in the cluster.
     */
    serviceIpv4Cidr?: string;
}

export interface KarbonClusterCniConfigCalicoConfig {
    ipPoolConfigs?: outputs.KarbonClusterCniConfigCalicoConfigIpPoolConfig[];
}

export interface KarbonClusterCniConfigCalicoConfigIpPoolConfig {
    cidr?: string;
}

export interface KarbonClusterCniConfigFlannelConfig {
}

export interface KarbonClusterEtcdNodePool {
    /**
     * - (Optional) VM configuration in AHV. **Note:** Updates to this attribute forces new resource creation.
     * * `ahv_config.cpu`: - (Required) The number of VCPUs allocated for each VM on the PE cluster.
     * * `ahv_config.disk_mib`: - (Optional) Size of local storage for each VM on the PE cluster in MiB.
     * * `ahv_config.memory_mib`: - (Optional) Memory allocated for each VM on the PE cluster in MiB.
     * * `ahv_config.network_uuid`: - (Required) The UUID of the network for the VMs deployed with this resource configuration.
     * * `ahv_config.prism_element_cluster_uuid`: - (Required) The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
     */
    ahvConfig?: outputs.KarbonClusterEtcdNodePoolAhvConfig;
    /**
     * - (Optional) Unique name of the node pool. **Note:** Updates to this attribute forces new resource creation.
     */
    name?: string;
    /**
     * - (Required) The version of the node OS image. **Note:** Updates to this attribute forces new resource creation.
     */
    nodeOsVersion: string;
    /**
     * - List of the deployed nodes in the node pool.
     * * `nodes.hostname`: - Hostname of the deployed node.
     * * `nodes.ipv4_address`: - IP of the deployed node.
     */
    nodes: outputs.KarbonClusterEtcdNodePoolNode[];
    /**
     * - (Required) Number of nodes in the node pool. **Note:** Updates to etcd or master node pool forces new resource creation.
     */
    numInstances: number;
}

export interface KarbonClusterEtcdNodePoolAhvConfig {
    cpu?: number;
    diskMib?: number;
    memoryMib?: number;
    networkUuid: string;
    prismElementClusterUuid: string;
}

export interface KarbonClusterEtcdNodePoolNode {
    hostname: string;
    ipv4Address: string;
}

export interface KarbonClusterExternalLbConfig {
    externalIpv4Address: string;
    masterNodesConfigs: outputs.KarbonClusterExternalLbConfigMasterNodesConfig[];
}

export interface KarbonClusterExternalLbConfigMasterNodesConfig {
    ipv4Address: string;
    nodePoolName?: string;
}

export interface KarbonClusterMasterNodePool {
    /**
     * - (Optional) VM configuration in AHV. **Note:** Updates to this attribute forces new resource creation.
     * * `ahv_config.cpu`: - (Required) The number of VCPUs allocated for each VM on the PE cluster.
     * * `ahv_config.disk_mib`: - (Optional) Size of local storage for each VM on the PE cluster in MiB.
     * * `ahv_config.memory_mib`: - (Optional) Memory allocated for each VM on the PE cluster in MiB.
     * * `ahv_config.network_uuid`: - (Required) The UUID of the network for the VMs deployed with this resource configuration.
     * * `ahv_config.prism_element_cluster_uuid`: - (Required) The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
     */
    ahvConfig?: outputs.KarbonClusterMasterNodePoolAhvConfig;
    /**
     * - (Optional) Unique name of the node pool. **Note:** Updates to this attribute forces new resource creation.
     */
    name?: string;
    /**
     * - (Required) The version of the node OS image. **Note:** Updates to this attribute forces new resource creation.
     */
    nodeOsVersion: string;
    /**
     * - List of the deployed nodes in the node pool.
     * * `nodes.hostname`: - Hostname of the deployed node.
     * * `nodes.ipv4_address`: - IP of the deployed node.
     */
    nodes: outputs.KarbonClusterMasterNodePoolNode[];
    /**
     * - (Required) Number of nodes in the node pool. **Note:** Updates to etcd or master node pool forces new resource creation.
     */
    numInstances: number;
}

export interface KarbonClusterMasterNodePoolAhvConfig {
    cpu?: number;
    diskMib?: number;
    memoryMib?: number;
    networkUuid: string;
    prismElementClusterUuid: string;
}

export interface KarbonClusterMasterNodePoolNode {
    hostname: string;
    ipv4Address: string;
}

export interface KarbonClusterPrivateRegistry {
    registryName: string;
}

export interface KarbonClusterSingleMasterConfig {
}

export interface KarbonClusterStorageClassConfig {
    /**
     * - (Required) The name of the storage class.
     */
    name?: string;
    /**
     * Reclaim policy for persistent volumes provisioned using the specified storage class.
     * * `volumes_config.#.file_system` - (Optional) Karbon uses either the ext4 or xfs file-system on the volume disk.
     * * `volumes_config.#.flash_mode` - (Optional) Pins the persistent volumes to the flash tier in case of a `true` value.
     * * `volumes_config.#.password` - (Required) The password of the Prism Element user that the API calls use to provision volumes.
     * * `volumes_config.#.prism_element_cluster_uuid` - (Required) The universally unique identifier (UUID) of the Prism Element cluster.
     * * `volumes_config.#.storage_container` - (Required) Name of the storage container the storage container uses to provision volumes.
     * * `volumes_config.#.username` - (Required) Username of the Prism Element user that the API calls use to provision volumes.
     *
     * **Note:** Updates to this attribute forces new resource creation.
     */
    reclaimPolicy?: string;
    volumesConfig: outputs.KarbonClusterStorageClassConfigVolumesConfig;
}

export interface KarbonClusterStorageClassConfigVolumesConfig {
    fileSystem?: string;
    flashMode?: boolean;
    password: string;
    prismElementClusterUuid: string;
    storageContainer: string;
    username: string;
}

export interface KarbonClusterWorkerNodePool {
    /**
     * - (Optional) VM configuration in AHV. **Note:** Updates to this attribute forces new resource creation.
     * * `ahv_config.cpu`: - (Required) The number of VCPUs allocated for each VM on the PE cluster.
     * * `ahv_config.disk_mib`: - (Optional) Size of local storage for each VM on the PE cluster in MiB.
     * * `ahv_config.memory_mib`: - (Optional) Memory allocated for each VM on the PE cluster in MiB.
     * * `ahv_config.network_uuid`: - (Required) The UUID of the network for the VMs deployed with this resource configuration.
     * * `ahv_config.prism_element_cluster_uuid`: - (Required) The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
     */
    ahvConfig?: outputs.KarbonClusterWorkerNodePoolAhvConfig;
    /**
     * - (Optional) Unique name of the node pool. **Note:** Updates to this attribute forces new resource creation.
     */
    name?: string;
    /**
     * - (Required) The version of the node OS image. **Note:** Updates to this attribute forces new resource creation.
     */
    nodeOsVersion: string;
    /**
     * - List of the deployed nodes in the node pool.
     * * `nodes.hostname`: - Hostname of the deployed node.
     * * `nodes.ipv4_address`: - IP of the deployed node.
     */
    nodes: outputs.KarbonClusterWorkerNodePoolNode[];
    /**
     * - (Required) Number of nodes in the node pool. **Note:** Updates to etcd or master node pool forces new resource creation.
     */
    numInstances: number;
}

export interface KarbonClusterWorkerNodePoolAhvConfig {
    cpu?: number;
    diskMib?: number;
    memoryMib?: number;
    networkUuid: string;
    prismElementClusterUuid: string;
}

export interface KarbonClusterWorkerNodePoolNode {
    hostname: string;
    ipv4Address: string;
}

export interface KarbonWorkerNodepoolAhvConfig {
    /**
     * - (Required) The number of VCPUs allocated for each VM on the PE cluster.
     */
    cpu?: number;
    /**
     * - (Optional) Size of local storage for each VM on the PE cluster in MiB.
     */
    diskMib?: number;
    /**
     * VM network UUID for isolating iscsi data traffic.
     */
    iscsiNetworkUuid: string;
    /**
     * - (Optional) Memory allocated for each VM on the PE cluster in MiB.
     */
    memoryMib?: number;
    /**
     * - (Required) The UUID of the network for the VMs deployed with this resource configuration.
     */
    networkUuid: string;
    /**
     * - (Optional) The unique universal identifier (UUID) of the Prism Element
     */
    prismElementClusterUuid: string;
}

export interface KarbonWorkerNodepoolNode {
    /**
     * hostname of node
     */
    hostname: string;
    /**
     * ipv4 address of node
     */
    ipv4Address: string;
}

export interface LcmPrechecksV2EntityUpdateSpec {
    /**
     * UUID of the LCM entity.
     */
    entityUuid: string;
    /**
     * Version to upgrade to.
     *
     * See detailed information in [Nutanix LCM Prechecks v4](https://developers.nutanix.com/api-reference?namespace=lifecycle&version=v4.0#tag/Prechecks/operation/performPrechecks)
     */
    toVersion: string;
}

export interface LcmPrechecksV2ManagementServer {
    /**
     * Type of Hypervisor present in the cluster. Enum Values:
     * * "HYPERV" : Hyper-V Hypervisor.
     * * "ESX" : ESX Hypervisor.
     * * "AHV" : Nutanix AHV Hypervisor.
     */
    hypervisorType: string;
    /**
     * IP address of the management server.
     */
    ip: string;
    /**
     * Password to login to the management server.
     */
    password: string;
    /**
     * Username to login to the management server.
     */
    username: string;
}

export interface LcmUpgradeV2EntityUpdateSpec {
    /**
     * UUID of the LCM entity.
     */
    entityUuid: string;
    /**
     * Version to upgrade to.
     *
     *
     * See detailed information in [Nutanix LCM Upgrade v4](https://developers.nutanix.com/api-reference?namespace=lifecycle&version=v4.0#tag/Upgrades/operation/performUpgrade).
     */
    toVersion: string;
}

export interface LcmUpgradeV2ManagementServer {
    /**
     * Type of Hypervisor present in the cluster. Enum Values:
     * * "HYPERV" : Hyper-V Hypervisor.
     * * "ESX" : ESX Hypervisor.
     * * "AHV" : Nutanix AHV Hypervisor.
     */
    hypervisorType: string;
    /**
     * IP address of the management server.
     */
    ip: string;
    /**
     * Password to login to the management server.
     */
    password: string;
    /**
     * Username to login to the management server.
     */
    username: string;
}

export interface NdbCloneActionargument {
    /**
     * - (Required) name of argument
     */
    name: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbCloneDatabaseNode {
    accessLevel: {[key: string]: string};
    databaseId: string;
    databaseStatus: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    dbserver: {[key: string]: string};
    /**
     * Specify if you want to create a database server. This value can be set to true or false as required.
     */
    dbserverId: string;
    /**
     * database instance description
     */
    description: string;
    id: string;
    /**
     * info of clone
     */
    infos: outputs.NdbCloneDatabaseNodeInfo[];
    /**
     * database instance name
     */
    name: string;
    primary: boolean;
    /**
     * List of all the properties
     */
    properties: outputs.NdbCloneDatabaseNodeProperty[];
    protectionDomainId: string;
    protectionDomains: outputs.NdbCloneDatabaseNodeProtectionDomain[];
    softwareInstallationId: string;
    /**
     * status of clone
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.NdbCloneDatabaseNodeTag[];
}

export interface NdbCloneDatabaseNodeInfo {
    /**
     * info of clone
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbCloneDatabaseNodeProperty {
    /**
     * database instance description
     */
    description: string;
    /**
     * database instance name
     */
    name: string;
    refId: string;
    secure: boolean;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbCloneDatabaseNodeProtectionDomain {
    assocEntities: string[];
    cloudId: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * database instance description
     */
    description: string;
    eraCreated: boolean;
    id: string;
    /**
     * database instance name
     */
    name: string;
    ownerId: string;
    primaryHost: string;
    /**
     * List of all the properties
     */
    properties: outputs.NdbCloneDatabaseNodeProtectionDomainProperty[];
    /**
     * status of clone
     */
    status: string;
    /**
     * type of clone
     */
    type: string;
}

export interface NdbCloneDatabaseNodeProtectionDomainProperty {
    /**
     * database instance description
     */
    description: string;
    /**
     * database instance name
     */
    name: string;
    refId: string;
    secure: boolean;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbCloneDatabaseNodeTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbCloneInfo {
    bpgConfigs: outputs.NdbCloneInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface NdbCloneInfoBpgConfig {
    bpgDbParams: outputs.NdbCloneInfoBpgConfigBpgDbParam[];
    storages: outputs.NdbCloneInfoBpgConfigStorage[];
    vmProperties: outputs.NdbCloneInfoBpgConfigVmProperty[];
}

export interface NdbCloneInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface NdbCloneInfoBpgConfigStorage {
    archiveStorages: outputs.NdbCloneInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.NdbCloneInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.NdbCloneInfoBpgConfigStorageLogDisk[];
}

export interface NdbCloneInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface NdbCloneInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface NdbCloneInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface NdbCloneInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface NdbCloneLcmConfig {
    databaseLcmConfigs?: outputs.NdbCloneLcmConfigDatabaseLcmConfig[];
}

export interface NdbCloneLcmConfigDatabaseLcmConfig {
    expiryDetails?: outputs.NdbCloneLcmConfigDatabaseLcmConfigExpiryDetail[];
    refreshDetails?: outputs.NdbCloneLcmConfigDatabaseLcmConfigRefreshDetail[];
}

export interface NdbCloneLcmConfigDatabaseLcmConfigExpiryDetail {
    deleteDatabase?: boolean;
    expireInDays?: number;
    expiryDateTimezone: string;
}

export interface NdbCloneLcmConfigDatabaseLcmConfigRefreshDetail {
    refreshDateTimezone?: string;
    refreshInDays?: number;
    refreshTime?: string;
}

export interface NdbCloneLinkedDatabase {
    /**
     * database name
     */
    databaseName: string;
    databaseStatus: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * database instance description
     */
    description: string;
    id: string;
    /**
     * info of clone
     */
    infos: outputs.NdbCloneLinkedDatabaseInfo[];
    /**
     * Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
     */
    metric: {[key: string]: string};
    /**
     * database instance name
     */
    name: string;
    parentDatabaseId: string;
    parentLinkedDatabaseId: string;
    /**
     * snapshot id from where clone is created
     */
    snapshotId: string;
    /**
     * status of clone
     */
    status: string;
    timezone: string;
}

export interface NdbCloneLinkedDatabaseInfo {
    /**
     * info of clone
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbCloneNode {
    /**
     * specify compute profile id
     */
    computeProfileId?: string;
    /**
     * dberver id
     */
    dbserverId?: string;
    /**
     * specify network profile id
     */
    networkProfileId?: string;
    /**
     * dbserver time zone
     */
    newDbServerTimeZone?: string;
    /**
     * cluster id
     */
    nxClusterId?: string;
    /**
     * properties of vm
     */
    properties?: outputs.NdbCloneNodeProperty[];
    /**
     * name for the database server VM.
     */
    vmName?: string;
}

export interface NdbCloneNodeProperty {
    /**
     * database instance name
     */
    name?: string;
    /**
     * - (Required) value for argument
     */
    value?: string;
}

export interface NdbClonePostgresqlInfo {
    /**
     * password of the postgres superuser.
     */
    dbPassword: string;
    /**
     * description for the dbserver.
     */
    dbserverDescription?: string;
    /**
     * OS command that you want to run after the instance is created.
     */
    postCloneCmd?: string;
    /**
     * OS command that you want to run before the instance is created.
     */
    preCloneCmd?: string;
    /**
     * name for the database server VM.
     */
    vmName: string;
}

export interface NdbCloneProperty {
    /**
     * database instance name
     */
    name: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbCloneTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbCloneTimeMachine {
    accessLevel: string;
    /**
     * cloned or not
     */
    clone: boolean;
    clones: string;
    /**
     * clone will be clustered or not
     */
    clustered: boolean;
    database: string;
    databaseId: string;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * database instance description
     */
    description: string;
    eaStatus: string;
    id: string;
    /**
     * Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
     */
    metric: string;
    /**
     * database instance name
     */
    name: string;
    /**
     * List of all the properties
     */
    properties: outputs.NdbCloneTimeMachineProperty[];
    scheduleId: string;
    schedules: outputs.NdbCloneTimeMachineSchedule[];
    scope: string;
    slaId: string;
    slaUpdateInProgress: boolean;
    slaUpdateMetadata: string;
    slas: outputs.NdbCloneTimeMachineSla[];
    sourceNxClusters: string[];
    /**
     * status of clone
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.NdbCloneTimeMachineTag[];
    /**
     * type of clone
     */
    type: string;
}

export interface NdbCloneTimeMachineProperty {
    /**
     * database instance description
     */
    description: string;
    /**
     * database instance name
     */
    name: string;
    refId: string;
    secure: boolean;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbCloneTimeMachineSchedule {
    continuousSchedules: outputs.NdbCloneTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.NdbCloneTimeMachineScheduleDailySchedule[];
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * database instance description
     */
    description: string;
    globalPolicy: boolean;
    id: string;
    monthlySchedules: outputs.NdbCloneTimeMachineScheduleMonthlySchedule[];
    /**
     * database instance name
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.NdbCloneTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.NdbCloneTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    /**
     * timezone
     */
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.NdbCloneTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.NdbCloneTimeMachineScheduleYearlySchedule[];
}

export interface NdbCloneTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface NdbCloneTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface NdbCloneTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface NdbCloneTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface NdbCloneTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface NdbCloneTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface NdbCloneTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface NdbCloneTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    /**
     * date created for clone
     */
    dateCreated: string;
    /**
     * last modified date for clone
     */
    dateModified: string;
    /**
     * database instance description
     */
    description: string;
    id: string;
    monthlyRetention: number;
    /**
     * database instance name
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface NdbCloneTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbClusterAgentNetworkInfo {
    /**
     * string of DNS servers(comma separted).
     */
    dns?: string;
    /**
     * string of NTP servers(comma separted).
     */
    ntp?: string;
}

export interface NdbClusterEntityCount {
    dbServers: number;
    engineCounts: outputs.NdbClusterEntityCountEngineCount[];
}

export interface NdbClusterEntityCountEngineCount {
    mariadbDatabases: outputs.NdbClusterEntityCountEngineCountMariadbDatabase[];
    mongodbDatabases: outputs.NdbClusterEntityCountEngineCountMongodbDatabase[];
    mysqlDatabases: outputs.NdbClusterEntityCountEngineCountMysqlDatabase[];
    oracleDatabases: outputs.NdbClusterEntityCountEngineCountOracleDatabase[];
    postgresDatabases: outputs.NdbClusterEntityCountEngineCountPostgresDatabase[];
    saphanaDatabases: outputs.NdbClusterEntityCountEngineCountSaphanaDatabase[];
    sqlserverDatabases: outputs.NdbClusterEntityCountEngineCountSqlserverDatabase[];
}

export interface NdbClusterEntityCountEngineCountMariadbDatabase {
    profiles: outputs.NdbClusterEntityCountEngineCountMariadbDatabaseProfile[];
    timeMachines: number;
}

export interface NdbClusterEntityCountEngineCountMariadbDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface NdbClusterEntityCountEngineCountMongodbDatabase {
    profiles: outputs.NdbClusterEntityCountEngineCountMongodbDatabaseProfile[];
    timeMachines: number;
}

export interface NdbClusterEntityCountEngineCountMongodbDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface NdbClusterEntityCountEngineCountMysqlDatabase {
    profiles: outputs.NdbClusterEntityCountEngineCountMysqlDatabaseProfile[];
    timeMachines: number;
}

export interface NdbClusterEntityCountEngineCountMysqlDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface NdbClusterEntityCountEngineCountOracleDatabase {
    profiles: outputs.NdbClusterEntityCountEngineCountOracleDatabaseProfile[];
    timeMachines: number;
}

export interface NdbClusterEntityCountEngineCountOracleDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface NdbClusterEntityCountEngineCountPostgresDatabase {
    profiles: outputs.NdbClusterEntityCountEngineCountPostgresDatabaseProfile[];
    timeMachines: number;
}

export interface NdbClusterEntityCountEngineCountPostgresDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface NdbClusterEntityCountEngineCountSaphanaDatabase {
    profiles: outputs.NdbClusterEntityCountEngineCountSaphanaDatabaseProfile[];
    timeMachines: number;
}

export interface NdbClusterEntityCountEngineCountSaphanaDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface NdbClusterEntityCountEngineCountSqlserverDatabase {
    profiles: outputs.NdbClusterEntityCountEngineCountSqlserverDatabaseProfile[];
    timeMachines: number;
}

export interface NdbClusterEntityCountEngineCountSqlserverDatabaseProfile {
    compute: number;
    databaseParameter: number;
    network: number;
    software: number;
    storage: number;
    windowsDomain: number;
}

export interface NdbClusterNetworksInfo {
    /**
     * VLAN access types for which you want to configure network segmentation. Supports [PRISM, DSIP, DBSERVER ]. 
     * Prism Element: Select this VLAN access type to configure a VLAN that the NDB agent VM can use to communicate with Prism.
     * Prism iSCSI Data Service. Select this VLAN access type to configure a VLAN that the agent VM can use to make connection requests to the iSCSI data services IP.
     * DBServer Access from NDB server. Select this VLAN access type to configure a VLAN that is used for communications between the NDB agent VM and the database server VM on the newly registered NDB server cluster.
     */
    accessTypes?: string[];
    /**
     * network segmentation to segment the network traffic
     */
    networkInfos?: outputs.NdbClusterNetworksInfoNetworkInfo[];
    /**
     * type of vlan. Supported [DHCP, Static, IPAM]
     */
    type?: string;
}

export interface NdbClusterNetworksInfoNetworkInfo {
    /**
     * gateway of agent network
     */
    gateway?: string;
    /**
     * static ip of agent network
     */
    staticIp?: string;
    /**
     * subnet mask of agent network
     */
    subnetMask?: string;
    /**
     * vlan name
     */
    vlanName?: string;
}

export interface NdbClusterProperty {
    /**
     * description of cluster
     */
    description: string;
    /**
     * name of the cluster to be registered
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbClusterResourceConfig {
    memoryThresholdPercentage: number;
    storageThresholdPercentage: number;
}

export interface NdbDatabaseActionargument {
    /**
     * - (Required) name of argument
     */
    name: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbDatabaseClusterInfo {
    clusterIpInfos: outputs.NdbDatabaseClusterInfoClusterIpInfo[];
}

export interface NdbDatabaseClusterInfoClusterIpInfo {
    /**
     * - (Optional) IP infos for custom network profile.
     */
    ipInfos?: outputs.NdbDatabaseClusterInfoClusterIpInfoIpInfo[];
    /**
     * - (Optional) cluster id.
     */
    nxClusterId: string;
}

export interface NdbDatabaseClusterInfoClusterIpInfoIpInfo {
    ipAddresses?: string[];
    ipType?: string;
}

export interface NdbDatabaseDatabaseNode {
    accessLevel: {[key: string]: string};
    databaseId: string;
    databaseStatus: string;
    dateCreated: string;
    dateModified: string;
    dbserver: {[key: string]: string};
    dbserverId: string;
    /**
     * - (Optional) The description
     */
    description: string;
    id: string;
    infos: outputs.NdbDatabaseDatabaseNodeInfo[];
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    primary: boolean;
    /**
     * List of all the properties
     */
    properties: outputs.NdbDatabaseDatabaseNodeProperty[];
    protectionDomainId: string;
    protectionDomains: outputs.NdbDatabaseDatabaseNodeProtectionDomain[];
    softwareInstallationId: string;
    status: string;
    /**
     * - (Optional) tags
     */
    tags: outputs.NdbDatabaseDatabaseNodeTag[];
}

export interface NdbDatabaseDatabaseNodeInfo {
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbDatabaseDatabaseNodeProperty {
    /**
     * - (Optional) The description
     */
    description: string;
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    refId: string;
    secure: boolean;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbDatabaseDatabaseNodeProtectionDomain {
    assocEntities: string[];
    cloudId: string;
    dateCreated: string;
    dateModified: string;
    /**
     * - (Optional) The description
     */
    description: string;
    eraCreated: boolean;
    id: string;
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    ownerId: string;
    primaryHost: string;
    /**
     * List of all the properties
     */
    properties: outputs.NdbDatabaseDatabaseNodeProtectionDomainProperty[];
    status: string;
    type: string;
}

export interface NdbDatabaseDatabaseNodeProtectionDomainProperty {
    /**
     * - (Optional) The description
     */
    description: string;
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    refId: string;
    secure: boolean;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbDatabaseDatabaseNodeTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbDatabaseInfo {
    bpgConfigs: outputs.NdbDatabaseInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface NdbDatabaseInfoBpgConfig {
    bpgDbParams: outputs.NdbDatabaseInfoBpgConfigBpgDbParam[];
    storages: outputs.NdbDatabaseInfoBpgConfigStorage[];
    vmProperties: outputs.NdbDatabaseInfoBpgConfigVmProperty[];
}

export interface NdbDatabaseInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface NdbDatabaseInfoBpgConfigStorage {
    archiveStorages: outputs.NdbDatabaseInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.NdbDatabaseInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.NdbDatabaseInfoBpgConfigStorageLogDisk[];
}

export interface NdbDatabaseInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface NdbDatabaseInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface NdbDatabaseInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface NdbDatabaseInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface NdbDatabaseLcmConfig {
    expiryDetails: outputs.NdbDatabaseLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.NdbDatabaseLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.NdbDatabaseLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.NdbDatabaseLcmConfigRefreshDetail[];
}

export interface NdbDatabaseLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    /**
     * - (Optional) Delete the database's Time Machine (snapshots/logs) from the NDB. Default value is true
     */
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface NdbDatabaseLcmConfigPostDeleteCommand {
    command: string;
}

export interface NdbDatabaseLcmConfigPreDeleteCommand {
    command: string;
}

export interface NdbDatabaseLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface NdbDatabaseLinkedDatabase {
    databaseName: string;
    databaseStatus: string;
    dateCreated: string;
    dateModified: string;
    /**
     * - (Optional) The description
     */
    description: string;
    id: string;
    infos: outputs.NdbDatabaseLinkedDatabaseInfo[];
    metric: {[key: string]: string};
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    parentDatabaseId: string;
    parentLinkedDatabaseId: string;
    snapshotId: string;
    status: string;
    timezone: string;
}

export interface NdbDatabaseLinkedDatabaseInfo {
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbDatabaseMaintenanceTasks {
    maintenanceWindowId?: string;
    tasks?: outputs.NdbDatabaseMaintenanceTasksTask[];
}

export interface NdbDatabaseMaintenanceTasksTask {
    postCommand?: string;
    preCommand?: string;
    taskType?: string;
}

export interface NdbDatabaseNode {
    /**
     * - (Optional) compute profile id
     */
    computeprofileid?: string;
    /**
     * - (Optional) Database server ID required for existing VM
     */
    dbserverid?: string;
    /**
     * - (Optional) IP infos for custom network profile.
     */
    ipInfos?: outputs.NdbDatabaseNodeIpInfo[];
    /**
     * - (Required) network profile ID
     */
    networkprofileid?: string;
    /**
     * - (Optional) cluster id.
     */
    nxClusterId?: string;
    /**
     * - (Optional) list of additional properties
     */
    properties?: outputs.NdbDatabaseNodeProperty[];
    /**
     * - (Required) name of vm
     */
    vmname: string;
}

export interface NdbDatabaseNodeIpInfo {
    ipAddresses?: string[];
    ipType?: string;
}

export interface NdbDatabaseNodeProperty {
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbDatabasePostgresqlInfo {
    /**
     * - (Optional) allocate huge page. Default: false
     */
    allocatePgHugepage?: boolean;
    /**
     * - (Optional) auth methods. Default: md5
     */
    authMethod?: string;
    /**
     * - (Optional) enable auto tuning of staging drive. Default: false
     */
    autoTuneStagingDrive?: boolean;
    /**
     * - (Optional) if clustered database. Default: false
     */
    clusterDatabase?: boolean;
    /**
     * - (Required) name of initial database to be created
     */
    databaseNames: string;
    /**
     * - (Required) initial database size
     */
    databaseSize: string;
    /**
     * - (Required) database instance password
     */
    dbPassword: string;
    /**
     * - (Optional) High Availability instance
     */
    haInstance?: outputs.NdbDatabasePostgresqlInfoHaInstance;
    /**
     * - (Required) listener port for database instance
     */
    listenerPort: string;
    /**
     * - (Optional) post instance create script
     */
    postCreateScript?: string;
    /**
     * - (Optional) pre instance create script
     */
    preCreateScript?: string;
}

export interface NdbDatabasePostgresqlInfoHaInstance {
    /**
     * - (Optional) archive wal expire days. Default is set to -1
     */
    archiveWalExpireDays?: number;
    /**
     * - (Optional) backup policy for instance. Default is "primaryOnly"
     */
    backupPolicy?: string;
    clusterDescription?: string;
    /**
     * - (Required) cluster name
     */
    clusterName: string;
    /**
     * - (Optional) HA proxy node. Default is set to false
     */
    deployHaproxy?: boolean;
    /**
     * - (Optional) enable peer auth . Default is set to false.
     */
    enablePeerAuth?: boolean;
    /**
     * - (Optional) enable synchronous mode. Default is set to true
     */
    enableSynchronousMode?: boolean;
    /**
     * - (Optional) failover mode of nodes.
     */
    failoverMode?: string;
    /**
     * - (Optional) node type of instance. Default is set to database
     */
    nodeType?: string;
    /**
     * - (Required) patroni cluster name
     */
    patroniClusterName: string;
    /**
     * - (Optional) provisional virtual ip. Default is set to true
     */
    provisionVirtualIp?: boolean;
    /**
     * -  (Required) proxy read port
     */
    proxyReadPort: string;
    /**
     * - (Required) proxy write port
     */
    proxyWritePort: string;
}

export interface NdbDatabaseProperty {
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbDatabaseRestoreDatabaseNode {
    accessLevel: {[key: string]: string};
    /**
     * database id
     */
    databaseId: string;
    databaseStatus: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    dbserver: {[key: string]: string};
    dbserverId: string;
    /**
     * description of database instance
     */
    description: string;
    id: string;
    /**
     * info of instance
     */
    infos: outputs.NdbDatabaseRestoreDatabaseNodeInfo[];
    /**
     * Name of database instance
     */
    name: string;
    primary: boolean;
    /**
     * properties of database created
     */
    properties: outputs.NdbDatabaseRestoreDatabaseNodeProperty[];
    protectionDomainId: string;
    protectionDomains: outputs.NdbDatabaseRestoreDatabaseNodeProtectionDomain[];
    softwareInstallationId: string;
    /**
     * status of instance
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.NdbDatabaseRestoreDatabaseNodeTag[];
}

export interface NdbDatabaseRestoreDatabaseNodeInfo {
    /**
     * info of instance
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbDatabaseRestoreDatabaseNodeProperty {
    /**
     * description of database instance
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbDatabaseRestoreDatabaseNodeProtectionDomain {
    assocEntities: string[];
    cloudId: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    eraCreated: boolean;
    id: string;
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    primaryHost: string;
    /**
     * properties of database created
     */
    properties: outputs.NdbDatabaseRestoreDatabaseNodeProtectionDomainProperty[];
    /**
     * status of instance
     */
    status: string;
    /**
     * type of database
     */
    type: string;
}

export interface NdbDatabaseRestoreDatabaseNodeProtectionDomainProperty {
    /**
     * description of database instance
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbDatabaseRestoreDatabaseNodeTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbDatabaseRestoreInfo {
    bpgConfigs: outputs.NdbDatabaseRestoreInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface NdbDatabaseRestoreInfoBpgConfig {
    bpgDbParams: outputs.NdbDatabaseRestoreInfoBpgConfigBpgDbParam[];
    storages: outputs.NdbDatabaseRestoreInfoBpgConfigStorage[];
    vmProperties: outputs.NdbDatabaseRestoreInfoBpgConfigVmProperty[];
}

export interface NdbDatabaseRestoreInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface NdbDatabaseRestoreInfoBpgConfigStorage {
    archiveStorages: outputs.NdbDatabaseRestoreInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.NdbDatabaseRestoreInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.NdbDatabaseRestoreInfoBpgConfigStorageLogDisk[];
}

export interface NdbDatabaseRestoreInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface NdbDatabaseRestoreInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface NdbDatabaseRestoreInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface NdbDatabaseRestoreInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface NdbDatabaseRestoreLcmConfig {
    expiryDetails: outputs.NdbDatabaseRestoreLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.NdbDatabaseRestoreLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.NdbDatabaseRestoreLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.NdbDatabaseRestoreLcmConfigRefreshDetail[];
}

export interface NdbDatabaseRestoreLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface NdbDatabaseRestoreLcmConfigPostDeleteCommand {
    command: string;
}

export interface NdbDatabaseRestoreLcmConfigPreDeleteCommand {
    command: string;
}

export interface NdbDatabaseRestoreLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface NdbDatabaseRestoreLinkedDatabase {
    /**
     * name of database
     */
    databaseName: string;
    databaseStatus: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    id: string;
    /**
     * info of instance
     */
    infos: outputs.NdbDatabaseRestoreLinkedDatabaseInfo[];
    /**
     * Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
     */
    metric: {[key: string]: string};
    /**
     * Name of database instance
     */
    name: string;
    /**
     * parent database id
     */
    parentDatabaseId: string;
    parentLinkedDatabaseId: string;
    /**
     * snapshot id from you want to use for restoring the instance
     */
    snapshotId: string;
    /**
     * status of instance
     */
    status: string;
    timezone: string;
}

export interface NdbDatabaseRestoreLinkedDatabaseInfo {
    /**
     * info of instance
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbDatabaseRestoreProperty {
    /**
     * Name of database instance
     */
    name: string;
    value: string;
}

export interface NdbDatabaseRestoreTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbDatabaseRestoreTimeMachine {
    accessLevel: string;
    /**
     * whether instance is cloned or not
     */
    clone: boolean;
    clones: string;
    clustered: boolean;
    database: string;
    /**
     * database id
     */
    databaseId: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    eaStatus: string;
    id: string;
    /**
     * Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
     */
    metric: string;
    /**
     * Name of database instance
     */
    name: string;
    /**
     * properties of database created
     */
    properties: outputs.NdbDatabaseRestoreTimeMachineProperty[];
    scheduleId: string;
    schedules: outputs.NdbDatabaseRestoreTimeMachineSchedule[];
    scope: string;
    slaId: string;
    slaUpdateInProgress: boolean;
    slaUpdateMetadata: string;
    slas: outputs.NdbDatabaseRestoreTimeMachineSla[];
    sourceNxClusters: string[];
    /**
     * status of instance
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.NdbDatabaseRestoreTimeMachineTag[];
    /**
     * type of database
     */
    type: string;
}

export interface NdbDatabaseRestoreTimeMachineProperty {
    /**
     * description of database instance
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbDatabaseRestoreTimeMachineSchedule {
    continuousSchedules: outputs.NdbDatabaseRestoreTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.NdbDatabaseRestoreTimeMachineScheduleDailySchedule[];
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    globalPolicy: boolean;
    id: string;
    monthlySchedules: outputs.NdbDatabaseRestoreTimeMachineScheduleMonthlySchedule[];
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.NdbDatabaseRestoreTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.NdbDatabaseRestoreTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    /**
     * timezone on which instance is created xw
     */
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.NdbDatabaseRestoreTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.NdbDatabaseRestoreTimeMachineScheduleYearlySchedule[];
}

export interface NdbDatabaseRestoreTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface NdbDatabaseRestoreTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface NdbDatabaseRestoreTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface NdbDatabaseRestoreTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface NdbDatabaseRestoreTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface NdbDatabaseRestoreTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface NdbDatabaseRestoreTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface NdbDatabaseRestoreTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    id: string;
    monthlyRetention: number;
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface NdbDatabaseRestoreTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbDatabaseScaleDatabaseNode {
    accessLevel: {[key: string]: string};
    databaseId: string;
    databaseStatus: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    dbserver: {[key: string]: string};
    dbserverId: string;
    /**
     * description of database instance
     */
    description: string;
    id: string;
    /**
     * info of instance
     */
    infos: outputs.NdbDatabaseScaleDatabaseNodeInfo[];
    /**
     * Name of database instance
     */
    name: string;
    primary: boolean;
    /**
     * properties of database created
     */
    properties: outputs.NdbDatabaseScaleDatabaseNodeProperty[];
    protectionDomainId: string;
    protectionDomains: outputs.NdbDatabaseScaleDatabaseNodeProtectionDomain[];
    softwareInstallationId: string;
    /**
     * status of instance
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.NdbDatabaseScaleDatabaseNodeTag[];
}

export interface NdbDatabaseScaleDatabaseNodeInfo {
    /**
     * info of instance
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbDatabaseScaleDatabaseNodeProperty {
    /**
     * description of database instance
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbDatabaseScaleDatabaseNodeProtectionDomain {
    assocEntities: string[];
    cloudId: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    eraCreated: boolean;
    id: string;
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    primaryHost: string;
    /**
     * properties of database created
     */
    properties: outputs.NdbDatabaseScaleDatabaseNodeProtectionDomainProperty[];
    /**
     * status of instance
     */
    status: string;
    /**
     * type of database
     */
    type: string;
}

export interface NdbDatabaseScaleDatabaseNodeProtectionDomainProperty {
    /**
     * description of database instance
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbDatabaseScaleDatabaseNodeTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbDatabaseScaleInfo {
    bpgConfigs: outputs.NdbDatabaseScaleInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface NdbDatabaseScaleInfoBpgConfig {
    bpgDbParams: outputs.NdbDatabaseScaleInfoBpgConfigBpgDbParam[];
    storages: outputs.NdbDatabaseScaleInfoBpgConfigStorage[];
    vmProperties: outputs.NdbDatabaseScaleInfoBpgConfigVmProperty[];
}

export interface NdbDatabaseScaleInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface NdbDatabaseScaleInfoBpgConfigStorage {
    archiveStorages: outputs.NdbDatabaseScaleInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.NdbDatabaseScaleInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.NdbDatabaseScaleInfoBpgConfigStorageLogDisk[];
}

export interface NdbDatabaseScaleInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface NdbDatabaseScaleInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface NdbDatabaseScaleInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface NdbDatabaseScaleInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface NdbDatabaseScaleLcmConfig {
    expiryDetails: outputs.NdbDatabaseScaleLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.NdbDatabaseScaleLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.NdbDatabaseScaleLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.NdbDatabaseScaleLcmConfigRefreshDetail[];
}

export interface NdbDatabaseScaleLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface NdbDatabaseScaleLcmConfigPostDeleteCommand {
    command: string;
}

export interface NdbDatabaseScaleLcmConfigPreDeleteCommand {
    command: string;
}

export interface NdbDatabaseScaleLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface NdbDatabaseScaleLinkedDatabase {
    /**
     * name of database
     */
    databaseName: string;
    databaseStatus: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    id: string;
    /**
     * info of instance
     */
    infos: outputs.NdbDatabaseScaleLinkedDatabaseInfo[];
    /**
     * Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
     */
    metric: {[key: string]: string};
    /**
     * Name of database instance
     */
    name: string;
    /**
     * parent database id
     */
    parentDatabaseId: string;
    parentLinkedDatabaseId: string;
    snapshotId: string;
    /**
     * status of instance
     */
    status: string;
    timezone: string;
}

export interface NdbDatabaseScaleLinkedDatabaseInfo {
    /**
     * info of instance
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbDatabaseScaleProperty {
    /**
     * Name of database instance
     */
    name: string;
    value: string;
}

export interface NdbDatabaseScaleTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbDatabaseScaleTimeMachine {
    accessLevel: string;
    /**
     * whether instance is cloned or not
     */
    clone: boolean;
    clones: string;
    clustered: boolean;
    database: string;
    databaseId: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    eaStatus: string;
    id: string;
    /**
     * Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
     */
    metric: string;
    /**
     * Name of database instance
     */
    name: string;
    /**
     * properties of database created
     */
    properties: outputs.NdbDatabaseScaleTimeMachineProperty[];
    scheduleId: string;
    schedules: outputs.NdbDatabaseScaleTimeMachineSchedule[];
    scope: string;
    slaId: string;
    slaUpdateInProgress: boolean;
    slaUpdateMetadata: string;
    slas: outputs.NdbDatabaseScaleTimeMachineSla[];
    sourceNxClusters: string[];
    /**
     * status of instance
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.NdbDatabaseScaleTimeMachineTag[];
    /**
     * type of database
     */
    type: string;
}

export interface NdbDatabaseScaleTimeMachineProperty {
    /**
     * description of database instance
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbDatabaseScaleTimeMachineSchedule {
    continuousSchedules: outputs.NdbDatabaseScaleTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.NdbDatabaseScaleTimeMachineScheduleDailySchedule[];
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    globalPolicy: boolean;
    id: string;
    monthlySchedules: outputs.NdbDatabaseScaleTimeMachineScheduleMonthlySchedule[];
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.NdbDatabaseScaleTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.NdbDatabaseScaleTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    /**
     * timezone on which instance is created xw
     */
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.NdbDatabaseScaleTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.NdbDatabaseScaleTimeMachineScheduleYearlySchedule[];
}

export interface NdbDatabaseScaleTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface NdbDatabaseScaleTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface NdbDatabaseScaleTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface NdbDatabaseScaleTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface NdbDatabaseScaleTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface NdbDatabaseScaleTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface NdbDatabaseScaleTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface NdbDatabaseScaleTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    id: string;
    monthlyRetention: number;
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface NdbDatabaseScaleTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbDatabaseSnapshotLcmConfig {
    expiryDetails: outputs.NdbDatabaseSnapshotLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.NdbDatabaseSnapshotLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.NdbDatabaseSnapshotLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.NdbDatabaseSnapshotLcmConfigRefreshDetail[];
}

export interface NdbDatabaseSnapshotLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    /**
     * Default is set to Asia/Calcutta
     */
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface NdbDatabaseSnapshotLcmConfigPostDeleteCommand {
    command: string;
}

export interface NdbDatabaseSnapshotLcmConfigPreDeleteCommand {
    command: string;
}

export interface NdbDatabaseSnapshotLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface NdbDatabaseSnapshotProperty {
    /**
     * description of snapshot
     */
    description: string;
    /**
     * Snapshot name. Default value is era_manual_snapshot.
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbDatabaseSnapshotTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbDatabaseTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbDatabaseTimeMachine {
    accessLevel: string;
    clone: boolean;
    clones: string;
    /**
     * - (Optional) If clustered database. Default: false
     */
    clustered: boolean;
    database: string;
    databaseId: string;
    dateCreated: string;
    dateModified: string;
    /**
     * - (Optional) The description
     */
    description: string;
    eaStatus: string;
    id: string;
    metric: string;
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    /**
     * List of all the properties
     */
    properties: outputs.NdbDatabaseTimeMachineProperty[];
    scheduleId: string;
    /**
     * - (Optional) schedule for snapshots
     */
    schedules: outputs.NdbDatabaseTimeMachineSchedule[];
    scope: string;
    slaId: string;
    slaUpdateInProgress: boolean;
    slaUpdateMetadata: string;
    slas: outputs.NdbDatabaseTimeMachineSla[];
    sourceNxClusters: string[];
    status: string;
    /**
     * - (Optional) tags
     */
    tags: outputs.NdbDatabaseTimeMachineTag[];
    type: string;
}

export interface NdbDatabaseTimeMachineProperty {
    /**
     * - (Optional) The description
     */
    description: string;
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    refId: string;
    secure: boolean;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbDatabaseTimeMachineSchedule {
    continuousSchedules: outputs.NdbDatabaseTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.NdbDatabaseTimeMachineScheduleDailySchedule[];
    dateCreated: string;
    dateModified: string;
    /**
     * - (Optional) The description
     */
    description: string;
    globalPolicy: boolean;
    id: string;
    monthlySchedules: outputs.NdbDatabaseTimeMachineScheduleMonthlySchedule[];
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.NdbDatabaseTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.NdbDatabaseTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.NdbDatabaseTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.NdbDatabaseTimeMachineScheduleYearlySchedule[];
}

export interface NdbDatabaseTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface NdbDatabaseTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface NdbDatabaseTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface NdbDatabaseTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface NdbDatabaseTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    /**
     * - (Required) hours
     */
    hours: number;
    /**
     * - (Required) minutes
     */
    minutes: number;
    /**
     * - (Required) seconds
     */
    seconds: number;
}

export interface NdbDatabaseTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface NdbDatabaseTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    /**
     * - (Required) month for snapshot
     */
    month: string;
    monthValue: string;
}

export interface NdbDatabaseTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    dateCreated: string;
    dateModified: string;
    /**
     * - (Optional) The description
     */
    description: string;
    id: string;
    monthlyRetention: number;
    /**
     * - (Required) Name of the instance.
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface NdbDatabaseTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbDatabaseTimemachineinfo {
    /**
     * - (Optional) enable auto tune log drive. Default: true
     */
    autotunelogdrive?: boolean;
    /**
     * - (Optional) description of time machine
     */
    description?: string;
    /**
     * - (Required) name of time machine
     */
    name: string;
    /**
     * - (Optional) schedule for snapshots
     */
    schedule: outputs.NdbDatabaseTimemachineinfoSchedule;
    /**
     * -  (optional) SLA details for HA instance
     */
    slaDetails?: outputs.NdbDatabaseTimemachineinfoSlaDetail[];
    /**
     * - (Optional) SLA ID for single instance
     */
    slaid?: string;
    /**
     * - (Optional) tags
     */
    tags: outputs.NdbDatabaseTimemachineinfoTag[];
}

export interface NdbDatabaseTimemachineinfoSchedule {
    /**
     * - (Optional) snapshot freq and log config
     */
    continuousschedule?: outputs.NdbDatabaseTimemachineinfoScheduleContinuousschedule;
    /**
     * - (Optional) monthly snapshot config
     */
    monthlyschedule?: outputs.NdbDatabaseTimemachineinfoScheduleMonthlyschedule;
    /**
     * - (Optional) quaterly snapshot config
     */
    quartelyschedule?: outputs.NdbDatabaseTimemachineinfoScheduleQuartelyschedule;
    /**
     * - (Optional) daily snapshot config
     */
    snapshottimeofday?: outputs.NdbDatabaseTimemachineinfoScheduleSnapshottimeofday;
    /**
     * - (Optional) weekly snapshot config
     */
    weeklyschedule?: outputs.NdbDatabaseTimemachineinfoScheduleWeeklyschedule;
    /**
     * - (Optional) yearly snapshot config
     */
    yearlyschedule?: outputs.NdbDatabaseTimemachineinfoScheduleYearlyschedule;
}

export interface NdbDatabaseTimemachineinfoScheduleContinuousschedule {
    /**
     * - (Required) to enable
     */
    enabled: boolean;
    /**
     * - (Required) log catchup interval for database
     */
    logbackupinterval: number;
    /**
     * - (Required) num of snapshots per day
     */
    snapshotsperday: number;
}

export interface NdbDatabaseTimemachineinfoScheduleMonthlyschedule {
    /**
     * - (Required) day of month to take snapshot
     */
    dayofmonth: number;
    /**
     * - (Required) to enable
     */
    enabled: boolean;
}

export interface NdbDatabaseTimemachineinfoScheduleQuartelyschedule {
    /**
     * - (Required) month's day for snapshot
     */
    dayofmonth: number;
    /**
     * - (Required) to enable
     */
    enabled: boolean;
    /**
     * - (Required) quarter start month
     */
    startmonth: string;
}

export interface NdbDatabaseTimemachineinfoScheduleSnapshottimeofday {
    /**
     * - (Required) hours
     */
    hours: number;
    /**
     * - (Required) minutes
     */
    minutes: number;
    /**
     * - (Required) seconds
     */
    seconds: number;
}

export interface NdbDatabaseTimemachineinfoScheduleWeeklyschedule {
    /**
     * - (Required) day of week to take snaphsot. Eg. "WEDNESDAY"
     */
    dayofweek: string;
    /**
     * - (Required) to enable
     */
    enabled: boolean;
}

export interface NdbDatabaseTimemachineinfoScheduleYearlyschedule {
    /**
     * - (Required) day of month to take snapshot
     */
    dayofmonth: number;
    /**
     * - (Required) to enable
     */
    enabled: boolean;
    /**
     * - (Required) month for snapshot
     */
    month: string;
}

export interface NdbDatabaseTimemachineinfoSlaDetail {
    /**
     * - (Required) primary sla details
     * * `primary_sla.sla_id` :- (Required) sla id
     * * `primary_sla.nx_cluster_ids` -: (Optioanl) cluster ids
     */
    primarySlas?: outputs.NdbDatabaseTimemachineinfoSlaDetailPrimarySla[];
}

export interface NdbDatabaseTimemachineinfoSlaDetailPrimarySla {
    nxClusterIds?: string[];
    /**
     * description of SLA ID.
     */
    slaId: string;
}

export interface NdbDatabaseTimemachineinfoTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbDbserverVmCredential {
    label?: string;
    password: string;
    username: string;
}

export interface NdbDbserverVmMaintenanceTasks {
    /**
     * Associate an existing maintenance window id. NDB starts OS patching or database patching as per the schedule defined in the maintenance window.
     */
    maintenanceWindowId?: string;
    /**
     * Tasks for the maintenance.
     * * `tasks.task_type`: use this option if you want NDB to perform database patching or OS patching automatically. Supports [ OS_PATCHING, DB_PATCHING ].
     * * `tasks.pre_command`: add pre (operating system and database patching) commands.
     * * `tasks.post_command`:add post (operating system and database patching) commands.
     */
    tasks?: outputs.NdbDbserverVmMaintenanceTasksTask[];
}

export interface NdbDbserverVmMaintenanceTasksTask {
    postCommand?: string;
    preCommand?: string;
    taskType?: string;
}

export interface NdbDbserverVmPostgresDatabase {
    /**
     * use SSH public keys to access the database server VM.
     */
    clientPublicKey?: string;
    /**
     * name for the database server VM.
     */
    vmName: string;
}

export interface NdbDbserverVmProperty {
    /**
     * name of the dbserver vm
     */
    name: string;
    value: string;
}

export interface NdbDbserverVmTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbLinkedDatabasesInfo {
    infos: outputs.NdbLinkedDatabasesInfoInfo[];
    secureInfo: {[key: string]: string};
}

export interface NdbLinkedDatabasesInfoInfo {
    createdBy: string;
}

export interface NdbMaintenanceTaskEntityTaskAssociation {
    /**
     * access level of tasks
     */
    accessLevel: string;
    /**
     * created date of task
     */
    dateCreated: string;
    /**
     * modified date of task
     */
    dateModified: string;
    /**
     * description of maintenance window
     */
    description: string;
    entity: string;
    /**
     * entity id
     */
    entityId: string;
    /**
     * type of the entity. i.e. DBSERVER
     */
    entityType: string;
    /**
     * id of maintenance window
     */
    id: string;
    /**
     * maintenance window id which has to be associated
     */
    maintenanceWindowId: string;
    /**
     * maintenance window owner id
     */
    maintenanceWindowOwnerId: string;
    /**
     * name of of maintenance window
     */
    name: string;
    /**
     * owner id of task
     */
    ownerId: string;
    /**
     * list of pre post commands of OS or DB task
     */
    payloads: outputs.NdbMaintenanceTaskEntityTaskAssociationPayload[];
    /**
     * properties of task
     */
    properties: outputs.NdbMaintenanceTaskEntityTaskAssociationProperty[];
    /**
     * status of task
     */
    status: string;
    /**
     * tags of task
     */
    tags: outputs.NdbMaintenanceTaskEntityTaskAssociationTag[];
    /**
     * type of the task. OS or DB
     */
    taskType: string;
}

export interface NdbMaintenanceTaskEntityTaskAssociationPayload {
    /**
     * Pre Post command of Task
     */
    prePostCommands: outputs.NdbMaintenanceTaskEntityTaskAssociationPayloadPrePostCommand[];
}

export interface NdbMaintenanceTaskEntityTaskAssociationPayloadPrePostCommand {
    /**
     * post command of task
     */
    postCommand: string;
    /**
     * pre command of task
     */
    preCommand: string;
}

export interface NdbMaintenanceTaskEntityTaskAssociationProperty {
    /**
     * name of of maintenance window
     */
    name: string;
    value: string;
}

export interface NdbMaintenanceTaskEntityTaskAssociationTag {
    /**
     * entity id
     */
    entityId: string;
    /**
     * type of the entity. i.e. DBSERVER
     */
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbMaintenanceTaskTask {
    /**
     * command that you want to run after patching the OS/DB
     */
    postCommand?: string;
    /**
     * command that you want to run before patching the OS/DB
     */
    preCommand?: string;
    /**
     * type of task. Supports [ "OS_PATCHING", "DB_PATCHING" ]
     */
    taskType?: string;
}

export interface NdbMaintenanceWindowEntityTaskAssoc {
    /**
     * access level
     */
    accessLevel: string;
    /**
     * created date of maintenance window
     */
    dateCreated: string;
    /**
     * modified date of maintenance window
     */
    dateModified: string;
    /**
     * Description for maintenance window
     */
    description: string;
    entity: string;
    entityId: string;
    entityType: string;
    id: string;
    maintenanceWindowId: string;
    maintenanceWindowOwnerId: string;
    /**
     * Name for the maintenance window.
     */
    name: string;
    /**
     * owner id of maintenance window
     */
    ownerId: string;
    payloads: outputs.NdbMaintenanceWindowEntityTaskAssocPayload[];
    /**
     * properties of maintenance window
     */
    properties: outputs.NdbMaintenanceWindowEntityTaskAssocProperty[];
    /**
     * status of maintennace window
     */
    status: string;
    /**
     * tags of maintenance window
     */
    tags: outputs.NdbMaintenanceWindowEntityTaskAssocTag[];
    taskType: string;
}

export interface NdbMaintenanceWindowEntityTaskAssocPayload {
    prePostCommands: outputs.NdbMaintenanceWindowEntityTaskAssocPayloadPrePostCommand[];
}

export interface NdbMaintenanceWindowEntityTaskAssocPayloadPrePostCommand {
    postCommand: string;
    preCommand: string;
}

export interface NdbMaintenanceWindowEntityTaskAssocProperty {
    /**
     * Name for the maintenance window.
     */
    name: string;
    value: string;
}

export interface NdbMaintenanceWindowEntityTaskAssocTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbMaintenanceWindowProperty {
    /**
     * Name for the maintenance window.
     */
    name: string;
    value: string;
}

export interface NdbMaintenanceWindowSchedule {
    /**
     * Day of the week to trigger maintenance window. Supports [ MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY ]
     */
    dayOfWeek: string;
    /**
     * duration in hours. Default is 2
     */
    duration: number;
    hour: number;
    minute: number;
    /**
     * Supported values [ MONTHLY, WEEKLY ]
     */
    recurrence: string;
    /**
     * start time for maintenance window to trigger
     */
    startTime?: string;
    threshold: string;
    /**
     * timezone . Default is Asia/Calcutta .
     */
    timezone: string;
    /**
     * week of the month. Supports [1, 2, 3, 4] .
     */
    weekOfMonth: number;
}

export interface NdbMaintenanceWindowTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbNetworkIpPool {
    addresses: outputs.NdbNetworkIpPoolAddress[];
    /**
     * ending IP address range for new database servers
     */
    endIp: string;
    id: string;
    modifiedBy: string;
    /**
     * starting IP address range for new database servers
     */
    startIp: string;
}

export interface NdbNetworkIpPoolAddress {
    ip: string;
    status: string;
}

export interface NdbNetworkPropertiesMap {
    vlanGateway: string;
    vlanPrimaryDns: string;
    vlanSecondaryDns: string;
    vlanSubnetMask: string;
}

export interface NdbNetworkProperty {
    /**
     * Name of the vlan to be attached in NDB
     */
    name: string;
    secure: boolean;
    value: string;
}

export interface NdbProfileClusterAvailability {
    dateCreated: string;
    dateModified: string;
    /**
     * cluster on which profile created
     */
    nxClusterId: string;
    ownerId: string;
    profileId: string;
    /**
     * status of profile
     */
    status: string;
}

export interface NdbProfileComputeProfile {
    /**
     * number of cores per vCPU for the database server VM.
     */
    corePerCpu?: string;
    /**
     * number of vCPUs for the database server VM.
     */
    cpus?: string;
    /**
     * amount of memory for the database server VM.
     */
    memorySize?: string;
}

export interface NdbProfileDatabaseParameterProfile {
    /**
     * Database parameters suuported for postgress.
     * * `postgres_database.max_connections`: (Optional) Determines the maximum number of concurrent connections to the database server. The default is set to 100
     * * `postgres_database.max_replication_slots`: (Optional) Specifies the maximum number of replication slots that the server can support. The default is zero. walLevel must be set to archive or higher to allow replication slots to be used. Setting it to a lower value than the number of currently existing replication slots will prevent the server from starting.
     * * `postgres_database.effective_io_concurrency`: (Optional) Sets the number of concurrent disk I/O operations that PostgreSQL expects can be executed simultaneously. Raising this value will increase the number of I/O operations that any individual PostgreSQL session attempts to initiate in parallel.
     * * `postgres_database.timezone`: (Optional) Sets the time zone for displaying and interpreting time stamps. Defult is UTC .
     * * `postgres_database.max_prepared_transactions`: (Optional) Sets the maximum number of transactions that can be in the prepared state simultaneously. Setting this parameter to zero (which is the default) disables the prepared-transaction feature.
     * * `postgres_database.max_locks_per_transaction`: (Optional) This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. Default is 64.
     * * `postgres_database.max_wal_senders`: (Optional) Specifies the maximum number of concurrent connections from standby servers or streaming base backup clients (i.e., the maximum number of simultaneously running WAL sender processes). The default is 10.
     * * `postgres_database.max_worker_processes`: (Optional) Sets the maximum number of background processes that the system can support. The default is 8.
     * * `postgres_database.min_wal_size`: (Optional) As long as WAL disk usage stays below this setting, old WAL files are always recycled for future use at a checkpoint, rather than removed. This can be used to ensure that enough WAL space is reserved to handle spikes in WAL usage, for example when running large batch jobs. The default is 80 MB.
     * * `postgres_database.max_wal_size`: (Optional) Maximum size to let the WAL grow to between automatic WAL checkpoints. The default is 1 GB
     * * `postgres_database.checkpoint_timeout`: (Optional) Sets the maximum time between automatic WAL checkpoints . High Value gives Good Performance, but takes More Recovery Time, Reboot time. can reduce the I/O load on your system, especially when using large values for shared_buffers. Default is 5min
     * * `postgres_database.autovacuum`: (Optional) Controls whether the server should run the autovacuum launcher daemon. This is on by default; however, trackCounts must also be enabled for autovacuum to work.
     * * `postgres_database.checkpoint_completion_target`: (Optional)
     * Specifies the target of checkpoint completion, as a fraction of total time between checkpoints. Time spent flushing dirty buffers during checkpoint, as fraction of checkpoint interval . Formula - (checkpoint_timeout - 2min) / checkpoint_timeout. The default is 0.5.
     * * `postgres_database.autovacuum_freeze_max_age`: (Optional) Age at which to autovacuum a table to prevent transaction ID wraparound. Default is 200000000
     * * `postgres_database.autovacuum_vacuum_threshold`: (Optional) Min number of row updates before vacuum. Minimum number of tuple updates or deletes prior to vacuum. Take value in KB. Default is 50 .
     * * `postgres_database.autovacuum_vacuum_scale_factor`: (Optional) Number of tuple updates or deletes prior to vacuum as a fraction of reltuples. Default is 0.2
     * * `postgres_database.autovacuum_work_mem`: (Optional) Sets the maximum memory to be used by each autovacuum worker process. Unit is in KB. Default is -1
     * * `postgres_database.autovacuum_max_workers`: (Optional) Sets the maximum number of simultaneously running autovacuum worker processes. Default is 3
     * * `postgres_database.autovacuum_vacuum_cost_delay`: (Optional) Vacuum cost delay in milliseconds, for autovacuum. Specifies the cost delay value that will be used in automatic VACUUM operation. Default is 2ms
     * * `postgres_database.wal_buffers`: (Optional)
     * Sets the number of disk-page buffers in shared memory for WAL. The amount of shared memory used for WAL data that has not yet been written to disk. The default is -1.
     * * `postgres_database.synchronous_commit`: (Optional) Sets the current transaction's synchronization level. Specifies whether transaction commit will wait for WAL records to be written to disk before the command returns a success indication to the client. Default is on.
     * * `postgres_database.random_page_cost`: (Optional) Sets the planner's estimate of the cost of a nonsequentially fetched disk page. Sets the planner's estimate of the cost of a non-sequentially-fetched disk page. The default is 4.0.
     * * `postgres_database.wal_keep_segments`: (Optional) Sets the number of WAL files held for standby servers, Specifies the minimum number of past log file segments kept in the pgWal directory. Default is 700 .
     */
    postgresDatabases?: outputs.NdbProfileDatabaseParameterProfilePostgresDatabase[];
}

export interface NdbProfileDatabaseParameterProfilePostgresDatabase {
    autovacuum?: string;
    autovacuumFreezeMaxAge?: string;
    autovacuumMaxWorkers?: string;
    autovacuumVacuumCostDelay?: string;
    autovacuumVacuumScaleFactor?: string;
    autovacuumVacuumThreshold?: string;
    autovacuumWorkMem?: string;
    checkpointCompletionTarget?: string;
    checkpointTimeout?: string;
    effectiveIoConcurrency?: string;
    maxConnections?: string;
    maxLocksPerTransaction?: string;
    maxPreparedTransactions?: string;
    maxReplicationSlots?: string;
    maxWalSenders?: string;
    maxWalSize?: string;
    maxWorkerProcesses?: string;
    minWalSize?: string;
    randomPageCost?: string;
    synchronousCommit?: string;
    timezone?: string;
    walBuffers?: string;
    walKeepSegments?: string;
}

export interface NdbProfileNetworkProfile {
    /**
     * Postgres Info to create network profile
     *
     * * `postgres_database.single_instance`: (Optional) Info for postgres database to create single instance network profile.
     * * `postgres_database.single_instance.vlan_name`: (Required) specify the VLAN to provide the IP address used to connect the database from the public network.
     * * `postgres_database.single_instance.enable_ip_address_selection`: (Optional) If Advanced Network Segmentation is enabled, then this vLAN needs to be a static vLAN and needs to be true.
     *
     * * `postgres_database.ha_instance`: (Optional) Info for craeting Network profile for HA instance
     * * `postgres_database.ha_instance.vlan_name`: (Required) specify the VLANs for network
     * * `postgres_database.ha_instance.cluster_name`: (Required) specify the cluster name associated with given VLANs
     * * `postgres_database.ha_instance.cluster_id`: (Optional) specify the cluster ids associated with given VLANs
     * * `postgres_database.ha_instance.num_of_clusters`: (Required) number of cluster attached to network profile
     */
    postgresDatabases?: outputs.NdbProfileNetworkProfilePostgresDatabase[];
    /**
     * Topology supported for network profile. Allowed values are "cluster" and "single"
     */
    topology: string;
    /**
     * cluster associated with VLAN. this is used with Single instance for postgres database.
     * * `version_cluster_association.nx_cluster_id`: (Required) cluster id for associated VLAN.
     */
    versionClusterAssociations?: outputs.NdbProfileNetworkProfileVersionClusterAssociation[];
}

export interface NdbProfileNetworkProfilePostgresDatabase {
    haInstances?: outputs.NdbProfileNetworkProfilePostgresDatabaseHaInstance[];
    singleInstances?: outputs.NdbProfileNetworkProfilePostgresDatabaseSingleInstance[];
}

export interface NdbProfileNetworkProfilePostgresDatabaseHaInstance {
    clusterIds?: string[];
    clusterNames?: string[];
    numOfClusters?: string;
    vlanNames?: string[];
}

export interface NdbProfileNetworkProfilePostgresDatabaseSingleInstance {
    enableIpAddressSelection?: string;
    vlanName?: string;
}

export interface NdbProfileNetworkProfileVersionClusterAssociation {
    /**
     * cluster on which profile created
     */
    nxClusterId: string;
}

export interface NdbProfileSoftwareProfile {
    /**
     * specify Nutanix clusters where this profile is available.
     */
    availableClusterIds?: string[];
    /**
     * Software profile info about postgres database.
     * * `postgres_database.source_dbserver_id`: source dbserver id where postgress software will be installed.
     * * `postgres_database.base_profile_version_name`: name for the software profile version.
     * * `postgres_database.base_profile_version_description`: description for the software profile version.
     * * `postgres_database.os_notes`: a note to provide additional information about the operating system
     * * `postgres_database.db_software_notes`: a note to provide additional information about the database software.
     */
    postgresDatabases?: outputs.NdbProfileSoftwareProfilePostgresDatabase[];
    /**
     * Topology of software profile. Allowed values are "cluster" and "single"
     */
    topology: string;
}

export interface NdbProfileSoftwareProfilePostgresDatabase {
    baseProfileVersionDescription?: string;
    baseProfileVersionName?: string;
    dbSoftwareNotes?: string;
    osNotes?: string;
    sourceDbserverId?: string;
}

export interface NdbProfileVersion {
    dbVersion: string;
    deprecated: boolean;
    /**
     * Description of profile
     */
    description: string;
    /**
     * Engine Type of database
     */
    engineType: string;
    id: string;
    /**
     * Name of profile
     */
    name: string;
    /**
     * owner  of profile
     */
    owner: string;
    profileId: string;
    properties: outputs.NdbProfileVersionProperty[];
    propertiesMap: {[key: string]: string};
    /**
     * Publish for all users
     */
    published: boolean;
    /**
     * status of profile
     */
    status: string;
    systemProfile: boolean;
    topology: string;
    type: string;
    version: string;
    /**
     * cluster associated with VLAN. this is used with Single instance for postgres database.
     * * `version_cluster_association.nx_cluster_id`: (Required) cluster id for associated VLAN.
     */
    versionClusterAssociations: outputs.NdbProfileVersionVersionClusterAssociation[];
}

export interface NdbProfileVersionProperty {
    /**
     * Name of profile
     */
    name: string;
    secure: boolean;
    value: string;
}

export interface NdbProfileVersionVersionClusterAssociation {
    dateCreated: string;
    dateModified: string;
    /**
     * cluster on which profile created
     */
    nxClusterId: string;
    optimizedForProvisioning: boolean;
    ownerId: string;
    profileVersionId: string;
    properties: outputs.NdbProfileVersionVersionClusterAssociationProperty[];
    /**
     * status of profile
     */
    status: string;
}

export interface NdbProfileVersionVersionClusterAssociationProperty {
    /**
     * Name of profile
     */
    name: string;
    secure: boolean;
    value: string;
}

export interface NdbRegisterDatabaseActionargument {
    /**
     * - (Required) name of argument
     */
    name: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbRegisterDatabaseDatabaseNode {
    accessLevel: {[key: string]: string};
    databaseId: string;
    /**
     * status of database
     */
    databaseStatus: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    dbserver: {[key: string]: string};
    dbserverId: string;
    /**
     * description
     */
    description: string;
    id: string;
    /**
     * info of instance
     */
    infos: outputs.NdbRegisterDatabaseDatabaseNodeInfo[];
    /**
     * Name of database instance
     */
    name: string;
    primary: boolean;
    /**
     * properties of database created
     */
    properties: outputs.NdbRegisterDatabaseDatabaseNodeProperty[];
    protectionDomainId: string;
    protectionDomains: outputs.NdbRegisterDatabaseDatabaseNodeProtectionDomain[];
    softwareInstallationId: string;
    /**
     * status of instance
     */
    status: string;
    /**
     * tags
     */
    tags: outputs.NdbRegisterDatabaseDatabaseNodeTag[];
}

export interface NdbRegisterDatabaseDatabaseNodeInfo {
    /**
     * info of instance
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbRegisterDatabaseDatabaseNodeProperty {
    /**
     * description
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbRegisterDatabaseDatabaseNodeProtectionDomain {
    assocEntities: string[];
    cloudId: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description
     */
    description: string;
    eraCreated: boolean;
    id: string;
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    primaryHost: string;
    /**
     * properties of database created
     */
    properties: outputs.NdbRegisterDatabaseDatabaseNodeProtectionDomainProperty[];
    /**
     * status of instance
     */
    status: string;
    /**
     * type of database
     */
    type: string;
}

export interface NdbRegisterDatabaseDatabaseNodeProtectionDomainProperty {
    /**
     * description
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbRegisterDatabaseDatabaseNodeTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbRegisterDatabaseInfo {
    bpgConfigs: outputs.NdbRegisterDatabaseInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface NdbRegisterDatabaseInfoBpgConfig {
    bpgDbParams: outputs.NdbRegisterDatabaseInfoBpgConfigBpgDbParam[];
    storages: outputs.NdbRegisterDatabaseInfoBpgConfigStorage[];
    vmProperties: outputs.NdbRegisterDatabaseInfoBpgConfigVmProperty[];
}

export interface NdbRegisterDatabaseInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface NdbRegisterDatabaseInfoBpgConfigStorage {
    archiveStorages: outputs.NdbRegisterDatabaseInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.NdbRegisterDatabaseInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.NdbRegisterDatabaseInfoBpgConfigStorageLogDisk[];
}

export interface NdbRegisterDatabaseInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface NdbRegisterDatabaseInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface NdbRegisterDatabaseInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface NdbRegisterDatabaseInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface NdbRegisterDatabaseLcmConfig {
    expiryDetails: outputs.NdbRegisterDatabaseLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.NdbRegisterDatabaseLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.NdbRegisterDatabaseLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.NdbRegisterDatabaseLcmConfigRefreshDetail[];
}

export interface NdbRegisterDatabaseLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    /**
     * - (Optional) Delete the database's Time Machine (snapshots/logs) from the NDB. Default value is true
     */
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface NdbRegisterDatabaseLcmConfigPostDeleteCommand {
    command: string;
}

export interface NdbRegisterDatabaseLcmConfigPreDeleteCommand {
    command: string;
}

export interface NdbRegisterDatabaseLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface NdbRegisterDatabaseLinkedDatabase {
    /**
     * name of database
     */
    databaseName: string;
    /**
     * status of database
     */
    databaseStatus: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description
     */
    description: string;
    id: string;
    /**
     * info of instance
     */
    infos: outputs.NdbRegisterDatabaseLinkedDatabaseInfo[];
    /**
     * Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
     */
    metric: {[key: string]: string};
    /**
     * Name of database instance
     */
    name: string;
    /**
     * parent database id
     */
    parentDatabaseId: string;
    parentLinkedDatabaseId: string;
    snapshotId: string;
    /**
     * status of instance
     */
    status: string;
    timezone: string;
}

export interface NdbRegisterDatabaseLinkedDatabaseInfo {
    /**
     * info of instance
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbRegisterDatabasePostgressInfo {
    /**
     * allow multiple databases. Default is true
     */
    allowMultipleDatabases?: boolean;
    /**
     * backup policy of database. Default is prefer_secondary.
     */
    backupPolicy?: string;
    /**
     * name of the database server VM on which the instance you want to register is running.
     */
    dbName: string;
    /**
     * database password
     */
    dbPassword: string;
    /**
     * username of the NDB drive user account that has sudo access.
     */
    dbUser?: string;
    /**
     * listner port of database
     */
    listenerPort: string;
    /**
     * path to the PostgreSQL home directory in which the PostgreSQL software is installed.
     */
    postgresSoftwareHome: string;
    /**
     * path to the directory in which the PostgreSQL software is installed.
     */
    softwareHome?: string;
    /**
     * switch log of database. Default is true
     */
    switchLog?: boolean;
    /**
     * VM IP of the database server VM on which the instance you want to register is running.
     */
    vmIp?: string;
}

export interface NdbRegisterDatabaseProperty {
    /**
     * Name of database instance
     */
    name: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbRegisterDatabaseTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbRegisterDatabaseTimeMachine {
    accessLevel: string;
    /**
     * whether instance is cloned or not
     */
    clone: boolean;
    clones: string;
    /**
     * clustered or not. Default is false
     */
    clustered: boolean;
    database: string;
    databaseId: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description
     */
    description: string;
    eaStatus: string;
    id: string;
    /**
     * Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
     */
    metric: string;
    /**
     * Name of database instance
     */
    name: string;
    /**
     * properties of database created
     */
    properties: outputs.NdbRegisterDatabaseTimeMachineProperty[];
    scheduleId: string;
    /**
     * - (Optional) schedule for snapshots
     */
    schedules: outputs.NdbRegisterDatabaseTimeMachineSchedule[];
    scope: string;
    slaId: string;
    slaUpdateInProgress: boolean;
    slaUpdateMetadata: string;
    slas: outputs.NdbRegisterDatabaseTimeMachineSla[];
    sourceNxClusters: string[];
    /**
     * status of instance
     */
    status: string;
    /**
     * tags
     */
    tags: outputs.NdbRegisterDatabaseTimeMachineTag[];
    /**
     * type of database
     */
    type: string;
}

export interface NdbRegisterDatabaseTimeMachineInfo {
    /**
     * - (Optional) enable auto tune log drive. Default: true
     */
    autotunelogdrive?: boolean;
    /**
     * - (Optional) description of time machine
     */
    description?: string;
    /**
     * - (Required) name of time machine
     */
    name: string;
    /**
     * - (Optional) schedule for snapshots
     */
    schedule: outputs.NdbRegisterDatabaseTimeMachineInfoSchedule;
    /**
     * -  (optional) SLA details for HA instance
     */
    slaDetails?: outputs.NdbRegisterDatabaseTimeMachineInfoSlaDetail[];
    /**
     * - (Optional) SLA ID for single instance
     */
    slaid?: string;
    /**
     * - (Optional) tags
     */
    tags: outputs.NdbRegisterDatabaseTimeMachineInfoTag[];
}

export interface NdbRegisterDatabaseTimeMachineInfoSchedule {
    /**
     * - (Optional) snapshot freq and log config
     */
    continuousschedule?: outputs.NdbRegisterDatabaseTimeMachineInfoScheduleContinuousschedule;
    /**
     * - (Optional) monthly snapshot config
     */
    monthlyschedule?: outputs.NdbRegisterDatabaseTimeMachineInfoScheduleMonthlyschedule;
    /**
     * - (Optional) quaterly snapshot config
     */
    quartelyschedule?: outputs.NdbRegisterDatabaseTimeMachineInfoScheduleQuartelyschedule;
    /**
     * - (Optional) daily snapshot config
     */
    snapshottimeofday?: outputs.NdbRegisterDatabaseTimeMachineInfoScheduleSnapshottimeofday;
    /**
     * - (Optional) weekly snapshot config
     */
    weeklyschedule?: outputs.NdbRegisterDatabaseTimeMachineInfoScheduleWeeklyschedule;
    /**
     * - (Optional) yearly snapshot config
     */
    yearlyschedule?: outputs.NdbRegisterDatabaseTimeMachineInfoScheduleYearlyschedule;
}

export interface NdbRegisterDatabaseTimeMachineInfoScheduleContinuousschedule {
    enabled: boolean;
    logbackupinterval: number;
    snapshotsperday: number;
}

export interface NdbRegisterDatabaseTimeMachineInfoScheduleMonthlyschedule {
    dayofmonth: number;
    enabled: boolean;
}

export interface NdbRegisterDatabaseTimeMachineInfoScheduleQuartelyschedule {
    dayofmonth: number;
    enabled: boolean;
    startmonth: string;
}

export interface NdbRegisterDatabaseTimeMachineInfoScheduleSnapshottimeofday {
    hours: number;
    minutes: number;
    seconds: number;
}

export interface NdbRegisterDatabaseTimeMachineInfoScheduleWeeklyschedule {
    dayofweek: string;
    enabled: boolean;
}

export interface NdbRegisterDatabaseTimeMachineInfoScheduleYearlyschedule {
    dayofmonth: number;
    enabled: boolean;
    month: string;
}

export interface NdbRegisterDatabaseTimeMachineInfoSlaDetail {
    /**
     * - (Required) primary sla details
     * * `primary_sla.sla_id` :- (Required) sla id
     * * `primary_sla.nx_cluster_ids` -: (Optioanl) cluster ids
     */
    primarySlas?: outputs.NdbRegisterDatabaseTimeMachineInfoSlaDetailPrimarySla[];
}

export interface NdbRegisterDatabaseTimeMachineInfoSlaDetailPrimarySla {
    nxClusterIds?: string[];
    /**
     * description of SLA ID.
     */
    slaId: string;
}

export interface NdbRegisterDatabaseTimeMachineInfoTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbRegisterDatabaseTimeMachineProperty {
    /**
     * description
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbRegisterDatabaseTimeMachineSchedule {
    continuousSchedules: outputs.NdbRegisterDatabaseTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.NdbRegisterDatabaseTimeMachineScheduleDailySchedule[];
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description
     */
    description: string;
    globalPolicy: boolean;
    id: string;
    monthlySchedules: outputs.NdbRegisterDatabaseTimeMachineScheduleMonthlySchedule[];
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.NdbRegisterDatabaseTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.NdbRegisterDatabaseTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    /**
     * timezone on which instance is created xw
     */
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.NdbRegisterDatabaseTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.NdbRegisterDatabaseTimeMachineScheduleYearlySchedule[];
}

export interface NdbRegisterDatabaseTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface NdbRegisterDatabaseTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface NdbRegisterDatabaseTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface NdbRegisterDatabaseTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface NdbRegisterDatabaseTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface NdbRegisterDatabaseTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface NdbRegisterDatabaseTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface NdbRegisterDatabaseTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description
     */
    description: string;
    id: string;
    monthlyRetention: number;
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface NdbRegisterDatabaseTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    /**
     * - (Required) value for argument
     */
    value: string;
}

export interface NdbRegisterDbserverCredential {
    label?: string;
    /**
     * password of the NDB drive user account. Conflicts with ssh_key.
     */
    password: string;
    /**
     * username of the NDB drive user account that has sudo access
     */
    username: string;
}

export interface NdbRegisterDbserverPostgresDatabase {
    /**
     * listener port of db server
     */
    listenerPort?: string;
    /**
     * path to the PostgreSQL home directory in which the PostgreSQL software is installed
     */
    postgresSoftwareHome?: string;
}

export interface NdbRegisterDbserverProperty {
    /**
     * Name of db server vm. Should be used in Update Method only.
     */
    name: string;
    value: string;
}

export interface NdbRegisterDbserverTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbScaleDatabaseDatabaseNode {
    accessLevel: {[key: string]: string};
    databaseId: string;
    databaseStatus: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    dbserver: {[key: string]: string};
    dbserverId: string;
    /**
     * description of database instance
     */
    description: string;
    id: string;
    /**
     * info of instance
     */
    infos: outputs.NdbScaleDatabaseDatabaseNodeInfo[];
    /**
     * Name of database instance
     */
    name: string;
    primary: boolean;
    /**
     * properties of database created
     */
    properties: outputs.NdbScaleDatabaseDatabaseNodeProperty[];
    protectionDomainId: string;
    protectionDomains: outputs.NdbScaleDatabaseDatabaseNodeProtectionDomain[];
    softwareInstallationId: string;
    /**
     * status of instance
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.NdbScaleDatabaseDatabaseNodeTag[];
}

export interface NdbScaleDatabaseDatabaseNodeInfo {
    /**
     * info of instance
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbScaleDatabaseDatabaseNodeProperty {
    /**
     * description of database instance
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbScaleDatabaseDatabaseNodeProtectionDomain {
    assocEntities: string[];
    cloudId: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    eraCreated: boolean;
    id: string;
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    primaryHost: string;
    /**
     * properties of database created
     */
    properties: outputs.NdbScaleDatabaseDatabaseNodeProtectionDomainProperty[];
    /**
     * status of instance
     */
    status: string;
    /**
     * type of database
     */
    type: string;
}

export interface NdbScaleDatabaseDatabaseNodeProtectionDomainProperty {
    /**
     * description of database instance
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbScaleDatabaseDatabaseNodeTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbScaleDatabaseInfo {
    bpgConfigs: outputs.NdbScaleDatabaseInfoBpgConfig[];
    secureInfo: {[key: string]: string};
}

export interface NdbScaleDatabaseInfoBpgConfig {
    bpgDbParams: outputs.NdbScaleDatabaseInfoBpgConfigBpgDbParam[];
    storages: outputs.NdbScaleDatabaseInfoBpgConfigStorage[];
    vmProperties: outputs.NdbScaleDatabaseInfoBpgConfigVmProperty[];
}

export interface NdbScaleDatabaseInfoBpgConfigBpgDbParam {
    effectiveCacheSize: string;
    maintenanceWorkMem: string;
    maxParallelWorkersPerGather: string;
    maxWorkerProcesses: string;
    sharedBuffers: string;
    workMem: string;
}

export interface NdbScaleDatabaseInfoBpgConfigStorage {
    archiveStorages: outputs.NdbScaleDatabaseInfoBpgConfigStorageArchiveStorage[];
    dataDisks: outputs.NdbScaleDatabaseInfoBpgConfigStorageDataDisk[];
    logDisks: outputs.NdbScaleDatabaseInfoBpgConfigStorageLogDisk[];
}

export interface NdbScaleDatabaseInfoBpgConfigStorageArchiveStorage {
    size: number;
}

export interface NdbScaleDatabaseInfoBpgConfigStorageDataDisk {
    count: number;
}

export interface NdbScaleDatabaseInfoBpgConfigStorageLogDisk {
    count: number;
    size: number;
}

export interface NdbScaleDatabaseInfoBpgConfigVmProperty {
    dirtyBackgroundRatio: number;
    dirtyExpireCentisecs: number;
    dirtyRatio: number;
    dirtyWritebackCentisecs: number;
    nrHugepages: number;
    overcommitMemory: number;
    swappiness: number;
}

export interface NdbScaleDatabaseLcmConfig {
    expiryDetails: outputs.NdbScaleDatabaseLcmConfigExpiryDetail[];
    postDeleteCommands: outputs.NdbScaleDatabaseLcmConfigPostDeleteCommand[];
    preDeleteCommands: outputs.NdbScaleDatabaseLcmConfigPreDeleteCommand[];
    refreshDetails: outputs.NdbScaleDatabaseLcmConfigRefreshDetail[];
}

export interface NdbScaleDatabaseLcmConfigExpiryDetail {
    deleteDatabase: boolean;
    deleteTimeMachine: boolean;
    deleteVm: boolean;
    effectiveTimestamp: string;
    expireInDays: number;
    expiryDateTimezone: string;
    expiryTimestamp: string;
    remindBeforeInDays: number;
    userCreated: boolean;
}

export interface NdbScaleDatabaseLcmConfigPostDeleteCommand {
    command: string;
}

export interface NdbScaleDatabaseLcmConfigPreDeleteCommand {
    command: string;
}

export interface NdbScaleDatabaseLcmConfigRefreshDetail {
    lastRefreshDate: string;
    nextRefreshDate: string;
    refreshDateTimezone: string;
    refreshInDays: number;
    refreshInHours: number;
    refreshInMonths: number;
    refreshTime: string;
}

export interface NdbScaleDatabaseLinkedDatabase {
    /**
     * name of database
     */
    databaseName: string;
    databaseStatus: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    id: string;
    /**
     * info of instance
     */
    infos: outputs.NdbScaleDatabaseLinkedDatabaseInfo[];
    /**
     * Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
     */
    metric: {[key: string]: string};
    /**
     * Name of database instance
     */
    name: string;
    /**
     * parent database id
     */
    parentDatabaseId: string;
    parentLinkedDatabaseId: string;
    snapshotId: string;
    /**
     * status of instance
     */
    status: string;
    timezone: string;
}

export interface NdbScaleDatabaseLinkedDatabaseInfo {
    /**
     * info of instance
     */
    info: {[key: string]: string};
    secureInfo: {[key: string]: string};
}

export interface NdbScaleDatabaseProperty {
    /**
     * Name of database instance
     */
    name: string;
    value: string;
}

export interface NdbScaleDatabaseTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbScaleDatabaseTimeMachine {
    accessLevel: string;
    /**
     * whether instance is cloned or not
     */
    clone: boolean;
    clones: string;
    clustered: boolean;
    database: string;
    databaseId: string;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    eaStatus: string;
    id: string;
    /**
     * Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
     */
    metric: string;
    /**
     * Name of database instance
     */
    name: string;
    /**
     * properties of database created
     */
    properties: outputs.NdbScaleDatabaseTimeMachineProperty[];
    scheduleId: string;
    schedules: outputs.NdbScaleDatabaseTimeMachineSchedule[];
    scope: string;
    slaId: string;
    slaUpdateInProgress: boolean;
    slaUpdateMetadata: string;
    slas: outputs.NdbScaleDatabaseTimeMachineSla[];
    sourceNxClusters: string[];
    /**
     * status of instance
     */
    status: string;
    /**
     * allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
     */
    tags: outputs.NdbScaleDatabaseTimeMachineTag[];
    /**
     * type of database
     */
    type: string;
}

export interface NdbScaleDatabaseTimeMachineProperty {
    /**
     * description of database instance
     */
    description: string;
    /**
     * Name of database instance
     */
    name: string;
    refId: string;
    secure: boolean;
    value: string;
}

export interface NdbScaleDatabaseTimeMachineSchedule {
    continuousSchedules: outputs.NdbScaleDatabaseTimeMachineScheduleContinuousSchedule[];
    dailySchedules: outputs.NdbScaleDatabaseTimeMachineScheduleDailySchedule[];
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    globalPolicy: boolean;
    id: string;
    monthlySchedules: outputs.NdbScaleDatabaseTimeMachineScheduleMonthlySchedule[];
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    quartelySchedules: outputs.NdbScaleDatabaseTimeMachineScheduleQuartelySchedule[];
    referenceCount: number;
    snapshotTimeOfDays: outputs.NdbScaleDatabaseTimeMachineScheduleSnapshotTimeOfDay[];
    startTime: string;
    systemPolicy: boolean;
    /**
     * timezone on which instance is created xw
     */
    timeZone: string;
    uniqueName: string;
    weeklySchedules: outputs.NdbScaleDatabaseTimeMachineScheduleWeeklySchedule[];
    yearlySchedules: outputs.NdbScaleDatabaseTimeMachineScheduleYearlySchedule[];
}

export interface NdbScaleDatabaseTimeMachineScheduleContinuousSchedule {
    enabled: boolean;
    logBackupInterval: number;
    snapshotsPerDay: number;
}

export interface NdbScaleDatabaseTimeMachineScheduleDailySchedule {
    enabled: boolean;
}

export interface NdbScaleDatabaseTimeMachineScheduleMonthlySchedule {
    dayOfMonth: number;
    enabled: boolean;
}

export interface NdbScaleDatabaseTimeMachineScheduleQuartelySchedule {
    dayOfMonth: number;
    enabled: boolean;
    startMonth: string;
    startMonthValue: string;
}

export interface NdbScaleDatabaseTimeMachineScheduleSnapshotTimeOfDay {
    extra: boolean;
    hours: number;
    minutes: number;
    seconds: number;
}

export interface NdbScaleDatabaseTimeMachineScheduleWeeklySchedule {
    dayOfWeek: string;
    dayOfWeekValue: string;
    enabled: boolean;
}

export interface NdbScaleDatabaseTimeMachineScheduleYearlySchedule {
    dayOfMonth: number;
    enabled: boolean;
    month: string;
    monthValue: string;
}

export interface NdbScaleDatabaseTimeMachineSla {
    continuousRetention: number;
    currentActiveFrequency: string;
    dailyRetention: number;
    /**
     * date created for db instance
     */
    dateCreated: string;
    /**
     * date modified for instance
     */
    dateModified: string;
    /**
     * description of database instance
     */
    description: string;
    id: string;
    monthlyRetention: number;
    /**
     * Name of database instance
     */
    name: string;
    ownerId: string;
    pitrEnabled: boolean;
    quarterlyRetention: number;
    referenceCount: number;
    systemSla: boolean;
    uniqueName: string;
    weeklyRetention: number;
    yearlyRetention: number;
}

export interface NdbScaleDatabaseTimeMachineTag {
    entityId: string;
    entityType: string;
    tagId: string;
    tagName: string;
    value: string;
}

export interface NdbSoftwareVersionProfilePostgresDatabase {
    /**
     * db software notes
     */
    dbSoftwareNotes?: string;
    /**
     * os notes for software profile
     */
    osNotes?: string;
    /**
     * source dbserver id
     */
    sourceDbserverId?: string;
}

export interface NdbSoftwareVersionProfileProperty {
    /**
     * Name of profile
     */
    name: string;
    /**
     * secure or not
     */
    secure: boolean;
    /**
     * value of property
     */
    value: string;
}

export interface NdbSoftwareVersionProfileVersionClusterAssociation {
    /**
     * date created of profile
     */
    dateCreated: string;
    /**
     * date modified of profile
     */
    dateModified: string;
    /**
     * nutanix cluster id
     */
    nxClusterId: string;
    /**
     * version optimized for provisioning
     */
    optimizedForProvisioning: boolean;
    /**
     * owner id
     */
    ownerId: string;
    /**
     * profile version id
     */
    profileVersionId: string;
    /**
     * properties of software profile
     */
    properties: outputs.NdbSoftwareVersionProfileVersionClusterAssociationProperty[];
    /**
     * status of profile. Allowed Values are "deprecated", "published", "unpublished"
     */
    status: string;
}

export interface NdbSoftwareVersionProfileVersionClusterAssociationProperty {
    /**
     * Name of profile
     */
    name: string;
    /**
     * secure or not
     */
    secure: boolean;
    /**
     * value of property
     */
    value: string;
}

export interface NdbStretchedVlanMetadata {
    gateway: string;
    subnetMask: string;
}

export interface NdbStretchedVlanVlansList {
    /**
     * cluster id where network is present
     */
    clusterId: string;
    /**
     * network id
     */
    id: string;
    /**
     * network managed by NDB or not
     */
    managed: boolean;
    /**
     * name for the stretched VLAN
     */
    name: string;
    /**
     * properties of network
     */
    properties: outputs.NdbStretchedVlanVlansListProperty[];
    /**
     * properties map of network
     */
    propertiesMaps: outputs.NdbStretchedVlanVlansListPropertiesMap[];
    /**
     * stretched vlan id
     */
    stretchedVlanId: string;
    /**
     * type of vlan. static VLANs that are managed in NDB can be added to a stretched VLAN.
     */
    type: string;
}

export interface NdbStretchedVlanVlansListPropertiesMap {
    /**
     * gateway of vlan
     */
    vlanGateway: string;
    /**
     * primary dns of vlan
     */
    vlanPrimaryDns: string;
    /**
     * secondary dns of vlan
     */
    vlanSecondaryDns: string;
    /**
     * subnet mask of vlan
     */
    vlanSubnetMask: string;
}

export interface NdbStretchedVlanVlansListProperty {
    /**
     * name for the stretched VLAN
     */
    name: string;
    secure: boolean;
    value: string;
}

export interface NetworkSecurityPolicyV2Link {
    href: string;
    rel: string;
}

export interface NetworkSecurityPolicyV2Rule {
    /**
     * A user defined annotation for a rule.
     */
    description: string;
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.NetworkSecurityPolicyV2RuleLink[];
    /**
     * Spec for rules.
     */
    specs: outputs.NetworkSecurityPolicyV2RuleSpec[];
    /**
     * The type for a rulethe value chosen here restricts which specification can be chosen. Acceptable values are "QUARANTINE", "TWO_ENV_ISOLATION", "APPLICATION", "INTRA_GROUP".
     */
    type: string;
}

export interface NetworkSecurityPolicyV2RuleLink {
    href: string;
    rel: string;
}

export interface NetworkSecurityPolicyV2RuleSpec {
    /**
     * Application Rule Spec.
     */
    applicationRuleSpecs?: outputs.NetworkSecurityPolicyV2RuleSpecApplicationRuleSpec[];
    /**
     * Intra entity group Rule Spec
     */
    intraEntityGroupRuleSpecs: outputs.NetworkSecurityPolicyV2RuleSpecIntraEntityGroupRuleSpec[];
    /**
     * Multi Environment Isolation Rule Spec.
     */
    multiEnvIsolationRuleSpecs: outputs.NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpec[];
    /**
     * Two Environment Isolation Rule Spec.
     */
    twoEnvIsolationRuleSpecs?: outputs.NetworkSecurityPolicyV2RuleSpecTwoEnvIsolationRuleSpec[];
}

export interface NetworkSecurityPolicyV2RuleSpecApplicationRuleSpec {
    /**
     * A list of address group references.
     */
    destAddressGroupReferences: string[];
    /**
     * A specification to how allow mode traffic should be applied, either ALL or NONE.
     */
    destAllowSpec: string;
    /**
     * List of categories that define a set of network endpoints as outbound.
     */
    destCategoryReferences: string[];
    /**
     * destination subnet value
     */
    destSubnets: outputs.NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecDestSubnet[];
    /**
     * icmp services
     */
    icmpServices?: outputs.NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecIcmpService[];
    /**
     * Denotes if rule allows traffic for all protocol.
     */
    isAllProtocolAllowed: boolean;
    /**
     * A reference to the network function chain in the rule.
     */
    networkFunctionChainReference: string;
    /**
     * A set of network endpoints which is protected by a Network Security Policy and defined as a list of categories.
     */
    securedGroupCategoryReferences: string[];
    /**
     * A list of service group references.
     */
    serviceGroupReferences: string[];
    /**
     * A list of address group references.
     */
    srcAddressGroupReferences: string[];
    /**
     * A specification to how allow mode traffic should be applied, either ALL or NONE.
     */
    srcAllowSpec: string;
    /**
     * List of categories that define a set of network endpoints as inbound.
     */
    srcCategoryReferences: string[];
    /**
     * source subnet value
     */
    srcSubnets: outputs.NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecSrcSubnet[];
    /**
     * tcp services
     */
    tcpServices?: outputs.NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecTcpService[];
    /**
     * udp services
     */
    udpServices?: outputs.NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecUdpService[];
}

export interface NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecDestSubnet {
    prefixLength: number;
    value: string;
}

export interface NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecIcmpService {
    /**
     * Icmp service Code. Ignore this field if Code has to be ANY.
     */
    code: number;
    /**
     * Set this field to true if both Type and Code is ANY.
     */
    isAllAllowed: boolean;
    /**
     * Icmp service Type. Ignore this field if Type has to be ANY.
     */
    type: number;
}

export interface NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecSrcSubnet {
    prefixLength: number;
    value: string;
}

export interface NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecTcpService {
    /**
     * end port
     */
    endPort: number;
    /**
     * start port
     */
    startPort: number;
}

export interface NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecUdpService {
    /**
     * end port
     */
    endPort: number;
    /**
     * start port
     */
    startPort: number;
}

export interface NetworkSecurityPolicyV2RuleSpecIntraEntityGroupRuleSpec {
    /**
     * List of secured group action.
     */
    securedGroupAction: string;
    /**
     * A specification to whether traffic between intra secured group entities should be allowed or denied.
     */
    securedGroupCategoryReferences: string[];
}

export interface NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpec {
    /**
     * Multi Environment Isolation Rule Spec.
     */
    specs: outputs.NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpec[];
}

export interface NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpec {
    /**
     * all to all isolation groups
     */
    allToAllIsolationGroups: outputs.NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroup[];
}

export interface NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroup {
    /**
     * Denotes the list of secured groups that will be used in All to All mutual isolation.
     */
    isolationGroups: outputs.NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupIsolationGroup[];
}

export interface NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupIsolationGroup {
    /**
     * External identifiers of categories belonging to the isolation group.
     */
    groupCategoryReferences: string[];
}

export interface NetworkSecurityPolicyV2RuleSpecTwoEnvIsolationRuleSpec {
    /**
     * Denotes the first group of category uuids that will be used in an isolation policy.
     */
    firstIsolationGroups: string[];
    /**
     * Denotes the second group of category uuids that will be used in an isolation policy.
     */
    secondIsolationGroups: string[];
}

export interface NetworkSecurityRuleAdRuleInboundAllowList {
    addressGroupInclusionLists: outputs.NetworkSecurityRuleAdRuleInboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.NetworkSecurityRuleAdRuleInboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.NetworkSecurityRuleAdRuleInboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.NetworkSecurityRuleAdRuleInboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.NetworkSecurityRuleAdRuleInboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.NetworkSecurityRuleAdRuleInboundAllowListUdpPortRangeList[];
}

export interface NetworkSecurityRuleAdRuleInboundAllowListAddressGroupInclusionList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface NetworkSecurityRuleAdRuleInboundAllowListFilterParam {
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    values: string[];
}

export interface NetworkSecurityRuleAdRuleInboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface NetworkSecurityRuleAdRuleInboundAllowListServiceGroupList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface NetworkSecurityRuleAdRuleInboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAdRuleInboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAdRuleOutboundAllowList {
    addressGroupInclusionLists: outputs.NetworkSecurityRuleAdRuleOutboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.NetworkSecurityRuleAdRuleOutboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.NetworkSecurityRuleAdRuleOutboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.NetworkSecurityRuleAdRuleOutboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.NetworkSecurityRuleAdRuleOutboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.NetworkSecurityRuleAdRuleOutboundAllowListUdpPortRangeList[];
}

export interface NetworkSecurityRuleAdRuleOutboundAllowListAddressGroupInclusionList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface NetworkSecurityRuleAdRuleOutboundAllowListFilterParam {
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    values: string[];
}

export interface NetworkSecurityRuleAdRuleOutboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface NetworkSecurityRuleAdRuleOutboundAllowListServiceGroupList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface NetworkSecurityRuleAdRuleOutboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAdRuleOutboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAdRuleTargetGroupFilterParam {
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    values: string[];
}

export interface NetworkSecurityRuleAppRuleInboundAllowList {
    addressGroupInclusionLists: outputs.NetworkSecurityRuleAppRuleInboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.NetworkSecurityRuleAppRuleInboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.NetworkSecurityRuleAppRuleInboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.NetworkSecurityRuleAppRuleInboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.NetworkSecurityRuleAppRuleInboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.NetworkSecurityRuleAppRuleInboundAllowListUdpPortRangeList[];
}

export interface NetworkSecurityRuleAppRuleInboundAllowListAddressGroupInclusionList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface NetworkSecurityRuleAppRuleInboundAllowListFilterParam {
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    values: string[];
}

export interface NetworkSecurityRuleAppRuleInboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface NetworkSecurityRuleAppRuleInboundAllowListServiceGroupList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface NetworkSecurityRuleAppRuleInboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAppRuleInboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAppRuleOutboundAllowList {
    addressGroupInclusionLists: outputs.NetworkSecurityRuleAppRuleOutboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.NetworkSecurityRuleAppRuleOutboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.NetworkSecurityRuleAppRuleOutboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.NetworkSecurityRuleAppRuleOutboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.NetworkSecurityRuleAppRuleOutboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.NetworkSecurityRuleAppRuleOutboundAllowListUdpPortRangeList[];
}

export interface NetworkSecurityRuleAppRuleOutboundAllowListAddressGroupInclusionList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface NetworkSecurityRuleAppRuleOutboundAllowListFilterParam {
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    values: string[];
}

export interface NetworkSecurityRuleAppRuleOutboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface NetworkSecurityRuleAppRuleOutboundAllowListServiceGroupList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind: string;
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface NetworkSecurityRuleAppRuleOutboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAppRuleOutboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAppRuleTargetGroupFilterParam {
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    values: string[];
}

export interface NetworkSecurityRuleCategory {
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    value: string;
}

export interface NetworkSecurityRuleIsolationRuleFirstEntityFilterParam {
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    values: string[];
}

export interface NetworkSecurityRuleIsolationRuleSecondEntityFilterParam {
    /**
     * - (Required) The name for the network_security_rule.
     */
    name: string;
    values: string[];
}

export interface NgtInstallationV2Credential {
    /**
     * - (Required) password to sign in to server
     */
    password: string;
    /**
     * - (Required) username to sign in to server
     */
    username: string;
}

export interface NgtInstallationV2RebootPreference {
    /**
     * - Restart schedule.
     */
    schedule?: outputs.NgtInstallationV2RebootPreferenceSchedule;
    /**
     * - Schedule type for restart.
     * * `LATER` : Schedule a restart for a specific time.
     * * `SKIP` : Do not schedule a restart.
     * * `IMMEDIATE` : Schedule an immediate restart.
     */
    scheduleType: string;
}

export interface NgtInstallationV2RebootPreferenceSchedule {
    /**
     * - The start time for a scheduled restart.
     */
    startTime: string;
}

export interface NgtUpgradeV2RebootPreference {
    /**
     * - Restart schedule.
     */
    schedule?: outputs.NgtUpgradeV2RebootPreferenceSchedule;
    /**
     * - Schedule type for restart.
     * * `LATER` : Schedule a restart for a specific time.
     * * `SKIP` : Do not schedule a restart.
     * * `IMMEDIATE` : Schedule an immediate restart.
     */
    scheduleType: string;
}

export interface NgtUpgradeV2RebootPreferenceSchedule {
    /**
     * - The start time for a scheduled restart.
     */
    startTime: string;
}

export interface PbrDestination {
    addressType?: string;
    prefixLength?: number;
    subnetIp?: string;
}

export interface PbrProtocolParameters {
    icmp?: outputs.PbrProtocolParametersIcmp;
    protocolNumber?: string;
    tcp?: outputs.PbrProtocolParametersTcp;
    udp?: outputs.PbrProtocolParametersUdp;
}

export interface PbrProtocolParametersIcmp {
    icmpCode: number;
    icmpType: number;
}

export interface PbrProtocolParametersTcp {
    destinationPortRangeLists: outputs.PbrProtocolParametersTcpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.PbrProtocolParametersTcpSourcePortRangeList[];
}

export interface PbrProtocolParametersTcpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface PbrProtocolParametersTcpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface PbrProtocolParametersUdp {
    destinationPortRangeLists: outputs.PbrProtocolParametersUdpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.PbrProtocolParametersUdpSourcePortRangeList[];
}

export interface PbrProtocolParametersUdpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface PbrProtocolParametersUdpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface PbrSource {
    addressType?: string;
    prefixLength?: number;
    subnetIp?: string;
}

export interface PbrV2Link {
    href: string;
    rel: string;
}

export interface PbrV2Metadata {
    categoryIds: any[][];
    ownerReferenceId: string;
    ownerUserName: string;
    projectName: string;
    projectReferenceId: string;
}

export interface PbrV2Policy {
    isBidirectional: boolean;
    policyActions: outputs.PbrV2PolicyPolicyAction[];
    policyMatches: outputs.PbrV2PolicyPolicyMatch[];
}

export interface PbrV2PolicyPolicyAction {
    actionType: string;
    nexthopIpAddresses: outputs.PbrV2PolicyPolicyActionNexthopIpAddress[];
    rerouteParams: outputs.PbrV2PolicyPolicyActionRerouteParam[];
}

export interface PbrV2PolicyPolicyActionNexthopIpAddress {
    ipv4s: outputs.PbrV2PolicyPolicyActionNexthopIpAddressIpv4[];
    ipv6s: outputs.PbrV2PolicyPolicyActionNexthopIpAddressIpv6[];
}

export interface PbrV2PolicyPolicyActionNexthopIpAddressIpv4 {
    prefixLength: number;
    value: string;
}

export interface PbrV2PolicyPolicyActionNexthopIpAddressIpv6 {
    prefixLength: number;
    value: string;
}

export interface PbrV2PolicyPolicyActionRerouteParam {
    egressServiceIps: outputs.PbrV2PolicyPolicyActionRerouteParamEgressServiceIp[];
    ingressServiceIps: outputs.PbrV2PolicyPolicyActionRerouteParamIngressServiceIp[];
    rerouteFallbackAction: string;
    serviceIps: outputs.PbrV2PolicyPolicyActionRerouteParamServiceIp[];
}

export interface PbrV2PolicyPolicyActionRerouteParamEgressServiceIp {
    ipv4s: outputs.PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv4[];
    ipv6s: outputs.PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv6[];
}

export interface PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv4 {
    prefixLength: number;
    value: string;
}

export interface PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv6 {
    prefixLength: number;
    value: string;
}

export interface PbrV2PolicyPolicyActionRerouteParamIngressServiceIp {
    ipv4s: outputs.PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv4[];
    ipv6s: outputs.PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv6[];
}

export interface PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv4 {
    prefixLength: number;
    value: string;
}

export interface PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv6 {
    prefixLength: number;
    value: string;
}

export interface PbrV2PolicyPolicyActionRerouteParamServiceIp {
    ipv4s: outputs.PbrV2PolicyPolicyActionRerouteParamServiceIpIpv4[];
    ipv6s: outputs.PbrV2PolicyPolicyActionRerouteParamServiceIpIpv6[];
}

export interface PbrV2PolicyPolicyActionRerouteParamServiceIpIpv4 {
    prefixLength: number;
    value: string;
}

export interface PbrV2PolicyPolicyActionRerouteParamServiceIpIpv6 {
    prefixLength: number;
    value: string;
}

export interface PbrV2PolicyPolicyMatch {
    destinations: outputs.PbrV2PolicyPolicyMatchDestination[];
    protocolParameters: outputs.PbrV2PolicyPolicyMatchProtocolParameter[];
    protocolType: string;
    sources: outputs.PbrV2PolicyPolicyMatchSource[];
}

export interface PbrV2PolicyPolicyMatchDestination {
    addressType: string;
    subnetPrefixes: outputs.PbrV2PolicyPolicyMatchDestinationSubnetPrefix[];
}

export interface PbrV2PolicyPolicyMatchDestinationSubnetPrefix {
    ipv4s: outputs.PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4[];
    ipv6s: outputs.PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6[];
}

export interface PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4 {
    ips: outputs.PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4Ip[];
    prefixLength: number;
}

export interface PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4Ip {
    prefixLength: number;
    value: string;
}

export interface PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6 {
    ips: outputs.PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6Ip[];
    prefixLength: number;
}

export interface PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6Ip {
    prefixLength: number;
    value: string;
}

export interface PbrV2PolicyPolicyMatchProtocolParameter {
    icmpObjects: outputs.PbrV2PolicyPolicyMatchProtocolParameterIcmpObject[];
    layerFourProtocolObjects: outputs.PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObject[];
    protocolNumberObjects: outputs.PbrV2PolicyPolicyMatchProtocolParameterProtocolNumberObject[];
}

export interface PbrV2PolicyPolicyMatchProtocolParameterIcmpObject {
    icmpCode: number;
    icmpType: number;
}

export interface PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObject {
    destinationPortRanges: outputs.PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectDestinationPortRange[];
    sourcePortRanges: outputs.PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectSourcePortRange[];
}

export interface PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectDestinationPortRange {
    endPort: number;
    startPort: number;
}

export interface PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectSourcePortRange {
    endPort: number;
    startPort: number;
}

export interface PbrV2PolicyPolicyMatchProtocolParameterProtocolNumberObject {
    protocolNumber: number;
}

export interface PbrV2PolicyPolicyMatchSource {
    addressType: string;
    subnetPrefixes: outputs.PbrV2PolicyPolicyMatchSourceSubnetPrefix[];
}

export interface PbrV2PolicyPolicyMatchSourceSubnetPrefix {
    ipv4s: outputs.PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4[];
    ipv6s: outputs.PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6[];
}

export interface PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4 {
    ips: outputs.PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4Ip[];
    prefixLength: number;
}

export interface PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4Ip {
    prefixLength: number;
    value: string;
}

export interface PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6 {
    ips: outputs.PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6Ip[];
    prefixLength: number;
}

export interface PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6Ip {
    prefixLength: number;
    value: string;
}

export interface PbrV2Vpc {
    name: string;
}

export interface PcBackupTargetV2Link {
    href: string;
    rel: string;
}

export interface PcBackupTargetV2Location {
    /**
     * -(Optional) A boolean value indicating whether to enable lockdown mode for a cluster.
     */
    clusterLocations?: outputs.PcBackupTargetV2LocationClusterLocation[];
    /**
     * -(Optional) Currently representing the build information to be used for the cluster creation.
     */
    objectStoreLocations?: outputs.PcBackupTargetV2LocationObjectStoreLocation[];
}

export interface PcBackupTargetV2LocationClusterLocation {
    /**
     * -(Required) Cluster reference of the remote cluster to be connected.
     */
    configs: outputs.PcBackupTargetV2LocationClusterLocationConfig[];
}

export interface PcBackupTargetV2LocationClusterLocationConfig {
    /**
     * -(Required) Cluster UUID of a remote cluster.
     */
    extId: string;
    name: string;
}

export interface PcBackupTargetV2LocationObjectStoreLocation {
    /**
     * -(Optional) Backup policy for the object store provided.
     */
    backupPolicies?: outputs.PcBackupTargetV2LocationObjectStoreLocationBackupPolicy[];
    /**
     * -(Required) The base model of S3 object store endpoint where domain manager is backed up.
     */
    providerConfigs: outputs.PcBackupTargetV2LocationObjectStoreLocationProviderConfig[];
}

export interface PcBackupTargetV2LocationObjectStoreLocationBackupPolicy {
    /**
     * -(Required) RPO interval in minutes at which the backup will be taken. The Value should be in the range of 60 to 1440.
     *
     * See detailed information in [Nutanix Create Backup Target V4](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/createBackupTarget).
     */
    rpoInMinutes: number;
}

export interface PcBackupTargetV2LocationObjectStoreLocationProviderConfig {
    /**
     * -(Required) The bucket name of the object store endpoint where backup data of domain manager is to be stored.
     */
    bucketName: string;
    /**
     * -(Optional) Secret credentials model for the object store containing access key ID and secret access key.
     */
    credentials?: outputs.PcBackupTargetV2LocationObjectStoreLocationProviderConfigCredentials;
    /**
     * -(Optional) The region name of the object store endpoint where backup data of domain manager is stored. Default is `us-east-1`.
     */
    region?: string;
}

export interface PcBackupTargetV2LocationObjectStoreLocationProviderConfigCredentials {
    /**
     * -(Required) Access key ID for the object store provided for backup target.
     */
    accessKeyId: string;
    /**
     * -(Required) Secret access key for the object store provided for backup target.
     */
    secretAccessKey: string;
}

export interface PcDeployV2Config {
    /**
     * - (Optional) Bootstrap configuration details for the domain manager (Prism Central).
     */
    bootstrapConfig: outputs.PcDeployV2ConfigBootstrapConfig;
    /**
     * -(Required) Currently representing the build information to be used for the cluster creation.
     */
    buildInfo: outputs.PcDeployV2ConfigBuildInfo;
    /**
     * - (Optional) The credentials consist of a username and password for a particular user like admin. Users can pass the credentials of admin users currently which will be configured in the create domain manager operation.
     */
    credentials?: outputs.PcDeployV2ConfigCredential[];
    /**
     * -(Required) Name of the domain manager (Prism Central).
     */
    name: string;
    /**
     * -(Optional) This configuration is used to provide the resource-related details like container external identifiers, number of VCPUs, memory size, data disk size of the domain manager (Prism Central). In the case of a multi-node setup, the sum of resources like number of VCPUs, memory size and data disk size are provided.
     */
    resourceConfigs: outputs.PcDeployV2ConfigResourceConfig[];
    /**
     * -(Optional) A boolean value indicating whether to enable lockdown mode for a cluster.
     */
    shouldEnableLockdownMode: boolean;
    /**
     * - (Required) Domain manager (Prism Central) size is an enumeration of starter, small, large, or extra large starter values. The allowed values are:
     * - `SMALL` : Domain manager (Prism Central) of size small.
     * - `LARGE` : Domain manager (Prism Central) of size large.
     * - `EXTRALARGE` : Domain manager (Prism Central) of size extra large.
     * - `STARTER` : Domain manager (Prism Central) of size starter.
     */
    size: string;
}

export interface PcDeployV2ConfigBootstrapConfig {
    /**
     * -(Optional) Cloud-init configuration for the domain manager (Prism Central) cluster.
     */
    cloudInitConfigs?: outputs.PcDeployV2ConfigBootstrapConfigCloudInitConfig[];
    /**
     * -(Optional) Environment information for the domain manager (Prism Central) cluster.
     */
    environmentInfo: outputs.PcDeployV2ConfigBootstrapConfigEnvironmentInfo;
}

export interface PcDeployV2ConfigBootstrapConfigCloudInitConfig {
    /**
     * -(Optional) The script to use for cloud-init.
     * - `cloud_init_script.user_data`: -(Optional) user data object
     * - `cloud_init_script.custom_keys`: -(Optional) The list of the individual KeyValuePair elements.
     */
    cloudInitScripts: outputs.PcDeployV2ConfigBootstrapConfigCloudInitConfigCloudInitScript[];
    /**
     * -(Optional) Type of datasource. Default: CONFIG_DRIVE_V2
     */
    datasourceType?: string;
    /**
     * -(Optional)The contents of the metaData configuration for cloud-init. This can be formatted as YAML or JSON. The value must be base64 encoded. Default value is 'CONFIG_DRIVE_V2'.
     */
    metadata: string;
}

export interface PcDeployV2ConfigBootstrapConfigCloudInitConfigCloudInitScript {
    customKeyValues: outputs.PcDeployV2ConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValue[];
    userDatas: outputs.PcDeployV2ConfigBootstrapConfigCloudInitConfigCloudInitScriptUserData[];
}

export interface PcDeployV2ConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValue {
    keyValuePairs: outputs.PcDeployV2ConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePair[];
}

export interface PcDeployV2ConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePair {
    /**
     * -(Required) Name of the domain manager (Prism Central).
     */
    name: string;
    values: outputs.PcDeployV2ConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePairValue[];
}

export interface PcDeployV2ConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePairValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.PcDeployV2ConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface PcDeployV2ConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString {
    map: {[key: string]: string};
}

export interface PcDeployV2ConfigBootstrapConfigCloudInitConfigCloudInitScriptUserData {
    value: string;
}

export interface PcDeployV2ConfigBootstrapConfigEnvironmentInfo {
    /**
     * -(Optional) Enums denoting the provider type of the PC, that is, AHV or ESXi.
     * Following are the supported provider types:
     * - `VSPHERE` : Vsphere cloud provider.
     * - `AZURE` : Azure cloud provider.
     * - `NTNX` : Nutanix cloud provider.
     * - `GCP` : GCP cloud provider.
     * - `AWS` : AWS cloud provider.
     */
    providerType: string;
    /**
     * -(Optional) Enums denoting the instance type of the cloud PC. It indicates whether the PC is created on bare-metal or on a cloud-provisioned VM. Hence, it supports two possible values:
     * - `NTNX` : Nutanix instance.
     * - `NATIVE` : Native instance.
     */
    provisioningType: string;
    /**
     * -(Optional) Enums denoting the environment type of the PC, that is, on-prem PC or cloud PC.
     * Following are the supported entity types:
     * - `ONPREM` : On-prem environment.
     * - `NTNX_CLOUD` : Nutanix cloud environment.
     */
    type: string;
}

export interface PcDeployV2ConfigBuildInfo {
    /**
     * -(Required) Software version.
     */
    version: string;
}

export interface PcDeployV2ConfigCredential {
    /**
     * -(Required) Password required for the basic auth scheme.
     */
    password: string;
    /**
     * -(Required) Username required for the basic auth scheme. As per RFC 2617 usernames might be case sensitive.
     */
    username: string;
}

export interface PcDeployV2ConfigResourceConfig {
    /**
     * -(Optional) The external identifier of the container that will be used to create the domain manager (Prism Central) cluster.
     */
    containerExtIds: string[];
    dataDiskSizeBytes: number;
    memorySizeBytes: number;
    numVcpus: number;
}

export interface PcDeployV2Network {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    externalAddress?: outputs.PcDeployV2NetworkExternalAddress;
    /**
     * -(Required) This configuration is used to manage Prism Central.
     */
    externalNetworks: outputs.PcDeployV2NetworkExternalNetwork[];
    fqdn: string;
    /**
     * -(Required) This configuration is used to internally manage Prism Central network.
     */
    internalNetworks: outputs.PcDeployV2NetworkInternalNetworks;
    /**
     * -(Required) List of name servers on a cluster. This is part of payload for both cluster create & update operations. For create operation, only ipv4 address / fqdn values are supported currently.
     */
    nameServers: outputs.PcDeployV2NetworkNameServer[];
    /**
     * -(Required) List of NTP servers on a cluster. This is part of payload for both cluster create & update operations. For create operation, only ipv4 address / fqdn values are supported currently.
     */
    ntpServers: outputs.PcDeployV2NetworkNtpServer[];
}

export interface PcDeployV2NetworkExternalAddress {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcDeployV2NetworkExternalAddressIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcDeployV2NetworkExternalAddressIpv6[];
}

export interface PcDeployV2NetworkExternalAddressIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcDeployV2NetworkExternalAddressIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcDeployV2NetworkExternalNetwork {
    /**
     * -(Required) An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    defaultGateway: outputs.PcDeployV2NetworkExternalNetworkDefaultGateway;
    /**
     * -(Required) Range of IPs used for Prism Central network setup.
     */
    ipRanges: outputs.PcDeployV2NetworkExternalNetworkIpRange[];
    /**
     * -(Required) The network external identifier to which Domain Manager (Prism Central) is to be deployed or is already configured.
     */
    networkExtId: string;
    /**
     * -(Required) An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    subnetMask: outputs.PcDeployV2NetworkExternalNetworkSubnetMask;
}

export interface PcDeployV2NetworkExternalNetworkDefaultGateway {
    /**
     * -(Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.PcDeployV2NetworkExternalNetworkDefaultGatewayFqdn[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcDeployV2NetworkExternalNetworkDefaultGatewayIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcDeployV2NetworkExternalNetworkDefaultGatewayIpv6[];
}

export interface PcDeployV2NetworkExternalNetworkDefaultGatewayFqdn {
    /**
     * -(Optional) The fully qualified domain name of the host.
     *
     * See detailed information in [Nutanix Deploy PC V4](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/createDomainManager).
     */
    value: string;
}

export interface PcDeployV2NetworkExternalNetworkDefaultGatewayIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcDeployV2NetworkExternalNetworkDefaultGatewayIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcDeployV2NetworkExternalNetworkIpRange {
    /**
     * -(Optional) The beginning IP address of the range.
     */
    begin: outputs.PcDeployV2NetworkExternalNetworkIpRangeBegin;
    /**
     * -(Optional) The ending IP address of the range.
     */
    end: outputs.PcDeployV2NetworkExternalNetworkIpRangeEnd;
}

export interface PcDeployV2NetworkExternalNetworkIpRangeBegin {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcDeployV2NetworkExternalNetworkIpRangeBeginIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcDeployV2NetworkExternalNetworkIpRangeBeginIpv6[];
}

export interface PcDeployV2NetworkExternalNetworkIpRangeBeginIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcDeployV2NetworkExternalNetworkIpRangeBeginIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcDeployV2NetworkExternalNetworkIpRangeEnd {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcDeployV2NetworkExternalNetworkIpRangeEndIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcDeployV2NetworkExternalNetworkIpRangeEndIpv6[];
}

export interface PcDeployV2NetworkExternalNetworkIpRangeEndIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcDeployV2NetworkExternalNetworkIpRangeEndIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcDeployV2NetworkExternalNetworkSubnetMask {
    /**
     * -(Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.PcDeployV2NetworkExternalNetworkSubnetMaskFqdn[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcDeployV2NetworkExternalNetworkSubnetMaskIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcDeployV2NetworkExternalNetworkSubnetMaskIpv6[];
}

export interface PcDeployV2NetworkExternalNetworkSubnetMaskFqdn {
    /**
     * -(Optional) The fully qualified domain name of the host.
     *
     * See detailed information in [Nutanix Deploy PC V4](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/createDomainManager).
     */
    value: string;
}

export interface PcDeployV2NetworkExternalNetworkSubnetMaskIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcDeployV2NetworkExternalNetworkSubnetMaskIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcDeployV2NetworkInternalNetworks {
    /**
     * -(Required) An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    defaultGateway: outputs.PcDeployV2NetworkInternalNetworksDefaultGateway;
    /**
     * -(Required) Range of IPs used for Prism Central network setup.
     */
    ipRanges: outputs.PcDeployV2NetworkInternalNetworksIpRange[];
    /**
     * -(Required) An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    subnetMask: outputs.PcDeployV2NetworkInternalNetworksSubnetMask;
}

export interface PcDeployV2NetworkInternalNetworksDefaultGateway {
    /**
     * -(Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.PcDeployV2NetworkInternalNetworksDefaultGatewayFqdn[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcDeployV2NetworkInternalNetworksDefaultGatewayIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcDeployV2NetworkInternalNetworksDefaultGatewayIpv6[];
}

export interface PcDeployV2NetworkInternalNetworksDefaultGatewayFqdn {
    /**
     * -(Optional) The fully qualified domain name of the host.
     *
     * See detailed information in [Nutanix Deploy PC V4](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/createDomainManager).
     */
    value: string;
}

export interface PcDeployV2NetworkInternalNetworksDefaultGatewayIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcDeployV2NetworkInternalNetworksDefaultGatewayIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcDeployV2NetworkInternalNetworksIpRange {
    /**
     * -(Optional) The beginning IP address of the range.
     */
    begin: outputs.PcDeployV2NetworkInternalNetworksIpRangeBegin;
    /**
     * -(Optional) The ending IP address of the range.
     */
    end: outputs.PcDeployV2NetworkInternalNetworksIpRangeEnd;
}

export interface PcDeployV2NetworkInternalNetworksIpRangeBegin {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcDeployV2NetworkInternalNetworksIpRangeBeginIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcDeployV2NetworkInternalNetworksIpRangeBeginIpv6[];
}

export interface PcDeployV2NetworkInternalNetworksIpRangeBeginIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcDeployV2NetworkInternalNetworksIpRangeBeginIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcDeployV2NetworkInternalNetworksIpRangeEnd {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcDeployV2NetworkInternalNetworksIpRangeEndIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcDeployV2NetworkInternalNetworksIpRangeEndIpv6[];
}

export interface PcDeployV2NetworkInternalNetworksIpRangeEndIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcDeployV2NetworkInternalNetworksIpRangeEndIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcDeployV2NetworkInternalNetworksSubnetMask {
    /**
     * -(Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.PcDeployV2NetworkInternalNetworksSubnetMaskFqdn[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcDeployV2NetworkInternalNetworksSubnetMaskIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcDeployV2NetworkInternalNetworksSubnetMaskIpv6[];
}

export interface PcDeployV2NetworkInternalNetworksSubnetMaskFqdn {
    /**
     * -(Optional) The fully qualified domain name of the host.
     *
     * See detailed information in [Nutanix Deploy PC V4](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/createDomainManager).
     */
    value: string;
}

export interface PcDeployV2NetworkInternalNetworksSubnetMaskIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcDeployV2NetworkInternalNetworksSubnetMaskIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcDeployV2NetworkNameServer {
    /**
     * -(Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.PcDeployV2NetworkNameServerFqdn[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcDeployV2NetworkNameServerIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcDeployV2NetworkNameServerIpv6[];
}

export interface PcDeployV2NetworkNameServerFqdn {
    /**
     * -(Optional) The fully qualified domain name of the host.
     *
     * See detailed information in [Nutanix Deploy PC V4](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/createDomainManager).
     */
    value: string;
}

export interface PcDeployV2NetworkNameServerIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcDeployV2NetworkNameServerIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcDeployV2NetworkNtpServer {
    /**
     * -(Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.PcDeployV2NetworkNtpServerFqdn[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcDeployV2NetworkNtpServerIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcDeployV2NetworkNtpServerIpv6[];
}

export interface PcDeployV2NetworkNtpServerFqdn {
    /**
     * -(Optional) The fully qualified domain name of the host.
     *
     * See detailed information in [Nutanix Deploy PC V4](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/createDomainManager).
     */
    value: string;
}

export interface PcDeployV2NetworkNtpServerIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcDeployV2NetworkNtpServerIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRegistrationV2Config {
    bootstrapConfig: outputs.PcRegistrationV2ConfigBootstrapConfig;
    buildInfo: outputs.PcRegistrationV2ConfigBuildInfo;
    /**
     * -(Required)  Credentials to connect to a remote cluster.
     */
    credentials?: outputs.PcRegistrationV2ConfigCredential[];
    name: string;
    resourceConfigs: outputs.PcRegistrationV2ConfigResourceConfig[];
    shouldEnableLockdownMode: boolean;
    size: string;
}

export interface PcRegistrationV2ConfigBootstrapConfig {
    cloudInitConfigs?: outputs.PcRegistrationV2ConfigBootstrapConfigCloudInitConfig[];
    environmentInfo: outputs.PcRegistrationV2ConfigBootstrapConfigEnvironmentInfo;
}

export interface PcRegistrationV2ConfigBootstrapConfigCloudInitConfig {
    cloudInitScripts: outputs.PcRegistrationV2ConfigBootstrapConfigCloudInitConfigCloudInitScript[];
    datasourceType?: string;
    metadata: string;
}

export interface PcRegistrationV2ConfigBootstrapConfigCloudInitConfigCloudInitScript {
    customKeyValues: outputs.PcRegistrationV2ConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValue[];
    userDatas: outputs.PcRegistrationV2ConfigBootstrapConfigCloudInitConfigCloudInitScriptUserData[];
}

export interface PcRegistrationV2ConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValue {
    keyValuePairs: outputs.PcRegistrationV2ConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePair[];
}

export interface PcRegistrationV2ConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePair {
    name: string;
    values: outputs.PcRegistrationV2ConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePairValue[];
}

export interface PcRegistrationV2ConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePairValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.PcRegistrationV2ConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface PcRegistrationV2ConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString {
    map: {[key: string]: string};
}

export interface PcRegistrationV2ConfigBootstrapConfigCloudInitConfigCloudInitScriptUserData {
    value: string;
}

export interface PcRegistrationV2ConfigBootstrapConfigEnvironmentInfo {
    providerType: string;
    provisioningType: string;
    type: string;
}

export interface PcRegistrationV2ConfigBuildInfo {
    version: string;
}

export interface PcRegistrationV2ConfigCredential {
    /**
     * -(Required)  Password required for the basic auth scheme.
     *
     * See detailed information in [Nutanix Register a PC Docs](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/register).
     */
    password: string;
    /**
     * -(Required)  Username required for the basic auth scheme. As per RFC 2617 usernames might be case sensitive.
     */
    username: string;
}

export interface PcRegistrationV2ConfigResourceConfig {
    containerExtIds: string[];
    dataDiskSizeBytes: number;
    memorySizeBytes: number;
    numVcpus: number;
}

export interface PcRegistrationV2Link {
    href: string;
    rel: string;
}

export interface PcRegistrationV2Network {
    externalAddress?: outputs.PcRegistrationV2NetworkExternalAddress;
    externalNetworks: outputs.PcRegistrationV2NetworkExternalNetwork[];
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdn: string;
    internalNetworks: outputs.PcRegistrationV2NetworkInternalNetworks;
    nameServers: outputs.PcRegistrationV2NetworkNameServer[];
    ntpServers: outputs.PcRegistrationV2NetworkNtpServer[];
}

export interface PcRegistrationV2NetworkExternalAddress {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRegistrationV2NetworkExternalAddressIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRegistrationV2NetworkExternalAddressIpv6[];
}

export interface PcRegistrationV2NetworkExternalAddressIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
     */
    value: string;
}

export interface PcRegistrationV2NetworkExternalAddressIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    value: string;
}

export interface PcRegistrationV2NetworkExternalNetwork {
    defaultGateway: outputs.PcRegistrationV2NetworkExternalNetworkDefaultGateway;
    ipRanges: outputs.PcRegistrationV2NetworkExternalNetworkIpRange[];
    networkExtId: string;
    subnetMask: outputs.PcRegistrationV2NetworkExternalNetworkSubnetMask;
}

export interface PcRegistrationV2NetworkExternalNetworkDefaultGateway {
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.PcRegistrationV2NetworkExternalNetworkDefaultGatewayFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv6[];
}

export interface PcRegistrationV2NetworkExternalNetworkDefaultGatewayFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
     */
    value: string;
}

export interface PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    value: string;
}

export interface PcRegistrationV2NetworkExternalNetworkIpRange {
    begin: outputs.PcRegistrationV2NetworkExternalNetworkIpRangeBegin;
    end: outputs.PcRegistrationV2NetworkExternalNetworkIpRangeEnd;
}

export interface PcRegistrationV2NetworkExternalNetworkIpRangeBegin {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv6[];
}

export interface PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
     */
    value: string;
}

export interface PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    value: string;
}

export interface PcRegistrationV2NetworkExternalNetworkIpRangeEnd {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv6[];
}

export interface PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
     */
    value: string;
}

export interface PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    value: string;
}

export interface PcRegistrationV2NetworkExternalNetworkSubnetMask {
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.PcRegistrationV2NetworkExternalNetworkSubnetMaskFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv6[];
}

export interface PcRegistrationV2NetworkExternalNetworkSubnetMaskFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
     */
    value: string;
}

export interface PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    value: string;
}

export interface PcRegistrationV2NetworkInternalNetworks {
    defaultGateway: outputs.PcRegistrationV2NetworkInternalNetworksDefaultGateway;
    ipRanges: outputs.PcRegistrationV2NetworkInternalNetworksIpRange[];
    subnetMask: outputs.PcRegistrationV2NetworkInternalNetworksSubnetMask;
}

export interface PcRegistrationV2NetworkInternalNetworksDefaultGateway {
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.PcRegistrationV2NetworkInternalNetworksDefaultGatewayFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRegistrationV2NetworkInternalNetworksDefaultGatewayIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRegistrationV2NetworkInternalNetworksDefaultGatewayIpv6[];
}

export interface PcRegistrationV2NetworkInternalNetworksDefaultGatewayFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface PcRegistrationV2NetworkInternalNetworksDefaultGatewayIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
     */
    value: string;
}

export interface PcRegistrationV2NetworkInternalNetworksDefaultGatewayIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    value: string;
}

export interface PcRegistrationV2NetworkInternalNetworksIpRange {
    begin: outputs.PcRegistrationV2NetworkInternalNetworksIpRangeBegin;
    end: outputs.PcRegistrationV2NetworkInternalNetworksIpRangeEnd;
}

export interface PcRegistrationV2NetworkInternalNetworksIpRangeBegin {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRegistrationV2NetworkInternalNetworksIpRangeBeginIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRegistrationV2NetworkInternalNetworksIpRangeBeginIpv6[];
}

export interface PcRegistrationV2NetworkInternalNetworksIpRangeBeginIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
     */
    value: string;
}

export interface PcRegistrationV2NetworkInternalNetworksIpRangeBeginIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    value: string;
}

export interface PcRegistrationV2NetworkInternalNetworksIpRangeEnd {
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRegistrationV2NetworkInternalNetworksIpRangeEndIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRegistrationV2NetworkInternalNetworksIpRangeEndIpv6[];
}

export interface PcRegistrationV2NetworkInternalNetworksIpRangeEndIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
     */
    value: string;
}

export interface PcRegistrationV2NetworkInternalNetworksIpRangeEndIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    value: string;
}

export interface PcRegistrationV2NetworkInternalNetworksSubnetMask {
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.PcRegistrationV2NetworkInternalNetworksSubnetMaskFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRegistrationV2NetworkInternalNetworksSubnetMaskIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRegistrationV2NetworkInternalNetworksSubnetMaskIpv6[];
}

export interface PcRegistrationV2NetworkInternalNetworksSubnetMaskFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface PcRegistrationV2NetworkInternalNetworksSubnetMaskIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
     */
    value: string;
}

export interface PcRegistrationV2NetworkInternalNetworksSubnetMaskIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    value: string;
}

export interface PcRegistrationV2NetworkNameServer {
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.PcRegistrationV2NetworkNameServerFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRegistrationV2NetworkNameServerIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRegistrationV2NetworkNameServerIpv6[];
}

export interface PcRegistrationV2NetworkNameServerFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface PcRegistrationV2NetworkNameServerIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
     */
    value: string;
}

export interface PcRegistrationV2NetworkNameServerIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    value: string;
}

export interface PcRegistrationV2NetworkNtpServer {
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.PcRegistrationV2NetworkNtpServerFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRegistrationV2NetworkNtpServerIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRegistrationV2NetworkNtpServerIpv6[];
}

export interface PcRegistrationV2NetworkNtpServerFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface PcRegistrationV2NetworkNtpServerIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
     */
    value: string;
}

export interface PcRegistrationV2NetworkNtpServerIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    value: string;
}

export interface PcRegistrationV2RemoteCluster {
    /**
     * - The registration request consists of the remote cluster details.
     */
    aosRemoteClusterSpec?: outputs.PcRegistrationV2RemoteClusterAosRemoteClusterSpec;
    /**
     * - The registration request consists of the remote cluster details. using the cluster reference.
     */
    clusterReference?: outputs.PcRegistrationV2RemoteClusterClusterReference;
    /**
     * - The registration request consists of the remote cluster details. and cloud type.
     */
    domainManagerRemoteClusterSpec?: outputs.PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpec;
}

export interface PcRegistrationV2RemoteClusterAosRemoteClusterSpec {
    /**
     * -(Required)  Address configuration of a remote cluster. It requires the address of the remote, that is an IP or domain name along with the basic authentication credentials.
     */
    remoteCluster: outputs.PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteCluster;
}

export interface PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteCluster {
    /**
     * -(Required)  An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    addresses: outputs.PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddress[];
    /**
     * -(Required)  Credentials to connect to a remote cluster.
     */
    credentials: outputs.PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentials;
}

export interface PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddress {
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv6[];
}

export interface PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
     */
    value: string;
}

export interface PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    value: string;
}

export interface PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentials {
    /**
     * -(Required)  An authentication scheme that requires the client to present a username and password. The server will service the request only if it can validate the user-ID and password for the protection space of the Request-URI.
     */
    authentication: outputs.PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsAuthentication;
}

export interface PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsAuthentication {
    /**
     * -(Required)  Password required for the basic auth scheme.
     *
     * See detailed information in [Nutanix Register a PC Docs](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/register).
     */
    password: string;
    /**
     * -(Required)  Username required for the basic auth scheme. As per RFC 2617 usernames might be case sensitive.
     */
    username: string;
}

export interface PcRegistrationV2RemoteClusterClusterReference {
    /**
     * -(Required)  Cluster UUID of a remote cluster.
     */
    extId: string;
}

export interface PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpec {
    /**
     * -(Required)  Enum denoting whether the domain manager (Prism Central) instance is reachable with its physical address or reachable through the My Nutanix portal. Based on the above description, the allowed enum values are:
     * * `NUTANIX_HOSTED_CLOUD` : Domain manager (Prism Central) reachable through My Nutanix portal.
     * * `ONPREM_CLOUD`: Domain manager (Prism Central) reachable on it's physical address.
     */
    cloudType: string;
    /**
     * -(Required)  Address configuration of a remote cluster. It requires the address of the remote, that is an IP or domain name along with the basic authentication credentials.
     */
    remoteCluster: outputs.PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteCluster;
}

export interface PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteCluster {
    /**
     * -(Required)  An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    addresses: outputs.PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddress[];
    /**
     * -(Required)  Credentials to connect to a remote cluster.
     */
    credentials: outputs.PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentials;
}

export interface PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddress {
    /**
     * - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressFqdn[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv4[];
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv6[];
}

export interface PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressFqdn {
    /**
     * - The fully qualified domain name of the host.
     */
    value: string;
}

export interface PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
     */
    value: string;
}

export interface PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv6 {
    /**
     * - The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    value: string;
}

export interface PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentials {
    /**
     * -(Required)  An authentication scheme that requires the client to present a username and password. The server will service the request only if it can validate the user-ID and password for the protection space of the Request-URI.
     */
    authentication: outputs.PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsAuthentication;
}

export interface PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsAuthentication {
    /**
     * -(Required)  Password required for the basic auth scheme.
     *
     * See detailed information in [Nutanix Register a PC Docs](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/register).
     */
    password: string;
    /**
     * -(Required)  Username required for the basic auth scheme. As per RFC 2617 usernames might be case sensitive.
     */
    username: string;
}

export interface PcRestoreSourceV2Link {
    href: string;
    rel: string;
}

export interface PcRestoreSourceV2Location {
    /**
     * -(Optional) A boolean value indicating whether to enable lockdown mode for a cluster.
     */
    clusterLocations?: outputs.PcRestoreSourceV2LocationClusterLocation[];
    /**
     * -(Optional) Currently representing the build information to be used for the cluster creation.
     */
    objectStoreLocations?: outputs.PcRestoreSourceV2LocationObjectStoreLocation[];
}

export interface PcRestoreSourceV2LocationClusterLocation {
    /**
     * -(Required) Cluster reference of the remote cluster to be connected.
     */
    configs: outputs.PcRestoreSourceV2LocationClusterLocationConfig[];
}

export interface PcRestoreSourceV2LocationClusterLocationConfig {
    /**
     * -(Required) Cluster UUID of a remote cluster.
     */
    extId: string;
    name: string;
}

export interface PcRestoreSourceV2LocationObjectStoreLocation {
    /**
     * -(Optional) Backup policy for the object store provided.
     */
    backupPolicies?: outputs.PcRestoreSourceV2LocationObjectStoreLocationBackupPolicy[];
    /**
     * -(Required) The base model of S3 object store endpoint where domain manager is backed up.
     */
    providerConfigs: outputs.PcRestoreSourceV2LocationObjectStoreLocationProviderConfig[];
}

export interface PcRestoreSourceV2LocationObjectStoreLocationBackupPolicy {
    /**
     * -(Required) RPO interval in minutes at which the backup will be taken. The Value should be in the range of 60 to 1440.
     *
     * See detailed information in [Nutanix Restore Source V4](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/createRestoreSource).
     */
    rpoInMinutes: number;
}

export interface PcRestoreSourceV2LocationObjectStoreLocationProviderConfig {
    /**
     * -(Required) The bucket name of the object store endpoint where backup data of domain manager is to be stored.
     */
    bucketName: string;
    /**
     * -(Optional) Secret credentials model for the object store containing access key ID and secret access key.
     */
    credentials?: outputs.PcRestoreSourceV2LocationObjectStoreLocationProviderConfigCredentials;
    /**
     * -(Optional) The region name of the object store endpoint where backup data of domain manager is stored. Default is `us-east-1`.
     */
    region?: string;
}

export interface PcRestoreSourceV2LocationObjectStoreLocationProviderConfigCredentials {
    /**
     * -(Required) Access key ID for the object store provided for backup target.
     */
    accessKeyId: string;
    /**
     * -(Required) Secret access key for the object store provided for backup target.
     */
    secretAccessKey: string;
}

export interface PcRestoreV2DomainManager {
    /**
     * -(Required) Domain manager (Prism Central) cluster configuration details.
     */
    configs: outputs.PcRestoreV2DomainManagerConfig[];
    hostingClusterExtId: string;
    isRegisteredWithHostingCluster: boolean;
    /**
     * -(Required) Domain manager (Prism Central) network configuration details.
     */
    networks: outputs.PcRestoreV2DomainManagerNetwork[];
    nodeExtIds: string[];
    /**
     * -(Optional) This configuration enables Prism Central to be deployed in scale-out mode. Default is `false`.
     */
    shouldEnableHighAvailability: boolean;
}

export interface PcRestoreV2DomainManagerConfig {
    /**
     * - (Optional) Bootstrap configuration details for the domain manager (Prism Central).
     */
    bootstrapConfig: outputs.PcRestoreV2DomainManagerConfigBootstrapConfig;
    /**
     * -(Required) Currently representing the build information to be used for the cluster creation.
     */
    buildInfo: outputs.PcRestoreV2DomainManagerConfigBuildInfo;
    /**
     * - (Optional) The credentials consist of a username and password for a particular user like admin. Users can pass the credentials of admin users currently which will be configured in the create domain manager operation.
     */
    credentials?: outputs.PcRestoreV2DomainManagerConfigCredential[];
    /**
     * -(Required) Name of the domain manager (Prism Central).
     */
    name: string;
    /**
     * -(Optional) This configuration is used to provide the resource-related details like container external identifiers, number of VCPUs, memory size, data disk size of the domain manager (Prism Central). In the case of a multi-node setup, the sum of resources like number of VCPUs, memory size and data disk size are provided.
     */
    resourceConfigs: outputs.PcRestoreV2DomainManagerConfigResourceConfig[];
    /**
     * -(Optional) A boolean value indicating whether to enable lockdown mode for a cluster.
     */
    shouldEnableLockdownMode: boolean;
    /**
     * - (Required) Domain manager (Prism Central) size is an enumeration of starter, small, large, or extra large starter values. The allowed values are:
     * - `SMALL` : Domain manager (Prism Central) of size small.
     * - `LARGE` : Domain manager (Prism Central) of size large.
     * - `EXTRALARGE` : Domain manager (Prism Central) of size extra large.
     * - `STARTER` : Domain manager (Prism Central) of size starter.
     */
    size: string;
}

export interface PcRestoreV2DomainManagerConfigBootstrapConfig {
    /**
     * -(Optional) Cloud-init configuration for the domain manager (Prism Central) cluster.
     */
    cloudInitConfigs?: outputs.PcRestoreV2DomainManagerConfigBootstrapConfigCloudInitConfig[];
    /**
     * -(Optional) Environment information for the domain manager (Prism Central) cluster.
     */
    environmentInfo: outputs.PcRestoreV2DomainManagerConfigBootstrapConfigEnvironmentInfo;
}

export interface PcRestoreV2DomainManagerConfigBootstrapConfigCloudInitConfig {
    /**
     * -(Optional) The script to use for cloud-init.
     * - `cloud_init_script.user_data`: -(Optional) user data object
     * - `cloud_init_script.custom_keys`: -(Optional) The list of the individual KeyValuePair elements.
     */
    cloudInitScripts: outputs.PcRestoreV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScript[];
    /**
     * -(Optional) Type of datasource. Default: CONFIG_DRIVE_V2
     */
    datasourceType?: string;
    /**
     * -(Optional)The contents of the metaData configuration for cloud-init. This can be formatted as YAML or JSON. The value must be base64 encoded. Default value is 'CONFIG_DRIVE_V2'.
     */
    metadata: string;
}

export interface PcRestoreV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScript {
    customKeyValues: outputs.PcRestoreV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValue[];
    userDatas: outputs.PcRestoreV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptUserData[];
}

export interface PcRestoreV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValue {
    keyValuePairs: outputs.PcRestoreV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePair[];
}

export interface PcRestoreV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePair {
    /**
     * -(Required) Name of the domain manager (Prism Central).
     */
    name: string;
    values: outputs.PcRestoreV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePairValue[];
}

export interface PcRestoreV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePairValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.PcRestoreV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface PcRestoreV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString {
    map: {[key: string]: string};
}

export interface PcRestoreV2DomainManagerConfigBootstrapConfigCloudInitConfigCloudInitScriptUserData {
    value: string;
}

export interface PcRestoreV2DomainManagerConfigBootstrapConfigEnvironmentInfo {
    /**
     * -(Optional) Enums denoting the provider type of the PC, that is, AHV or ESXi.
     * Following are the supported provider types:
     * - `VSPHERE` : Vsphere cloud provider.
     * - `AZURE` : Azure cloud provider.
     * - `NTNX` : Nutanix cloud provider.
     * - `GCP` : GCP cloud provider.
     * - `AWS` : AWS cloud provider.
     */
    providerType: string;
    /**
     * -(Optional) Enums denoting the instance type of the cloud PC. It indicates whether the PC is created on bare-metal or on a cloud-provisioned VM. Hence, it supports two possible values:
     * - `NTNX` : Nutanix instance.
     * - `NATIVE` : Native instance.
     */
    provisioningType: string;
    /**
     * -(Optional) Enums denoting the environment type of the PC, that is, on-prem PC or cloud PC.
     * Following are the supported entity types:
     * - `ONPREM` : On-prem environment.
     * - `NTNX_CLOUD` : Nutanix cloud environment.
     */
    type: string;
}

export interface PcRestoreV2DomainManagerConfigBuildInfo {
    /**
     * -(Optional) Software version.
     */
    version: string;
}

export interface PcRestoreV2DomainManagerConfigCredential {
    /**
     * -(Required) Password required for the basic auth scheme.
     */
    password: string;
    /**
     * -(Required) Username required for the basic auth scheme. As per RFC 2617 usernames might be case sensitive.
     */
    username: string;
}

export interface PcRestoreV2DomainManagerConfigResourceConfig {
    /**
     * -(Optional) The external identifier of the container that will be used to create the domain manager (Prism Central) cluster.
     */
    containerExtIds: string[];
    dataDiskSizeBytes: number;
    memorySizeBytes: number;
    numVcpus: number;
}

export interface PcRestoreV2DomainManagerNetwork {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
     */
    externalAddress?: outputs.PcRestoreV2DomainManagerNetworkExternalAddress;
    /**
     * -(Required) This configuration is used to manage Prism Central.
     */
    externalNetworks: outputs.PcRestoreV2DomainManagerNetworkExternalNetwork[];
    fqdn: string;
    /**
     * -(Required) This configuration is used to internally manage Prism Central network.
     */
    internalNetworks: outputs.PcRestoreV2DomainManagerNetworkInternalNetworks;
    /**
     * -(Required) List of name servers on a cluster. This is part of payload for both cluster create & update operations. For create operation, only ipv4 address / fqdn values are supported currently.
     */
    nameServers: outputs.PcRestoreV2DomainManagerNetworkNameServer[];
    /**
     * -(Required) List of NTP servers on a cluster. This is part of payload for both cluster create & update operations. For create operation, only ipv4 address / fqdn values are supported currently.
     */
    ntpServers: outputs.PcRestoreV2DomainManagerNetworkNtpServer[];
}

export interface PcRestoreV2DomainManagerNetworkExternalAddress {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRestoreV2DomainManagerNetworkExternalAddressIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRestoreV2DomainManagerNetworkExternalAddressIpv6[];
}

export interface PcRestoreV2DomainManagerNetworkExternalAddressIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkExternalAddressIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkExternalNetwork {
    /**
     * -(Required) An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    defaultGateway: outputs.PcRestoreV2DomainManagerNetworkExternalNetworkDefaultGateway;
    /**
     * -(Required) Range of IPs used for Prism Central network setup.
     */
    ipRanges: outputs.PcRestoreV2DomainManagerNetworkExternalNetworkIpRange[];
    /**
     * -(Required) The network external identifier to which Domain Manager (Prism Central) is to be deployed or is already configured.
     */
    networkExtId: string;
    /**
     * -(Required) An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    subnetMask: outputs.PcRestoreV2DomainManagerNetworkExternalNetworkSubnetMask;
}

export interface PcRestoreV2DomainManagerNetworkExternalNetworkDefaultGateway {
    /**
     * -(Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.PcRestoreV2DomainManagerNetworkExternalNetworkDefaultGatewayFqdn[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRestoreV2DomainManagerNetworkExternalNetworkDefaultGatewayIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRestoreV2DomainManagerNetworkExternalNetworkDefaultGatewayIpv6[];
}

export interface PcRestoreV2DomainManagerNetworkExternalNetworkDefaultGatewayFqdn {
    /**
     * -(Optional) The fully qualified domain name of the host.
     *
     * See detailed information in [Nutanix Restore PC V4](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/restore).
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkExternalNetworkDefaultGatewayIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkExternalNetworkDefaultGatewayIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkExternalNetworkIpRange {
    /**
     * -(Optional) The beginning IP address of the range.
     */
    begin: outputs.PcRestoreV2DomainManagerNetworkExternalNetworkIpRangeBegin;
    /**
     * -(Optional) The ending IP address of the range.
     */
    end: outputs.PcRestoreV2DomainManagerNetworkExternalNetworkIpRangeEnd;
}

export interface PcRestoreV2DomainManagerNetworkExternalNetworkIpRangeBegin {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRestoreV2DomainManagerNetworkExternalNetworkIpRangeBeginIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRestoreV2DomainManagerNetworkExternalNetworkIpRangeBeginIpv6[];
}

export interface PcRestoreV2DomainManagerNetworkExternalNetworkIpRangeBeginIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkExternalNetworkIpRangeBeginIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkExternalNetworkIpRangeEnd {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRestoreV2DomainManagerNetworkExternalNetworkIpRangeEndIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRestoreV2DomainManagerNetworkExternalNetworkIpRangeEndIpv6[];
}

export interface PcRestoreV2DomainManagerNetworkExternalNetworkIpRangeEndIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkExternalNetworkIpRangeEndIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkExternalNetworkSubnetMask {
    /**
     * -(Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.PcRestoreV2DomainManagerNetworkExternalNetworkSubnetMaskFqdn[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRestoreV2DomainManagerNetworkExternalNetworkSubnetMaskIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRestoreV2DomainManagerNetworkExternalNetworkSubnetMaskIpv6[];
}

export interface PcRestoreV2DomainManagerNetworkExternalNetworkSubnetMaskFqdn {
    /**
     * -(Optional) The fully qualified domain name of the host.
     *
     * See detailed information in [Nutanix Restore PC V4](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/restore).
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkExternalNetworkSubnetMaskIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkExternalNetworkSubnetMaskIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkInternalNetworks {
    /**
     * -(Required) An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    defaultGateway: outputs.PcRestoreV2DomainManagerNetworkInternalNetworksDefaultGateway;
    /**
     * -(Required) Range of IPs used for Prism Central network setup.
     */
    ipRanges: outputs.PcRestoreV2DomainManagerNetworkInternalNetworksIpRange[];
    /**
     * -(Required) An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
     */
    subnetMask: outputs.PcRestoreV2DomainManagerNetworkInternalNetworksSubnetMask;
}

export interface PcRestoreV2DomainManagerNetworkInternalNetworksDefaultGateway {
    /**
     * -(Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.PcRestoreV2DomainManagerNetworkInternalNetworksDefaultGatewayFqdn[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRestoreV2DomainManagerNetworkInternalNetworksDefaultGatewayIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRestoreV2DomainManagerNetworkInternalNetworksDefaultGatewayIpv6[];
}

export interface PcRestoreV2DomainManagerNetworkInternalNetworksDefaultGatewayFqdn {
    /**
     * -(Optional) The fully qualified domain name of the host.
     *
     * See detailed information in [Nutanix Restore PC V4](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/restore).
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkInternalNetworksDefaultGatewayIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkInternalNetworksDefaultGatewayIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkInternalNetworksIpRange {
    /**
     * -(Optional) The beginning IP address of the range.
     */
    begin: outputs.PcRestoreV2DomainManagerNetworkInternalNetworksIpRangeBegin;
    /**
     * -(Optional) The ending IP address of the range.
     */
    end: outputs.PcRestoreV2DomainManagerNetworkInternalNetworksIpRangeEnd;
}

export interface PcRestoreV2DomainManagerNetworkInternalNetworksIpRangeBegin {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRestoreV2DomainManagerNetworkInternalNetworksIpRangeBeginIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRestoreV2DomainManagerNetworkInternalNetworksIpRangeBeginIpv6[];
}

export interface PcRestoreV2DomainManagerNetworkInternalNetworksIpRangeBeginIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkInternalNetworksIpRangeBeginIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkInternalNetworksIpRangeEnd {
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRestoreV2DomainManagerNetworkInternalNetworksIpRangeEndIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRestoreV2DomainManagerNetworkInternalNetworksIpRangeEndIpv6[];
}

export interface PcRestoreV2DomainManagerNetworkInternalNetworksIpRangeEndIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkInternalNetworksIpRangeEndIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkInternalNetworksSubnetMask {
    /**
     * -(Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.PcRestoreV2DomainManagerNetworkInternalNetworksSubnetMaskFqdn[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRestoreV2DomainManagerNetworkInternalNetworksSubnetMaskIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRestoreV2DomainManagerNetworkInternalNetworksSubnetMaskIpv6[];
}

export interface PcRestoreV2DomainManagerNetworkInternalNetworksSubnetMaskFqdn {
    /**
     * -(Optional) The fully qualified domain name of the host.
     *
     * See detailed information in [Nutanix Restore PC V4](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/restore).
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkInternalNetworksSubnetMaskIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkInternalNetworksSubnetMaskIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkNameServer {
    /**
     * -(Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.PcRestoreV2DomainManagerNetworkNameServerFqdn[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRestoreV2DomainManagerNetworkNameServerIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRestoreV2DomainManagerNetworkNameServerIpv6[];
}

export interface PcRestoreV2DomainManagerNetworkNameServerFqdn {
    /**
     * -(Optional) The fully qualified domain name of the host.
     *
     * See detailed information in [Nutanix Restore PC V4](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/restore).
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkNameServerIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkNameServerIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkNtpServer {
    /**
     * -(Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.PcRestoreV2DomainManagerNetworkNtpServerFqdn[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.PcRestoreV2DomainManagerNetworkNtpServerIpv4[];
    /**
     * -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.PcRestoreV2DomainManagerNetworkNtpServerIpv6[];
}

export interface PcRestoreV2DomainManagerNetworkNtpServerFqdn {
    /**
     * -(Optional) The fully qualified domain name of the host.
     *
     * See detailed information in [Nutanix Restore PC V4](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/restore).
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkNtpServerIpv4 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface PcRestoreV2DomainManagerNetworkNtpServerIpv6 {
    /**
     * -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength?: number;
    /**
     * -(Required) The IPv4/IPv6 address of the host.
     */
    value: string;
}

export interface ProjectAccountReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectAcp {
    /**
     * The list of context filters. These are OR filters. The scope-expression-list defines the context, and the filter works in conjunction with the entity-expression-list.
     */
    contextFilterLists: outputs.ProjectAcpContextFilterList[];
    /**
     * A description for project.
     */
    description?: string;
    metadata: {[key: string]: string};
    /**
     * The name for the project.
     */
    name: string;
    /**
     * Reference to role.
     */
    roleReference: outputs.ProjectAcpRoleReference;
    /**
     * List of Reference of users groups.
     */
    userGroupReferenceLists?: outputs.ProjectAcpUserGroupReferenceList[];
    /**
     * List of Reference of users.
     */
    userReferenceLists?: outputs.ProjectAcpUserReferenceList[];
}

export interface ProjectAcpContextFilterList {
    /**
     * (Required) A list of Entity filter expressions.
     */
    entityFilterExpressionLists: outputs.ProjectAcpContextFilterListEntityFilterExpressionList[];
    /**
     * - (Optional) Filter the scope of an Access Control Policy.
     */
    scopeFilterExpressionLists?: outputs.ProjectAcpContextFilterListScopeFilterExpressionList[];
}

export interface ProjectAcpContextFilterListEntityFilterExpressionList {
    /**
     * - (Optional)  The LHS of the filter expression - the entity type.
     */
    leftHandSideEntityType: string;
    /**
     * - (Required) The operator in the filter expression.
     */
    operator: string;
    /**
     * - (Required) The right hand side (RHS) of an scope expression.
     */
    rightHandSide: outputs.ProjectAcpContextFilterListEntityFilterExpressionListRightHandSide;
}

export interface ProjectAcpContextFilterListEntityFilterExpressionListRightHandSide {
    /**
     * - (Optional) The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideCategories;
    /**
     * - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
     */
    collection: string;
    /**
     * - (Optional) The explicit list of UUIDs for the given kind.
     */
    uuidLists: string[];
}

export interface ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideCategories {
    /**
     * The name for the project.
     */
    name: string;
    /**
     * value of the key.
     */
    values: string[];
}

export interface ProjectAcpContextFilterListScopeFilterExpressionList {
    /**
     * - (Optional)  The LHS of the filter expression - the scope type.
     */
    leftHandSide: string;
    /**
     * - (Required) The operator in the filter expression.
     */
    operator: string;
    /**
     * - (Required) The right hand side (RHS) of an scope expression.
     */
    rightHandSide: outputs.ProjectAcpContextFilterListScopeFilterExpressionListRightHandSide;
}

export interface ProjectAcpContextFilterListScopeFilterExpressionListRightHandSide {
    /**
     * - (Optional) The category values represented as a dictionary of key > list of values.
     */
    categories: outputs.ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideCategories;
    /**
     * - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
     */
    collection: string;
    /**
     * - (Optional) The explicit list of UUIDs for the given kind.
     */
    uuidLists: string[];
}

export interface ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideCategories {
    /**
     * The name for the project.
     */
    name: string;
    /**
     * value of the key.
     */
    values: string[];
}

export interface ProjectAcpRoleReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectAcpUserGroupReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name?: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectAcpUserReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name?: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectCategory {
    /**
     * The name for the project.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface ProjectClusterReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectDefaultEnvironmentReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectDefaultSubnetReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectEnvironmentReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectExternalNetworkList {
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectExternalUserGroupReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectResourceDomain {
    resources: outputs.ProjectResourceDomainResource[];
}

export interface ProjectResourceDomainResource {
    limit: number;
    resourceType: string;
    units: string;
    /**
     * value of the key.
     */
    value: number;
}

export interface ProjectSubnetReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectTunnelReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectUserGroupList {
    directoryServiceOus?: outputs.ProjectUserGroupListDirectoryServiceOus[];
    directoryServiceUserGroups?: outputs.ProjectUserGroupListDirectoryServiceUserGroup[];
    metadata?: {[key: string]: string};
    samlUserGroups?: outputs.ProjectUserGroupListSamlUserGroup[];
}

export interface ProjectUserGroupListDirectoryServiceOus {
    distinguishedName: string;
}

export interface ProjectUserGroupListDirectoryServiceUserGroup {
    distinguishedName: string;
}

export interface ProjectUserGroupListSamlUserGroup {
    idpUuid: string;
    /**
     * The name for the project.
     */
    name: string;
}

export interface ProjectUserList {
    directoryServiceUser: outputs.ProjectUserListDirectoryServiceUser;
    identityProviderUser: outputs.ProjectUserListIdentityProviderUser;
    metadata?: {[key: string]: string};
}

export interface ProjectUserListDirectoryServiceUser {
    defaultUserPrincipalName: string;
    directoryServiceReference: outputs.ProjectUserListDirectoryServiceUserDirectoryServiceReference;
    userPrincipalName: string;
}

export interface ProjectUserListDirectoryServiceUserDirectoryServiceReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectUserListIdentityProviderUser {
    identityProviderReference: outputs.ProjectUserListIdentityProviderUserIdentityProviderReference;
    username: string;
}

export interface ProjectUserListIdentityProviderUserIdentityProviderReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectUserReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectVpcReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProtectionPolicyV2Link {
    href: string;
    rel: string;
}

export interface ProtectionPolicyV2ReplicationConfiguration {
    /**
     * -(Optional) Label of the source location from the replication locations list, where the entity will be replicated.
     */
    remoteLocationLabel?: string;
    /**
     * -(Required) Schedule for protection. The schedule specifies the recovery point objective and the retention policy for the participating locations.
     */
    schedule: outputs.ProtectionPolicyV2ReplicationConfigurationSchedule;
    /**
     * -(Required) Label of the source location from the replication locations list, where the entity is running. The location of type MST can not be specified as the replication source.
     */
    sourceLocationLabel: string;
}

export interface ProtectionPolicyV2ReplicationConfigurationSchedule {
    /**
     * -(Required) The Recovery point objective of the schedule in seconds and specified in multiple of 60 seconds. Only following RPO values can be provided for rollup retention type:
     * - Minute(s): 1, 2, 3, 4, 5, 6, 10, 12, 15
     * - Hour(s): 1, 2, 3, 4, 6, 8, 12
     * - Day(s): 1
     * - Week(s): 1, 2
     */
    recoveryPointObjectiveTimeSeconds?: number;
    /**
     * -(Optional) Type of recovery point.
     * * `CRASH_CONSISTENT`: Crash-consistent Recovery points capture all the VM and application level details.
     * * `APP_CONSISTENT`: Application-consistent Recovery points can capture all the data stored in the memory and also the in-progress transaction details.
     */
    recoveryPointType?: string;
    /**
     * -(Optional) Specifies the retention policy for the recovery point schedule.
     */
    retention?: outputs.ProtectionPolicyV2ReplicationConfigurationScheduleRetention;
    /**
     * -(Optional) Represents the protection start time for the new entities added to the policy after the policy is created in h:m format. The values must be between 00h:00m and 23h:59m and in UTC timezone. It specifies the time when the first snapshot is taken and replicated for any entity added to the policy. If this is not specified, the snapshot is taken immediately and replicated for any new entity added to the policy.
     */
    startTime?: string;
    /**
     * -(Optional) Auto suspend timeout if there is a connection failure between locations for synchronous replication. If this value is not set, then the policy will not be suspended.
     */
    syncReplicationAutoSuspendTimeoutSeconds?: number;
}

export interface ProtectionPolicyV2ReplicationConfigurationScheduleRetention {
    /**
     * -(Optional) Auto rollup retention policy.
     */
    autoRollupRetention?: outputs.ProtectionPolicyV2ReplicationConfigurationScheduleRetentionAutoRollupRetention;
    /**
     * -(Optional) Linear retention policy.
     */
    linearRetention?: outputs.ProtectionPolicyV2ReplicationConfigurationScheduleRetentionLinearRetention;
}

export interface ProtectionPolicyV2ReplicationConfigurationScheduleRetentionAutoRollupRetention {
    /**
     * -(Required) Specifies the auto rollup retention details.
     */
    local: outputs.ProtectionPolicyV2ReplicationConfigurationScheduleRetentionAutoRollupRetentionLocal;
    /**
     * -(Optional) Specifies the auto rollup retention details.
     */
    remote?: outputs.ProtectionPolicyV2ReplicationConfigurationScheduleRetentionAutoRollupRetentionRemote;
}

export interface ProtectionPolicyV2ReplicationConfigurationScheduleRetentionAutoRollupRetentionLocal {
    /**
     * -(Required) Multiplier to 'snapshotIntervalType'. For example, if 'snapshotIntervalType' is 'YEARLY' and 'multiple' is 5, then 5 years worth of rollup snapshots will be retained.
     *
     *
     *
     * See detailed information in [Nutanix Protection Policy v4](https://developers.nutanix.com/api-reference?namespace=datapolicies&version=v4.0#tag/ProtectionPolicies/operation/createProtectionPolicy).
     */
    frequency: number;
    /**
     * -(Required) Snapshot interval period.
     * * `YEARLY`: Specifies the number of latest yearly recovery points to retain.
     * * `WEEKLY`: Specifies the number of latest weekly recovery points to retain.
     * * `DAILY`: Specifies the number of latest daily recovery points to retain.
     * * `MONTHLY`: Specifies the number of latest monthly recovery points to retain.
     * * `HOURLY`: Specifies the number of latest hourly recovery points to retain.
     */
    snapshotIntervalType?: string;
}

export interface ProtectionPolicyV2ReplicationConfigurationScheduleRetentionAutoRollupRetentionRemote {
    /**
     * -(Required) Multiplier to 'snapshotIntervalType'. For example, if 'snapshotIntervalType' is 'YEARLY' and 'multiple' is 5, then 5 years worth of rollup snapshots will be retained.
     *
     *
     *
     * See detailed information in [Nutanix Protection Policy v4](https://developers.nutanix.com/api-reference?namespace=datapolicies&version=v4.0#tag/ProtectionPolicies/operation/createProtectionPolicy).
     */
    frequency: number;
    /**
     * -(Required) Snapshot interval period.
     * * `YEARLY`: Specifies the number of latest yearly recovery points to retain.
     * * `WEEKLY`: Specifies the number of latest weekly recovery points to retain.
     * * `DAILY`: Specifies the number of latest daily recovery points to retain.
     * * `MONTHLY`: Specifies the number of latest monthly recovery points to retain.
     * * `HOURLY`: Specifies the number of latest hourly recovery points to retain.
     */
    snapshotIntervalType?: string;
}

export interface ProtectionPolicyV2ReplicationConfigurationScheduleRetentionLinearRetention {
    /**
     * -(Required) Specifies the number of recovery points to retain on the local location.
     */
    local: number;
    /**
     * -(Optional) Specifies the number of recovery points to retain on the remote location.
     */
    remote?: number;
}

export interface ProtectionPolicyV2ReplicationLocation {
    /**
     * -(Required) External identifier of the domain manager.
     */
    domainManagerExtId: string;
    /**
     * -(Optional) One of the locations must be specified as the primary location. All the other locations must be connected to the primary location.
     */
    isPrimary?: boolean;
    /**
     * -(Required) This is a unique user defined label of the replication location. It is used to identify the location in the replication configurations.
     */
    label: string;
    /**
     * -(Optional) Specifies the replication sub-locations where recovery points can be created or replicated.
     */
    replicationSubLocation?: outputs.ProtectionPolicyV2ReplicationLocationReplicationSubLocation;
}

export interface ProtectionPolicyV2ReplicationLocationReplicationSubLocation {
    /**
     * -(Optional) External identifier of the clusters.
     */
    clusterExtIds: outputs.ProtectionPolicyV2ReplicationLocationReplicationSubLocationClusterExtIds;
}

export interface ProtectionPolicyV2ReplicationLocationReplicationSubLocationClusterExtIds {
    /**
     * -(Optional) External identifier of the clusters.
     */
    clusterExtIds: string[];
}

export interface ProtectionRuleAvailabilityZoneConnectivityList {
    destinationAvailabilityZoneIndex: number;
    snapshotScheduleLists: outputs.ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleList[];
    sourceAvailabilityZoneIndex: number;
}

export interface ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleList {
    autoSuspendTimeoutSecs: number;
    localSnapshotRetentionPolicy: outputs.ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicy;
    recoveryPointObjectiveSecs: number;
    remoteSnapshotRetentionPolicy: outputs.ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicy;
    snapshotType: string;
}

export interface ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicy {
    numSnapshots: number;
    rollupRetentionPolicyMultiple: number;
    rollupRetentionPolicySnapshotIntervalType: string;
}

export interface ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicy {
    numSnapshots: number;
    rollupRetentionPolicyMultiple: number;
    rollupRetentionPolicySnapshotIntervalType: string;
}

export interface ProtectionRuleCategory {
    /**
     * The name for the protection rule.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface ProtectionRuleCategoryFilter {
    kindLists: string[];
    params: outputs.ProtectionRuleCategoryFilterParam[];
    type: string;
}

export interface ProtectionRuleCategoryFilterParam {
    /**
     * The name for the protection rule.
     */
    name: string;
    values: string[];
}

export interface ProtectionRuleOrderedAvailabilityZoneList {
    availabilityZoneUrl: string;
    clusterUuid: string;
}

export interface ProtectionRuleOwnerReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the protection rule.
     */
    name?: string;
    /**
     * (Required) the UUID.
     */
    uuid?: string;
}

export interface ProtectionRuleProjectReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the protection rule.
     */
    name?: string;
    /**
     * (Required) the UUID.
     */
    uuid?: string;
}

export interface RecoveryPlanCategory {
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface RecoveryPlanOwnerReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the Recovery Plan.
     */
    name?: string;
    /**
     * (Required) the UUID.
     */
    uuid?: string;
}

export interface RecoveryPlanParameters {
    floatingIpAssignmentLists: outputs.RecoveryPlanParametersFloatingIpAssignmentList[];
    networkMappingLists: outputs.RecoveryPlanParametersNetworkMappingList[];
}

export interface RecoveryPlanParametersFloatingIpAssignmentList {
    availabilityZoneUrl: string;
    vmIpAssignmentLists: outputs.RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentList[];
}

export interface RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentList {
    recoveryFloatingIpConfig: outputs.RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfig;
    testFloatingIpConfig: outputs.RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfig;
    vmNicInformation: outputs.RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmNicInformation;
    vmReference: outputs.RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmReference;
}

export interface RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfig {
    ip: string;
    shouldAllocateDynamically: boolean;
}

export interface RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfig {
    ip: string;
    shouldAllocateDynamically: boolean;
}

export interface RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmNicInformation {
    ip: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersNetworkMappingList {
    areNetworksStretched: boolean;
    availabilityZoneNetworkMappingLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingList[];
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingList {
    availabilityZoneUrl: string;
    clusterReferenceLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceList[];
    recoveryIpAssignmentLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentList[];
    recoveryNetwork: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetwork;
    testIpAssignmentLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentList[];
    testNetwork: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetwork;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentList {
    ipConfigLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigList[];
    vmReference: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReference;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigList {
    ipAddress: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetwork {
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    subnetLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetList[];
    useVpcReference: boolean;
    virtualNetworkReference: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReference;
    vpcReference: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReference;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetList {
    externalConnectivityState: string;
    gatewayIp: string;
    prefixLength: number;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentList {
    ipConfigLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigList[];
    vmReference: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReference;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigList {
    ipAddress: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetwork {
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    subnetLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetList[];
    useVpcReference: boolean;
    virtualNetworkReference: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReference;
    vpcReference: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReference;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetList {
    externalConnectivityState: string;
    gatewayIp: string;
    prefixLength: number;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanProjectReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the Recovery Plan.
     */
    name?: string;
    /**
     * (Required) the UUID.
     */
    uuid?: string;
}

export interface RecoveryPlanStageList {
    delayTimeSecs: number;
    stageUuid: string;
    stageWork: outputs.RecoveryPlanStageListStageWork;
}

export interface RecoveryPlanStageListStageWork {
    recoverEntities: outputs.RecoveryPlanStageListStageWorkRecoverEntities;
}

export interface RecoveryPlanStageListStageWorkRecoverEntities {
    entityInfoLists: outputs.RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoList[];
}

export interface RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoList {
    anyEntityReferenceKind?: string;
    anyEntityReferenceName?: string;
    anyEntityReferenceUuid?: string;
    categories?: outputs.RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListCategory[];
    scriptLists: outputs.RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListScriptList[];
}

export interface RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListCategory {
    /**
     * The name for the Recovery Plan.
     */
    name?: string;
    /**
     * value of the key.
     */
    value?: string;
}

export interface RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListScriptList {
    enableScriptExec: boolean;
    timeout: string;
}

export interface RecoveryPointRestoreV2VmRecoveryPointRestoreOverride {
    /**
     * -(Required) External identifier of a VM recovery point, that is a part of the top-level recovery point.
     */
    vmRecoveryPointExtId: string;
}

export interface RecoveryPointRestoreV2VolumeGroupRecoveryPointRestoreOverride {
    /**
     * -(Optional) Protected resource/recovery point restore that overrides the volume group configuration. The specified properties will be overridden for the restored volume group.
     */
    volumeGroupOverrideSpecs?: outputs.RecoveryPointRestoreV2VolumeGroupRecoveryPointRestoreOverrideVolumeGroupOverrideSpec[];
    /**
     * -(Required) External identifier of a volume group recovery point, that is a part of the top-level recovery point.
     */
    volumeGroupRecoveryPointExtId: string;
}

export interface RecoveryPointRestoreV2VolumeGroupRecoveryPointRestoreOverrideVolumeGroupOverrideSpec {
    /**
     * -(Optional) The name of the restored volume group.
     */
    name?: string;
}

export interface RecoveryPointsV2Link {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface RecoveryPointsV2LocationReference {
    /**
     * External identifier of the cluster where the recovery point is present.
     */
    locationExtId: string;
}

export interface RecoveryPointsV2VmRecoveryPoint {
    /**
     * User-defined application-consistent properties for the recovery point.
     */
    applicationConsistentProperties: outputs.RecoveryPointsV2VmRecoveryPointApplicationConsistentProperty[];
    /**
     * External identifier of the Consistency group which the entity was part of at the time of recovery point creation.
     */
    consistencyGroupExtId: string;
    /**
     * The UTC date and time in ISO-8601 format when the Recovery point is created.
     */
    creationTime: string;
    /**
     * array of disk recovery points.
     */
    diskRecoveryPoints: outputs.RecoveryPointsV2VmRecoveryPointDiskRecoveryPoint[];
    /**
     * The UTC date and time in ISO-8601 format when the current Recovery point expires and will be garbage collected.
     */
    expirationTime: string;
    /**
     * recovery point UUID
     */
    extId: string;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.RecoveryPointsV2VmRecoveryPointLink[];
    /**
     * Location agnostic identifier of the recovery point. This identifier is used to identify the same instances of a recovery point across different sites.
     */
    locationAgnosticId: string;
    /**
     * The name of the Recovery point.
     */
    name: string;
    /**
     * Type of the Recovery point.
     */
    recoveryPointType: string;
    /**
     * The status of the Recovery point, which indicates whether this Recovery point is fit to be consumed.
     * * supported values:
     * * `COMPLETE`: - The Recovery point is in a complete state and ready to be consumed.
     */
    status: string;
    /**
     * A globally unique identifier that represents the tenant that owns this entity
     */
    tenantId: string;
    /**
     * Category key-value pairs associated with the VM at the time of recovery point creation. The category key and value are separated by '/'. For example, a category with key 'dept' and value 'hr' is displayed as 'dept/hr'.
     */
    vmCategories: string[];
    /**
     * VM external identifier which is captured as a part of this recovery point.
     */
    vmExtId: string;
}

export interface RecoveryPointsV2VmRecoveryPointApplicationConsistentProperty {
    /**
     * -(Required) The backup type specifies the criteria for identifying the files to be backed up. This property should be specified to the application-consistent recovery points for Windows VMs/agents. The following backup types are supported for the application-consistent recovery points:
     * * supported values:
     * * `FULL_BACKUP`: -  All the files are backed up irrespective of their last backup date/time or state. Also, this backup type updates the backup history of each file that participated in the recovery point. If not explicitly specified, this is the default backup type.
     * * `COPY_BACKUP`: -  this backup type does not update the backup history of individual files involved in the recovery point.
     */
    backupType: string;
    /**
     * -(Required) value: `dataprotection.v4.common.VssProperties`
     */
    objectType: string;
    /**
     * -(Optional) Indicates whether the given set of VSS writers' UUIDs should be included or excluded from the application consistent recovery point. By default, the value is set to false, indicating that all listed VSS writers' UUIDs will be excluded.
     */
    shouldIncludeWriters: boolean;
    /**
     * -(Optional) Indicates whether to store the VSS metadata if the user is interested in application-specific backup/restore. The VSS metadata consists of VSS writers and requester metadata details. These are compressed into a cabinet file(.cab file) during a VSS backup operation. This cabinet file must be saved to the backup media during a backup operation, as it is required during the restore operation.
     */
    shouldStoreVssMetadata: boolean;
    /**
     * -(Optional) List of VSS writer UUIDs that are used in an application consistent recovery point. The default values are the system and the registry writer UUIDs.
     */
    writers: string[];
}

export interface RecoveryPointsV2VmRecoveryPointDiskRecoveryPoint {
    /**
     * External identifier of the disk.
     */
    diskExtId: string;
    /**
     * External identifier of the disk recovery point.
     */
    diskRecoveryPointExtId: string;
}

export interface RecoveryPointsV2VmRecoveryPointLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface RecoveryPointsV2VolumeGroupRecoveryPoint {
    /**
     * External identifier of the Consistency group which the entity was part of at the time of recovery point creation.
     */
    consistencyGroupExtId: string;
    /**
     * array of disk recovery points.
     */
    diskRecoveryPoints: outputs.RecoveryPointsV2VolumeGroupRecoveryPointDiskRecoveryPoint[];
    /**
     * recovery point UUID
     */
    extId: string;
    /**
     * A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.RecoveryPointsV2VolumeGroupRecoveryPointLink[];
    /**
     * Location agnostic identifier of the recovery point. This identifier is used to identify the same instances of a recovery point across different sites.
     */
    locationAgnosticId: string;
    /**
     * A globally unique identifier that represents the tenant that owns this entity
     */
    tenantId: string;
    /**
     * Category key-value pairs associated with the volume group at the time of recovery point creation. The category key and value are separated by '/'. For example, a category with key 'dept' and value 'hr' will be represented as 'dept/hr'.
     */
    volumeGroupCategories: string[];
    /**
     * Volume Group external identifier which is captured as part of this recovery point.
     */
    volumeGroupExtId: string;
}

export interface RecoveryPointsV2VolumeGroupRecoveryPointDiskRecoveryPoint {
    /**
     * External identifier of the disk.
     */
    diskExtId: string;
    /**
     * External identifier of the disk recovery point.
     */
    diskRecoveryPointExtId: string;
}

export interface RecoveryPointsV2VolumeGroupRecoveryPointLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface RoleCategory {
    /**
     * - (Optional) Name of the role.
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface RoleOwnerReference {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind?: string;
    /**
     * - (Optional) Name of the role.
     */
    name?: string;
    /**
     * - the UUID(Required).
     */
    uuid?: string;
}

export interface RolePermissionReferenceList {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind?: string;
    /**
     * - (Optional) Name of the role.
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface RoleProjectReference {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind?: string;
    /**
     * - (Optional) Name of the role.
     */
    name?: string;
    /**
     * - the UUID(Required).
     */
    uuid?: string;
}

export interface RolesV2Link {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface RoutesV2Destination {
    /**
     * IPv4 Subnet Object
     * * `ipv4.ip`: (Required) An unique address that identifies a device on the internet or a local network in IPv4 format.
     * * `ipv4.ip.value`: (Required) The IPv4 address of the host.
     * * `ipv4.ip.prefix_length`: (Optional) The prefix length of the network to which this host IPv4 address belongs.
     * * `ipv4.prefix_length`: (Required) The prefix length of the network to which this host IPv4 address belongs.
     */
    ipv4: outputs.RoutesV2DestinationIpv4;
    /**
     * IPv6 Subnet Object
     * * `ipv6.ip`: (Required) IP address format
     * * `ipv6.ip.value`: (Required) The IPv6 address of the host.
     * * `ipv6.ip.prefix_length`: (Optional) The prefix length of the network to which this host IPv6 address belongs.
     * * `ipv6.prefix_length`: (Required) The prefix length of the network to which this host IPv6 address belongs.
     */
    ipv6: outputs.RoutesV2DestinationIpv6;
}

export interface RoutesV2DestinationIpv4 {
    ip: outputs.RoutesV2DestinationIpv4Ip;
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
}

export interface RoutesV2DestinationIpv4Ip {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of IP address
     */
    value: string;
}

export interface RoutesV2DestinationIpv6 {
    ip: outputs.RoutesV2DestinationIpv6Ip;
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
}

export interface RoutesV2DestinationIpv6Ip {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of IP address
     */
    value: string;
}

export interface RoutesV2Link {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface RoutesV2Metadata {
    /**
     * A list of globally unique identifiers that represent all the categories the resource is associated with.
     */
    categoryIds: string[];
    /**
     * A globally unique identifier that represents the owner of this resource.
     */
    ownerReferenceId: string;
    /**
     * The userName of the owner of this resource.
     */
    ownerUserName: string;
    /**
     * The name of the project this resource belongs to.
     */
    projectName: string;
    /**
     * A globally unique identifier that represents the project this resource belongs to.
     */
    projectReferenceId: string;
}

export interface RoutesV2NextHop {
    nextHopIpAddresses: outputs.RoutesV2NextHopNextHopIpAddress[];
    nextHopName: string;
    nextHopReference: string;
    nextHopType: string;
}

export interface RoutesV2NextHopNextHopIpAddress {
    /**
     * IPv4 Address
     */
    ipv4: outputs.RoutesV2NextHopNextHopIpAddressIpv4;
    /**
     * IPv6 Address
     */
    ipv6: outputs.RoutesV2NextHopNextHopIpAddressIpv6;
}

export interface RoutesV2NextHopNextHopIpAddressIpv4 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of IP address
     */
    value: string;
}

export interface RoutesV2NextHopNextHopIpAddressIpv6 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of IP address
     */
    value: string;
}

export interface SamlIdentityProvidersV2IdpMetadata {
    certificate: string;
    entityId: string;
    errorUrl?: string;
    loginUrl: string;
    logoutUrl?: string;
    nameIdPolicyFormat?: string;
}

export interface SelfServiceAppPatchCategory {
    /**
     * - (Optional) The operation to perform on the category. (e.g. "add", "delete")
     */
    operation: string;
    /**
     * - (Optional, string) The value of the category. A Key:Value pair (e.g. "AppType:Oracle_DB"). There should not be any space in value.
     */
    value?: string;
}

export interface SelfServiceAppPatchDisk {
    /**
     * - (Optional, integer) The size of the disk to allocate (in MiB).
     */
    diskSizeMib?: number;
    /**
     * - (Optional) The operation to perform on the category. (e.g. "add", "delete")
     */
    operation: string;
}

export interface SelfServiceAppPatchNic {
    /**
     * - (Optional, string) The index of the NIC. A dummy string for now.
     */
    index?: number;
    /**
     * - (Optional) The operation to perform on the category. (e.g. "add", "delete")
     */
    operation?: string;
    /**
     * - (Optional, string) The UUID of the subnet to which the NIC should be attached.
     */
    subnetUuid?: string;
}

export interface SelfServiceAppPatchVmConfig {
    /**
     * - (Optional, integer) The amount of memory (in MiB) to allocate for the VM.
     */
    memorySizeMib?: number;
    /**
     * - (Optional, integer) The number of vCPUs to assign.
     */
    numSockets?: number;
    /**
     * - (Optional, integer) The number of cores per vCPU to assign to the VM.
     */
    numVcpusPerSocket?: number;
}

export interface SelfServiceAppProvisionAction {
    /**
     * description of the action
     */
    description: string;
    /**
     * name of action.
     */
    name: string;
    /**
     * UUID of the action.
     */
    uuid: string;
}

export interface SelfServiceAppProvisionAppSummary {
    /**
     * The profile assigned to the application.
     */
    applicationProfile: string;
    /**
     * The UUID of the application.
     */
    applicationUuid: string;
    /**
     * The blueprint associated with the application.
     */
    blueprint: string;
    /**
     * The timestamp when the application was created.
     */
    createdOn: string;
    /**
     * The timestamp when the application was last updated.
     */
    lastUpdatedOn: string;
    /**
     * The owner of the application.
     */
    owner: string;
    /**
     * The project associated with the application.
     */
    project: string;
}

export interface SelfServiceAppProvisionRuntimeEditable {
    /**
     * -  A list of actions associated with the blueprint. Each action contains runtime specifications (defined in RuntimeSpec).
     */
    actionLists?: outputs.SelfServiceAppProvisionRuntimeEditableActionList[];
    /**
     * -  A list of application profiles associated with the blueprint. Each application profile contains runtime specifications (defined in RuntimeSpec).
     */
    appProfile?: outputs.SelfServiceAppProvisionRuntimeEditableAppProfile;
    /**
     * -  A list of credentials associated with the blueprint. Each credential contains runtime specifications (defined in RuntimeSpec).
     */
    credentialLists?: outputs.SelfServiceAppProvisionRuntimeEditableCredentialList[];
    /**
     * -  A list of deployments associated with the blueprint. Each deployment contains runtime specifications (defined in RuntimeSpec).
     */
    deploymentLists?: outputs.SelfServiceAppProvisionRuntimeEditableDeploymentList[];
    /**
     * -  A list of packages associated with the blueprint. Each package contains runtime specifications (defined in RuntimeSpec).
     */
    packageLists?: outputs.SelfServiceAppProvisionRuntimeEditablePackageList[];
    /**
     * -  A list of restore configurations associated with the blueprint. Each restore configuration contains runtime specifications (defined in RuntimeSpec).
     */
    restoreConfigLists?: outputs.SelfServiceAppProvisionRuntimeEditableRestoreConfigList[];
    /**
     * - A list of services associated with the blueprint. Each service contains runtime specifications (defined in RuntimeSpec).
     */
    serviceLists?: outputs.SelfServiceAppProvisionRuntimeEditableServiceList[];
    /**
     * - A list of snapshot configurations associated with the blueprint. Each snapshot configuration contains runtime specifications (defined in RuntimeSpec).
     */
    snapshotConfigLists?: outputs.SelfServiceAppProvisionRuntimeEditableSnapshotConfigList[];
    /**
     * - A list of substrates associated with the blueprint. Each substrate contains runtime specifications (defined in RuntimeSpec).
     */
    substrateLists?: outputs.SelfServiceAppProvisionRuntimeEditableSubstrateList[];
    /**
     * - A list of tasks associated with the blueprint. Each task contains runtime specifications (defined in RuntimeSpec).
     */
    taskLists?: outputs.SelfServiceAppProvisionRuntimeEditableTaskList[];
    /**
     * - A list of variables associated with the blueprint. Each variable contains runtime specifications (defined in RuntimeSpec).
     */
    variableLists?: outputs.SelfServiceAppProvisionRuntimeEditableVariableList[];
}

export interface SelfServiceAppProvisionRuntimeEditableActionList {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * description of the action
     */
    description: string;
    /**
     * name of action.
     */
    name: string;
    /**
     * -   The type of network interface.
     */
    type: string;
    /**
     * UUID of the action.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface SelfServiceAppProvisionRuntimeEditableAppProfile {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * description of the action
     */
    description: string;
    /**
     * name of action.
     */
    name: string;
    /**
     * -   The type of network interface.
     */
    type: string;
    /**
     * UUID of the action.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface SelfServiceAppProvisionRuntimeEditableCredentialList {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * description of the action
     */
    description: string;
    /**
     * name of action.
     */
    name: string;
    /**
     * -   The type of network interface.
     */
    type: string;
    /**
     * UUID of the action.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface SelfServiceAppProvisionRuntimeEditableDeploymentList {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * description of the action
     */
    description: string;
    /**
     * name of action.
     */
    name: string;
    /**
     * -   The type of network interface.
     */
    type: string;
    /**
     * UUID of the action.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface SelfServiceAppProvisionRuntimeEditablePackageList {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * description of the action
     */
    description: string;
    /**
     * name of action.
     */
    name: string;
    /**
     * -   The type of network interface.
     */
    type: string;
    /**
     * UUID of the action.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface SelfServiceAppProvisionRuntimeEditableRestoreConfigList {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * description of the action
     */
    description: string;
    /**
     * name of action.
     */
    name: string;
    /**
     * -   The type of network interface.
     */
    type: string;
    /**
     * UUID of the action.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface SelfServiceAppProvisionRuntimeEditableServiceList {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * description of the action
     */
    description: string;
    /**
     * name of action.
     */
    name: string;
    /**
     * -   The type of network interface.
     */
    type: string;
    /**
     * UUID of the action.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface SelfServiceAppProvisionRuntimeEditableSnapshotConfigList {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * description of the action
     */
    description: string;
    /**
     * name of action.
     */
    name: string;
    /**
     * -   The type of network interface.
     */
    type: string;
    /**
     * UUID of the action.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface SelfServiceAppProvisionRuntimeEditableSubstrateList {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * description of the action
     */
    description: string;
    /**
     * name of action.
     */
    name: string;
    /**
     * -   The type of network interface.
     */
    type: string;
    /**
     * UUID of the action.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface SelfServiceAppProvisionRuntimeEditableTaskList {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * description of the action
     */
    description: string;
    /**
     * name of action.
     */
    name: string;
    /**
     * -   The type of network interface.
     */
    type: string;
    /**
     * UUID of the action.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface SelfServiceAppProvisionRuntimeEditableVariableList {
    /**
     * (Optional, Computed) The context in which the runtime specification is applied. It is full address of where the entity in target is present.
     */
    context: string;
    /**
     * description of the action
     */
    description: string;
    /**
     * name of action.
     */
    name: string;
    /**
     * -   The type of network interface.
     */
    type: string;
    /**
     * UUID of the action.
     */
    uuid: string;
    /**
     * (Optional, Computed) The value associated with the runtime specification. This can be a string value representing a configuration or setting.
     */
    value: string;
}

export interface SelfServiceAppProvisionVm {
    /**
     * -  A map of categories applied to the VM. Each key is a category name, and the value is the category value.
     */
    categories: {[key: string]: string};
    /**
     * -  Cluster-related information for the VM.
     */
    clusterInfos: outputs.SelfServiceAppProvisionVmClusterInfo[];
    /**
     * -  Configuration details for the VM.
     */
    configurations: outputs.SelfServiceAppProvisionVmConfiguration[];
    /**
     * -  A list of network interfaces attached to the VM.
     */
    nics: outputs.SelfServiceAppProvisionVmNic[];
}

export interface SelfServiceAppProvisionVmClusterInfo {
    /**
     * -   The name of the cluster.
     */
    clusterName: string;
    /**
     * -   The UUID of the cluster.
     */
    clusterUuid: string;
}

export interface SelfServiceAppProvisionVmConfiguration {
    /**
     * -   Number of CPU cores.
     */
    cores: number;
    /**
     * -   The VM image used.
     */
    image: string;
    /**
     * -   IP address of the VM.
     */
    ipAddress: string;
    /**
     * -  Memory allocated to the VM.
     */
    memory: number;
    /**
     * name of action.
     */
    name: string;
    /**
     * -   Number of virtual CPUs assigned to the VM.
     */
    vcpus: number;
    /**
     * -   The UUID of the VM.
     */
    vmUuid: string;
}

export interface SelfServiceAppProvisionVmNic {
    /**
     * -   The MAC address of the VM's network interface.
     */
    macAddress: string;
    /**
     * -   The subnet the VM's network interface is attached to.
     */
    subnet: string;
    /**
     * -   The type of network interface.
     */
    type: string;
}

export interface ServiceGroupServiceList {
    /**
     * - (Optional) ICMP type code list
     */
    icmpTypeCodeLists?: outputs.ServiceGroupServiceListIcmpTypeCodeList[];
    /**
     * - (Optional) The UserPrincipalName of the user from the directory service.
     */
    protocol?: string;
    /**
     * - (Optional) TCP Port range list
     */
    tcpPortRangeLists?: outputs.ServiceGroupServiceListTcpPortRangeList[];
    /**
     * - (Optional) UDP port range list
     */
    udpPortRangeLists?: outputs.ServiceGroupServiceListUdpPortRangeList[];
}

export interface ServiceGroupServiceListIcmpTypeCodeList {
    /**
     * - (Optional) Code as text
     */
    code?: string;
    /**
     * - (Optional) Type as text
     */
    type?: string;
}

export interface ServiceGroupServiceListTcpPortRangeList {
    endPort?: number;
    startPort?: number;
}

export interface ServiceGroupServiceListUdpPortRangeList {
    endPort?: number;
    startPort?: number;
}

export interface ServiceGroupsV2IcmpService {
    /**
     * Icmp service Code. Ignore this field if Code has to be ANY
     */
    code?: number;
    /**
     * Set this field to true if both Type and Code is ANY. Default is False.
     */
    isAllAllowed: boolean;
    /**
     * Icmp service Type. Ignore this field if Type has to be ANY.
     */
    type?: number;
}

export interface ServiceGroupsV2Link {
    href: string;
    rel: string;
}

export interface ServiceGroupsV2TcpService {
    /**
     * end port
     */
    endPort: number;
    /**
     * start port
     */
    startPort: number;
}

export interface ServiceGroupsV2UdpService {
    /**
     * end port
     */
    endPort: number;
    /**
     * start port
     */
    startPort: number;
}

export interface StaticRoutesDefaultRouteNexthop {
    /**
     * Reference to a subnet.
     */
    externalSubnetReferenceUuid?: string;
}

export interface StaticRoutesStaticRoutesList {
    /**
     * Destination ip with prefix.
     */
    destination: string;
    /**
     * Reference to a subnet. Supported with 2022.x .
     */
    externalSubnetReferenceUuid?: string;
    /**
     * Reference to a vpn connection.
     */
    vpnConnectionReferenceUuid?: string;
}

export interface StorageContainersV2Link {
    href: string;
    rel: string;
}

export interface StorageContainersV2NfsWhitelistAddress {
    /**
     * Reference to address configuration
     */
    fqdns: outputs.StorageContainersV2NfsWhitelistAddressFqdn[];
    /**
     * Reference to address configuration
     */
    ipv4s: outputs.StorageContainersV2NfsWhitelistAddressIpv4[];
    /**
     * Reference to address configuration
     */
    ipv6s: outputs.StorageContainersV2NfsWhitelistAddressIpv6[];
}

export interface StorageContainersV2NfsWhitelistAddressFqdn {
    /**
     * value of fqdn address
     */
    value: string;
}

export interface StorageContainersV2NfsWhitelistAddressIpv4 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of fqdn address
     */
    value: string;
}

export interface StorageContainersV2NfsWhitelistAddressIpv6 {
    /**
     * The prefix length of the network to which this host IPv4/IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * value of fqdn address
     */
    value: string;
}

export interface SubnetCategory {
    /**
     * - (Optional) Subnet name (Readonly).
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface SubnetV2DhcpOption {
    bootFileName: string;
    domainName: string;
    domainNameServers: outputs.SubnetV2DhcpOptionDomainNameServer[];
    ntpServers: outputs.SubnetV2DhcpOptionNtpServer[];
    searchDomains: string[];
    tftpServerName: string;
}

export interface SubnetV2DhcpOptionDomainNameServer {
    ipv4s: outputs.SubnetV2DhcpOptionDomainNameServerIpv4[];
    ipv6s: outputs.SubnetV2DhcpOptionDomainNameServerIpv6[];
}

export interface SubnetV2DhcpOptionDomainNameServerIpv4 {
    prefixLength: number;
    value: string;
}

export interface SubnetV2DhcpOptionDomainNameServerIpv6 {
    prefixLength: number;
    value: string;
}

export interface SubnetV2DhcpOptionNtpServer {
    ipv4s: outputs.SubnetV2DhcpOptionNtpServerIpv4[];
    ipv6s: outputs.SubnetV2DhcpOptionNtpServerIpv6[];
}

export interface SubnetV2DhcpOptionNtpServerIpv4 {
    prefixLength: number;
    value: string;
}

export interface SubnetV2DhcpOptionNtpServerIpv6 {
    prefixLength: number;
    value: string;
}

export interface SubnetV2DynamicIpAddress {
    ipv4s: outputs.SubnetV2DynamicIpAddressIpv4[];
    ipv6s: outputs.SubnetV2DynamicIpAddressIpv6[];
}

export interface SubnetV2DynamicIpAddressIpv4 {
    prefixLength: number;
    value: string;
}

export interface SubnetV2DynamicIpAddressIpv6 {
    prefixLength: number;
    value: string;
}

export interface SubnetV2IpConfig {
    ipv4s: outputs.SubnetV2IpConfigIpv4[];
    ipv6s: outputs.SubnetV2IpConfigIpv6[];
}

export interface SubnetV2IpConfigIpv4 {
    defaultGatewayIps: outputs.SubnetV2IpConfigIpv4DefaultGatewayIp[];
    dhcpServerAddresses: outputs.SubnetV2IpConfigIpv4DhcpServerAddress[];
    ipSubnets: outputs.SubnetV2IpConfigIpv4IpSubnet[];
    poolLists: outputs.SubnetV2IpConfigIpv4PoolList[];
}

export interface SubnetV2IpConfigIpv4DefaultGatewayIp {
    prefixLength: number;
    value: string;
}

export interface SubnetV2IpConfigIpv4DhcpServerAddress {
    prefixLength: number;
    value: string;
}

export interface SubnetV2IpConfigIpv4IpSubnet {
    ips: outputs.SubnetV2IpConfigIpv4IpSubnetIp[];
    prefixLength: number;
}

export interface SubnetV2IpConfigIpv4IpSubnetIp {
    prefixLength: number;
    value: string;
}

export interface SubnetV2IpConfigIpv4PoolList {
    endIps: outputs.SubnetV2IpConfigIpv4PoolListEndIp[];
    startIps: outputs.SubnetV2IpConfigIpv4PoolListStartIp[];
}

export interface SubnetV2IpConfigIpv4PoolListEndIp {
    prefixLength: number;
    value: string;
}

export interface SubnetV2IpConfigIpv4PoolListStartIp {
    prefixLength: number;
    value: string;
}

export interface SubnetV2IpConfigIpv6 {
    defaultGatewayIps: outputs.SubnetV2IpConfigIpv6DefaultGatewayIp[];
    dhcpServerAddresses: outputs.SubnetV2IpConfigIpv6DhcpServerAddress[];
    ipSubnets: outputs.SubnetV2IpConfigIpv6IpSubnet[];
    poolLists: outputs.SubnetV2IpConfigIpv6PoolList[];
}

export interface SubnetV2IpConfigIpv6DefaultGatewayIp {
    prefixLength: number;
    value: string;
}

export interface SubnetV2IpConfigIpv6DhcpServerAddress {
    prefixLength: number;
    value: string;
}

export interface SubnetV2IpConfigIpv6IpSubnet {
    ips: outputs.SubnetV2IpConfigIpv6IpSubnetIp[];
    prefixLength: number;
}

export interface SubnetV2IpConfigIpv6IpSubnetIp {
    prefixLength: number;
    value: string;
}

export interface SubnetV2IpConfigIpv6PoolList {
    endIps: outputs.SubnetV2IpConfigIpv6PoolListEndIp[];
    startIps: outputs.SubnetV2IpConfigIpv6PoolListStartIp[];
}

export interface SubnetV2IpConfigIpv6PoolListEndIp {
    prefixLength: number;
    value: string;
}

export interface SubnetV2IpConfigIpv6PoolListStartIp {
    prefixLength: number;
    value: string;
}

export interface SubnetV2IpUsage {
    ipPoolUsages: outputs.SubnetV2IpUsageIpPoolUsage[];
    numAssignedIps: number;
    numFreeIps: number;
    numMacs: number;
}

export interface SubnetV2IpUsageIpPoolUsage {
    numFreeIps: number;
    numTotalIps: number;
    ranges: outputs.SubnetV2IpUsageIpPoolUsageRange[];
}

export interface SubnetV2IpUsageIpPoolUsageRange {
    endIps: outputs.SubnetV2IpUsageIpPoolUsageRangeEndIp[];
    startIps: outputs.SubnetV2IpUsageIpPoolUsageRangeStartIp[];
}

export interface SubnetV2IpUsageIpPoolUsageRangeEndIp {
    prefixLength: number;
    value: string;
}

export interface SubnetV2IpUsageIpPoolUsageRangeStartIp {
    prefixLength: number;
    value: string;
}

export interface SubnetV2Link {
    href?: string;
    rel?: string;
}

export interface SubnetV2ReservedIpAddress {
    prefixLength: number;
    value: string;
}

export interface SubnetV2VirtualSwitch {
    bondMode: boolean;
    clusters: outputs.SubnetV2VirtualSwitchCluster[];
    description: string;
    extId: string;
    hasDeploymentError: boolean;
    isDefault: boolean;
    links: outputs.SubnetV2VirtualSwitchLink[];
    metadatas: outputs.SubnetV2VirtualSwitchMetadata[];
    mtu: number;
    name: string;
    tenantId: string;
}

export interface SubnetV2VirtualSwitchCluster {
    extId: string;
    gatewayIpAddresses: outputs.SubnetV2VirtualSwitchClusterGatewayIpAddress[];
    hosts: outputs.SubnetV2VirtualSwitchClusterHost[];
}

export interface SubnetV2VirtualSwitchClusterGatewayIpAddress {
    prefixLength: number;
    value: string;
}

export interface SubnetV2VirtualSwitchClusterHost {
    extId: string;
    hostNics: string[];
    internalBridgeName: string;
    ipAddresses: outputs.SubnetV2VirtualSwitchClusterHostIpAddress[];
    routeTable: number;
}

export interface SubnetV2VirtualSwitchClusterHostIpAddress {
    ips: outputs.SubnetV2VirtualSwitchClusterHostIpAddressIp[];
    prefixLength: number;
}

export interface SubnetV2VirtualSwitchClusterHostIpAddressIp {
    prefixLength: number;
    value: string;
}

export interface SubnetV2VirtualSwitchLink {
    href: string;
    rel: string;
}

export interface SubnetV2VirtualSwitchMetadata {
    categoryIds: any[][];
    ownerReferenceId: string;
    ownerUserName: string;
    projectName: string;
    projectReferenceId: string;
}

export interface SubnetV2Vpc {
    commonDhcpOptions: outputs.SubnetV2VpcCommonDhcpOption[];
    description: string;
    extId: string;
    externalRoutingDomainReference: string;
    externalSubnets: outputs.SubnetV2VpcExternalSubnet[];
    externallyRoutablePrefixes: outputs.SubnetV2VpcExternallyRoutablePrefix[];
    links: outputs.SubnetV2VpcLink[];
    metadatas: outputs.SubnetV2VpcMetadata[];
    name: string;
    snatIps: outputs.SubnetV2VpcSnatIp[];
    tenantId: string;
    vpcType: string;
}

export interface SubnetV2VpcCommonDhcpOption {
    domainNameServers: outputs.SubnetV2VpcCommonDhcpOptionDomainNameServer[];
}

export interface SubnetV2VpcCommonDhcpOptionDomainNameServer {
    ipv4s: outputs.SubnetV2VpcCommonDhcpOptionDomainNameServerIpv4[];
    ipv6s: outputs.SubnetV2VpcCommonDhcpOptionDomainNameServerIpv6[];
}

export interface SubnetV2VpcCommonDhcpOptionDomainNameServerIpv4 {
    prefixLength: number;
    value: string;
}

export interface SubnetV2VpcCommonDhcpOptionDomainNameServerIpv6 {
    prefixLength: number;
    value: string;
}

export interface SubnetV2VpcExternalSubnet {
    activeGatewayCount: number;
    activeGatewayNodes: outputs.SubnetV2VpcExternalSubnetActiveGatewayNode[];
    externalIps: outputs.SubnetV2VpcExternalSubnetExternalIp[];
    gatewayNodes: string[];
    subnetReference: string;
}

export interface SubnetV2VpcExternalSubnetActiveGatewayNode {
    nodeId: string;
    nodeIpAddresses: outputs.SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddress[];
}

export interface SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddress {
    ipv4s: outputs.SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4[];
    ipv6s: outputs.SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6[];
}

export interface SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4 {
    prefixLength: number;
    value: string;
}

export interface SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6 {
    prefixLength: number;
    value: string;
}

export interface SubnetV2VpcExternalSubnetExternalIp {
    ipv4s: outputs.SubnetV2VpcExternalSubnetExternalIpIpv4[];
    ipv6s: outputs.SubnetV2VpcExternalSubnetExternalIpIpv6[];
}

export interface SubnetV2VpcExternalSubnetExternalIpIpv4 {
    prefixLength: number;
    value: string;
}

export interface SubnetV2VpcExternalSubnetExternalIpIpv6 {
    prefixLength: number;
    value: string;
}

export interface SubnetV2VpcExternallyRoutablePrefix {
    ipv4s: outputs.SubnetV2VpcExternallyRoutablePrefixIpv4[];
    ipv6s: outputs.SubnetV2VpcExternallyRoutablePrefixIpv6[];
}

export interface SubnetV2VpcExternallyRoutablePrefixIpv4 {
    ips: outputs.SubnetV2VpcExternallyRoutablePrefixIpv4Ip[];
    prefixLength: number;
}

export interface SubnetV2VpcExternallyRoutablePrefixIpv4Ip {
    prefixLength: number;
    value: string;
}

export interface SubnetV2VpcExternallyRoutablePrefixIpv6 {
    ips: outputs.SubnetV2VpcExternallyRoutablePrefixIpv6Ip[];
    prefixLength: number;
}

export interface SubnetV2VpcExternallyRoutablePrefixIpv6Ip {
    prefixLength: number;
    value: string;
}

export interface SubnetV2VpcLink {
    href: string;
    rel: string;
}

export interface SubnetV2VpcMetadata {
    categoryIds: any[][];
    ownerReferenceId: string;
    ownerUserName: string;
    projectName: string;
    projectReferenceId: string;
}

export interface SubnetV2VpcSnatIp {
    ipv4s: outputs.SubnetV2VpcSnatIpIpv4[];
    ipv6s: outputs.SubnetV2VpcSnatIpIpv6[];
}

export interface SubnetV2VpcSnatIpIpv4 {
    prefixLength: number;
    value: string;
}

export interface SubnetV2VpcSnatIpIpv6 {
    prefixLength: number;
    value: string;
}

export interface TemplateV2CreatedBy {
    additionalAttributes: outputs.TemplateV2CreatedByAdditionalAttribute[];
    creationType: string;
    description: string;
    displayName: string;
    emailId: string;
    extId: string;
    firstName: string;
    idpId: string;
    isForceResetPasswordEnabled: boolean;
    lastName: string;
    locale: string;
    middleInitial: string;
    password: string;
    region: string;
    status: string;
    userType: string;
    username: string;
}

export interface TemplateV2CreatedByAdditionalAttribute {
    name: string;
    values: outputs.TemplateV2CreatedByAdditionalAttributeValue[];
}

export interface TemplateV2CreatedByAdditionalAttributeValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.TemplateV2CreatedByAdditionalAttributeValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface TemplateV2CreatedByAdditionalAttributeValueMapOfString {
    map: {[key: string]: string};
}

export interface TemplateV2GuestUpdateStatus {
    deployedVmReference: string;
}

export interface TemplateV2Link {
    href: string;
    rel: string;
}

export interface TemplateV2TemplateVersionSpec {
    createTime: string;
    createdBies: outputs.TemplateV2TemplateVersionSpecCreatedBy[];
    extId: string;
    isActiveVersion?: boolean;
    isGcOverrideEnabled: boolean;
    links: outputs.TemplateV2TemplateVersionSpecLink[];
    tenantId: string;
    versionDescription: string;
    versionName: string;
    versionSource: outputs.TemplateV2TemplateVersionSpecVersionSource;
    versionSourceDiscriminator: string;
    vmSpecs: outputs.TemplateV2TemplateVersionSpecVmSpec[];
}

export interface TemplateV2TemplateVersionSpecCreatedBy {
    additionalAttributes: outputs.TemplateV2TemplateVersionSpecCreatedByAdditionalAttribute[];
    creationType: string;
    description: string;
    displayName: string;
    emailId: string;
    extId: string;
    firstName: string;
    idpId: string;
    isForceResetPasswordEnabled: boolean;
    lastName: string;
    locale: string;
    middleInitial: string;
    password: string;
    region: string;
    status: string;
    userType: string;
    username: string;
}

export interface TemplateV2TemplateVersionSpecCreatedByAdditionalAttribute {
    name: string;
    values: outputs.TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValue[];
}

export interface TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueMapOfString {
    map: {[key: string]: string};
}

export interface TemplateV2TemplateVersionSpecLink {
    href: string;
    rel: string;
}

export interface TemplateV2TemplateVersionSpecVersionSource {
    templateVersionReference: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReference;
    templateVmReference: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVmReference;
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReference {
    overrideVmConfigs: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfig[];
    versionId: string;
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfig {
    guestCustomizations: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomization[];
    memorySizeBytes?: number;
    name: string;
    nics: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNic[];
    numCoresPerSocket: number;
    numSockets: number;
    numThreadsPerCore: number;
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomization {
    configs: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfig[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfig {
    cloudInits: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInit[];
    syspreps: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprep[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInit {
    cloudInitScripts: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScript[];
    datasourceType: string;
    metadata: string;
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScript {
    customKeyValues: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValue[];
    userDatas: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptUserData[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValue {
    keyValuePairs: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePair[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePair {
    name: string;
    values: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValue[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString {
    map: {[key: string]: string};
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptUserData {
    value: string;
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprep {
    installType: string;
    sysprepScripts: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScript[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScript {
    customKeyValues: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValue[];
    unattendXmls: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptUnattendXml[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValue {
    keyValuePairs: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePair[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePair {
    name: string;
    values: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValue[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfString {
    map: {[key: string]: string};
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptUnattendXml {
    value: string;
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNic {
    backingInfos: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicBackingInfo[];
    extId: string;
    links: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicLink[];
    networkInfos: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfo[];
    tenantId: string;
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicBackingInfo {
    isConnected?: boolean;
    macAddress: string;
    model: string;
    numQueues?: number;
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicLink {
    href: string;
    rel: string;
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfo {
    ipv4Configs: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4Config[];
    ipv4Infos: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4Info[];
    networkFunctionChains: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoNetworkFunctionChain[];
    networkFunctionNicType: string;
    nicType: string;
    shouldAllowUnknownMacs: boolean;
    subnets: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoSubnet[];
    trunkedVlans: number[];
    vlanMode: string;
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4Config {
    ipAddresses: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigIpAddress[];
    secondaryIpAddressLists: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigSecondaryIpAddressList[];
    shouldAssignIp: boolean;
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigIpAddress {
    prefixLength?: number;
    value: string;
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigSecondaryIpAddressList {
    prefixLength?: number;
    value: string;
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4Info {
    learnedIpAddresses: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4InfoLearnedIpAddress[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4InfoLearnedIpAddress {
    prefixLength?: number;
    value: string;
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoNetworkFunctionChain {
    extId: string;
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoSubnet {
    extId: string;
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVmReference {
    extId: string;
    guestCustomizations: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomization[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomization {
    configs: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfig[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfig {
    cloudInits: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInit[];
    syspreps: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprep[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInit {
    cloudInitScripts: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScript[];
    datasourceType: string;
    metadata: string;
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScript {
    customKeyValues: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValue[];
    userDatas: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptUserData[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValue {
    keyValuePairs: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePair[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePair {
    name: string;
    values: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValue[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString {
    map: {[key: string]: string};
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptUserData {
    value: string;
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprep {
    installType: string;
    sysprepScripts: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScript[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScript {
    customKeyValues: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValue[];
    unattendXmls: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptUnattendXml[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValue {
    keyValuePairs: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePair[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePair {
    name: string;
    values: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValue[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfString {
    map: {[key: string]: string};
}

export interface TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptUnattendXml {
    value: string;
}

export interface TemplateV2TemplateVersionSpecVmSpec {
    apcConfigs: outputs.TemplateV2TemplateVersionSpecVmSpecApcConfig[];
    availabilityZones: outputs.TemplateV2TemplateVersionSpecVmSpecAvailabilityZone[];
    biosUuid: string;
    bootConfigs: outputs.TemplateV2TemplateVersionSpecVmSpecBootConfig[];
    categories: outputs.TemplateV2TemplateVersionSpecVmSpecCategory[];
    cdRoms: outputs.TemplateV2TemplateVersionSpecVmSpecCdRom[];
    clusters: outputs.TemplateV2TemplateVersionSpecVmSpecCluster[];
    createTime: string;
    description: string;
    disks: outputs.TemplateV2TemplateVersionSpecVmSpecDisk[];
    enabledCpuFeatures: string[];
    extId: string;
    generationUuid: string;
    gpuses: outputs.TemplateV2TemplateVersionSpecVmSpecGpus[];
    guestCustomizations: outputs.TemplateV2TemplateVersionSpecVmSpecGuestCustomization[];
    guestTools: outputs.TemplateV2TemplateVersionSpecVmSpecGuestTool[];
    hardwareClockTimezone: string;
    hosts: outputs.TemplateV2TemplateVersionSpecVmSpecHost[];
    isAgentVm: boolean;
    isBrandingEnabled: boolean;
    isCpuHotplugEnabled: boolean;
    isCpuPassthroughEnabled: boolean;
    isCrossClusterMigrationInProgress: boolean;
    isGpuConsoleEnabled: boolean;
    isLiveMigrateCapable: boolean;
    isMemoryOvercommitEnabled: boolean;
    isScsiControllerEnabled: boolean;
    isVcpuHardPinningEnabled: boolean;
    isVgaConsoleEnabled: boolean;
    links: outputs.TemplateV2TemplateVersionSpecVmSpecLink[];
    machineType: string;
    memorySizeBytes: number;
    name: string;
    nics: outputs.TemplateV2TemplateVersionSpecVmSpecNic[];
    numCoresPerSocket: number;
    numNumaNodes: number;
    numSockets: number;
    numThreadsPerCore: number;
    ownershipInfos: outputs.TemplateV2TemplateVersionSpecVmSpecOwnershipInfo[];
    pciDevices: outputs.TemplateV2TemplateVersionSpecVmSpecPciDevice[];
    powerState: string;
    protectionPolicyStates: outputs.TemplateV2TemplateVersionSpecVmSpecProtectionPolicyState[];
    protectionType: string;
    serialPorts: outputs.TemplateV2TemplateVersionSpecVmSpecSerialPort[];
    sources: outputs.TemplateV2TemplateVersionSpecVmSpecSource[];
    storageConfigs: outputs.TemplateV2TemplateVersionSpecVmSpecStorageConfig[];
    tenantId: string;
    updateTime: string;
    vtpmConfigs: outputs.TemplateV2TemplateVersionSpecVmSpecVtpmConfig[];
}

export interface TemplateV2TemplateVersionSpecVmSpecApcConfig {
    cpuModels: outputs.TemplateV2TemplateVersionSpecVmSpecApcConfigCpuModel[];
    isApcEnabled: boolean;
}

export interface TemplateV2TemplateVersionSpecVmSpecApcConfigCpuModel {
    extId: string;
    name: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecAvailabilityZone {
    extId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecBootConfig {
    legacyBoots: outputs.TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBoot[];
    uefiBoots: outputs.TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBoot[];
}

export interface TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBoot {
    bootDevices: outputs.TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDevice[];
    bootOrders: string[];
}

export interface TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDevice {
    bootDeviceDisks: outputs.TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDisk[];
    bootDeviceNics: outputs.TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceNic[];
}

export interface TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDisk {
    diskAddresses: outputs.TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddress[];
}

export interface TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddress {
    busType: string;
    index: number;
}

export interface TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceNic {
    macAddress: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBoot {
    bootDevices: outputs.TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDevice[];
    bootOrders: string[];
    isSecureBootEnabled: boolean;
    nvramDevices: outputs.TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDevice[];
}

export interface TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDevice {
    bootDeviceDisks: outputs.TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDisk[];
    bootDeviceNics: outputs.TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceNic[];
}

export interface TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDisk {
    diskAddresses: outputs.TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskDiskAddress[];
}

export interface TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskDiskAddress {
    busType: string;
    index: number;
}

export interface TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceNic {
    macAddress: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDevice {
    backingStorageInfos: outputs.TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfo[];
}

export interface TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfo {
    dataSources: outputs.TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSource[];
    diskExtId: string;
    diskSizeBytes: number;
    isMigrationInProgress: boolean;
    storageConfigs: outputs.TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfig[];
    storageContainers: outputs.TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainer[];
}

export interface TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSource {
    references: outputs.TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReference[];
}

export interface TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReference {
    imageReferences: outputs.TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReference[];
    vmDiskReferences: outputs.TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReference[];
}

export interface TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReference {
    imageExtId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReference {
    diskAddresses: outputs.TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddress[];
    diskExtId: string;
    vmReferences: outputs.TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddress {
    busType: string;
    index: number;
}

export interface TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReference {
    extId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfig {
    isFlashModeEnabled: boolean;
}

export interface TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainer {
    extId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecCategory {
    extId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecCdRom {
    backingInfos: outputs.TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfo[];
    diskAddresses: outputs.TemplateV2TemplateVersionSpecVmSpecCdRomDiskAddress[];
    extId: string;
    isoType: string;
    links: outputs.TemplateV2TemplateVersionSpecVmSpecCdRomLink[];
    tenantId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfo {
    dataSources: outputs.TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSource[];
    diskExtId: string;
    diskSizeBytes: number;
    isMigrationInProgress: boolean;
    storageConfigs: outputs.TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageConfig[];
    storageContainers: outputs.TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageContainer[];
}

export interface TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSource {
    references: outputs.TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReference[];
}

export interface TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReference {
    imageReferences: outputs.TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceImageReference[];
    vmDiskReferences: outputs.TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReference[];
}

export interface TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceImageReference {
    imageExtId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReference {
    diskAddresses: outputs.TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddress[];
    diskExtId: string;
    vmReferences: outputs.TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddress {
    busType: string;
    index: number;
}

export interface TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReference {
    extId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageConfig {
    isFlashModeEnabled: boolean;
}

export interface TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageContainer {
    extId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecCdRomDiskAddress {
    busType: string;
    index: number;
}

export interface TemplateV2TemplateVersionSpecVmSpecCdRomLink {
    href: string;
    rel: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecCluster {
    extId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecDisk {
    backingInfos: outputs.TemplateV2TemplateVersionSpecVmSpecDiskBackingInfo[];
    diskAddresses: outputs.TemplateV2TemplateVersionSpecVmSpecDiskDiskAddress[];
    extId: string;
    links: outputs.TemplateV2TemplateVersionSpecVmSpecDiskLink[];
    tenantId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecDiskBackingInfo {
    adfsVolumeGroupReferences: outputs.TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoAdfsVolumeGroupReference[];
    vmDisks: outputs.TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDisk[];
}

export interface TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoAdfsVolumeGroupReference {
    volumeGroupExtId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDisk {
    dataSources: outputs.TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSource[];
    diskExtId: string;
    diskSizeBytes: number;
    isMigrationInProgress: boolean;
    storageConfigs: outputs.TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageConfig[];
    storageContainers: outputs.TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageContainer[];
}

export interface TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSource {
    references: outputs.TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReference[];
}

export interface TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReference {
    imageReferences: outputs.TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceImageReference[];
    vmDiskReferences: outputs.TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReference[];
}

export interface TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceImageReference {
    imageExtId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReference {
    diskAddresses: outputs.TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddress[];
    diskExtId: string;
    vmReferences: outputs.TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddress {
    busType: string;
    index: number;
}

export interface TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReference {
    extId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageConfig {
    isFlashModeEnabled: boolean;
}

export interface TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageContainer {
    extId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecDiskDiskAddress {
    busType: string;
    index: number;
}

export interface TemplateV2TemplateVersionSpecVmSpecDiskLink {
    href: string;
    rel: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecGpus {
    deviceId: number;
    extId: string;
    fraction: number;
    frameBufferSizeBytes: number;
    guestDriverVersion: string;
    links: outputs.TemplateV2TemplateVersionSpecVmSpecGpusLink[];
    mode: string;
    name: string;
    numVirtualDisplayHeads: number;
    pciAddresses: outputs.TemplateV2TemplateVersionSpecVmSpecGpusPciAddress[];
    tenantId: string;
    vendor: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecGpusLink {
    href: string;
    rel: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecGpusPciAddress {
    bus: number;
    device: number;
    func: number;
    segment: number;
}

export interface TemplateV2TemplateVersionSpecVmSpecGuestCustomization {
    configs: outputs.TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfig[];
}

export interface TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfig {
    cloudInits: outputs.TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInit[];
    syspreps: outputs.TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprep[];
}

export interface TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInit {
    cloudInitScripts: outputs.TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScript[];
    datasourceType: string;
    metadata: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScript {
    customKeyValues: outputs.TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValue[];
    userDatas: outputs.TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptUserData[];
}

export interface TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValue {
    keyValuePairs: outputs.TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePair[];
}

export interface TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePair {
    name: string;
    values: outputs.TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValue[];
}

export interface TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString {
    map: {[key: string]: string};
}

export interface TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptUserData {
    value: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprep {
    installType: string;
    sysprepScripts: outputs.TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScript[];
}

export interface TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScript {
    customKeyValues: outputs.TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValue[];
    unattendXmls: outputs.TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptUnattendXml[];
}

export interface TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValue {
    keyValuePairs: outputs.TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePair[];
}

export interface TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePair {
    name: string;
    values: outputs.TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValue[];
}

export interface TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfString {
    map: {[key: string]: string};
}

export interface TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptUnattendXml {
    value: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecGuestTool {
    availableVersion: string;
    capabilities: string[];
    guestOsVersion: string;
    isEnabled: boolean;
    isInstalled: boolean;
    isIsoInserted: boolean;
    isReachable: boolean;
    isVmMobilityDriversInstalled: boolean;
    isVssSnapshotCapable: boolean;
    version: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecHost {
    extId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecLink {
    href: string;
    rel: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecNic {
    backingInfos: outputs.TemplateV2TemplateVersionSpecVmSpecNicBackingInfo[];
    extId: string;
    links: outputs.TemplateV2TemplateVersionSpecVmSpecNicLink[];
    networkInfos: outputs.TemplateV2TemplateVersionSpecVmSpecNicNetworkInfo[];
    tenantId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecNicBackingInfo {
    isConnected?: boolean;
    macAddress: string;
    model: string;
    numQueues?: number;
}

export interface TemplateV2TemplateVersionSpecVmSpecNicLink {
    href: string;
    rel: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecNicNetworkInfo {
    ipv4Configs: outputs.TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4Config[];
    ipv4Infos: outputs.TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4Info[];
    networkFunctionChains: outputs.TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoNetworkFunctionChain[];
    networkFunctionNicType: string;
    nicType: string;
    shouldAllowUnknownMacs: boolean;
    subnets: outputs.TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoSubnet[];
    trunkedVlans: number[];
    vlanMode: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4Config {
    ipAddresses: outputs.TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigIpAddress[];
    secondaryIpAddressLists: outputs.TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigSecondaryIpAddressList[];
    shouldAssignIp: boolean;
}

export interface TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigIpAddress {
    prefixLength?: number;
    value: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigSecondaryIpAddressList {
    prefixLength?: number;
    value: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4Info {
    learnedIpAddresses: outputs.TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoLearnedIpAddress[];
}

export interface TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoLearnedIpAddress {
    prefixLength?: number;
    value: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoNetworkFunctionChain {
    extId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoSubnet {
    extId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecOwnershipInfo {
    owners: outputs.TemplateV2TemplateVersionSpecVmSpecOwnershipInfoOwner[];
}

export interface TemplateV2TemplateVersionSpecVmSpecOwnershipInfoOwner {
    extId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecPciDevice {
    assignedDeviceInfos: outputs.TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfo[];
    backingInfos: outputs.TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfo[];
    extId: string;
    links: outputs.TemplateV2TemplateVersionSpecVmSpecPciDeviceLink[];
    tenantId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfo {
    devices: outputs.TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoDevice[];
}

export interface TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoDevice {
    deviceExtId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfo {
    pcieDeviceReferences: outputs.TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoPcieDeviceReference[];
}

export interface TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoPcieDeviceReference {
    deviceExtId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecPciDeviceLink {
    href: string;
    rel: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecProtectionPolicyState {
    policies: outputs.TemplateV2TemplateVersionSpecVmSpecProtectionPolicyStatePolicy[];
}

export interface TemplateV2TemplateVersionSpecVmSpecProtectionPolicyStatePolicy {
    extId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecSerialPort {
    extId: string;
    index: number;
    isConnected: boolean;
    links: outputs.TemplateV2TemplateVersionSpecVmSpecSerialPortLink[];
    tenantId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecSerialPortLink {
    href: string;
    rel: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecSource {
    entityType: string;
    extId: string;
}

export interface TemplateV2TemplateVersionSpecVmSpecStorageConfig {
    isFlashModeEnabled: boolean;
    qosConfigs: outputs.TemplateV2TemplateVersionSpecVmSpecStorageConfigQosConfig[];
}

export interface TemplateV2TemplateVersionSpecVmSpecStorageConfigQosConfig {
    throttledIops: number;
}

export interface TemplateV2TemplateVersionSpecVmSpecVtpmConfig {
    isVtpmEnabled: boolean;
    version: string;
}

export interface TemplateV2UpdatedBy {
    additionalAttributes: outputs.TemplateV2UpdatedByAdditionalAttribute[];
    creationType: string;
    description: string;
    displayName: string;
    emailId: string;
    extId: string;
    firstName: string;
    idpId: string;
    isForceResetPasswordEnabled: boolean;
    lastName: string;
    locale: string;
    middleInitial: string;
    password: string;
    region: string;
    status: string;
    userType: string;
    username: string;
}

export interface TemplateV2UpdatedByAdditionalAttribute {
    name: string;
    values: outputs.TemplateV2UpdatedByAdditionalAttributeValue[];
}

export interface TemplateV2UpdatedByAdditionalAttributeValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.TemplateV2UpdatedByAdditionalAttributeValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface TemplateV2UpdatedByAdditionalAttributeValueMapOfString {
    map: {[key: string]: string};
}

export interface UserAccessControlPolicyReferenceList {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface UserCategory {
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface UserDirectoryServiceUser {
    defaultUserPrincipalName: string;
    /**
     * - (Optional) The reference to a directory service. See #reference for to look the supported attributes.
     */
    directoryServiceReference: outputs.UserDirectoryServiceUserDirectoryServiceReference;
    /**
     * - (Optional) The UserPrincipalName of the user from the directory service.
     */
    userPrincipalName: string;
}

export interface UserDirectoryServiceUserDirectoryServiceReference {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind?: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface UserGroupsCategory {
    /**
     * - subnet name.
     */
    name: string;
    value: string;
}

export interface UserGroupsDirectoryServiceOus {
    /**
     * - (Required) The Distinguished name for the user group.
     */
    distinguishedName: string;
}

export interface UserGroupsDirectoryServiceUserGroup {
    /**
     * - (Required) The Distinguished name for the user group.
     */
    distinguishedName: string;
}

export interface UserGroupsSamlUserGroup {
    /**
     * - (Required) The UUID of the Identity Provider that the group belongs to.
     */
    idpUuid: string;
    /**
     * - (Required) The name of the SAML group which the IDP provides.
     */
    name: string;
}

export interface UserIdentityProviderUser {
    /**
     * - (Optional) The reference to a identity provider. See #reference for to look the supported attributes.
     */
    identityProviderReference: outputs.UserIdentityProviderUserIdentityProviderReference;
    /**
     * - (Optional) The username from identity provider. Name ID for SAML Identity Provider.
     */
    username: string;
}

export interface UserIdentityProviderUserIdentityProviderReference {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind?: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface UserProjectReferenceList {
    /**
     * - The kind name. (Default depends on the resource you are referencing)
     */
    kind: string;
    /**
     * - the name(Optional).
     */
    name: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface UsersV2AdditionalAttribute {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    name: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    value: number;
}

export interface UsersV2BucketsAccessKey {
    /**
     * - Name of the Bucket Access Key.
     */
    accessKeyName: string;
    /**
     * - Creation time for the Bucket Access Key.
     */
    createdTime: string;
    /**
     * - A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    /**
     * - A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
     */
    links: outputs.UsersV2BucketsAccessKeyLink[];
    /**
     * - Secret Access Key, it will be returned only during Bucket Access Key creation.
     */
    secretAccessKey: string;
    /**
     * - User Identifier who owns the Bucket Access Key.
     */
    userId: string;
}

export interface UsersV2BucketsAccessKeyLink {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface UsersV2Link {
    /**
     * - The URL at which the entity described by the link can be accessed.
     */
    href: string;
    /**
     * - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
     */
    rel: string;
}

export interface VirtualMachineCategory {
    /**
     * - (Required) The name for the vm.
     */
    name: string;
    /**
     * - value of the key.
     */
    value: string;
}

export interface VirtualMachineDiskList {
    /**
     * Reference to a data source.
     *
     * The diskSize (the disk sizeMib and the diskSizeBytes attributes) is only honored by creating an empty disk. When you are creating from an image, the size is ignored and the disk becomes the size of the image from which it was cloned. In VM creation, you can't set either disk sizeMib or diskSizeBytes when you set dataSourceReference but, you can update the diskSize after creation (second apply).
     */
    dataSourceReference: {[key: string]: string};
    /**
     * Properties to a device.
     */
    deviceProperties: outputs.VirtualMachineDiskListDeviceProperties;
    /**
     * Size of the disk in Bytes.
     */
    diskSizeBytes: number;
    /**
     * Size of the disk in MiB. Must match the size specified in 'disk_size_bytes' - rounded up to the nearest MiB - when that field is present.
     */
    diskSizeMib: number;
    storageConfig: outputs.VirtualMachineDiskListStorageConfig;
    /**
     * - (Optional) The device ID which is used to uniquely identify this particular disk.
     */
    uuid: string;
    volumeGroupReference: {[key: string]: string};
}

export interface VirtualMachineDiskListDeviceProperties {
    /**
     * - A Disk type (default: DISK).
     */
    deviceType?: string;
    /**
     * - Address of disk to boot from.
     */
    diskAddress: {[key: string]: string};
}

export interface VirtualMachineDiskListStorageConfig {
    /**
     * - State of the storage policy to pin virtual disks to the hot tier. When specified as a VM attribute, the storage policy applies to all virtual disks of the VM unless overridden by the same attribute specified for a virtual disk.
     */
    flashMode?: string;
    /**
     * - Reference to a kind. Either one of (kind, uuid) or url needs to be specified. Requires Prism Central / AOS 5.17+.
     * * `storage_container_reference.#.url`: - GET query on the URL will provide information on the source.
     * * `storage_container_reference.#.kind`: - kind of the container reference
     * * `storage_container_reference.#.name`: - name of the container reference
     * * `storage_container_reference.#.uuid`: - uiid of the container reference
     */
    storageContainerReferences: outputs.VirtualMachineDiskListStorageConfigStorageContainerReference[];
}

export interface VirtualMachineDiskListStorageConfigStorageContainerReference {
    /**
     * - The kind name (Default value: project)(Required).
     */
    kind?: string;
    /**
     * - (Required) The name for the vm.
     */
    name: string;
    url: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface VirtualMachineGpuList {
    /**
     * - (Computed) The device ID of the GPU.
     */
    deviceId: number;
    /**
     * Fraction of the physical GPU assigned.
     */
    fraction: number;
    /**
     * - (ReadOnly) GPU frame buffer size in MiB.
     */
    frameBufferSizeMib: number;
    /**
     * - (ReadOnly) Last determined guest driver version.
     */
    guestDriverVersion: string;
    /**
     * - (Optional) The mode of this GPU.
     */
    mode: string;
    /**
     * - (ReadOnly) Name of the GPU resource.
     */
    name: string;
    /**
     * - (ReadOnly) Number of supported virtual display heads.
     */
    numVirtualDisplayHeads: number;
    /**
     * GPU {segment:bus:device:function} (sbdf) address if assigned.
     */
    pciAddress: string;
    /**
     * - (ReadOnly) UUID of the GPU.
     */
    uuid: string;
    /**
     * - (Optional) The vendor of the GPU.
     */
    vendor: string;
}

export interface VirtualMachineNicList {
    /**
     * - IP endpoints for the adapter. Currently, IPv4 addresses are supported.
     */
    ipEndpointLists: outputs.VirtualMachineNicListIpEndpointList[];
    /**
     * - Indicates whether the serial port connection is connected or not (`true` or `false`).
     */
    isConnected?: string;
    /**
     * - The MAC address for the adapter.
     */
    macAddress: string;
    /**
     * - The model of this NIC. (Options : VIRTIO , E1000).
     */
    model: string;
    /**
     * - The reference to a network_function_chain.
     */
    networkFunctionChainReference: {[key: string]: string};
    /**
     * - The type of this Network function NIC. Defaults to INGRESS. (Options : INGRESS , EGRESS , TAP).
     */
    networkFunctionNicType: string;
    /**
     * - The type of this NIC. Defaults to NORMAL_NIC. (Options : NORMAL_NIC , DIRECT_NIC , NETWORK_FUNCTION_NIC).
     */
    nicType: string;
    /**
     * - The number of tx/rx queue pairs for this NIC.
     */
    numQueues: number;
    /**
     * - The name of the subnet reference to.
     */
    subnetName: string;
    /**
     * - The reference to a subnet.
     */
    subnetUuid?: string;
    /**
     * - The NIC's UUID, which is used to uniquely identify this particular NIC. This UUID may be used to refer to the NIC outside the context of the particular VM it is attached to.
     */
    uuid: string;
}

export interface VirtualMachineNicListIpEndpointList {
    /**
     * - Address string.
     */
    ip: string;
    /**
     * - Address type. It can only be "ASSIGNED" in the spec. If no type is specified in the spec, the default type is set to "ASSIGNED". (Options : ASSIGNED , LEARNED)
     */
    type: string;
}

export interface VirtualMachineNicListStatus {
    /**
     * -  The Floating IP associated with the vnic. (Only in `nicListStatus`)
     */
    floatingIp: string;
    /**
     * - IP endpoints for the adapter. Currently, IPv4 addresses are supported.
     */
    ipEndpointLists: outputs.VirtualMachineNicListStatusIpEndpointList[];
    /**
     * - Indicates whether the serial port connection is connected or not (`true` or `false`).
     */
    isConnected: string;
    /**
     * - The MAC address for the adapter.
     */
    macAddress: string;
    /**
     * - The model of this NIC. (Options : VIRTIO , E1000).
     */
    model: string;
    /**
     * - The reference to a network_function_chain.
     */
    networkFunctionChainReference: {[key: string]: string};
    /**
     * - The type of this Network function NIC. Defaults to INGRESS. (Options : INGRESS , EGRESS , TAP).
     */
    networkFunctionNicType: string;
    /**
     * - The type of this NIC. Defaults to NORMAL_NIC. (Options : NORMAL_NIC , DIRECT_NIC , NETWORK_FUNCTION_NIC).
     */
    nicType: string;
    /**
     * - The number of tx/rx queue pairs for this NIC.
     */
    numQueues: number;
    /**
     * - The name of the subnet reference to.
     */
    subnetName: string;
    /**
     * - The reference to a subnet.
     */
    subnetUuid: string;
    /**
     * - the UUID(Required).
     */
    uuid: string;
}

export interface VirtualMachineNicListStatusIpEndpointList {
    /**
     * - Address string.
     */
    ip: string;
    /**
     * - Address type. It can only be "ASSIGNED" in the spec. If no type is specified in the spec, the default type is set to "ASSIGNED". (Options : ASSIGNED , LEARNED)
     */
    type: string;
}

export interface VirtualMachineSerialPortList {
    /**
     * - Index of the serial port (int).
     */
    index: number;
    /**
     * - Indicates whether the serial port connection is connected or not (`true` or `false`).
     */
    isConnected: boolean;
}

export interface VirtualMachineV2ApcConfig {
    /**
     * CPU model associated with the VM if Advanced Processor Compatibility(APC) is enabled. If APC is enabled and no CPU model is explicitly set, a default baseline CPU model is picked by the system. See the APC documentation for more information
     * * `cpu_model.name`: (Required) Name of the CPU model associated with the VM.
     */
    cpuModels: outputs.VirtualMachineV2ApcConfigCpuModel[];
    /**
     * If enabled, the selected CPU model will be retained across live and cold migrations of the VM.
     */
    isApcEnabled: boolean;
}

export interface VirtualMachineV2ApcConfigCpuModel {
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    /**
     * VM name.
     */
    name: string;
}

export interface VirtualMachineV2AvailabilityZone {
    /**
     * The globally unique identifier of an availability zone type UUID.
     */
    extId: string;
}

export interface VirtualMachineV2BootConfig {
    /**
     * LegacyBoot config Object
     */
    legacyBoots: outputs.VirtualMachineV2BootConfigLegacyBoot[];
    /**
     * UefiBoot config Object
     */
    uefiBoots: outputs.VirtualMachineV2BootConfigUefiBoot[];
}

export interface VirtualMachineV2BootConfigLegacyBoot {
    /**
     * Boot Device object
     * * `boot_device.boot_device_disk`: (Optional) Disk address.
     * * `boot_device.boot_device_disk.disk_address.bus_type`: (Required) Bus type for the device
     * * `boot_device.boot_device_disk.disk_address.index`: (Required) Device index on the bus. This field is ignored unless the bus details are specified.
     *
     * * `boot_device.boot_device_nic`: (Optional) Disk Nic address.
     * * `boot_device.boot_device_nic.mac_address`: (Required) mac address
     */
    bootDevices: outputs.VirtualMachineV2BootConfigLegacyBootBootDevice[];
    /**
     * Indicates the order of device types in which the VM should try to boot from. If the boot device order is not provided the system will decide an appropriate boot device order. Valid values are 'CDROM', 'DISK', 'NETWORK'.
     */
    bootOrders: string[];
}

export interface VirtualMachineV2BootConfigLegacyBootBootDevice {
    bootDeviceDisks: outputs.VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDisk[];
    bootDeviceNics: outputs.VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceNic[];
}

export interface VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDisk {
    diskAddresses: outputs.VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddress[];
}

export interface VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddress {
    busType: string;
    /**
     * ) Index of the serial port.
     */
    index: number;
}

export interface VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceNic {
    /**
     * MAC address of the emulated NIC.
     */
    macAddress: string;
}

export interface VirtualMachineV2BootConfigUefiBoot {
    /**
     * Boot Device object
     * * `boot_device.boot_device_disk`: (Optional) Disk address.
     * * `boot_device.boot_device_disk.disk_address.bus_type`: (Required) Bus type for the device
     * * `boot_device.boot_device_disk.disk_address.index`: (Required) Device index on the bus. This field is ignored unless the bus details are specified.
     *
     * * `boot_device.boot_device_nic`: (Optional) Disk Nic address.
     * * `boot_device.boot_device_nic.mac_address`: (Required) mac address
     */
    bootDevices: outputs.VirtualMachineV2BootConfigUefiBootBootDevice[];
    /**
     * Indicates the order of device types in which the VM should try to boot from. If the boot device order is not provided the system will decide an appropriate boot device order. Valid values are 'CDROM', 'DISK', 'NETWORK'.
     */
    bootOrders: string[];
    /**
     * Indicate whether to enable secure boot or not
     */
    isSecureBootEnabled: boolean;
    /**
     * Configuration for NVRAM to be presented to the VM.
     * * `nvram_device.backing_storage_info`: (Required) Storage provided by Nutanix ADSF
     */
    nvramDevices: outputs.VirtualMachineV2BootConfigUefiBootNvramDevice[];
}

export interface VirtualMachineV2BootConfigUefiBootBootDevice {
    bootDeviceDisks: outputs.VirtualMachineV2BootConfigUefiBootBootDeviceBootDeviceDisk[];
    bootDeviceNics: outputs.VirtualMachineV2BootConfigUefiBootBootDeviceBootDeviceNic[];
}

export interface VirtualMachineV2BootConfigUefiBootBootDeviceBootDeviceDisk {
    diskAddresses: outputs.VirtualMachineV2BootConfigUefiBootBootDeviceBootDeviceDiskDiskAddress[];
}

export interface VirtualMachineV2BootConfigUefiBootBootDeviceBootDeviceDiskDiskAddress {
    busType: string;
    /**
     * ) Index of the serial port.
     */
    index: number;
}

export interface VirtualMachineV2BootConfigUefiBootBootDeviceBootDeviceNic {
    /**
     * MAC address of the emulated NIC.
     */
    macAddress: string;
}

export interface VirtualMachineV2BootConfigUefiBootNvramDevice {
    backingStorageInfos: outputs.VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfo[];
}

export interface VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfo {
    dataSources: outputs.VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSource[];
    diskExtId: string;
    diskSizeBytes: number;
    isMigrationInProgress: boolean;
    /**
     * Storage configuration for VM.
     */
    storageConfigs: outputs.VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfig[];
    storageContainers: outputs.VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainer[];
}

export interface VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSource {
    /**
     * Reference to image or vm disk
     */
    references: outputs.VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReference[];
}

export interface VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReference {
    /**
     * Image Reference
     * * `image_reference.image_ext_id`: (Required) The globally unique identifier of an image. It should be of type UUID.
     */
    imageReferences: outputs.VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReference[];
    /**
     * Vm Disk Reference
     * * `vm_disk_reference.disk_ext_id`: (Optional) The globally unique identifier of a VM disk. It should be of type UUID.
     * * `vm_disk_reference.disk_address`: (Optional) Disk address.
     * * `vm_disk_reference.vm_reference`: (Optional) This is a reference to a VM.
     */
    vmDiskReferences: outputs.VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReference[];
}

export interface VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReference {
    imageExtId: string;
}

export interface VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReference {
    diskAddresses: outputs.VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddress[];
    diskExtId: string;
    vmReferences: outputs.VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddress {
    busType: string;
    /**
     * ) Index of the serial port.
     */
    index: number;
}

export interface VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReference {
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
}

export interface VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfig {
    /**
     * Indicates whether the virtual disk is pinned to the hot tier or not.
     */
    isFlashModeEnabled: boolean;
}

export interface VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainer {
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
}

export interface VirtualMachineV2Category {
    /**
     * A globally unique identifier of a VM category of type UUID.
     */
    extId: string;
}

export interface VirtualMachineV2CdRom {
    /**
     * Storage provided by Nutanix ADSF
     */
    backingInfos: outputs.VirtualMachineV2CdRomBackingInfo[];
    /**
     * Virtual Machine disk (VM disk).
     */
    diskAddresses: outputs.VirtualMachineV2CdRomDiskAddress[];
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    /**
     * Type of ISO image inserted in CD-ROM. Valid values "OTHER", "GUEST_TOOLS", "GUEST_CUSTOMIZATION" .
     */
    isoType: string;
}

export interface VirtualMachineV2CdRomBackingInfo {
    /**
     * A reference to a disk or image that contains the contents of a disk.
     */
    dataSources: outputs.VirtualMachineV2CdRomBackingInfoDataSource[];
    diskExtId: string;
    /**
     * Size of the disk in Bytes
     */
    diskSizeBytes: number;
    isMigrationInProgress: boolean;
    /**
     * Storage configuration for VM disks
     * * `storage_config.is_flash_mode_enabled`: Indicates whether the virtual disk is pinned to the hot tier or not.
     */
    storageConfigs: outputs.VirtualMachineV2CdRomBackingInfoStorageConfig[];
    /**
     * This reference is for disk level storage container preference. This preference specifies the storage container to which this disk belongs.
     */
    storageContainers: outputs.VirtualMachineV2CdRomBackingInfoStorageContainer[];
}

export interface VirtualMachineV2CdRomBackingInfoDataSource {
    /**
     * Reference to image or vm disk
     */
    references: outputs.VirtualMachineV2CdRomBackingInfoDataSourceReference[];
}

export interface VirtualMachineV2CdRomBackingInfoDataSourceReference {
    /**
     * Image Reference
     * * `image_reference.image_ext_id`: (Required) The globally unique identifier of an image. It should be of type UUID.
     */
    imageReferences: outputs.VirtualMachineV2CdRomBackingInfoDataSourceReferenceImageReference[];
    /**
     * Vm Disk Reference
     * * `vm_disk_reference.disk_ext_id`: (Optional) The globally unique identifier of a VM disk. It should be of type UUID.
     * * `vm_disk_reference.disk_address`: (Optional) Disk address.
     * * `vm_disk_reference.vm_reference`: (Optional) This is a reference to a VM.
     */
    vmDiskReferences: outputs.VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReference[];
}

export interface VirtualMachineV2CdRomBackingInfoDataSourceReferenceImageReference {
    imageExtId: string;
}

export interface VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReference {
    diskAddresses: outputs.VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddress[];
    diskExtId: string;
    vmReferences: outputs.VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddress {
    busType: string;
    /**
     * ) Index of the serial port.
     */
    index: number;
}

export interface VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReference {
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
}

export interface VirtualMachineV2CdRomBackingInfoStorageConfig {
    /**
     * Indicates whether the virtual disk is pinned to the hot tier or not.
     */
    isFlashModeEnabled: boolean;
}

export interface VirtualMachineV2CdRomBackingInfoStorageContainer {
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
}

export interface VirtualMachineV2CdRomDiskAddress {
    busType: string;
    /**
     * ) Index of the serial port.
     */
    index: number;
}

export interface VirtualMachineV2Cluster {
    /**
     * The globally unique identifier of a cluster type UUID.
     */
    extId: string;
}

export interface VirtualMachineV2Disk {
    /**
     * Supporting storage to create virtual disk on.
     * * `backing_info.vm_disk`:(Optional) backing Info for vmDisk
     * * `backing_info.adfs_volume_group_reference`: (Required) Volume Group Reference
     * * `backing_info.adfs_volume_group_reference.volume_group_ext_id`: (Required) The globally unique identifier of an ADSF volume group. It should be of type UUID.
     */
    backingInfos: outputs.VirtualMachineV2DiskBackingInfo[];
    /**
     * Disk address.
     * * `disk_address.bus_type`: (Required) Bus type for the device. The acceptable values are: SCSI, IDE, PCI, SATA, SPAPR (only PPC).
     * * `disk_address.index`: (Required) Device index on the bus. This field is ignored unless the bus details are specified.
     */
    diskAddresses: outputs.VirtualMachineV2DiskDiskAddress[];
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
}

export interface VirtualMachineV2DiskBackingInfo {
    adfsVolumeGroupReferences: outputs.VirtualMachineV2DiskBackingInfoAdfsVolumeGroupReference[];
    vmDisks: outputs.VirtualMachineV2DiskBackingInfoVmDisk[];
}

export interface VirtualMachineV2DiskBackingInfoAdfsVolumeGroupReference {
    volumeGroupExtId: string;
}

export interface VirtualMachineV2DiskBackingInfoVmDisk {
    dataSources: outputs.VirtualMachineV2DiskBackingInfoVmDiskDataSource[];
    diskExtId: string;
    diskSizeBytes: number;
    isMigrationInProgress: boolean;
    /**
     * Storage configuration for VM.
     */
    storageConfigs: outputs.VirtualMachineV2DiskBackingInfoVmDiskStorageConfig[];
    storageContainers: outputs.VirtualMachineV2DiskBackingInfoVmDiskStorageContainer[];
}

export interface VirtualMachineV2DiskBackingInfoVmDiskDataSource {
    /**
     * Reference to image or vm disk
     */
    references: outputs.VirtualMachineV2DiskBackingInfoVmDiskDataSourceReference[];
}

export interface VirtualMachineV2DiskBackingInfoVmDiskDataSourceReference {
    /**
     * Image Reference
     * * `image_reference.image_ext_id`: (Required) The globally unique identifier of an image. It should be of type UUID.
     */
    imageReferences: outputs.VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceImageReference[];
    /**
     * Vm Disk Reference
     * * `vm_disk_reference.disk_ext_id`: (Optional) The globally unique identifier of a VM disk. It should be of type UUID.
     * * `vm_disk_reference.disk_address`: (Optional) Disk address.
     * * `vm_disk_reference.vm_reference`: (Optional) This is a reference to a VM.
     */
    vmDiskReferences: outputs.VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReference[];
}

export interface VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceImageReference {
    imageExtId: string;
}

export interface VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReference {
    diskAddresses: outputs.VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddress[];
    diskExtId: string;
    vmReferences: outputs.VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddress {
    busType: string;
    /**
     * ) Index of the serial port.
     */
    index: number;
}

export interface VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReference {
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
}

export interface VirtualMachineV2DiskBackingInfoVmDiskStorageConfig {
    /**
     * Indicates whether the virtual disk is pinned to the hot tier or not.
     */
    isFlashModeEnabled: boolean;
}

export interface VirtualMachineV2DiskBackingInfoVmDiskStorageContainer {
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
}

export interface VirtualMachineV2DiskDiskAddress {
    busType: string;
    /**
     * ) Index of the serial port.
     */
    index: number;
}

export interface VirtualMachineV2Gpus {
    /**
     * The device Id of the GPU.
     */
    deviceId: number;
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    fraction: number;
    frameBufferSizeBytes: number;
    guestDriverVersion: string;
    links: outputs.VirtualMachineV2GpusLink[];
    /**
     * ) The mode of this GPU. Valid values "PASSTHROUGH_GRAPHICS", "PASSTHROUGH_COMPUTE", "VIRTUAL" .
     */
    mode: string;
    /**
     * VM name.
     */
    name: string;
    numVirtualDisplayHeads: number;
    /**
     * The (S)egment:(B)us:(D)evice.(F)unction hardware address.
     */
    pciAddresses: outputs.VirtualMachineV2GpusPciAddress[];
    tenantId: string;
    /**
     * The vendor of the GPU. Valid values "NVIDIA", "AMD", "INTEL" .
     */
    vendor: string;
}

export interface VirtualMachineV2GpusLink {
    href: string;
    rel: string;
}

export interface VirtualMachineV2GpusPciAddress {
    bus: number;
    device: number;
    func: number;
    segment: number;
}

export interface VirtualMachineV2GuestCustomization {
    /**
     * The Nutanix Guest Tools customization settings.
     *
     * * `config.sysprep`: Sysprep config
     * * `config.cloud_init`: CloudInit Config
     */
    configs: outputs.VirtualMachineV2GuestCustomizationConfig[];
}

export interface VirtualMachineV2GuestCustomizationConfig {
    cloudInits: outputs.VirtualMachineV2GuestCustomizationConfigCloudInit[];
    syspreps: outputs.VirtualMachineV2GuestCustomizationConfigSysprep[];
}

export interface VirtualMachineV2GuestCustomizationConfigCloudInit {
    /**
     * The script to use for cloud-init.
     * * `cloud_init_script.user_data`: (Optional) user data object
     * * `cloud_init_script.custom_keys`: (Optional) The list of the individual KeyValuePair elements.
     */
    cloudInitScripts: outputs.VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScript[];
    /**
     * Type of datasource. Default: CONFIG_DRIVE_V2
     */
    datasourceType?: string;
    /**
     * The contents of the metaData configuration for cloud-init. This can be formatted as YAML or JSON. The value must be base64 encoded. Default value is 'CONFIG_DRIVE_V2'.
     */
    metadata: string;
}

export interface VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScript {
    customKeyValues: outputs.VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValue[];
    userDatas: outputs.VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptUserData[];
}

export interface VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValue {
    keyValuePairs: outputs.VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePair[];
}

export interface VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePair {
    /**
     * VM name.
     */
    name: string;
    values: outputs.VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValue[];
}

export interface VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfString {
    map: {[key: string]: string};
}

export interface VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptUserData {
    value: string;
}

export interface VirtualMachineV2GuestCustomizationConfigSysprep {
    /**
     * Indicates whether the guest will be freshly installed using this unattend configuration, or this unattend configuration will be applied to a pre-prepared image. Values allowed is 'PREPARED', 'FRESH'.
     */
    installType: string;
    /**
     * Object either UnattendXml or CustomKeyValues
     * * `sysprep_script.unattend_xml`: (Optional) xml object
     * * `sysprep_script.custom_key_values`: (Optional) The list of the individual KeyValuePair elements.
     */
    sysprepScripts: outputs.VirtualMachineV2GuestCustomizationConfigSysprepSysprepScript[];
}

export interface VirtualMachineV2GuestCustomizationConfigSysprepSysprepScript {
    customKeyValues: outputs.VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValue[];
    unattendXmls: outputs.VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptUnattendXml[];
}

export interface VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValue {
    keyValuePairs: outputs.VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePair[];
}

export interface VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePair {
    /**
     * VM name.
     */
    name: string;
    values: outputs.VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValue[];
}

export interface VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValue {
    boolean: boolean;
    integer: number;
    integerLists: number[];
    mapOfStrings: outputs.VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfString[];
    object: {[key: string]: string};
    string: string;
    stringLists: string[];
}

export interface VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfString {
    map: {[key: string]: string};
}

export interface VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptUnattendXml {
    value: string;
}

export interface VirtualMachineV2GuestTool {
    availableVersion: string;
    /**
     * The list of the application names that are enabled on the guest VM.
     */
    capabilities: string[];
    guestOsVersion: string;
    /**
     * Indicates whether Nutanix Guest Tools is enabled or not.
     */
    isEnabled: boolean;
    isInstalled: boolean;
    isIsoInserted: boolean;
    isReachable: boolean;
    isVmMobilityDriversInstalled: boolean;
    isVssSnapshotCapable: boolean;
    version: string;
}

export interface VirtualMachineV2Host {
    /**
     * A globally unique identifier of a host of type UUID.
     */
    extId: string;
}

export interface VirtualMachineV2Nic {
    /**
     * Defines a NIC emulated by the hypervisor
     */
    backingInfos: outputs.VirtualMachineV2NicBackingInfo[];
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    /**
     * Network information for a NIC.
     */
    networkInfos: outputs.VirtualMachineV2NicNetworkInfo[];
}

export interface VirtualMachineV2NicBackingInfo {
    isConnected: boolean;
    /**
     * MAC address of the emulated NIC.
     */
    macAddress: string;
    /**
     * Options for the NIC emulation. Valid values "VIRTIO" , "E1000".
     */
    model: string;
    /**
     * The number of Tx/Rx queue pairs for this NIC. Default is 1.
     */
    numQueues?: number;
}

export interface VirtualMachineV2NicNetworkInfo {
    /**
     * The IP address configurations.
     */
    ipv4Configs: outputs.VirtualMachineV2NicNetworkInfoIpv4Config[];
    ipv4Infos: outputs.VirtualMachineV2NicNetworkInfoIpv4Info[];
    /**
     * The network function chain associates with the NIC. Only valid if nicType is NORMAL_NIC.
     */
    networkFunctionChains: outputs.VirtualMachineV2NicNetworkInfoNetworkFunctionChain[];
    /**
     * The type of this Network function NIC. Defaults to INGRESS.
     */
    networkFunctionNicType: string;
    /**
     * NIC type. Valid values "SPAN_DESTINATION_NIC",  "NORMAL_NIC", "DIRECT_NIC", "NETWORK_FUNCTION_NIC" .
     */
    nicType: string;
    /**
     * Indicates whether an unknown unicast traffic is forwarded to this NIC or not. This is applicable only for the NICs on the overlay subnets.
     */
    shouldAllowUnknownMacs: boolean;
    /**
     * Network identifier for this adapter. Only valid if nicType is NORMAL_NIC or DIRECT_NIC
     * * `subnet.ext_id`: (Optional) The globally unique identifier of a subnet of type UUID.
     */
    subnets: outputs.VirtualMachineV2NicNetworkInfoSubnet[];
    /**
     * List of networks to trunk if VLAN mode is marked as TRUNKED. If empty and VLAN mode is set to TRUNKED, all the VLANs are trunked.
     */
    trunkedVlans: number[];
    /**
     * all the virtual NICs are created in ACCESS mode, which permits only one VLAN per virtual network. TRUNKED mode allows multiple VLANs on a single VM NIC for network-aware user VMs.
     */
    vlanMode: string;
}

export interface VirtualMachineV2NicNetworkInfoIpv4Config {
    /**
     * The IP address of the NIC.
     */
    ipAddresses: outputs.VirtualMachineV2NicNetworkInfoIpv4ConfigIpAddress[];
    /**
     * Secondary IP addresses for the NIC.
     */
    secondaryIpAddressLists: outputs.VirtualMachineV2NicNetworkInfoIpv4ConfigSecondaryIpAddressList[];
    /**
     * If set to true (default value), an IP address must be assigned to the VM NIC - either the one explicitly specified by the user or allocated automatically by the IPAM service by not specifying the IP address. If false, then no IP assignment is required for this VM NIC.
     */
    shouldAssignIp: boolean;
}

export interface VirtualMachineV2NicNetworkInfoIpv4ConfigIpAddress {
    /**
     * The prefix length of the IP address.
     */
    prefixLength?: number;
    /**
     * The IPv4 address of the host.
     */
    value: string;
}

export interface VirtualMachineV2NicNetworkInfoIpv4ConfigSecondaryIpAddressList {
    /**
     * The prefix length of the IP address.
     */
    prefixLength?: number;
    value: string;
}

export interface VirtualMachineV2NicNetworkInfoIpv4Info {
    learnedIpAddresses: outputs.VirtualMachineV2NicNetworkInfoIpv4InfoLearnedIpAddress[];
}

export interface VirtualMachineV2NicNetworkInfoIpv4InfoLearnedIpAddress {
    /**
     * The prefix length of the IP address.
     */
    prefixLength?: number;
    value: string;
}

export interface VirtualMachineV2NicNetworkInfoNetworkFunctionChain {
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
}

export interface VirtualMachineV2NicNetworkInfoSubnet {
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
}

export interface VirtualMachineV2OwnershipInfo {
    /**
     * Reference to the owner.
     * * `owner.ext_id`: A globally unique identifier of a VM owner type UUID.
     */
    owners: outputs.VirtualMachineV2OwnershipInfoOwner[];
}

export interface VirtualMachineV2OwnershipInfoOwner {
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
}

export interface VirtualMachineV2ProtectionPolicyState {
    /**
     * Reference to the policy object in use.
     * * `policy.ext_id`: (Optional) Reference to the policy object in use.
     */
    policies: outputs.VirtualMachineV2ProtectionPolicyStatePolicy[];
}

export interface VirtualMachineV2ProtectionPolicyStatePolicy {
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
}

export interface VirtualMachineV2SerialPort {
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
    /**
     * ) Index of the serial port.
     */
    index: number;
    /**
     * Indicates whether the serial port is connected or not.
     */
    isConnected: boolean;
}

export interface VirtualMachineV2Source {
    /**
     * Reference to an entity from which the VM should be cloned or created. Values are:
     * - VM_RECOVERY_POINT: Reference to the recovery point entity from which the VM should be cloned or created.
     * - VM: Reference to an entity from which the VM should be cloned or created.
     */
    entityType: string;
    /**
     * A globally unique identifier of an instance that is suitable for external consumption.
     */
    extId: string;
}

export interface VirtualMachineV2StorageConfig {
    /**
     * Indicates whether the virtual disk is pinned to the hot tier or not.
     */
    isFlashModeEnabled: boolean;
    /**
     * QoS parameters to be enforced.
     * * `qos_config.throttled_iops`: (Optional) Throttled IOPS for the governed entities. The block size for the I/O is 32 kB.
     */
    qosConfigs: outputs.VirtualMachineV2StorageConfigQosConfig[];
}

export interface VirtualMachineV2StorageConfigQosConfig {
    throttledIops: number;
}

export interface VirtualMachineV2VtpmConfig {
    /**
     * Indicates whether the virtual trusted platform module is enabled for the Guest OS or not.
     */
    isVtpmEnabled: boolean;
    version: string;
}

export interface VmCdromInsertEjectV2BackingInfo {
    dataSources?: outputs.VmCdromInsertEjectV2BackingInfoDataSource[];
    diskSizeBytes?: number;
    storageConfigs?: outputs.VmCdromInsertEjectV2BackingInfoStorageConfig[];
    storageContainers: outputs.VmCdromInsertEjectV2BackingInfoStorageContainer[];
}

export interface VmCdromInsertEjectV2BackingInfoDataSource {
    references?: outputs.VmCdromInsertEjectV2BackingInfoDataSourceReference[];
}

export interface VmCdromInsertEjectV2BackingInfoDataSourceReference {
    imageReferences?: outputs.VmCdromInsertEjectV2BackingInfoDataSourceReferenceImageReference[];
    vmDiskReferences?: outputs.VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReference[];
}

export interface VmCdromInsertEjectV2BackingInfoDataSourceReferenceImageReference {
    imageExtId?: string;
}

export interface VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReference {
    diskAddresses?: outputs.VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceDiskAddress[];
    diskExtId?: string;
    vmReferences?: outputs.VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceDiskAddress {
    busType?: string;
    index?: number;
}

export interface VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceVmReference {
    extId?: string;
}

export interface VmCdromInsertEjectV2BackingInfoStorageConfig {
    isFlashModeEnabled?: boolean;
}

export interface VmCdromInsertEjectV2BackingInfoStorageContainer {
    extId?: string;
}

export interface VmCloneV2ApcConfig {
    cpuModels: outputs.VmCloneV2ApcConfigCpuModel[];
    isApcEnabled: boolean;
}

export interface VmCloneV2ApcConfigCpuModel {
    extId: string;
    name: string;
}

export interface VmCloneV2BootConfig {
    legacyBoots: outputs.VmCloneV2BootConfigLegacyBoot[];
    uefiBoots: outputs.VmCloneV2BootConfigUefiBoot[];
}

export interface VmCloneV2BootConfigLegacyBoot {
    bootDevices: outputs.VmCloneV2BootConfigLegacyBootBootDevice[];
    bootOrders: string[];
}

export interface VmCloneV2BootConfigLegacyBootBootDevice {
    bootDeviceDisks: outputs.VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDisk[];
    bootDeviceNics: outputs.VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceNic[];
}

export interface VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDisk {
    diskAddresses: outputs.VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddress[];
}

export interface VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddress {
    busType: string;
    index: number;
}

export interface VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceNic {
    macAddress: string;
}

export interface VmCloneV2BootConfigUefiBoot {
    bootDevices: outputs.VmCloneV2BootConfigUefiBootBootDevice[];
    bootOrders: string[];
    isSecureBootEnabled: boolean;
    nvramDevices: outputs.VmCloneV2BootConfigUefiBootNvramDevice[];
}

export interface VmCloneV2BootConfigUefiBootBootDevice {
    bootDeviceDisks: outputs.VmCloneV2BootConfigUefiBootBootDeviceBootDeviceDisk[];
    bootDeviceNics: outputs.VmCloneV2BootConfigUefiBootBootDeviceBootDeviceNic[];
}

export interface VmCloneV2BootConfigUefiBootBootDeviceBootDeviceDisk {
    diskAddresses: outputs.VmCloneV2BootConfigUefiBootBootDeviceBootDeviceDiskDiskAddress[];
}

export interface VmCloneV2BootConfigUefiBootBootDeviceBootDeviceDiskDiskAddress {
    busType: string;
    index: number;
}

export interface VmCloneV2BootConfigUefiBootBootDeviceBootDeviceNic {
    macAddress: string;
}

export interface VmCloneV2BootConfigUefiBootNvramDevice {
    backingStorageInfos: outputs.VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfo[];
}

export interface VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfo {
    dataSources: outputs.VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSource[];
    diskExtId: string;
    diskSizeBytes: number;
    isMigrationInProgress: boolean;
    storageConfigs: outputs.VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfig[];
    storageContainers: outputs.VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainer[];
}

export interface VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSource {
    references: outputs.VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReference[];
}

export interface VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReference {
    imageReferences: outputs.VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReference[];
    vmDiskReferences: outputs.VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReference[];
}

export interface VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReference {
    imageExtId: string;
}

export interface VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReference {
    diskAddresses: outputs.VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddress[];
    diskExtId: string;
    vmReferences: outputs.VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddress {
    busType: string;
    index: number;
}

export interface VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReference {
    extId: string;
}

export interface VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfig {
    isFlashModeEnabled: boolean;
}

export interface VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainer {
    extId: string;
}

export interface VmCloneV2Category {
    extId: string;
}

export interface VmCloneV2CdRom {
    backingInfos: outputs.VmCloneV2CdRomBackingInfo[];
    diskAddresses: outputs.VmCloneV2CdRomDiskAddress[];
    extId: string;
    isoType: string;
}

export interface VmCloneV2CdRomBackingInfo {
    dataSources: outputs.VmCloneV2CdRomBackingInfoDataSource[];
    diskExtId: string;
    diskSizeBytes: number;
    isMigrationInProgress: boolean;
    storageConfigs: outputs.VmCloneV2CdRomBackingInfoStorageConfig[];
    storageContainers: outputs.VmCloneV2CdRomBackingInfoStorageContainer[];
}

export interface VmCloneV2CdRomBackingInfoDataSource {
    references: outputs.VmCloneV2CdRomBackingInfoDataSourceReference[];
}

export interface VmCloneV2CdRomBackingInfoDataSourceReference {
    imageReferences: outputs.VmCloneV2CdRomBackingInfoDataSourceReferenceImageReference[];
    vmDiskReferences: outputs.VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReference[];
}

export interface VmCloneV2CdRomBackingInfoDataSourceReferenceImageReference {
    imageExtId: string;
}

export interface VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReference {
    diskAddresses: outputs.VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddress[];
    diskExtId: string;
    vmReferences: outputs.VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddress {
    busType: string;
    index: number;
}

export interface VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReference {
    extId: string;
}

export interface VmCloneV2CdRomBackingInfoStorageConfig {
    isFlashModeEnabled: boolean;
}

export interface VmCloneV2CdRomBackingInfoStorageContainer {
    extId: string;
}

export interface VmCloneV2CdRomDiskAddress {
    busType: string;
    index: number;
}

export interface VmCloneV2Cluster {
    extId: string;
}

export interface VmCloneV2Disk {
    backingInfos: outputs.VmCloneV2DiskBackingInfo[];
    diskAddresses: outputs.VmCloneV2DiskDiskAddress[];
    extId: string;
}

export interface VmCloneV2DiskBackingInfo {
    adfsVolumeGroupReferences: outputs.VmCloneV2DiskBackingInfoAdfsVolumeGroupReference[];
    vmDisks: outputs.VmCloneV2DiskBackingInfoVmDisk[];
}

export interface VmCloneV2DiskBackingInfoAdfsVolumeGroupReference {
    volumeGroupExtId: string;
}

export interface VmCloneV2DiskBackingInfoVmDisk {
    dataSources: outputs.VmCloneV2DiskBackingInfoVmDiskDataSource[];
    diskExtId: string;
    diskSizeBytes: number;
    isMigrationInProgress: boolean;
    storageConfigs: outputs.VmCloneV2DiskBackingInfoVmDiskStorageConfig[];
    storageContainers: outputs.VmCloneV2DiskBackingInfoVmDiskStorageContainer[];
}

export interface VmCloneV2DiskBackingInfoVmDiskDataSource {
    references: outputs.VmCloneV2DiskBackingInfoVmDiskDataSourceReference[];
}

export interface VmCloneV2DiskBackingInfoVmDiskDataSourceReference {
    imageReferences: outputs.VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceImageReference[];
    vmDiskReferences: outputs.VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReference[];
}

export interface VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceImageReference {
    imageExtId: string;
}

export interface VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReference {
    diskAddresses: outputs.VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddress[];
    diskExtId: string;
    vmReferences: outputs.VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReference[];
}

export interface VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddress {
    busType: string;
    index: number;
}

export interface VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReference {
    extId: string;
}

export interface VmCloneV2DiskBackingInfoVmDiskStorageConfig {
    isFlashModeEnabled: boolean;
}

export interface VmCloneV2DiskBackingInfoVmDiskStorageContainer {
    extId: string;
}

export interface VmCloneV2DiskDiskAddress {
    busType: string;
    index: number;
}

export interface VmCloneV2Gpus {
    deviceId: number;
    extId: string;
    fraction: number;
    frameBufferSizeBytes: number;
    guestDriverVersion: string;
    mode: string;
    name: string;
    numVirtualDisplayHeads: number;
    pciAddresses: outputs.VmCloneV2GpusPciAddress[];
    vendor: string;
}

export interface VmCloneV2GpusPciAddress {
    bus: number;
    device: number;
    func: number;
    segment: number;
}

export interface VmCloneV2GuestCustomization {
    configs: outputs.VmCloneV2GuestCustomizationConfig[];
}

export interface VmCloneV2GuestCustomizationConfig {
    cloudInits: outputs.VmCloneV2GuestCustomizationConfigCloudInit[];
    syspreps: outputs.VmCloneV2GuestCustomizationConfigSysprep[];
}

export interface VmCloneV2GuestCustomizationConfigCloudInit {
    cloudInitScripts: outputs.VmCloneV2GuestCustomizationConfigCloudInitCloudInitScript[];
    datasourceType?: string;
    metadata: string;
}

export interface VmCloneV2GuestCustomizationConfigCloudInitCloudInitScript {
    customKeys: outputs.VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKey[];
    userDatas: outputs.VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptUserData[];
}

export interface VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKey {
    keyValuePairs: outputs.VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyKeyValuePair[];
}

export interface VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyKeyValuePair {
    name: string;
    value: string;
}

export interface VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptUserData {
    value: string;
}

export interface VmCloneV2GuestCustomizationConfigSysprep {
    installType: string;
    sysprepScripts: outputs.VmCloneV2GuestCustomizationConfigSysprepSysprepScript[];
}

export interface VmCloneV2GuestCustomizationConfigSysprepSysprepScript {
    customKeyValues: outputs.VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValue[];
    unattendXmls: outputs.VmCloneV2GuestCustomizationConfigSysprepSysprepScriptUnattendXml[];
}

export interface VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValue {
    keyValuePairs: outputs.VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePair[];
}

export interface VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePair {
    name: string;
    value: string;
}

export interface VmCloneV2GuestCustomizationConfigSysprepSysprepScriptUnattendXml {
    value: string;
}

export interface VmCloneV2GuestTool {
    availableVersion: string;
    capabilities: string[];
    guestOsVersion: string;
    isEnabled: boolean;
    isInstalled: boolean;
    isIsoInserted: boolean;
    isReachable: boolean;
    isVmMobilityDriversInstalled: boolean;
    isVssSnapshotCapable: boolean;
    version: string;
}

export interface VmCloneV2Host {
    extId: string;
}

export interface VmCloneV2Link {
    href: string;
    rel: string;
}

export interface VmCloneV2Nic {
    backingInfos: outputs.VmCloneV2NicBackingInfo[];
    extId: string;
    networkInfos: outputs.VmCloneV2NicNetworkInfo[];
}

export interface VmCloneV2NicBackingInfo {
    isConnected: boolean;
    macAddress: string;
    model: string;
    numQueues?: number;
}

export interface VmCloneV2NicNetworkInfo {
    ipv4Configs: outputs.VmCloneV2NicNetworkInfoIpv4Config[];
    networkFunctionChains: outputs.VmCloneV2NicNetworkInfoNetworkFunctionChain[];
    networkFunctionNicType: string;
    nicType: string;
    shouldAllowUnknownMacs: boolean;
    subnets: outputs.VmCloneV2NicNetworkInfoSubnet[];
    trunkedVlans: number[];
    vlanMode: string;
}

export interface VmCloneV2NicNetworkInfoIpv4Config {
    ipAddresses: outputs.VmCloneV2NicNetworkInfoIpv4ConfigIpAddress[];
    secondaryIpAddressLists: outputs.VmCloneV2NicNetworkInfoIpv4ConfigSecondaryIpAddressList[];
    shouldAssignIp: boolean;
}

export interface VmCloneV2NicNetworkInfoIpv4ConfigIpAddress {
    prefixLength: number;
    value: string;
}

export interface VmCloneV2NicNetworkInfoIpv4ConfigSecondaryIpAddressList {
    prefixLength: number;
    value: string;
}

export interface VmCloneV2NicNetworkInfoNetworkFunctionChain {
    extId: string;
}

export interface VmCloneV2NicNetworkInfoSubnet {
    extId: string;
}

export interface VmCloneV2OwnershipInfo {
    owners: outputs.VmCloneV2OwnershipInfoOwner[];
}

export interface VmCloneV2OwnershipInfoOwner {
    extId: string;
}

export interface VmCloneV2ProtectionPolicyState {
    policies: outputs.VmCloneV2ProtectionPolicyStatePolicy[];
}

export interface VmCloneV2ProtectionPolicyStatePolicy {
    extId: string;
}

export interface VmCloneV2SerialPort {
    extId: string;
    index: number;
    isConnected: boolean;
}

export interface VmCloneV2Source {
    entityType: string;
    extId: string;
}

export interface VmCloneV2StorageConfig {
    isFlashModeEnabled: boolean;
    qosConfigs: outputs.VmCloneV2StorageConfigQosConfig[];
}

export interface VmCloneV2StorageConfigQosConfig {
    throttledIops: number;
}

export interface VmCloneV2VtpmConfig {
    isVtpmEnabled: boolean;
    version: string;
}

export interface VmGcUpdateV2Config {
    cloudInits: outputs.VmGcUpdateV2ConfigCloudInit[];
    syspreps: outputs.VmGcUpdateV2ConfigSysprep[];
}

export interface VmGcUpdateV2ConfigCloudInit {
    cloudInitScripts: outputs.VmGcUpdateV2ConfigCloudInitCloudInitScript[];
    datasourceType?: string;
    metadata: string;
}

export interface VmGcUpdateV2ConfigCloudInitCloudInitScript {
    customKeys: outputs.VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKey[];
    userDatas: outputs.VmGcUpdateV2ConfigCloudInitCloudInitScriptUserData[];
}

export interface VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKey {
    keyValuePairs: outputs.VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKeyKeyValuePair[];
}

export interface VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKeyKeyValuePair {
    name: string;
    value: string;
}

export interface VmGcUpdateV2ConfigCloudInitCloudInitScriptUserData {
    value: string;
}

export interface VmGcUpdateV2ConfigSysprep {
    installType: string;
    sysprepScripts: outputs.VmGcUpdateV2ConfigSysprepSysprepScript[];
}

export interface VmGcUpdateV2ConfigSysprepSysprepScript {
    customKeyValues: outputs.VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValue[];
    unattendXmls: outputs.VmGcUpdateV2ConfigSysprepSysprepScriptUnattendXml[];
}

export interface VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValue {
    keyValuePairs: outputs.VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValueKeyValuePair[];
}

export interface VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValueKeyValuePair {
    name: string;
    value: string;
}

export interface VmGcUpdateV2ConfigSysprepSysprepScriptUnattendXml {
    value: string;
}

export interface VmNetworkDeviceAssignIpV2IpAddress {
    prefixLength?: number;
    value: string;
}

export interface VmNetworkDeviceMigrateV2IpAddress {
    prefixLength?: number;
    value: string;
}

export interface VmNetworkDeviceMigrateV2Subnet {
    extId?: string;
}

export interface VmShutdownActionV2GuestPowerStateTransitionConfig {
    /**
     * Indicates whether to run the set script before the VM shutdowns/restarts.
     */
    shouldEnableScriptExec?: boolean;
    /**
     * Indicates whether to abort VM shutdown/restart if the script fails.
     *
     *
     * See detailed information in [Nutanix VMs Power Action Shutdown V4](https://developers.nutanix.com/api-reference?namespace=vmm&version=v4.0#tag/Vm/operation/shutdownVm).
     * See detailed information in [Nutanix VMs Power Action Shutdown Guest Vm V4](https://developers.nutanix.com/api-reference?namespace=vmm&version=v4.0#tag/Vm/operation/shutdownGuestVm).
     * See detailed information in [Nutanix VMs Power Action Reboot V4](https://developers.nutanix.com/api-reference?namespace=vmm&version=v4.0#tag/Vm/operation/rebootVm).
     * See detailed information in [Nutanix VMs Power Action Reboot Guest Vm V4](https://developers.nutanix.com/api-reference?namespace=vmm&version=v4.0#tag/Vm/operation/rebootGuestVm).
     */
    shouldFailOnScriptFailure?: boolean;
}

export interface VolumeGroupDiskV2DiskDataSourceReference {
    /**
     * - The Entity Type of the Data Source Reference. valid values are:
     * - STORAGE_CONTAINER
     * - VM_DISK
     * - VOLUME_DISK
     * - DISK_RECOVERY_POINT
     */
    entityType?: string;
    /**
     * - The external identifier of the Data Source Reference.
     */
    extId: string;
    /**
     * - The name of the Data Source Reference.bled for the Volume Group.
     */
    name?: string;
    /**
     * - The uri list of the Data Source Reference.
     */
    uris: string[];
}

export interface VolumeGroupDiskV2DiskStorageFeature {
    /**
     * - this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
     */
    flashModes?: outputs.VolumeGroupDiskV2DiskStorageFeatureFlashMode[];
}

export interface VolumeGroupDiskV2DiskStorageFeatureFlashMode {
    /**
     * - Indicates whether the flash mode is enabled for the Volume Group Disk.
     *
     * See detailed information in [Nutanix Create Volume Disk V4](https://developers.nutanix.com/api-reference?namespace=volumes&version=v4.0#tag/VolumeGroups/operation/createVolumeDisk).
     */
    isEnabled?: boolean;
}

export interface VolumeGroupIscsiClientV2IscsiInitiatorNetworkId {
    /**
     * A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
     */
    fqdns: outputs.VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdFqdn[];
    /**
     * An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    ipv4s: outputs.VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv4[];
    /**
     * An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    ipv6s: outputs.VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv6[];
}

export interface VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdFqdn {
    /**
     * - The fully qualified domain name.
     *
     *
     * See detailed information in [Nutanix Attach an iSCSI Client to Volume Group V4](https://developers.nutanix.com/api-reference?namespace=volumes&version=v4.0#tag/VolumeGroups/operation/attachIscsiClient).
     */
    value: string;
}

export interface VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv4 {
    /**
     * - The prefix length of the network to which this host IPv4 address belongs.
     */
    prefixLength: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv4 format.
     */
    value: string;
}

export interface VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv6 {
    /**
     * - The prefix length of the network to which this host IPv6 address belongs.
     */
    prefixLength: number;
    /**
     * - An unique address that identifies a device on the internet or a local network in IPv6 format.
     */
    value: string;
}

export interface VolumeGroupV2Disk {
    /**
     * - Volume Disk description.
     */
    description?: string;
    /**
     * -(Required) Disk Data Source Reference.
     */
    diskDataSourceReferences: outputs.VolumeGroupV2DiskDiskDataSourceReference[];
    /**
     * - ize of the disk in bytes. This field is mandatory during Volume Group creation if a new disk is being created on the storage container.
     */
    diskSizeBytes: number;
    /**
     * - Storage optimization features which must be enabled on the Volume Disks. This is an optional field. If omitted, the disks will honor the Volume Group specific storage features setting.
     */
    diskStorageFeatures?: outputs.VolumeGroupV2DiskDiskStorageFeature[];
    /**
     * - Index of the disk in a Volume Group. This field is optional and immutable.
     */
    index?: number;
}

export interface VolumeGroupV2DiskDiskDataSourceReference {
    /**
     * - The Entity Type of the Data Source Reference.
     */
    entityType?: string;
    /**
     * - The external identifier of the Data Source Reference.
     */
    extId: string;
    /**
     * - The name of the Data Source Reference.bled for the Volume Group.
     */
    name?: string;
    /**
     * - The uri list of the Data Source Reference.
     */
    uris: string[];
}

export interface VolumeGroupV2DiskDiskStorageFeature {
    /**
     * - this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
     */
    flashModes?: outputs.VolumeGroupV2DiskDiskStorageFeatureFlashMode[];
}

export interface VolumeGroupV2DiskDiskStorageFeatureFlashMode {
    /**
     * - Indicates whether the flash mode is enabled for the Volume Group Disk.
     *
     * See detailed information in [Nutanix Create Volume Group V4](https://developers.nutanix.com/api-reference?namespace=volumes&version=v4.0#tag/VolumeGroups/operation/createVolumeGroup).
     */
    isEnabled?: boolean;
}

export interface VolumeGroupV2IscsiFeature {
    /**
     * - The authentication type enabled for the Volume Group.
     */
    enabledAuthentications?: string;
    /**
     * Target secret in case of a CHAP authentication. This field must only be provided in case the authentication type is not set to CHAP. This is an optional field and it cannot be retrieved once configured.
     */
    targetSecret?: string;
}

export interface VolumeGroupV2StorageFeature {
    /**
     * - this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
     */
    flashModes?: outputs.VolumeGroupV2StorageFeatureFlashMode[];
}

export interface VolumeGroupV2StorageFeatureFlashMode {
    /**
     * - Indicates whether the flash mode is enabled for the Volume Group Disk.
     *
     * See detailed information in [Nutanix Create Volume Group V4](https://developers.nutanix.com/api-reference?namespace=volumes&version=v4.0#tag/VolumeGroups/operation/createVolumeGroup).
     */
    isEnabled?: boolean;
}

export interface VpcCommonDomainNameServerIpList {
    /**
     * ip address.
     */
    ip: string;
}

export interface VpcExternalSubnetListStatus {
    activeGatewayNode: outputs.VpcExternalSubnetListStatusActiveGatewayNode;
    externalIpLists: string[];
    externalSubnetReference: {[key: string]: string};
}

export interface VpcExternalSubnetListStatusActiveGatewayNode {
    hostReference: {[key: string]: string};
    ipAddress: string;
}

export interface VpcExternallyRoutablePrefixList {
    /**
     * ip address.
     */
    ip: string;
    /**
     * prefix length.
     */
    prefixLength: number;
}

export interface VpcV2CommonDhcpOption {
    /**
     * List of Domain Name Server addresses
     * - `domain_name_servers.ipv4`:(Optional) Reference to address configuration
     * - `domain_name_servers.ipv6`: (Optional) Reference to address configuration
     */
    domainNameServers: outputs.VpcV2CommonDhcpOptionDomainNameServer[];
}

export interface VpcV2CommonDhcpOptionDomainNameServer {
    ipv4s: outputs.VpcV2CommonDhcpOptionDomainNameServerIpv4[];
    ipv6s: outputs.VpcV2CommonDhcpOptionDomainNameServerIpv6[];
}

export interface VpcV2CommonDhcpOptionDomainNameServerIpv4 {
    prefixLength: number;
    value: string;
}

export interface VpcV2CommonDhcpOptionDomainNameServerIpv6 {
    prefixLength: number;
    value: string;
}

export interface VpcV2ExternalSubnet {
    activeGatewayCount: number;
    activeGatewayNodes: outputs.VpcV2ExternalSubnetActiveGatewayNode[];
    /**
     * List of IP Addresses used for SNAT, if NAT is enabled on the external subnet. If NAT is not enabled, this specifies the IP address of the VPC port connected to the external gateway.
     */
    externalIps: outputs.VpcV2ExternalSubnetExternalIp[];
    gatewayNodes: string[];
    /**
     * External subnet reference.
     */
    subnetReference: string;
}

export interface VpcV2ExternalSubnetActiveGatewayNode {
    nodeId: string;
    nodeIpAddresses: outputs.VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddress[];
}

export interface VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddress {
    ipv4s: outputs.VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv4[];
    ipv6s: outputs.VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv6[];
}

export interface VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv4 {
    prefixLength: number;
    value: string;
}

export interface VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv6 {
    prefixLength: number;
    value: string;
}

export interface VpcV2ExternalSubnetExternalIp {
    /**
     * Reference to address configuration
     */
    ipv4s: outputs.VpcV2ExternalSubnetExternalIpIpv4[];
    /**
     * Reference to address configuration
     */
    ipv6s: outputs.VpcV2ExternalSubnetExternalIpIpv6[];
}

export interface VpcV2ExternalSubnetExternalIpIpv4 {
    prefixLength: number;
    value: string;
}

export interface VpcV2ExternalSubnetExternalIpIpv6 {
    prefixLength: number;
    value: string;
}

export interface VpcV2ExternallyRoutablePrefix {
    /**
     * IP V4 Configuration
     * - `ipv4.ip`: (Required) Reference to address configuration
     * - `ipv4.prefix_length`: (Required) The prefix length of the network
     */
    ipv4s: outputs.VpcV2ExternallyRoutablePrefixIpv4[];
    /**
     * IP V6 Configuration
     * - `ipv6.ip`: (Required) Reference to address configuration
     * - `ipv6.prefix_length`: (Required) The prefix length of the network
     */
    ipv6s: outputs.VpcV2ExternallyRoutablePrefixIpv6[];
}

export interface VpcV2ExternallyRoutablePrefixIpv4 {
    ips: outputs.VpcV2ExternallyRoutablePrefixIpv4Ip[];
    prefixLength: number;
}

export interface VpcV2ExternallyRoutablePrefixIpv4Ip {
    prefixLength: number;
    value: string;
}

export interface VpcV2ExternallyRoutablePrefixIpv6 {
    ips: outputs.VpcV2ExternallyRoutablePrefixIpv6Ip[];
    prefixLength: number;
}

export interface VpcV2ExternallyRoutablePrefixIpv6Ip {
    prefixLength: number;
    value: string;
}

export interface VpcV2Link {
    href: string;
    rel: string;
}

export interface VpcV2Metadata {
    categoryIds: any[][];
    ownerReferenceId: string;
    ownerUserName: string;
    projectName: string;
    projectReferenceId: string;
}

export interface VpcV2SnatIp {
    ipv4s: outputs.VpcV2SnatIpIpv4[];
    ipv6s: outputs.VpcV2SnatIpIpv6[];
}

export interface VpcV2SnatIpIpv4 {
    prefixLength: number;
    value: string;
}

export interface VpcV2SnatIpIpv6 {
    prefixLength: number;
    value: string;
}

