// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface AccessControlPolicyCategory {
    name: string;
    value: string;
}

export interface AccessControlPolicyContextFilterList {
    /**
     * A list of Entity filter expressions.
     */
    entityFilterExpressionLists: outputs.AccessControlPolicyContextFilterListEntityFilterExpressionList[];
    scopeFilterExpressionLists: outputs.AccessControlPolicyContextFilterListScopeFilterExpressionList[];
}

export interface AccessControlPolicyContextFilterListEntityFilterExpressionList {
    leftHandSideEntityType: string;
    operator: string;
    rightHandSide: outputs.AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSide;
}

export interface AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSide {
    categories: outputs.AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategories;
    collection: string;
    uuidLists: string[];
}

export interface AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategories {
    name: string;
    values: string[];
}

export interface AccessControlPolicyContextFilterListScopeFilterExpressionList {
    leftHandSide: string;
    operator: string;
    rightHandSide: outputs.AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSide;
}

export interface AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSide {
    categories: outputs.AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategories;
    collection: string;
    uuidLists: string[];
}

export interface AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategories {
    name: string;
    values: string[];
}

export interface AccessControlPolicyOwnerReference {
    kind?: string;
    name?: string;
    uuid?: string;
}

export interface AccessControlPolicyRoleReference {
    kind: string;
    name: string;
    uuid: string;
}

export interface AccessControlPolicyUserGroupReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface AccessControlPolicyUserReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface AddressGroupIpAddressBlockList {
    ip: string;
    prefixLength: number;
}

export interface FoundationCentralImageClusterClusterStatus {
    aggregatePercentComplete: number;
    clusterCreationStarted: boolean;
    clusterProgressDetails: outputs.FoundationCentralImageClusterClusterStatusClusterProgressDetail[];
    currentFoundationIp: string;
    foundationSessionId: string;
    imagingStopped: boolean;
    intentPickedUp: boolean;
    nodeProgressDetails: outputs.FoundationCentralImageClusterClusterStatusNodeProgressDetail[];
}

export interface FoundationCentralImageClusterClusterStatusClusterProgressDetail {
    clusterName: string;
    messageLists: string[];
    percentComplete: number;
    status: string;
}

export interface FoundationCentralImageClusterClusterStatusNodeProgressDetail {
    imagedNodeUuid: string;
    imagingStopped: boolean;
    intentPickedUp: boolean;
    messageLists: string[];
    percentComplete: number;
    status: string;
}

export interface FoundationCentralImageClusterCommonNetworkSettings {
    cvmDnsServers: string[];
    cvmNtpServers: string[];
    hypervisorDnsServers: string[];
    hypervisorNtpServers: string[];
}

export interface FoundationCentralImageClusterFoundationInitConfig {
    blocks: outputs.FoundationCentralImageClusterFoundationInitConfigBlock[];
    clusters: outputs.FoundationCentralImageClusterFoundationInitConfigCluster[];
    cvmGateway: string;
    cvmNetmask: string;
    dnsServers: string;
    hypervProductKey: string;
    hypervSku: string;
    hypervisorGateway: string;
    hypervisorIsoUrl: {[key: string]: string};
    hypervisorIsos: outputs.FoundationCentralImageClusterFoundationInitConfigHypervisorIso[];
    hypervisorNetmask: string;
    ipmiGateway: string;
    ipmiNetmask: string;
    nosPackageUrls: outputs.FoundationCentralImageClusterFoundationInitConfigNosPackageUrl[];
}

export interface FoundationCentralImageClusterFoundationInitConfigBlock {
    blockId: string;
    nodes: outputs.FoundationCentralImageClusterFoundationInitConfigBlockNode[];
}

export interface FoundationCentralImageClusterFoundationInitConfigBlockNode {
    cvmIp: string;
    cvmVlanId: number;
    fcImagedNodeUuid: string;
    hardwareAttributesOverride: {[key: string]: string};
    hypervisor: string;
    hypervisorHostname: string;
    hypervisorIp: string;
    imageNow: boolean;
    ipmiIp: string;
    ipv6Address: string;
    nodePosition: string;
    nodeSerial: string;
}

export interface FoundationCentralImageClusterFoundationInitConfigCluster {
    clusterExternalIp: string;
    clusterInitNow: boolean;
    clusterInitSuccessful: boolean;
    clusterMembers: string[];
    clusterName: string;
    cvmDnsServers: string;
    cvmNtpServers: string;
    redundancyFactor: number;
    timezone: string;
}

export interface FoundationCentralImageClusterFoundationInitConfigHypervisorIso {
    hypervisorType: string;
    sha256sum: string;
    url: string;
}

export interface FoundationCentralImageClusterFoundationInitConfigNosPackageUrl {
    sha256sum: string;
    url: string;
}

export interface FoundationCentralImageClusterHypervisorIsoDetails {
    hypervProductKey: string;
    hypervSku: string;
    sha256sum: string;
    url?: string;
}

export interface FoundationCentralImageClusterNodeList {
    cvmGateway: string;
    cvmIp: string;
    cvmNetmask?: string;
    cvmRamGb?: number;
    cvmVlanId: number;
    hardwareAttributesOverride: {[key: string]: any};
    hypervisorGateway: string;
    hypervisorHostname: string;
    hypervisorIp: string;
    hypervisorNetmask: string;
    hypervisorType?: string;
    imageNow: boolean;
    imagedNodeUuid: string;
    ipmiGateway: string;
    ipmiIp: string;
    ipmiNetmask?: string;
    rdmaPassthrough?: boolean;
    useExistingNetworkSettings?: boolean;
}

export interface FoundationImageNodesBlock {
    /**
     * : - Block ID.
     */
    blockId?: string;
    nodes: outputs.FoundationImageNodesBlockNode[];
}

export interface FoundationImageNodesBlockNode {
    /**
     * :- (Required if node is lacp configured) slow or fast if lacp if being used at the switch
     */
    bondLacpRate?: string;
    /**
     * :- (Required if node is capable) dynamic if using LACP, static for LAG
     */
    bondMode?: string;
    /**
     * :- MAC Addresses of NICs in a team/bond
     */
    bondUplinks?: string;
    /**
     * :- ID of cluster.
     */
    clusterId?: string;
    /**
     * :- Current CVM vlan tag. 0 Value with remove vlan tag.
     */
    currentCvmVlanTag?: number;
    /**
     * :- CVM current network interface.
     */
    currentNetworkInterface?: string;
    /**
     * :- RAM capacity of CVM in GB.
     */
    cvmGbRam?: number;
    cvmIp?: string;
    /**
     * :- Number of CVM vcpus.
     */
    cvmNumVcpus?: number;
    /**
     * :- use "vmInstaller" to enable CVM imaging from standalone.
     */
    deviceHint?: string;
    /**
     * :- serial of boot device to be excluded (used by NX G6 platforms)
     */
    exludeBootSerial?: string;
    hypervisor?: string;
    /**
     * :- (Required) Hypervisor Hostname.
     */
    hypervisorHostname: string;
    /**
     * :- (Required) Hypervisor IP address.
     */
    hypervisorIp: string;
    /**
     * :- Imaging delay.
     */
    imageDelay?: number;
    /**
     * :- (Optional, Default = true) If the node should be imaged now.
     */
    imageNow?: boolean;
    imageSuccessful?: boolean;
    /**
     * :- Whether IPMI should be configured.
     */
    ipmiConfigureNow?: boolean;
    /**
     * :- (Required incase using IPMI based imaging either here or outside blocks) IPMI gateway for this node
     */
    ipmiGateway?: string;
    /**
     * :- (Required) IPMI IP address.
     */
    ipmiIp?: string;
    /**
     * :- IPMI MAC address.
     */
    ipmiMac?: string;
    /**
     * :- (Required incase using IPMI based imaging either here or outside blocks) IPMI netmask for this node
     */
    ipmiNetmask?: string;
    /**
     * :- (Required incase using IPMI based imaging either here or outside blocks) IPMI username
     */
    ipmiPassword?: string;
    /**
     * :- (Required incase using IPMI based imaging either here or outside blocks) IPMI password
     */
    ipmiUser?: string;
    /**
     * :- (Required when deviceHint = "vmInstaller" for imaging using node's existing cvm for imaging) IPV6 address.
     */
    ipv6Address?: string;
    /**
     * :- (Required when deviceHint = "vmInstaller" for imaging using node's existing cvm for imaging) ipv6 interface.
     */
    ipv6Interface?: string;
    /**
     * :- relocate bootbank files to make space for phoenix files.
     */
    mitigateLowBootSpace?: boolean;
    /**
     * :- (Required) Position of the node in the block.
     */
    nodePosition: string;
    /**
     * :- serial number of the node.
     */
    nodeSerial?: string;
    /**
     * :- mac address of nic to be used for rdma
     */
    rdmaMacAddr?: string;
    /**
     * :- (Required if node is capable) passthru RDMA nic to CVM if possible, default to false
     */
    rdmaPassthrough?: boolean;
    /**
     * :- UCSM Managed mode.
     */
    ucsmManagedMode?: string;
    /**
     * :- UCSM node serial.
     */
    ucsmNodeSerial?: string;
    /**
     * :- Object of UCSM parameters.
     * * `ucsm_params.native_vlan` :- If the vlan is native.
     * * `ucsm_params.keep_ucsm_settings` :- Whether UCSM settings should be kept.
     * * `ucsm_params.mac_pool` :- Mac address pool.
     * * `ucsm_params.vlan_name` :- Name of vlan.
     */
    ucsmParams?: outputs.FoundationImageNodesBlockNodeUcsmParams;
    vswitches?: outputs.FoundationImageNodesBlockNodeVswitch[];
}

export interface FoundationImageNodesBlockNodeUcsmParams {
    keepUcsmSettings?: boolean;
    macPool?: string;
    nativeVlan?: boolean;
    vlanName?: string;
}

export interface FoundationImageNodesBlockNodeVswitch {
    /**
     * :- (Required if node is capable) dynamic if using LACP, static for LAG
     */
    bondMode?: string;
    lacp?: string;
    mtu?: number;
    name?: string;
    otherConfigs?: string[];
    uplinks?: string[];
}

export interface FoundationImageNodesCluster {
    /**
     * : - Backplane netmask.
     */
    backplaneNetmask?: string;
    /**
     * : - Backplane subnet address.
     */
    backplaneSubnet?: string;
    /**
     * : - Backplane vlan.
     */
    backplaneVlan?: string;
    /**
     * : - External IP of the cluster.
     */
    clusterExternalIp?: string;
    /**
     * : - (Optional, Default = true) If cluster should be created.
     */
    clusterInitNow?: boolean;
    /**
     * : - If cluster initialization was successful.
     */
    clusterInitSuccessful?: boolean;
    /**
     * : - (Required) Members in the cluster.
     */
    clusterMembers: string[];
    /**
     * : - (Required) Name of the cluster.
     */
    clusterName: string;
    /**
     * : - DNS servers of CVM.
     */
    cvmDnsServers?: string;
    /**
     * : - NTP servers of CVM.
     */
    cvmNtpServers?: string;
    /**
     * : - If network segmentation should be enabled.
     */
    enableNs?: boolean;
    /**
     * : - NTP servers of hypervisor.
     */
    hypervisorNtpServers?: string;
    /**
     * : - (Required) Cluster Redundancy Factor.
     */
    redundancyFactor: number;
    /**
     * : - If it is a single node cluster.
     */
    singleNodeCluster?: boolean;
}

export interface FoundationImageNodesClusterUrl {
    /**
     * : - (Required) Name of the cluster.
     */
    clusterName: string;
    clusterUrl: string;
}

export interface FoundationImageNodesEosMetadata {
    /**
     * : - arrya of account names
     */
    accountNames?: string[];
    /**
     * : - Id of the Eos config uploaded in foundation GUI.
     */
    configId?: string;
    /**
     * : - Email address of the user who downloaded Eos config.
     */
    email?: string;
}

export interface FoundationImageNodesFcSettings {
    /**
     * :- Foundation Central metadata which will be transferred to the newly imaged node.
     * * `fc_metadata.fc_ip` :- IP address of foundation central.
     * * `fc_metadata.api_key` :- apiKey which the node uses to register itself with foundation central.
     */
    fcMetadata: outputs.FoundationImageNodesFcSettingsFcMetadata;
    /**
     * :- If this attribute is set to True, FC workflow will be invoked.
     */
    foundationCentral: boolean;
}

export interface FoundationImageNodesFcSettingsFcMetadata {
    apiKey: string;
    fcIp: string;
}

export interface FoundationImageNodesHypervisorIso {
    /**
     * : - Details of hypervisor ISO of type esx.
     */
    esx?: outputs.FoundationImageNodesHypervisorIsoEsx;
    /**
     * : - Details of hypervisor ISO of type hyperv.
     */
    hyperv?: outputs.FoundationImageNodesHypervisorIsoHyperv;
    /**
     * : - Details of hypervisor ISO of type kvm.
     */
    kvm?: outputs.FoundationImageNodesHypervisorIsoKvm;
    /**
     * : - Details of hypervisor ISO of type xen.
     */
    xen?: outputs.FoundationImageNodesHypervisorIsoXen;
}

export interface FoundationImageNodesHypervisorIsoEsx {
    /**
     * :- (Required) Filename of hypervisor ISO.
     */
    checksum: string;
    /**
     * :- (Required) Checksum for ISO file.
     */
    filename: string;
}

export interface FoundationImageNodesHypervisorIsoHyperv {
    /**
     * :- (Required) Filename of hypervisor ISO.
     */
    checksum: string;
    /**
     * :- (Required) Checksum for ISO file.
     */
    filename: string;
}

export interface FoundationImageNodesHypervisorIsoKvm {
    /**
     * :- (Required) Filename of hypervisor ISO.
     */
    checksum: string;
    /**
     * :- (Required) Checksum for ISO file.
     */
    filename: string;
}

export interface FoundationImageNodesHypervisorIsoXen {
    /**
     * :- (Required) Filename of hypervisor ISO.
     */
    checksum: string;
    /**
     * :- (Required) Checksum for ISO file.
     */
    filename: string;
}

export interface FoundationImageNodesTests {
    /**
     * : - Whether NCC checks should run.
     */
    runNcc?: boolean;
    /**
     * : - Whether system checks should run.
     */
    runSyscheck?: boolean;
}

export interface FoundationIpmiConfigBlock {
    blockId?: string;
    nodes: outputs.FoundationIpmiConfigBlockNode[];
}

export interface FoundationIpmiConfigBlockNode {
    ipmiConfigureNow: boolean;
    ipmiConfigureSuccessful: boolean;
    ipmiIp: string;
    ipmiMac: string;
    ipmiMessage: string;
}

export interface GetAccessControlPoliciesEntity {
    accessControlPolicyId: string;
    /**
     * The version of the API.
     * * `state`: - The state of the Access Control Policy.
     */
    apiVersion: string;
    categories: outputs.GetAccessControlPoliciesEntityCategory[];
    contextFilterLists: outputs.GetAccessControlPoliciesEntityContextFilterList[];
    description: string;
    metadata: {[key: string]: string};
    name: string;
    ownerReference: {[key: string]: string};
    projectReference: {[key: string]: string};
    roleReferences: outputs.GetAccessControlPoliciesEntityRoleReference[];
    state: string;
    userGroupReferenceLists: outputs.GetAccessControlPoliciesEntityUserGroupReferenceList[];
    userReferenceLists: outputs.GetAccessControlPoliciesEntityUserReferenceList[];
}

export interface GetAccessControlPoliciesEntityCategory {
    name: string;
    value: string;
}

export interface GetAccessControlPoliciesEntityContextFilterList {
    /**
     * A list of Entity filter expressions.
     */
    entityFilterExpressionLists: outputs.GetAccessControlPoliciesEntityContextFilterListEntityFilterExpressionList[];
    scopeFilterExpressionLists: outputs.GetAccessControlPoliciesEntityContextFilterListScopeFilterExpressionList[];
}

export interface GetAccessControlPoliciesEntityContextFilterListEntityFilterExpressionList {
    leftHandSideEntityType: string;
    operator: string;
    rightHandSides: outputs.GetAccessControlPoliciesEntityContextFilterListEntityFilterExpressionListRightHandSide[];
}

export interface GetAccessControlPoliciesEntityContextFilterListEntityFilterExpressionListRightHandSide {
    categories: outputs.GetAccessControlPoliciesEntityContextFilterListEntityFilterExpressionListRightHandSideCategory[];
    collection: string;
    uuidLists: string[];
}

export interface GetAccessControlPoliciesEntityContextFilterListEntityFilterExpressionListRightHandSideCategory {
    name: string;
    values: string[];
}

export interface GetAccessControlPoliciesEntityContextFilterListScopeFilterExpressionList {
    leftHandSide: string;
    operator: string;
    rightHandSides: outputs.GetAccessControlPoliciesEntityContextFilterListScopeFilterExpressionListRightHandSide[];
}

export interface GetAccessControlPoliciesEntityContextFilterListScopeFilterExpressionListRightHandSide {
    categories: outputs.GetAccessControlPoliciesEntityContextFilterListScopeFilterExpressionListRightHandSideCategory[];
    collection: string;
    uuidLists: string[];
}

export interface GetAccessControlPoliciesEntityContextFilterListScopeFilterExpressionListRightHandSideCategory {
    name: string;
    values: string[];
}

export interface GetAccessControlPoliciesEntityRoleReference {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetAccessControlPoliciesEntityUserGroupReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetAccessControlPoliciesEntityUserReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetAccessControlPoliciesMetadata {
    filter: string;
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetAccessControlPolicyCategory {
    name: string;
    value: string;
}

export interface GetAccessControlPolicyContextFilterList {
    /**
     * A list of Entity filter expressions.
     */
    entityFilterExpressionLists: outputs.GetAccessControlPolicyContextFilterListEntityFilterExpressionList[];
    scopeFilterExpressionLists: outputs.GetAccessControlPolicyContextFilterListScopeFilterExpressionList[];
}

export interface GetAccessControlPolicyContextFilterListEntityFilterExpressionList {
    leftHandSideEntityType: string;
    operator: string;
    rightHandSides: outputs.GetAccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSide[];
}

export interface GetAccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSide {
    categories: outputs.GetAccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategory[];
    collection: string;
    uuidLists: string[];
}

export interface GetAccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategory {
    name: string;
    values: string[];
}

export interface GetAccessControlPolicyContextFilterListScopeFilterExpressionList {
    leftHandSide: string;
    operator: string;
    rightHandSides: outputs.GetAccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSide[];
}

export interface GetAccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSide {
    categories: outputs.GetAccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategory[];
    collection: string;
    uuidLists: string[];
}

export interface GetAccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategory {
    name: string;
    values: string[];
}

export interface GetAccessControlPolicyRoleReference {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetAccessControlPolicyUserGroupReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetAccessControlPolicyUserReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetAddressGroupIpAddressBlockList {
    ip: string;
    prefixLength: number;
}

export interface GetAddressGroupsEntity {
    addressGroups: outputs.GetAddressGroupsEntityAddressGroup[];
    associatedPoliciesLists: outputs.GetAddressGroupsEntityAssociatedPoliciesList[];
}

export interface GetAddressGroupsEntityAddressGroup {
    addressGroupString: string;
    description?: string;
    ipAddressBlockLists: outputs.GetAddressGroupsEntityAddressGroupIpAddressBlockList[];
    name: string;
}

export interface GetAddressGroupsEntityAddressGroupIpAddressBlockList {
    ip: string;
    prefixLength: number;
}

export interface GetAddressGroupsEntityAssociatedPoliciesList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetAddressGroupsMetadata {
    filter: string;
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetAssertHelperCheck {
    condition: boolean;
    errorMessage: string;
}

export interface GetClusterAuthorizedPublicKeyList {
    key: string;
    name: string;
}

export interface GetClusterCaCertificateList {
    caName: string;
    certificate: string;
}

export interface GetClusterCategory {
    name: string;
    value: string;
}

export interface GetClusterHttpProxyList {
    address: {[key: string]: string};
    credentials: {[key: string]: string};
    proxyTypeLists: string[];
}

export interface GetClusterHttpProxyWhitelist {
    target: string;
    targetType: string;
}

export interface GetClusterManagementServerList {
    drsEnabled: boolean;
    ip: string;
    statusLists: string[];
    type: string;
}

export interface GetClusterNode {
    ip: string;
    type: string;
    version: string;
}

export interface GetClustersEntity {
    analysisVmEfficiencyMap: {[key: string]: string};
    /**
     * The API version.
     * * `description`: - A description for image.
     * * `metadata`: - The image kind metadata.
     * * `state`: - The state of the cluster entity.
     * * `gpuDriverVersion`: - GPU driver version.
     * * `clientAuth`: - Client authentication config.
     * * `authorizedPiblicKeyList`: - List of valid ssh keys for the cluster.
     * * `softwareMapNcc`: - Map of software on the cluster with software type as the key.
     * * `softwareMapNos`: - Map of software on the cluster with software type as the key.
     * * `encryptionStatus`: - Cluster encryption status.
     * * `sslKeyType`: - SSL key type. Key types with RSA_2048, ECDSA_256 and ECDSA_384 are supported for key generation and importing.
     * * `sslKeySigningInfo`: - Customer information used in Certificate Signing Request for creating digital certificates.
     * * `sslKeyExpireDatetime`: - UTC date and time in RFC-3339 format when the key expires
     * * `serviceList`: - Array of enabled cluster services. For example, a cluster can function as both AOS and cloud data gateway. - 'AOS': Regular Prism Element - 'PRISM_CENTRAL': Prism Central - 'CLOUD_DATA_GATEWAY': Cloud backup and DR gateway - 'AFS': Cluster for file server - 'WITNESS' : Witness cluster - 'XI_PORTAL': Xi cluster.
     * * `supportedInformationVerbosity`: - Verbosity level settings for populating support information. - 'Nothing': Send nothing - 'Basic': Send basic information - skip core dump and hypervisor stats information - 'BasicPlusCoreDump': Send basic and core dump information - 'All': Send all information (Default value: BASIC_PLUS_CORE_DUMP)
     * * `certificationSigningInfo`: - Customer information used in Certificate Signing Request for creating digital certificates.
     * * `operationMode`: - Cluster operation mode. - 'NORMAL': Cluster is operating normally. - 'READ_ONLY': Cluster is operating in read only mode. - 'STAND_ALONE': Only one node is operational in the cluster. This is valid only for single node or two node clusters. - 'SWITCH_TO_TWO_NODE': Cluster is moving from single node to two node cluster. - 'OVERRIDE': Valid only for single node cluster. If the user wants to run vms on a single node cluster in read only mode, he can set the cluster peration mode to override. Writes will be allowed in override mode.
     * * `caCertificateList`: - Zone name used in value of TZ environment variable.
     * * `enabledFeatureList`: - Array of enabled features.
     * * `isAvailable`: - Indicates if cluster is available to contact. (Readonly)
     * * `build`: - Cluster build details.
     * * `timezone`: - Zone name used in value of TZ environment variable.
     * * `clusterArch`: - Cluster architecture. (Readonly, Options: Options : X86_64 , PPC64LE)
     * * `managementServerList`: - List of cluster management servers. (Readonly)
     * * `masqueradingPort`: - Port used together with masqueradingIp to connect to the cluster.
     * * `masqueradingIp`: - The cluster NAT'd or proxy IP which maps to the cluster local IP.
     * * `externalIp`: - The local IP of cluster visible externally.
     * * `httpProxyList`: - List of proxies to connect to the service centers.
     * * `smtpServerType`: - SMTP Server type.
     * * `smtpServerEmailAddress`: - SMTP Server Email Address.
     * * `smtpServerCredentials`: - SMTP Server Credentials.
     * * `smtpServerProxyTypeList`: - SMTP Server Proxy Type List
     * * `smtpServerAddress`: - SMTP Server Address.
     * * `ntpServerIpList`: - The list of IP addresses or FQDNs of the NTP servers.
     * * `externalSubnet`: - External subnet for cross server communication. The format is IP/netmask. (default 172.16.0.0/255.240.0.0)
     * * `externalDataServicesIp`: - The cluster IP address that provides external entities access to various cluster data services.
     * * `internalSubnet`: - The internal subnet is local to every server - its not visible outside.iSCSI requests generated internally within the appliance (by user VMs or VMFS) are sent to the internal subnet. The format is IP/netmask.
     * * `domainServerNameserver`: -  The IP of the nameserver that can resolve the domain name. Must set when joining the domain.
     * * `domainServerName`: - Joined domain name. In 'put' request, empty name will unjoin the cluster from current domain.
     * * `domainServerCredentials`: - Cluster domain credentials.
     * * `nfsSubnetWhitelist`: - Comma separated list of subnets (of the form 'a.b.c.d/l.m.n.o') that are allowed to send NFS requests to this container. If not specified, the global NFS whitelist will be looked up for access permission. The internal subnet is always automatically considered part of the whitelist, even if the field below does not explicitly specify it. Similarly, all the hypervisor IPs are considered part of the whitelist. Finally, to permit debugging, all of the SVMs local IPs are considered to be implicitly part of the whitelist.
     * * `nameServerIpList`: - The list of IP addresses of the name servers.
     * * `httpProxyWhitelist`: - HTTP proxy whitelist.
     * * `analysisVmEfficiencyMap`: - Map of cluster efficiency which includes numbers of inefficient vms. The value is populated by analytics on PC. (Readonly)
     */
    apiVersion: string;
    authorizedPublicKeyLists: outputs.GetClustersEntityAuthorizedPublicKeyList[];
    build: {[key: string]: string};
    caCertificateLists: outputs.GetClustersEntityCaCertificateList[];
    categories: outputs.GetClustersEntityCategory[];
    certificationSigningInfo: {[key: string]: string};
    clientAuth: {[key: string]: string};
    clusterArch: string;
    domainServerCredentials: {[key: string]: string};
    domainServerName: string;
    domainServerNameserver: string;
    enabledFeatureLists: string[];
    encryptionStatus: string;
    externalDataServicesIp: string;
    externalIp: string;
    externalSubnet: string;
    gpuDriverVersion: string;
    httpProxyLists: outputs.GetClustersEntityHttpProxyList[];
    httpProxyWhitelists: outputs.GetClustersEntityHttpProxyWhitelist[];
    internalSubnet: string;
    isAvailable: boolean;
    managementServerLists: outputs.GetClustersEntityManagementServerList[];
    masqueradingIp: string;
    masqueradingPort: number;
    metadata: {[key: string]: string};
    name: string;
    nameServerIpLists: string[];
    nfsSubnetWhitelists: string[];
    nodes: outputs.GetClustersEntityNode[];
    ntpServerIpLists: string[];
    operationMode: string;
    ownerReference: {[key: string]: string};
    projectReference: {[key: string]: string};
    serviceLists: string[];
    smtpServerAddress: {[key: string]: string};
    smtpServerCredentials: {[key: string]: string};
    smtpServerEmailAddress: string;
    smtpServerProxyTypeLists: string[];
    smtpServerType: string;
    softwareMapNcc: {[key: string]: any};
    softwareMapNos: {[key: string]: any};
    sslKeyExpireDatetime: string;
    sslKeyName: string;
    sslKeySigningInfo: {[key: string]: string};
    sslKeyType: string;
    state: string;
    supportedInformationVerbosity: string;
    timezone: string;
}

export interface GetClustersEntityAuthorizedPublicKeyList {
    key: string;
    name: string;
}

export interface GetClustersEntityCaCertificateList {
    caName: string;
    certificate: string;
}

export interface GetClustersEntityCategory {
    name: string;
    value: string;
}

export interface GetClustersEntityHttpProxyList {
    address: {[key: string]: string};
    credentials: {[key: string]: string};
    proxyTypeLists: string[];
}

export interface GetClustersEntityHttpProxyWhitelist {
    target: string;
    targetType: string;
}

export interface GetClustersEntityManagementServerList {
    drsEnabled: boolean;
    ip: string;
    statusLists: string[];
    type: string;
}

export interface GetClustersEntityNode {
    ip: string;
    type: string;
    version: string;
}

export interface GetFloatingIpSpec {
    /**
     * Floating IP allocation status.
     */
    resources: outputs.GetFloatingIpSpecResource[];
}

export interface GetFloatingIpSpecResource {
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a vm_nic
     */
    vmNicReference: {[key: string]: string};
    /**
     * The reference to a vpc
     */
    vpcReference: {[key: string]: string};
}

export interface GetFloatingIpStatus {
    /**
     * Execution Context of Floating IP.
     */
    executionContexts: outputs.GetFloatingIpStatusExecutionContext[];
    /**
     * floating_ip Name.
     */
    name: string;
    /**
     * Floating IP allocation status.
     */
    resources: outputs.GetFloatingIpStatusResource[];
    /**
     * The state of the floating_ip.
     */
    state: string;
}

export interface GetFloatingIpStatusExecutionContext {
    taskUuids: string[];
}

export interface GetFloatingIpStatusResource {
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * Private IP with which the floating IP is associated.
     */
    floatingIp: string;
    /**
     * The reference to a vm_nic
     */
    vmNicReference: {[key: string]: string};
    /**
     * The reference to a vpc
     */
    vpcReference: {[key: string]: string};
}

export interface GetFloatingIpsEntity {
    metadata: {[key: string]: string};
    /**
     * Floating IP spec
     */
    specs: outputs.GetFloatingIpsEntitySpec[];
    /**
     * Floating IP output status
     */
    statuses: outputs.GetFloatingIpsEntityStatus[];
}

export interface GetFloatingIpsEntitySpec {
    /**
     * Floating IP allocation status.
     */
    resources: outputs.GetFloatingIpsEntitySpecResource[];
}

export interface GetFloatingIpsEntitySpecResource {
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a vm_nic
     */
    vmNicReference: {[key: string]: string};
    /**
     * The reference to a vpc
     */
    vpcReference: {[key: string]: string};
}

export interface GetFloatingIpsEntityStatus {
    /**
     * Execution Context of Floating IP.
     */
    executionContexts: outputs.GetFloatingIpsEntityStatusExecutionContext[];
    /**
     * floating_ip Name.
     */
    name: string;
    /**
     * Floating IP allocation status.
     */
    resources: outputs.GetFloatingIpsEntityStatusResource[];
    /**
     * The state of the floating_ip.
     */
    state: string;
}

export interface GetFloatingIpsEntityStatusExecutionContext {
    taskUuids: string[];
}

export interface GetFloatingIpsEntityStatusResource {
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * Private IP with which the floating IP is associated.
     */
    floatingIp: string;
    /**
     * The reference to a vm_nic
     */
    vmNicReference: {[key: string]: string};
    /**
     * The reference to a vpc
     */
    vpcReference: {[key: string]: string};
}

export interface GetFloatingIpsMetadata {
    filter: string;
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
    totalMatches: number;
}

export interface GetFoundationCentralClusterDetailsClusterStatus {
    aggregatePercentComplete: number;
    clusterCreationStarted: boolean;
    clusterProgressDetails: outputs.GetFoundationCentralClusterDetailsClusterStatusClusterProgressDetail[];
    currentFoundationIp: string;
    foundationSessionId: string;
    imagingStopped: boolean;
    intentPickedUp: boolean;
    nodeProgressDetails: outputs.GetFoundationCentralClusterDetailsClusterStatusNodeProgressDetail[];
}

export interface GetFoundationCentralClusterDetailsClusterStatusClusterProgressDetail {
    clusterName: string;
    messageLists: string[];
    percentComplete: number;
    status: string;
}

export interface GetFoundationCentralClusterDetailsClusterStatusNodeProgressDetail {
    imagedNodeUuid: string;
    imagingStopped: boolean;
    intentPickedUp: boolean;
    messageLists: string[];
    percentComplete: number;
    status: string;
}

export interface GetFoundationCentralClusterDetailsCommonNetworkSettings {
    cvmDnsServers: string[];
    cvmNtpServers: string[];
    hypervisorDnsServers: string[];
    hypervisorNtpServers: string[];
}

export interface GetFoundationCentralClusterDetailsFoundationInitConfig {
    blocks: outputs.GetFoundationCentralClusterDetailsFoundationInitConfigBlock[];
    clusters: outputs.GetFoundationCentralClusterDetailsFoundationInitConfigCluster[];
    cvmGateway: string;
    cvmNetmask: string;
    dnsServers: string;
    hypervProductKey: string;
    hypervSku: string;
    hypervisorGateway: string;
    hypervisorIsoUrl: {[key: string]: string};
    hypervisorIsos: outputs.GetFoundationCentralClusterDetailsFoundationInitConfigHypervisorIso[];
    hypervisorNetmask: string;
    ipmiGateway: string;
    ipmiNetmask: string;
    nosPackageUrls: outputs.GetFoundationCentralClusterDetailsFoundationInitConfigNosPackageUrl[];
}

export interface GetFoundationCentralClusterDetailsFoundationInitConfigBlock {
    blockId: string;
    nodes: outputs.GetFoundationCentralClusterDetailsFoundationInitConfigBlockNode[];
}

export interface GetFoundationCentralClusterDetailsFoundationInitConfigBlockNode {
    cvmIp: string;
    cvmVlanId: number;
    fcImagedNodeUuid: string;
    hardwareAttributesOverride: {[key: string]: string};
    hypervisor: string;
    hypervisorHostname: string;
    hypervisorIp: string;
    imageNow: boolean;
    ipmiIp: string;
    ipv6Address: string;
    nodePosition: string;
    nodeSerial: string;
}

export interface GetFoundationCentralClusterDetailsFoundationInitConfigCluster {
    clusterExternalIp: string;
    clusterInitNow: boolean;
    clusterInitSuccessful: boolean;
    clusterMembers: string[];
    clusterName: string;
    cvmDnsServers: string;
    cvmNtpServers: string;
    redundancyFactor: number;
    timezone: string;
}

export interface GetFoundationCentralClusterDetailsFoundationInitConfigHypervisorIso {
    hypervisorType: string;
    sha256sum: string;
    url: string;
}

export interface GetFoundationCentralClusterDetailsFoundationInitConfigNosPackageUrl {
    sha256sum: string;
    url: string;
}

export interface GetFoundationCentralImagedClustersListFilters {
    archived?: boolean;
}

export interface GetFoundationCentralImagedClustersListImagedCluster {
    archived: boolean;
    clusterExternalIp: string;
    clusterName: string;
    clusterSize: number;
    clusterStatus: outputs.GetFoundationCentralImagedClustersListImagedClusterClusterStatus;
    commonNetworkSettings: outputs.GetFoundationCentralImagedClustersListImagedClusterCommonNetworkSettings;
    createdTimestamp: string;
    currentTime: string;
    destroyed: boolean;
    foundationInitConfigs: outputs.GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfig[];
    foundationInitNodeUuid: string;
    imagedClusterUuid: string;
    imagedNodeUuidLists: string[];
    redundancyFactor?: number;
    storageNodeCount: number;
    workflowType: string;
}

export interface GetFoundationCentralImagedClustersListImagedClusterClusterStatus {
    aggregatePercentComplete: number;
    clusterCreationStarted: boolean;
    clusterProgressDetails: outputs.GetFoundationCentralImagedClustersListImagedClusterClusterStatusClusterProgressDetail[];
    currentFoundationIp: string;
    foundationSessionId: string;
    imagingStopped: boolean;
    intentPickedUp: boolean;
    nodeProgressDetails: outputs.GetFoundationCentralImagedClustersListImagedClusterClusterStatusNodeProgressDetail[];
}

export interface GetFoundationCentralImagedClustersListImagedClusterClusterStatusClusterProgressDetail {
    clusterName: string;
    messageLists: string[];
    percentComplete: number;
    status: string;
}

export interface GetFoundationCentralImagedClustersListImagedClusterClusterStatusNodeProgressDetail {
    imagedNodeUuid: string;
    imagingStopped: boolean;
    intentPickedUp: boolean;
    messageLists: string[];
    percentComplete: number;
    status: string;
}

export interface GetFoundationCentralImagedClustersListImagedClusterCommonNetworkSettings {
    cvmDnsServers: string[];
    cvmNtpServers: string[];
    hypervisorDnsServers: string[];
    hypervisorNtpServers: string[];
}

export interface GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfig {
    blocks: outputs.GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigBlock[];
    clusters: outputs.GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigCluster[];
    cvmGateway: string;
    cvmNetmask: string;
    dnsServers: string;
    hypervProductKey: string;
    hypervSku: string;
    hypervisorGateway: string;
    hypervisorIsoUrl: {[key: string]: string};
    hypervisorIsos: outputs.GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigHypervisorIso[];
    hypervisorNetmask: string;
    ipmiGateway: string;
    ipmiNetmask: string;
    nosPackageUrls: outputs.GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigNosPackageUrl[];
}

export interface GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigBlock {
    blockId: string;
    nodes: outputs.GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigBlockNode[];
}

export interface GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigBlockNode {
    cvmIp: string;
    cvmVlanId: number;
    fcImagedNodeUuid: string;
    hardwareAttributesOverride: {[key: string]: string};
    hypervisor: string;
    hypervisorHostname: string;
    hypervisorIp: string;
    imageNow: boolean;
    ipmiIp: string;
    ipv6Address: string;
    nodePosition: string;
    nodeSerial: string;
}

export interface GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigCluster {
    clusterExternalIp: string;
    clusterInitNow: boolean;
    clusterInitSuccessful: boolean;
    clusterMembers: string[];
    clusterName: string;
    cvmDnsServers: string;
    cvmNtpServers: string;
    redundancyFactor: number;
    timezone: string;
}

export interface GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigHypervisorIso {
    hypervisorType: string;
    sha256sum: string;
    url: string;
}

export interface GetFoundationCentralImagedClustersListImagedClusterFoundationInitConfigNosPackageUrl {
    sha256sum: string;
    url: string;
}

export interface GetFoundationCentralImagedClustersListMetadata {
    length: number;
    offset: number;
    totalMatches: number;
}

export interface GetFoundationCentralImagedNodesListFilters {
    nodeState?: string;
}

export interface GetFoundationCentralImagedNodesListImagedNode {
    aosVersion: string;
    apiKeyUuid: string;
    available: boolean;
    blockSerial: string;
    createdTimestamp: string;
    currentTime: string;
    cvmGateway: string;
    cvmIp: string;
    cvmIpv6: string;
    cvmNetmask: string;
    cvmUp: boolean;
    cvmUuid: string;
    cvmVlanId: number;
    foundationVersion: string;
    hardwareAttributes: {[key: string]: any};
    hypervisorGateway: string;
    hypervisorHostname: string;
    hypervisorIp: string;
    hypervisorNetmask: string;
    hypervisorType: string;
    hypervisorVersion: string;
    imagedClusterUuid: string;
    imagedNodeUuid: string;
    ipmiGateway: string;
    ipmiIp: string;
    ipmiNetmask: string;
    ipv6Interface: string;
    latestHbTsLists: string[];
    model: string;
    nodePosition: string;
    nodeSerial: string;
    nodeState: string;
    nodeType: string;
    objectVersion: number;
    supportedFeatures: string[];
}

export interface GetFoundationCentralImagedNodesListMetadata {
    length: number;
    offset: number;
    totalMatches: number;
}

export interface GetFoundationCentralListApiKeysApiKey {
    alias: string;
    apiKey: string;
    createdTimestamp: string;
    currentTime: string;
    keyUuid: string;
}

export interface GetFoundationCentralListApiKeysMetadata {
    length: number;
    offset: number;
    totalMatches: number;
}

export interface GetFoundationDiscoverNodesEntity {
    blockId: string;
    chassisN: number;
    model: string;
    nodes: outputs.GetFoundationDiscoverNodesEntityNode[];
}

export interface GetFoundationDiscoverNodesEntityNode {
    clusterId: string;
    configured: boolean;
    currentCvmVlanTag: string;
    currentNetworkInterface: string;
    foundationVersion: string;
    hypervisor: string;
    hypervisorVersion: string;
    ipv6Address: string;
    model: string;
    nodePosition: string;
    nodeSerial: string;
    nodeUuid: string;
    nosVersion: string;
    svmIp: string;
}

export interface GetFoundationHypervisorIsosEsx {
    filename: string;
    supported: boolean;
}

export interface GetFoundationHypervisorIsosHyperv {
    filename: string;
    supported: boolean;
}

export interface GetFoundationHypervisorIsosKvm {
    filename: string;
    supported: boolean;
}

export interface GetFoundationHypervisorIsosLinux {
    filename: string;
    supported: boolean;
}

export interface GetFoundationHypervisorIsosXen {
    filename: string;
    supported: boolean;
}

export interface GetFoundationNodeNetworkDetailsNode {
    cvmGateway: string;
    cvmIp: string;
    cvmNetmask: string;
    cvmVlanId: string;
    error: string;
    hypervisorGateway: string;
    hypervisorHostname: string;
    hypervisorIp: string;
    hypervisorNetmask: string;
    ipmiGateway: string;
    ipmiIp: string;
    ipmiNetmask: string;
    ipv6Address: string;
    nodeSerial: string;
}

export interface GetHostCategory {
    name: string;
    value: string;
}

export interface GetHostGpuList {
    assignable: boolean;
    consumerReference: {[key: string]: string};
    deviceId: number;
    fraction: number;
    frameBufferSizeMib: number;
    guestDriverVersion: string;
    index: number;
    licenseLists: string[];
    maxResolution: string;
    mode: string;
    name: string;
    numVgpusAllocated: number;
    numVirtualDisplayHeads: number;
    numaNode: number;
    pciAddress: string;
    status: string;
    uuid: string;
    vendor: string;
}

export interface GetHostHostDisksReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetHostsEntity {
    /**
     * The API version.
     * * `gpuDriverVersion`: - Host GPU driver version.
     * * `failoverCluster`: - Hyper-V failover cluster.
     * * `ipmi`: - Host IPMI info.
     * * `cpuModel`: - Host CPU model.
     * * `hostNicsIdList`: - Host NICs.
     * * `numCpuSockets`: - Number of CPU sockets.
     * * `windowsDomain`: - The name of the node to be renamed to during domain-join. If not given,a new name will be automatically assigned.
     * * `gpuList`: - List of GPUs on the host.
     * * `serialNumber`: - Node serial number.
     * * `cpuCapacityHz`: - Host CPU capacity.
     * * `memoryCapacityMib`: - Host memory capacity in MiB.
     * * `hostDisksReferenceList`: - The reference to a disk.
     * * `monitoringState`: - Host monitoring status.
     * * `hypervisor`: - Host Hypervisor information.
     * * `hostType`: - Host type.
     * * `numCpuCores`: - Number of CPU cores on Host.
     * * `rackableUnitReference`: - The reference to a rackable_unit.
     * * `controllerVm`: - Host controller vm information.
     * * `block`: - Host block config info.
     */
    apiVersion: string;
    block: {[key: string]: string};
    categories: outputs.GetHostsEntityCategory[];
    clusterReference: {[key: string]: string};
    controllerVm: {[key: string]: string};
    cpuCapacityHz: number;
    cpuModel: string;
    failoverCluster: {[key: string]: string};
    gpuDriverVersion: string;
    gpuLists: outputs.GetHostsEntityGpuList[];
    hostDisksReferenceLists: outputs.GetHostsEntityHostDisksReferenceList[];
    hostNicsIdLists: string[];
    hostType: string;
    hypervisor: {[key: string]: string};
    ipmi: {[key: string]: string};
    memoryCapacityMib: number;
    metadata: {[key: string]: string};
    monitoringState: string;
    name: string;
    numCpuCores: number;
    numCpuSockets: number;
    ownerReference: {[key: string]: string};
    projectReference: {[key: string]: string};
    rackableUnitReference: {[key: string]: string};
    serialNumber: string;
    windowsDomain: {[key: string]: string};
}

export interface GetHostsEntityCategory {
    name: string;
    value: string;
}

export interface GetHostsEntityGpuList {
    assignable: boolean;
    consumerReference: {[key: string]: string};
    deviceId: number;
    fraction: number;
    frameBufferSizeMib: number;
    guestDriverVersion: string;
    index: number;
    licenseLists: string[];
    maxResolution: string;
    mode: string;
    name: string;
    numVgpusAllocated: number;
    numVirtualDisplayHeads: number;
    numaNode: number;
    pciAddress: string;
    status: string;
    uuid: string;
    vendor: string;
}

export interface GetHostsEntityHostDisksReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetImageCategory {
    name: string;
    value: string;
}

export interface GetImageClusterReference {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetImageCurrentClusterReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetKarbonClusterEtcdNodePool {
    ahvConfigs: outputs.GetKarbonClusterEtcdNodePoolAhvConfig[];
    name: string;
    nodeOsVersion: string;
    nodes: outputs.GetKarbonClusterEtcdNodePoolNode[];
    numInstances: number;
}

export interface GetKarbonClusterEtcdNodePoolAhvConfig {
    cpu: number;
    diskMib: number;
    memoryMib: number;
    networkUuid: string;
    prismElementClusterUuid: string;
}

export interface GetKarbonClusterEtcdNodePoolNode {
    hostname: string;
    ipv4Address: string;
}

export interface GetKarbonClusterMasterNodePool {
    ahvConfigs: outputs.GetKarbonClusterMasterNodePoolAhvConfig[];
    name: string;
    nodeOsVersion: string;
    nodes: outputs.GetKarbonClusterMasterNodePoolNode[];
    numInstances: number;
}

export interface GetKarbonClusterMasterNodePoolAhvConfig {
    cpu: number;
    diskMib: number;
    memoryMib: number;
    networkUuid: string;
    prismElementClusterUuid: string;
}

export interface GetKarbonClusterMasterNodePoolNode {
    hostname: string;
    ipv4Address: string;
}

export interface GetKarbonClusterWorkerNodePool {
    ahvConfigs: outputs.GetKarbonClusterWorkerNodePoolAhvConfig[];
    name: string;
    nodeOsVersion: string;
    nodes: outputs.GetKarbonClusterWorkerNodePoolNode[];
    numInstances: number;
}

export interface GetKarbonClusterWorkerNodePoolAhvConfig {
    cpu: number;
    diskMib: number;
    memoryMib: number;
    networkUuid: string;
    prismElementClusterUuid: string;
}

export interface GetKarbonClusterWorkerNodePoolNode {
    hostname: string;
    ipv4Address: string;
}

export interface GetKarbonClustersCluster {
    deploymentType: string;
    etcdNodePools: outputs.GetKarbonClustersClusterEtcdNodePool[];
    kubeapiServerIpv4Address: string;
    masterNodePools: outputs.GetKarbonClustersClusterMasterNodePool[];
    name: string;
    status: string;
    uuid: string;
    version: string;
    workerNodePools: outputs.GetKarbonClustersClusterWorkerNodePool[];
}

export interface GetKarbonClustersClusterEtcdNodePool {
    ahvConfigs: outputs.GetKarbonClustersClusterEtcdNodePoolAhvConfig[];
    name: string;
    nodeOsVersion: string;
    nodes: outputs.GetKarbonClustersClusterEtcdNodePoolNode[];
    numInstances: number;
}

export interface GetKarbonClustersClusterEtcdNodePoolAhvConfig {
    cpu: number;
    diskMib: number;
    memoryMib: number;
    networkUuid: string;
    prismElementClusterUuid: string;
}

export interface GetKarbonClustersClusterEtcdNodePoolNode {
    hostname: string;
    ipv4Address: string;
}

export interface GetKarbonClustersClusterMasterNodePool {
    ahvConfigs: outputs.GetKarbonClustersClusterMasterNodePoolAhvConfig[];
    name: string;
    nodeOsVersion: string;
    nodes: outputs.GetKarbonClustersClusterMasterNodePoolNode[];
    numInstances: number;
}

export interface GetKarbonClustersClusterMasterNodePoolAhvConfig {
    cpu: number;
    diskMib: number;
    memoryMib: number;
    networkUuid: string;
    prismElementClusterUuid: string;
}

export interface GetKarbonClustersClusterMasterNodePoolNode {
    hostname: string;
    ipv4Address: string;
}

export interface GetKarbonClustersClusterWorkerNodePool {
    ahvConfigs: outputs.GetKarbonClustersClusterWorkerNodePoolAhvConfig[];
    name: string;
    nodeOsVersion: string;
    nodes: outputs.GetKarbonClustersClusterWorkerNodePoolNode[];
    numInstances: number;
}

export interface GetKarbonClustersClusterWorkerNodePoolAhvConfig {
    cpu: number;
    diskMib: number;
    memoryMib: number;
    networkUuid: string;
    prismElementClusterUuid: string;
}

export interface GetKarbonClustersClusterWorkerNodePoolNode {
    hostname: string;
    ipv4Address: string;
}

export interface GetKarbonPrivateRegistriesPrivateRegistry {
    endpoint: string;
    name: string;
    uuid: string;
}

export interface GetNetworkSecurityRuleAdRuleInboundAllowList {
    addressGroupInclusionLists: outputs.GetNetworkSecurityRuleAdRuleInboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.GetNetworkSecurityRuleAdRuleInboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.GetNetworkSecurityRuleAdRuleInboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.GetNetworkSecurityRuleAdRuleInboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.GetNetworkSecurityRuleAdRuleInboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetNetworkSecurityRuleAdRuleInboundAllowListUdpPortRangeList[];
}

export interface GetNetworkSecurityRuleAdRuleInboundAllowListAddressGroupInclusionList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetNetworkSecurityRuleAdRuleInboundAllowListFilterParam {
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleAdRuleInboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetNetworkSecurityRuleAdRuleInboundAllowListServiceGroupList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetNetworkSecurityRuleAdRuleInboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAdRuleInboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAdRuleOutboundAllowList {
    addressGroupInclusionLists: outputs.GetNetworkSecurityRuleAdRuleOutboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.GetNetworkSecurityRuleAdRuleOutboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.GetNetworkSecurityRuleAdRuleOutboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.GetNetworkSecurityRuleAdRuleOutboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.GetNetworkSecurityRuleAdRuleOutboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetNetworkSecurityRuleAdRuleOutboundAllowListUdpPortRangeList[];
}

export interface GetNetworkSecurityRuleAdRuleOutboundAllowListAddressGroupInclusionList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetNetworkSecurityRuleAdRuleOutboundAllowListFilterParam {
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleAdRuleOutboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetNetworkSecurityRuleAdRuleOutboundAllowListServiceGroupList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetNetworkSecurityRuleAdRuleOutboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAdRuleOutboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAdRuleTargetGroupFilterParam {
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleAppRuleInboundAllowList {
    addressGroupInclusionLists: outputs.GetNetworkSecurityRuleAppRuleInboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.GetNetworkSecurityRuleAppRuleInboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.GetNetworkSecurityRuleAppRuleInboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.GetNetworkSecurityRuleAppRuleInboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.GetNetworkSecurityRuleAppRuleInboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetNetworkSecurityRuleAppRuleInboundAllowListUdpPortRangeList[];
}

export interface GetNetworkSecurityRuleAppRuleInboundAllowListAddressGroupInclusionList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetNetworkSecurityRuleAppRuleInboundAllowListFilterParam {
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleAppRuleInboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetNetworkSecurityRuleAppRuleInboundAllowListServiceGroupList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetNetworkSecurityRuleAppRuleInboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAppRuleInboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAppRuleOutboundAllowList {
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.GetNetworkSecurityRuleAppRuleOutboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.GetNetworkSecurityRuleAppRuleOutboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    tcpPortRangeLists: outputs.GetNetworkSecurityRuleAppRuleOutboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetNetworkSecurityRuleAppRuleOutboundAllowListUdpPortRangeList[];
}

export interface GetNetworkSecurityRuleAppRuleOutboundAllowListFilterParam {
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleAppRuleOutboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetNetworkSecurityRuleAppRuleOutboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAppRuleOutboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleAppRuleTargetGroupFilterParam {
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleCategory {
    name: string;
    value: string;
}

export interface GetNetworkSecurityRuleIsolationRuleFirstEntityFilterParam {
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleIsolationRuleSecondEntityFilterParam {
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleQuarantineRuleInboundAllowList {
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.GetNetworkSecurityRuleQuarantineRuleInboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.GetNetworkSecurityRuleQuarantineRuleInboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    tcpPortRangeLists: outputs.GetNetworkSecurityRuleQuarantineRuleInboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetNetworkSecurityRuleQuarantineRuleInboundAllowListUdpPortRangeList[];
}

export interface GetNetworkSecurityRuleQuarantineRuleInboundAllowListFilterParam {
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleQuarantineRuleInboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetNetworkSecurityRuleQuarantineRuleInboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleQuarantineRuleInboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleQuarantineRuleOutboundAllowList {
    addressGroupInclusionLists: outputs.GetNetworkSecurityRuleQuarantineRuleOutboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.GetNetworkSecurityRuleQuarantineRuleOutboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.GetNetworkSecurityRuleQuarantineRuleOutboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.GetNetworkSecurityRuleQuarantineRuleOutboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.GetNetworkSecurityRuleQuarantineRuleOutboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetNetworkSecurityRuleQuarantineRuleOutboundAllowListUdpPortRangeList[];
}

export interface GetNetworkSecurityRuleQuarantineRuleOutboundAllowListAddressGroupInclusionList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetNetworkSecurityRuleQuarantineRuleOutboundAllowListFilterParam {
    name: string;
    values: string[];
}

export interface GetNetworkSecurityRuleQuarantineRuleOutboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetNetworkSecurityRuleQuarantineRuleOutboundAllowListServiceGroupList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetNetworkSecurityRuleQuarantineRuleOutboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleQuarantineRuleOutboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetNetworkSecurityRuleQuarantineRuleTargetGroupFilterParam {
    name: string;
    values: string[];
}

export interface GetPbrSpec {
    /**
     * The name of the PBR
     */
    name: string;
    /**
     * PBR resources status
     */
    resources: outputs.GetPbrSpecResource[];
}

export interface GetPbrSpecResource {
    /**
     * Routing policy action
     */
    actions: outputs.GetPbrSpecResourceAction[];
    /**
     * destination address of an IP.
     */
    destinations: outputs.GetPbrSpecResourceDestination[];
    /**
     * Policy in reverse direction.
     */
    isBidirectional: boolean;
    /**
     * priority of routing policy
     */
    priority: number;
    /**
     * Routing policy IP protocol parameters
     */
    protocolParameters: outputs.GetPbrSpecResourceProtocolParameter[];
    /**
     * Protocol type of routing policy
     */
    protocolType: string;
    /**
     * source address of an IP.
     */
    sources: outputs.GetPbrSpecResourceSource[];
    /**
     * Reference to VPC
     */
    vpcReference: {[key: string]: string};
}

export interface GetPbrSpecResourceAction {
    /**
     * Routing policy action
     */
    action: string;
    serviceIpLists: string[];
}

export interface GetPbrSpecResourceDestination {
    addressType: string;
    prefixLength?: number;
    subnetIp?: string;
}

export interface GetPbrSpecResourceProtocolParameter {
    icmps: outputs.GetPbrSpecResourceProtocolParameterIcmp[];
    protocolNumber: number;
    tcps: outputs.GetPbrSpecResourceProtocolParameterTcp[];
    udps: outputs.GetPbrSpecResourceProtocolParameterUdp[];
}

export interface GetPbrSpecResourceProtocolParameterIcmp {
    icmpCode: number;
    icmpType: number;
}

export interface GetPbrSpecResourceProtocolParameterTcp {
    destinationPortRangeLists: outputs.GetPbrSpecResourceProtocolParameterTcpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrSpecResourceProtocolParameterTcpSourcePortRangeList[];
}

export interface GetPbrSpecResourceProtocolParameterTcpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrSpecResourceProtocolParameterTcpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrSpecResourceProtocolParameterUdp {
    destinationPortRangeLists: outputs.GetPbrSpecResourceProtocolParameterUdpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrSpecResourceProtocolParameterUdpSourcePortRangeList[];
}

export interface GetPbrSpecResourceProtocolParameterUdpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrSpecResourceProtocolParameterUdpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrSpecResourceSource {
    addressType: string;
    prefixLength?: number;
    subnetIp?: string;
}

export interface GetPbrStatus {
    /**
     * Execution Context of PBR.
     */
    executionContexts: outputs.GetPbrStatusExecutionContext[];
    /**
     * The name of the PBR
     */
    name: string;
    /**
     * PBR resources status
     */
    resources: outputs.GetPbrStatusResource[];
    /**
     * The state of the PBR
     */
    state: string;
}

export interface GetPbrStatusExecutionContext {
    taskUuids: string[];
}

export interface GetPbrStatusResource {
    /**
     * Routing policy action
     */
    actions: outputs.GetPbrStatusResourceAction[];
    /**
     * destination address of an IP.
     */
    destinations: outputs.GetPbrStatusResourceDestination[];
    /**
     * Policy in reverse direction.
     */
    isBidirectional: boolean;
    /**
     * priority of routing policy
     */
    priority: number;
    /**
     * Routing policy IP protocol parameters
     */
    protocolParameters: outputs.GetPbrStatusResourceProtocolParameter[];
    /**
     * Protocol type of routing policy
     */
    protocolType: string;
    routingPolicyCounters: outputs.GetPbrStatusResourceRoutingPolicyCounter[];
    /**
     * source address of an IP.
     */
    sources: outputs.GetPbrStatusResourceSource[];
    /**
     * Reference to VPC
     */
    vpcReference: {[key: string]: string};
}

export interface GetPbrStatusResourceAction {
    /**
     * Routing policy action
     */
    action: string;
    serviceIpLists: string[];
}

export interface GetPbrStatusResourceDestination {
    addressType: string;
    prefixLength?: number;
    subnetIp?: string;
}

export interface GetPbrStatusResourceProtocolParameter {
    icmps: outputs.GetPbrStatusResourceProtocolParameterIcmp[];
    protocolNumber: number;
    tcps: outputs.GetPbrStatusResourceProtocolParameterTcp[];
    udps: outputs.GetPbrStatusResourceProtocolParameterUdp[];
}

export interface GetPbrStatusResourceProtocolParameterIcmp {
    icmpCode: number;
    icmpType: number;
}

export interface GetPbrStatusResourceProtocolParameterTcp {
    destinationPortRangeLists: outputs.GetPbrStatusResourceProtocolParameterTcpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrStatusResourceProtocolParameterTcpSourcePortRangeList[];
}

export interface GetPbrStatusResourceProtocolParameterTcpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrStatusResourceProtocolParameterTcpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrStatusResourceProtocolParameterUdp {
    destinationPortRangeLists: outputs.GetPbrStatusResourceProtocolParameterUdpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrStatusResourceProtocolParameterUdpSourcePortRangeList[];
}

export interface GetPbrStatusResourceProtocolParameterUdpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrStatusResourceProtocolParameterUdpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrStatusResourceRoutingPolicyCounter {
    byteCount: number;
    packetCount: number;
}

export interface GetPbrStatusResourceSource {
    addressType: string;
    prefixLength?: number;
    subnetIp?: string;
}

export interface GetPbrsEntity {
    metadata: {[key: string]: string};
    /**
     * PBR spec
     */
    specs: outputs.GetPbrsEntitySpec[];
    /**
     * PBR output status
     */
    statuses: outputs.GetPbrsEntityStatus[];
}

export interface GetPbrsEntitySpec {
    /**
     * The name of the PBR
     */
    name: string;
    /**
     * PBR resources status
     */
    resources: outputs.GetPbrsEntitySpecResource[];
}

export interface GetPbrsEntitySpecResource {
    /**
     * Routing policy action
     */
    actions: outputs.GetPbrsEntitySpecResourceAction[];
    /**
     * destination address of an IP.
     */
    destinations: outputs.GetPbrsEntitySpecResourceDestination[];
    /**
     * Policy in reverse direction.
     */
    isBidirectional: boolean;
    /**
     * priority of routing policy
     */
    priority: number;
    /**
     * Routing policy IP protocol parameters
     */
    protocolParameters: outputs.GetPbrsEntitySpecResourceProtocolParameter[];
    /**
     * Protocol type of routing policy
     */
    protocolType: string;
    /**
     * source address of an IP.
     */
    sources: outputs.GetPbrsEntitySpecResourceSource[];
    /**
     * Reference to VPC
     */
    vpcReference: {[key: string]: string};
}

export interface GetPbrsEntitySpecResourceAction {
    /**
     * Routing policy action
     */
    action: string;
    serviceIpLists: string[];
}

export interface GetPbrsEntitySpecResourceDestination {
    addressType: string;
    prefixLength?: number;
    subnetIp?: string;
}

export interface GetPbrsEntitySpecResourceProtocolParameter {
    icmps: outputs.GetPbrsEntitySpecResourceProtocolParameterIcmp[];
    protocolNumber: number;
    tcps: outputs.GetPbrsEntitySpecResourceProtocolParameterTcp[];
    udps: outputs.GetPbrsEntitySpecResourceProtocolParameterUdp[];
}

export interface GetPbrsEntitySpecResourceProtocolParameterIcmp {
    icmpCode: number;
    icmpType: number;
}

export interface GetPbrsEntitySpecResourceProtocolParameterTcp {
    destinationPortRangeLists: outputs.GetPbrsEntitySpecResourceProtocolParameterTcpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrsEntitySpecResourceProtocolParameterTcpSourcePortRangeList[];
}

export interface GetPbrsEntitySpecResourceProtocolParameterTcpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntitySpecResourceProtocolParameterTcpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntitySpecResourceProtocolParameterUdp {
    destinationPortRangeLists: outputs.GetPbrsEntitySpecResourceProtocolParameterUdpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrsEntitySpecResourceProtocolParameterUdpSourcePortRangeList[];
}

export interface GetPbrsEntitySpecResourceProtocolParameterUdpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntitySpecResourceProtocolParameterUdpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntitySpecResourceSource {
    addressType: string;
    prefixLength?: number;
    subnetIp?: string;
}

export interface GetPbrsEntityStatus {
    /**
     * Execution Context of PBR.
     */
    executionContexts: outputs.GetPbrsEntityStatusExecutionContext[];
    /**
     * The name of the PBR
     */
    name: string;
    /**
     * PBR resources status
     */
    resources: outputs.GetPbrsEntityStatusResource[];
    /**
     * The state of the PBR
     */
    state: string;
}

export interface GetPbrsEntityStatusExecutionContext {
    taskUuids: string[];
}

export interface GetPbrsEntityStatusResource {
    /**
     * Routing policy action
     */
    actions: outputs.GetPbrsEntityStatusResourceAction[];
    /**
     * destination address of an IP.
     */
    destinations: outputs.GetPbrsEntityStatusResourceDestination[];
    /**
     * Policy in reverse direction.
     */
    isBidirectional: boolean;
    /**
     * priority of routing policy
     */
    priority: number;
    /**
     * Routing policy IP protocol parameters
     */
    protocolParameters: outputs.GetPbrsEntityStatusResourceProtocolParameter[];
    /**
     * Protocol type of routing policy
     */
    protocolType: string;
    routingPolicyCounters: outputs.GetPbrsEntityStatusResourceRoutingPolicyCounter[];
    /**
     * source address of an IP.
     */
    sources: outputs.GetPbrsEntityStatusResourceSource[];
    /**
     * Reference to VPC
     */
    vpcReference: {[key: string]: string};
}

export interface GetPbrsEntityStatusResourceAction {
    /**
     * Routing policy action
     */
    action: string;
    serviceIpLists: string[];
}

export interface GetPbrsEntityStatusResourceDestination {
    addressType: string;
    prefixLength?: number;
    subnetIp?: string;
}

export interface GetPbrsEntityStatusResourceProtocolParameter {
    icmps: outputs.GetPbrsEntityStatusResourceProtocolParameterIcmp[];
    protocolNumber: number;
    tcps: outputs.GetPbrsEntityStatusResourceProtocolParameterTcp[];
    udps: outputs.GetPbrsEntityStatusResourceProtocolParameterUdp[];
}

export interface GetPbrsEntityStatusResourceProtocolParameterIcmp {
    icmpCode: number;
    icmpType: number;
}

export interface GetPbrsEntityStatusResourceProtocolParameterTcp {
    destinationPortRangeLists: outputs.GetPbrsEntityStatusResourceProtocolParameterTcpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrsEntityStatusResourceProtocolParameterTcpSourcePortRangeList[];
}

export interface GetPbrsEntityStatusResourceProtocolParameterTcpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntityStatusResourceProtocolParameterTcpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntityStatusResourceProtocolParameterUdp {
    destinationPortRangeLists: outputs.GetPbrsEntityStatusResourceProtocolParameterUdpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.GetPbrsEntityStatusResourceProtocolParameterUdpSourcePortRangeList[];
}

export interface GetPbrsEntityStatusResourceProtocolParameterUdpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntityStatusResourceProtocolParameterUdpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetPbrsEntityStatusResourceRoutingPolicyCounter {
    byteCount: number;
    packetCount: number;
}

export interface GetPbrsEntityStatusResourceSource {
    addressType: string;
    prefixLength?: number;
    subnetIp?: string;
}

export interface GetPbrsMetadata {
    filter: string;
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
    totalMatches: number;
}

export interface GetPermissionCategory {
    /**
     * the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetPermissionField {
    fieldMode: string;
    fieldNameLists: string[];
}

export interface GetPermissionsEntity {
    apiVersion: string;
    categories: outputs.GetPermissionsEntityCategory[];
    description: string;
    fields: outputs.GetPermissionsEntityField[];
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    metadata: {[key: string]: string};
    /**
     * the name.
     */
    name: string;
    operation: string;
    ownerReference: {[key: string]: string};
    projectReference: {[key: string]: string};
    state: string;
}

export interface GetPermissionsEntityCategory {
    /**
     * the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetPermissionsEntityField {
    fieldMode: string;
    fieldNameLists: string[];
}

export interface GetPermissionsMetadata {
    filter: string;
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetProjectAccountReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectCategory {
    /**
     * the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetProjectEnvironmentReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectExternalNetworkList {
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectExternalUserGroupReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectResourceDomain {
    resources: outputs.GetProjectResourceDomainResource[];
}

export interface GetProjectResourceDomainResource {
    limit: number;
    resourceType: string;
    units: string;
    /**
     * value of the key.
     */
    value: number;
}

export interface GetProjectSubnetReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectUserReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectsEntity {
    /**
     * List of accounts associated with the project.
     * * `account_reference_list.#.kind` - The kind name. Default value is `account`
     * * `account_reference_list.#.uuid` - The UUID of an account.
     * * `account_reference_list.#.name` - The name of an account.
     */
    accountReferenceLists: outputs.GetProjectsEntityAccountReferenceList[];
    apiVersion: string;
    categories: outputs.GetProjectsEntityCategory[];
    /**
     * Reference to a subnet.
     * * `default_subnet_reference.kind` - The kind name. Default value is `subnet`
     * * `default_subnet_reference.uuid` - The UUID of a subnet.
     * * `default_subnet_reference.name` - The name of a subnet.
     */
    defaultSubnetReference: {[key: string]: string};
    description: string;
    /**
     * List of environments associated with the project.
     * * `environment_reference_list.#.kind` - The kind name. Default value is `environment`
     * * `environment_reference_list.#.uuid` - The UUID of an environment.
     * * `environment_reference_list.#.name` - The name of an environment.
     */
    environmentReferenceLists: outputs.GetProjectsEntityEnvironmentReferenceList[];
    /**
     * List of external networks associated with the project.
     * * `external_network_list.#.uuid` - The UUID of a network.
     * * `external_network_list.#.name` - The name of a network.
     */
    externalNetworkLists: outputs.GetProjectsEntityExternalNetworkList[];
    /**
     * List of directory service user groups. These groups are not managed by Nutanix.
     * * `external_user_group_reference_list.#.kind` - The kind name. Default value is `userGroup`
     * * `external_user_group_reference_list.#.uuid` - The UUID of a userGroup
     * * `external_user_group_reference_list.#.name` - The name of a user_group
     */
    externalUserGroupReferenceLists: outputs.GetProjectsEntityExternalUserGroupReferenceList[];
    isDefault: boolean;
    metadata: {[key: string]: string};
    /**
     * (Optional) the name.
     */
    name: string;
    ownerReference: {[key: string]: string};
    projectReference: {[key: string]: string};
    resourceDomains: outputs.GetProjectsEntityResourceDomain[];
    state: string;
    /**
     * List of subnets for the project.
     * * `subnet_reference_list.#.kind` - The kind name. Default value is `subnet`
     * * `subnet_reference_list.#.uuid` - The UUID of a subnet
     * * `subnet_reference_list.#.name` - The name of a subnet.
     */
    subnetReferenceLists: outputs.GetProjectsEntitySubnetReferenceList[];
    /**
     * List of users in the project.
     * * `user_reference_list.#.kind` - The kind name. Default value is `user`
     * * `user_reference_list.#.uuid` - The UUID of a user
     * * `user_reference_list.#.name` - The name of a user.
     */
    userReferenceLists: outputs.GetProjectsEntityUserReferenceList[];
}

export interface GetProjectsEntityAccountReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectsEntityCategory {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetProjectsEntityEnvironmentReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectsEntityExternalNetworkList {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectsEntityExternalUserGroupReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectsEntityResourceDomain {
    resources: outputs.GetProjectsEntityResourceDomainResource[];
}

export interface GetProjectsEntityResourceDomainResource {
    limit: number;
    resourceType: string;
    units: string;
    /**
     * value of the key.
     */
    value: number;
}

export interface GetProjectsEntitySubnetReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProjectsEntityUserReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProtectionRuleAvailabilityZoneConnectivityList {
    destinationAvailabilityZoneIndex: number;
    snapshotScheduleLists: outputs.GetProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleList[];
    sourceAvailabilityZoneIndex: number;
}

export interface GetProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleList {
    autoSuspendTimeoutSecs: number;
    localSnapshotRetentionPolicies: outputs.GetProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicy[];
    recoveryPointObjectiveSecs: number;
    remoteSnapshotRetentionPolicies: outputs.GetProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicy[];
    snapshotType: string;
}

export interface GetProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicy {
    numSnapshots: number;
    rollupRetentionPolicyMultiple: number;
    rollupRetentionPolicySnapshotIntervalType: string;
}

export interface GetProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicy {
    numSnapshots: number;
    rollupRetentionPolicyMultiple: number;
    rollupRetentionPolicySnapshotIntervalType: string;
}

export interface GetProtectionRuleCategory {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetProtectionRuleCategoryFilter {
    kindLists: string[];
    params: outputs.GetProtectionRuleCategoryFilterParam[];
    type: string;
}

export interface GetProtectionRuleCategoryFilterParam {
    /**
     * (Optional) the name.
     */
    name: string;
    values: string[];
}

export interface GetProtectionRuleOrderedAvailabilityZoneList {
    availabilityZoneUrl: string;
    clusterUuid: string;
}

export interface GetProtectionRuleOwnerReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProtectionRuleProjectReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProtectionRulesEntity {
    apiVersion: string;
    /**
     * (Required) This encodes the datapipes between various availability zones and\nthe backup policy of the pipes.
     * * `availability_zone_connectivity_list.destination_availability_zone_index` - (Optional/Computed) Index of the availability zone.
     * * `availability_zone_connectivity_list.source_availability_zone_index` - (Optional/Computed) Index of the availability zone.
     * * `availability_zone_connectivity_list.snapshot_schedule_list` - (Optional/Computed) Snapshot schedules for the pair of the availability zones.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.recovery_point_objective_secs` - (Required) "A recovery point objective (RPO) is the maximum acceptable amount of data loss.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.local_snapshot_retention_policy` - (Optional/Computed) This describes the snapshot retention policy for this availability zone.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.local_snapshot_retention_policy.0.num_snapshots` - (Optional/Computed) Number of snapshots need to be retained.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.local_snapshot_retention_policy.0.rollup_retention_policy_multiple` - (Optional/Computed) Multiplier to 'snapshot_interval_type'.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.local_snapshot_retention_policy.0.rollup_retention_policy_snapshot_interval_type` - (Optional/Computed)
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.auto_suspend_timeout_secs` - (Optional/Computed) Auto suspend timeout in case of connection failure between the sites.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.snapshot_type` - (Optional/Computed) Crash consistent or Application Consistent snapshot.
     * * `availability_zone_connectivity_list.snapshot_schedule_list.#.remote_snapshot_retention_policy` - (Optional/Computed) This describes the snapshot retention policy for this availability zone.
     */
    availabilityZoneConnectivityLists: outputs.GetProtectionRulesEntityAvailabilityZoneConnectivityList[];
    categories: outputs.GetProtectionRulesEntityCategory[];
    /**
     * (Optional/Computed)
     * * `category_filter.0.type` - (Optional/Computed) The type of the filter being used.
     * * `category_filter.0.kind_list` - (Optional/Computed) List of kinds associated with this filter.
     * * `category_filter.0.params` - (Optional/Computed) A list of category key and list of values.
     */
    categoryFilters: outputs.GetProtectionRulesEntityCategoryFilter[];
    description: string;
    metadata: {[key: string]: string};
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) A list of availability zones, each of which, receives a replica\nof the data for the entities protected by this protection rule.
     * * `ordered_availability_zone_list.#.cluster_uuid` - (Optional/Computed) UUID of specific cluster to which we will be replicating.
     * * `ordered_availability_zone_list.#.availability_zone_url` - (Optional/Computed) The FQDN or IP address of the availability zone.
     */
    orderedAvailabilityZoneLists: outputs.GetProtectionRulesEntityOrderedAvailabilityZoneList[];
    ownerReferences: outputs.GetProtectionRulesEntityOwnerReference[];
    projectReferences: outputs.GetProtectionRulesEntityProjectReference[];
    startTime: string;
    state: string;
}

export interface GetProtectionRulesEntityAvailabilityZoneConnectivityList {
    destinationAvailabilityZoneIndex: number;
    snapshotScheduleLists: outputs.GetProtectionRulesEntityAvailabilityZoneConnectivityListSnapshotScheduleList[];
    sourceAvailabilityZoneIndex: number;
}

export interface GetProtectionRulesEntityAvailabilityZoneConnectivityListSnapshotScheduleList {
    autoSuspendTimeoutSecs: number;
    localSnapshotRetentionPolicies: outputs.GetProtectionRulesEntityAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicy[];
    recoveryPointObjectiveSecs: number;
    remoteSnapshotRetentionPolicies: outputs.GetProtectionRulesEntityAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicy[];
    snapshotType: string;
}

export interface GetProtectionRulesEntityAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicy {
    numSnapshots: number;
    rollupRetentionPolicyMultiple: number;
    rollupRetentionPolicySnapshotIntervalType: string;
}

export interface GetProtectionRulesEntityAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicy {
    numSnapshots: number;
    rollupRetentionPolicyMultiple: number;
    rollupRetentionPolicySnapshotIntervalType: string;
}

export interface GetProtectionRulesEntityCategory {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetProtectionRulesEntityCategoryFilter {
    kindLists: string[];
    params: outputs.GetProtectionRulesEntityCategoryFilterParam[];
    type: string;
}

export interface GetProtectionRulesEntityCategoryFilterParam {
    /**
     * (Optional) the name.
     */
    name: string;
    values: string[];
}

export interface GetProtectionRulesEntityOrderedAvailabilityZoneList {
    availabilityZoneUrl: string;
    clusterUuid: string;
}

export interface GetProtectionRulesEntityOwnerReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetProtectionRulesEntityProjectReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanCategory {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetRecoveryPlanOwnerReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameter {
    floatingIpAssignmentLists: outputs.GetRecoveryPlanParameterFloatingIpAssignmentList[];
    networkMappingLists: outputs.GetRecoveryPlanParameterNetworkMappingList[];
}

export interface GetRecoveryPlanParameterFloatingIpAssignmentList {
    availabilityZoneUrl: string;
    vmIpAssignmentLists: outputs.GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentList[];
}

export interface GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentList {
    recoveryFloatingIpConfigs: outputs.GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfig[];
    testFloatingIpConfigs: outputs.GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfig[];
    vmNicInformations: outputs.GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListVmNicInformation[];
    vmReferences: outputs.GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListVmReference[];
}

export interface GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfig {
    ip: string;
    shouldAllocateDynamically: boolean;
}

export interface GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfig {
    ip: string;
    shouldAllocateDynamically: boolean;
}

export interface GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListVmNicInformation {
    ip: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterFloatingIpAssignmentListVmIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterNetworkMappingList {
    areNetworksStretched: boolean;
    availabilityZoneNetworkMappingLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingList[];
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingList {
    availabilityZoneUrl: string;
    clusterReferenceLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceList[];
    recoveryIpAssignmentLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentList[];
    recoveryNetworks: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetwork[];
    testIpAssignmentLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentList[];
    testNetworks: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetwork[];
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentList {
    ipConfigLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigList[];
    vmReference: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReference;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigList {
    ipAddress: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetwork {
    /**
     * (Optional) the name.
     */
    name: string;
    subnetLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetList[];
    useVpcReference: boolean;
    virtualNetworkReferences: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReference[];
    vpcReferences: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReference[];
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetList {
    externalConnectivityState: string;
    gatewayIp: string;
    prefixLength: number;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentList {
    ipConfigLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigList[];
    vmReference: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReference;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigList {
    ipAddress: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetwork {
    /**
     * (Optional) the name.
     */
    name: string;
    subnetLists: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetList[];
    useVpcReference: boolean;
    virtualNetworkReferences: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReference[];
    vpcReferences: outputs.GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReference[];
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetList {
    externalConnectivityState: string;
    gatewayIp: string;
    prefixLength: number;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanProjectReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlanStageList {
    delayTimeSecs: number;
    stageUuid: string;
    stageWorks: outputs.GetRecoveryPlanStageListStageWork[];
}

export interface GetRecoveryPlanStageListStageWork {
    recoverEntities: outputs.GetRecoveryPlanStageListStageWorkRecoverEntity[];
}

export interface GetRecoveryPlanStageListStageWorkRecoverEntity {
    entityInfoLists: outputs.GetRecoveryPlanStageListStageWorkRecoverEntityEntityInfoList[];
}

export interface GetRecoveryPlanStageListStageWorkRecoverEntityEntityInfoList {
    anyEntityReferenceKind: string;
    anyEntityReferenceName: string;
    anyEntityReferenceUuid: string;
    categories: outputs.GetRecoveryPlanStageListStageWorkRecoverEntityEntityInfoListCategory[];
    scriptLists: outputs.GetRecoveryPlanStageListStageWorkRecoverEntityEntityInfoListScriptList[];
}

export interface GetRecoveryPlanStageListStageWorkRecoverEntityEntityInfoListCategory {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetRecoveryPlanStageListStageWorkRecoverEntityEntityInfoListScriptList {
    enableScriptExec: boolean;
    timeout: string;
}

export interface GetRecoveryPlansEntity {
    apiVersion: string;
    categories: outputs.GetRecoveryPlansEntityCategory[];
    description: string;
    metadata: {[key: string]: string};
    /**
     * (Optional) the name.
     */
    name: string;
    ownerReferences: outputs.GetRecoveryPlansEntityOwnerReference[];
    /**
     * (Required) Parameters for the Recovery Plan.
     * * `parameters.0.floating_ip_assignment_list` - (Optional/Computed) Floating IP assignment for VMs upon recovery in an Availability Zone. This is applicable only for the public cloud Availability Zones.
     * * `parameters.0.floating_ip_assignment_list.#.availability_zone_url` - (Required) URL of the Availability Zone.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list` - (Required) IP assignment for VMs upon recovery in the specified Availability Zone.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.test_floating_ip_config` - (Optional/Computed) Configuration for assigning floating IP to a VM on the execution of the Recovery Plan.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.test_floating_ip_config.ip` - (Optional/Computed) IP to be assigned to VM, in case of failover.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.test_floating_ip_config.should_allocate_dynamically` - (Optional/Computed) Whether to allocate the floating IPs for the VMs dynamically.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.recovery_floating_ip_config` - (Optional/Computed) Configuration for assigning floating IP to a VM on the execution of the Recovery Plan.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.recovery_floating_ip_config.ip` - (Optional/Computed) IP to be assigned to VM, in case of failover.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.recovery_floating_ip_config.should_allocate_dynamically` - (Optional/Computed) Whether to allocate the floating IPs for the VMs dynamically.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_reference` - (Required) Reference to a vm.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_reference.kind` - (Required) The kind name.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_reference.uuid` - (Required) The uuid.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_nic_information` - (Required) Information about vnic to which floating IP has to be assigned.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_nic_information.ip` - (Optional/Computed) IP address associated with vnic for which floating IP has to be assigned on failover.
     * * `parameters.0.floating_ip_assignment_list.#.vm_ip_assignment_list.#.vm_nic_information.uuid` - (Required) Uuid of the vnic of the VM to which floating IP has to be assigned.
     * * `parameters.0.network_mapping_list` - (Required) Network mappings to be used for the Recovery Plan. This will be represented by array of network mappings across the Availability Zones.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list` - (Required) Mapping of networks across the Availability Zones.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.availability_zone_url` - (Optional/Computed) URL of the Availability Zone.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network` - (Optional/Computed) Network configuration to be used for performing network mapping and IP preservation/mapping on Recovery Plan execution.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.virtual_network_reference` - (Optional/Computed) The reference to a virtual_network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.virtual_network_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.virtual_network_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.virtual_network_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.use_vpc_reference` - (Optional/Computed) The reference to a VPC.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.vpc_reference` - (Optional/Computed) The reference to a VPC.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.vpc_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.vpc_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.vpc_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.subnet_list` - (Optional/Computed) List of subnets for the network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.subnet_list.#.gateway_ip` - (Required) Gateway IP address for the subnet.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.subnet_list.#.external_connectivity_state` - (Optional/Computed) External connectivity state of the subnet. This is applicable only for the subnet to be created in public cloud Availability Zone.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.subnet_list.#.prefix_length` - (Required) Prefix length for the subnet.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_network.0.name` - (Required) Name of the network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network` - (Optional/Computed) Network configuration to be used for performing network mapping and IP preservation/mapping on Recovery Plan execution.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.virtual_network_reference` - (Optional/Computed) The reference to a virtual_network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.virtual_network_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.virtual_network_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.virtual_network_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.subnet_list` - (Optional/Computed) List of subnets for the network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.subnet_list.#.gateway_ip` - (Required) Gateway IP address for the subnet.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.subnet_list.#.external_connectivity_state` - (Optional/Computed) External connectivity state of the subnet. This is applicable only for the subnet to be created in public cloud Availability Zone.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.subnet_list.#.prefix_length` - (Required) Prefix length for the subnet.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_network.0.name` - (Required) Name of the network.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list` - (Optional/Computed) Static IP configuration for the VMs to be applied post recovery in the recovery network for migrate/ failover action on the Recovery Plan.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.vm_reference` - (Optional/Computed) The reference to a vm.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.vm_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.vm_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.vm_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.ip_config_list` - (Optional/Computed) List of IP configurations for a VM.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.recovery_ip_assignment_list.0.ip_config_list.#.ip_address` - (Required) IP address.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list` - (Optional/Computed) Static IP configuration for the VMs to be applied post recovery in the test network for test failover action on the Recovery Plan.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.vm_reference` - (Optional/Computed) The reference to a vm.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.vm_reference.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.vm_reference.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.vm_reference.name` - (Optional/Computed) The name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.ip_config_list` - (Optional/Computed) List of IP configurations for a VM.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.ip_config_list.#.ip_address` - (Required) IP address.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.cluster_reference_list` - (Optional/Computed) The clusters where the recovery and test networks reside. This is required to specify network mapping across clusters for a Recovery Plan created to handle failover within the same Availability Zone.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.cluster_reference_list.0.kind` - (Optional/Computed) The kind name.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.cluster_reference_list.0.uuid` - (Optional/Computed) The uuid.
     * * `parameters.0.network_mapping_list.#.availability_zone_network_mapping_list.#.test_ip_assignment_list.0.name` - (Optional/Computed) The name.
     */
    parameters: outputs.GetRecoveryPlansEntityParameter[];
    projectReferences: outputs.GetRecoveryPlansEntityProjectReference[];
    /**
     * (Required) Input for the stages of the Recovery Plan. Each stage will perform a predefined type of task.
     * * `stage_list.stage_uuid` - (Optional/Computed) UUID of stage.
     * * `stage_list.delay_time_secs` - (Optional/Computed) Amount of time in seconds to delay the execution of next stage after execution of current stage.
     * * `stage_list.stage_work` - (Required) A stage specifies the work to be performed when the Recovery Plan is executed.
     * * `stage_list.stage_work.0.recover_entities` - (Optional/Computed) Information about entities to be recovered.
     * * `stage_list.stage_work.0.recover_entities.0.entity_info_list` - (Optional/Computed) Information about entities to be recovered as part of this stage. For VM, entity information will include set of scripts to be executed after recovery of VM. Only one of categories or anyEntityReference has to be provided.
     * * `stage_list.stage_work.0.recover_entities.0.entity_info_list.#.any_entity_reference_kind` - (Optional/Computed) Reference to a kind.
     * * `stage_list.stage_work.0.recover_entities.0.entity_info_list.#.any_entity_reference_uuid` - (Optional/Computed) Reference to a uuid.
     * * `stage_list.stage_work.0.recover_entities.0.entity_info_list.#.any_entity_reference_name` - (Optional/Computed) Reference to a name.
     * * `stage_list.stage_work.0.recover_entities.0.entity_info_list.#.categories` - (Optional/Computed)  Categories for filtering entities.
     */
    stageLists: outputs.GetRecoveryPlansEntityStageList[];
    state: string;
}

export interface GetRecoveryPlansEntityCategory {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetRecoveryPlansEntityOwnerReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameter {
    floatingIpAssignmentLists: outputs.GetRecoveryPlansEntityParameterFloatingIpAssignmentList[];
    networkMappingLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingList[];
}

export interface GetRecoveryPlansEntityParameterFloatingIpAssignmentList {
    availabilityZoneUrl: string;
    vmIpAssignmentLists: outputs.GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentList[];
}

export interface GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentList {
    recoveryFloatingIpConfigs: outputs.GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfig[];
    testFloatingIpConfigs: outputs.GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfig[];
    vmNicInformations: outputs.GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListVmNicInformation[];
    vmReferences: outputs.GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListVmReference[];
}

export interface GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfig {
    ip: string;
    shouldAllocateDynamically: boolean;
}

export interface GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfig {
    ip: string;
    shouldAllocateDynamically: boolean;
}

export interface GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListVmNicInformation {
    ip: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterFloatingIpAssignmentListVmIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingList {
    areNetworksStretched: boolean;
    availabilityZoneNetworkMappingLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingList[];
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingList {
    availabilityZoneUrl: string;
    clusterReferenceLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceList[];
    recoveryIpAssignmentLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentList[];
    recoveryNetworks: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetwork[];
    testIpAssignmentLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentList[];
    testNetworks: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetwork[];
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentList {
    ipConfigLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigList[];
    vmReference: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReference;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigList {
    ipAddress: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetwork {
    /**
     * (Optional) the name.
     */
    name: string;
    subnetLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetList[];
    useVpcReference: boolean;
    virtualNetworkReferences: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReference[];
    vpcReferences: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReference[];
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetList {
    externalConnectivityState: string;
    gatewayIp: string;
    prefixLength: number;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentList {
    ipConfigLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigList[];
    vmReference: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReference;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigList {
    ipAddress: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetwork {
    /**
     * (Optional) the name.
     */
    name: string;
    subnetLists: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetList[];
    useVpcReference: boolean;
    virtualNetworkReferences: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReference[];
    vpcReferences: outputs.GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReference[];
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetList {
    externalConnectivityState: string;
    gatewayIp: string;
    prefixLength: number;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityParameterNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityProjectReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface GetRecoveryPlansEntityStageList {
    delayTimeSecs: number;
    stageUuid: string;
    stageWorks: outputs.GetRecoveryPlansEntityStageListStageWork[];
}

export interface GetRecoveryPlansEntityStageListStageWork {
    recoverEntities: outputs.GetRecoveryPlansEntityStageListStageWorkRecoverEntity[];
}

export interface GetRecoveryPlansEntityStageListStageWorkRecoverEntity {
    entityInfoLists: outputs.GetRecoveryPlansEntityStageListStageWorkRecoverEntityEntityInfoList[];
}

export interface GetRecoveryPlansEntityStageListStageWorkRecoverEntityEntityInfoList {
    anyEntityReferenceKind: string;
    anyEntityReferenceName: string;
    anyEntityReferenceUuid: string;
    categories: outputs.GetRecoveryPlansEntityStageListStageWorkRecoverEntityEntityInfoListCategory[];
    scriptLists: outputs.GetRecoveryPlansEntityStageListStageWorkRecoverEntityEntityInfoListScriptList[];
}

export interface GetRecoveryPlansEntityStageListStageWorkRecoverEntityEntityInfoListCategory {
    /**
     * (Optional) the name.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface GetRecoveryPlansEntityStageListStageWorkRecoverEntityEntityInfoListScriptList {
    enableScriptExec: boolean;
    timeout: string;
}

export interface GetRoleCategory {
    name: string;
    value: string;
}

export interface GetRolePermissionReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetRolesEntity {
    /**
     * The version of the API.
     * * `state`: - The state of the role.
     */
    apiVersion: string;
    categories: outputs.GetRolesEntityCategory[];
    description: string;
    metadata: {[key: string]: string};
    name: string;
    ownerReference: {[key: string]: string};
    permissionReferenceLists: outputs.GetRolesEntityPermissionReferenceList[];
    projectReference: {[key: string]: string};
    roleId: string;
    state: string;
}

export interface GetRolesEntityCategory {
    name: string;
    value: string;
}

export interface GetRolesEntityPermissionReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetRolesMetadata {
    filter: string;
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetServiceGroupServiceList {
    icmpTypeCodeLists: outputs.GetServiceGroupServiceListIcmpTypeCodeList[];
    protocol: string;
    tcpPortRangeLists: outputs.GetServiceGroupServiceListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetServiceGroupServiceListUdpPortRangeList[];
}

export interface GetServiceGroupServiceListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetServiceGroupServiceListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetServiceGroupServiceListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetServiceGroupsEntity {
    associatedPoliciesLists: outputs.GetServiceGroupsEntityAssociatedPoliciesList[];
    serviceGroups: outputs.GetServiceGroupsEntityServiceGroup[];
    uuid: string;
}

export interface GetServiceGroupsEntityAssociatedPoliciesList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetServiceGroupsEntityServiceGroup {
    description: string;
    isSystemDefined: boolean;
    name: string;
    serviceLists: outputs.GetServiceGroupsEntityServiceGroupServiceList[];
}

export interface GetServiceGroupsEntityServiceGroupServiceList {
    icmpTypeCodeLists: outputs.GetServiceGroupsEntityServiceGroupServiceListIcmpTypeCodeList[];
    protocol: string;
    tcpPortRangeLists: outputs.GetServiceGroupsEntityServiceGroupServiceListTcpPortRangeList[];
    udpPortRangeLists: outputs.GetServiceGroupsEntityServiceGroupServiceListUdpPortRangeList[];
}

export interface GetServiceGroupsEntityServiceGroupServiceListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface GetServiceGroupsEntityServiceGroupServiceListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetServiceGroupsEntityServiceGroupServiceListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface GetServiceGroupsMetadata {
    filter: string;
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetStaticRoutesSpec {
    /**
     * vpc_route_table Name.
     */
    name: string;
    /**
     * VPC route table resources status
     */
    resources: outputs.GetStaticRoutesSpecResource[];
}

export interface GetStaticRoutesSpecResource {
    /**
     * default routes (present in spec resource)
     */
    defaultRouteNexthops: outputs.GetStaticRoutesSpecResourceDefaultRouteNexthop[];
    /**
     * list of static routes
     */
    staticRoutesLists: outputs.GetStaticRoutesSpecResourceStaticRoutesList[];
}

export interface GetStaticRoutesSpecResourceDefaultRouteNexthop {
    /**
     * The reference to a direct_connect_virtual_interface
     */
    directConnectVirtualInterfaceReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    localSubnetReference: {[key: string]: string};
    /**
     * The reference to a vpn_connection
     */
    vpnConnectionReference: {[key: string]: string};
}

export interface GetStaticRoutesSpecResourceStaticRoutesList {
    /**
     * destination ip address with prefix.
     */
    destination: string;
    /**
     * Targeted link to use as the nexthop in a route.
     */
    nexthops: outputs.GetStaticRoutesSpecResourceStaticRoutesListNexthop[];
}

export interface GetStaticRoutesSpecResourceStaticRoutesListNexthop {
    /**
     * The reference to a direct_connect_virtual_interface
     */
    directConnectVirtualInterfaceReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    localSubnetReference: {[key: string]: string};
    /**
     * The reference to a vpn_connection
     */
    vpnConnectionReference: {[key: string]: string};
}

export interface GetStaticRoutesStatus {
    /**
     * Execution Context of VPC.
     */
    executionContexts: outputs.GetStaticRoutesStatusExecutionContext[];
    /**
     * VPC route table resources status
     */
    resources: outputs.GetStaticRoutesStatusResource[];
    /**
     * The state of the vpc_route_table.
     */
    state: string;
}

export interface GetStaticRoutesStatusExecutionContext {
    taskUuids: string[];
}

export interface GetStaticRoutesStatusResource {
    /**
     * default route. (present in status resource only )
     */
    defaultRoutes: outputs.GetStaticRoutesStatusResourceDefaultRoute[];
    /**
     * list of dynamic routes (present in status resource only)
     */
    dynamicRoutesLists: outputs.GetStaticRoutesStatusResourceDynamicRoutesList[];
    /**
     * list of local routes (present in status resource only )
     */
    localRoutesLists: outputs.GetStaticRoutesStatusResourceLocalRoutesList[];
    /**
     * list of static routes
     */
    staticRoutesLists: outputs.GetStaticRoutesStatusResourceStaticRoutesList[];
}

export interface GetStaticRoutesStatusResourceDefaultRoute {
    /**
     * destination ip address with prefix.
     */
    destination: string;
    /**
     * Whether this route is currently active. Present in Status Resources.
     */
    isActive: boolean;
    /**
     * Targeted link to use as the nexthop in a route.
     */
    nexthops: outputs.GetStaticRoutesStatusResourceDefaultRouteNexthop[];
    /**
     * The preference value assigned to this route. A higher value means greater preference. Present in Status Resource.
     */
    priority: number;
}

export interface GetStaticRoutesStatusResourceDefaultRouteNexthop {
    /**
     * The reference to a direct_connect_virtual_interface
     */
    directConnectVirtualInterfaceReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    localSubnetReference: {[key: string]: string};
    nexthopIpAddress: string;
    /**
     * The reference to a vpn_connection
     */
    vpnConnectionReference: {[key: string]: string};
}

export interface GetStaticRoutesStatusResourceDynamicRoutesList {
    /**
     * destination ip address with prefix.
     */
    destination: string;
    /**
     * Whether this route is currently active. Present in Status Resources.
     */
    isActive: boolean;
    /**
     * Targeted link to use as the nexthop in a route.
     */
    nexthops: outputs.GetStaticRoutesStatusResourceDynamicRoutesListNexthop[];
    /**
     * The preference value assigned to this route. A higher value means greater preference. Present in Status Resource.
     */
    priority: number;
}

export interface GetStaticRoutesStatusResourceDynamicRoutesListNexthop {
    /**
     * The reference to a direct_connect_virtual_interface
     */
    directConnectVirtualInterfaceReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    localSubnetReference: {[key: string]: string};
    nexthopIpAddress: string;
    /**
     * The reference to a vpn_connection
     */
    vpnConnectionReference: {[key: string]: string};
}

export interface GetStaticRoutesStatusResourceLocalRoutesList {
    /**
     * destination ip address with prefix.
     */
    destination: string;
    /**
     * Whether this route is currently active. Present in Status Resources.
     */
    isActive: boolean;
    /**
     * Targeted link to use as the nexthop in a route.
     */
    nexthops: outputs.GetStaticRoutesStatusResourceLocalRoutesListNexthop[];
    /**
     * The preference value assigned to this route. A higher value means greater preference. Present in Status Resource.
     */
    priority: number;
}

export interface GetStaticRoutesStatusResourceLocalRoutesListNexthop {
    /**
     * The reference to a direct_connect_virtual_interface
     */
    directConnectVirtualInterfaceReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    localSubnetReference: {[key: string]: string};
    nexthopIpAddress: string;
    /**
     * The reference to a vpn_connection
     */
    vpnConnectionReference: {[key: string]: string};
}

export interface GetStaticRoutesStatusResourceStaticRoutesList {
    /**
     * destination ip address with prefix.
     */
    destination: string;
    /**
     * Whether this route is currently active. Present in Status Resources.
     */
    isActive: boolean;
    /**
     * Targeted link to use as the nexthop in a route.
     */
    nexthops: outputs.GetStaticRoutesStatusResourceStaticRoutesListNexthop[];
    /**
     * The preference value assigned to this route. A higher value means greater preference. Present in Status Resource.
     */
    priority: number;
}

export interface GetStaticRoutesStatusResourceStaticRoutesListNexthop {
    /**
     * The reference to a direct_connect_virtual_interface
     */
    directConnectVirtualInterfaceReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    externalSubnetReference: {[key: string]: string};
    /**
     * The reference to a subnet
     */
    localSubnetReference: {[key: string]: string};
    nexthopIpAddress: string;
    /**
     * The reference to a vpn_connection
     */
    vpnConnectionReference: {[key: string]: string};
}

export interface GetSubnetAdditionalFilter {
    name: string;
    values: string[];
}

export interface GetSubnetCategory {
    name: string;
    value: string;
}

export interface GetSubnetMessageList {
    details: {[key: string]: any};
    message: string;
    reason: string;
}

export interface GetSubnetsEntity {
    apiVersion: string;
    availabilityZoneReference: {[key: string]: string};
    categories: outputs.GetSubnetsEntityCategory[];
    clusterName: string;
    clusterReference: {[key: string]: string};
    clusterUuid: string;
    defaultGatewayIp: string;
    description: string;
    dhcpDomainNameServerLists: string[];
    dhcpDomainSearchLists: string[];
    dhcpOptions: {[key: string]: string};
    dhcpServerAddress: {[key: string]: string};
    dhcpServerAddressPort: number;
    enableNat: boolean;
    ipConfigPoolListRanges: string[];
    isExternal: boolean;
    messageLists: outputs.GetSubnetsEntityMessageList[];
    metadata: {[key: string]: string};
    name: string;
    networkFunctionChainReference: {[key: string]: string};
    ownerReference: {[key: string]: string};
    prefixLength: number;
    projectReference: {[key: string]: string};
    state: string;
    subnetId: string;
    subnetIp: string;
    subnetName: string;
    subnetType: string;
    vlanId: number;
    vpcReference: {[key: string]: string};
    vswitchName: string;
}

export interface GetSubnetsEntityCategory {
    name: string;
    value: string;
}

export interface GetSubnetsEntityMessageList {
    details: {[key: string]: any};
    message: string;
    reason: string;
}

export interface GetSubnetsMetadata {
    filter: string;
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetUserAccessControlPolicyReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetUserCategory {
    name: string;
    value: string;
}

export interface GetUserDirectoryServiceUser {
    defaultUserPrincipalName: string;
    directoryServiceReferences: outputs.GetUserDirectoryServiceUserDirectoryServiceReference[];
    userPrincipalName: string;
}

export interface GetUserDirectoryServiceUserDirectoryServiceReference {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetUserGroupAccessControlPolicyReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetUserGroupCategory {
    name: string;
    value: string;
}

export interface GetUserGroupDirectoryServiceUserGroup {
    defaultUserPrincipalName: string;
    directoryServiceReferences: outputs.GetUserGroupDirectoryServiceUserGroupDirectoryServiceReference[];
    distinguishedName: string;
}

export interface GetUserGroupDirectoryServiceUserGroupDirectoryServiceReference {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetUserGroupProjectReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetUserGroupsEntity {
    accessControlPolicyReferenceLists: outputs.GetUserGroupsEntityAccessControlPolicyReferenceList[];
    /**
     * The version of the API.
     * * `metadata`: - The user group kind metadata.
     * * `categories`: - The Categories for the user group.
     * * `ownerReference`: - The reference to a user.
     * * `projectReference`: - The reference to a project.
     * * `userGroupType`: - The type of the user group.
     * * `displayName`: - The display name of the user group.
     * * `directoryServiceUserGroup`: - A Directory Service User Group.
     * * `projectReferenceList`: - A list of projects the user is part of. See #reference for more details.
     * * `accessControlPolicyReferenceList`: - List of ACP references. See #reference for more details.
     * * `state`: - The state of the entity.
     */
    apiVersion: string;
    categories: outputs.GetUserGroupsEntityCategory[];
    directoryServiceUserGroups: outputs.GetUserGroupsEntityDirectoryServiceUserGroup[];
    displayName: string;
    metadata: {[key: string]: string};
    ownerReference: {[key: string]: string};
    projectReference?: {[key: string]: string};
    projectReferenceLists: outputs.GetUserGroupsEntityProjectReferenceList[];
    state: string;
    userGroupType: string;
}

export interface GetUserGroupsEntityAccessControlPolicyReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetUserGroupsEntityCategory {
    name: string;
    value: string;
}

export interface GetUserGroupsEntityDirectoryServiceUserGroup {
    defaultUserPrincipalName: string;
    directoryServiceReferences: outputs.GetUserGroupsEntityDirectoryServiceUserGroupDirectoryServiceReference[];
    distinguishedName: string;
}

export interface GetUserGroupsEntityDirectoryServiceUserGroupDirectoryServiceReference {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetUserGroupsEntityProjectReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetUserGroupsMetadata {
    filter: string;
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetUserIdentityProviderUser {
    identityProviderReferences: outputs.GetUserIdentityProviderUserIdentityProviderReference[];
    username: string;
}

export interface GetUserIdentityProviderUserIdentityProviderReference {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetUserProjectReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetUsersEntity {
    accessControlPolicyReferenceLists: outputs.GetUsersEntityAccessControlPolicyReferenceList[];
    /**
     * The version of the API.
     * * `state`: - The state of the entity.
     * * `name`: - The name of the user.
     * * `userType`: - The name of the user.
     * * `displayName`: - The display name of the user (common name) provided by the directory service.
     * * `projectReferenceList`: - A list of projects the user is part of. See #reference for more details.
     * * `accessControlPolicyReferenceList`: - List of ACP references. See #reference for more details.
     * * `directoryServiceUser`: - (Optional) The directory service user configuration. See below for more information.
     * * `identityProviderUser`: - (Optional) (Optional) The identity provider user configuration. See below for more information.
     * * `categories`: - (Optional) Categories for the user.
     * * `projectReference`: - (Optional) The reference to a project.
     * * `ownerReference`: - (Optional) The reference to a user.
     */
    apiVersion: string;
    categories: outputs.GetUsersEntityCategory[];
    directoryServiceUsers: outputs.GetUsersEntityDirectoryServiceUser[];
    displayName: string;
    identityProviderUsers: outputs.GetUsersEntityIdentityProviderUser[];
    metadata: {[key: string]: string};
    name: string;
    ownerReference: {[key: string]: string};
    projectReference?: {[key: string]: string};
    projectReferenceLists: outputs.GetUsersEntityProjectReferenceList[];
    state: string;
    userType: string;
}

export interface GetUsersEntityAccessControlPolicyReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetUsersEntityCategory {
    name: string;
    value: string;
}

export interface GetUsersEntityDirectoryServiceUser {
    defaultUserPrincipalName: string;
    directoryServiceReferences: outputs.GetUsersEntityDirectoryServiceUserDirectoryServiceReference[];
    userPrincipalName: string;
}

export interface GetUsersEntityDirectoryServiceUserDirectoryServiceReference {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetUsersEntityIdentityProviderUser {
    identityProviderReferences: outputs.GetUsersEntityIdentityProviderUserIdentityProviderReference[];
    username: string;
}

export interface GetUsersEntityIdentityProviderUserIdentityProviderReference {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetUsersEntityProjectReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface GetUsersMetadata {
    filter: string;
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
}

export interface GetVirtualMachineCategory {
    name: string;
    value: string;
}

export interface GetVirtualMachineDiskList {
    /**
     * Reference to a data source.
     */
    dataSourceReference: {[key: string]: string};
    /**
     * Properties to a device.
     */
    deviceProperties: outputs.GetVirtualMachineDiskListDeviceProperty[];
    /**
     * Size of the disk in Bytes.
     */
    diskSizeBytes: number;
    /**
     * Size of the disk in MiB. Must match the size specified in 'disk_size_bytes' - rounded up to the nearest MiB - when that field is present.
     */
    diskSizeMib: number;
    storageConfigs: outputs.GetVirtualMachineDiskListStorageConfig[];
    uuid: string;
    /**
     * Reference to a volume group.
     */
    volumeGroupReference: {[key: string]: string};
}

export interface GetVirtualMachineDiskListDeviceProperty {
    deviceType: string;
    diskAddress: {[key: string]: string};
}

export interface GetVirtualMachineDiskListStorageConfig {
    flashMode: string;
    storageContainerReferences: outputs.GetVirtualMachineDiskListStorageConfigStorageContainerReference[];
}

export interface GetVirtualMachineDiskListStorageConfigStorageContainerReference {
    kind: string;
    name: string;
    url: string;
    uuid: string;
}

export interface GetVirtualMachineGpuList {
    deviceId: number;
    /**
     * Fraction of the physical GPU assigned.
     * * `mode`: - The mode of this GPU.
     * * `numVirtualDisplayHeads`: - Number of supported virtual display heads.
     * * `guestDriverVersion`: - Last determined guest driver version.
     * * `deviceId`: - (Computed) The device ID of the GPU.
     */
    fraction: number;
    frameBufferSizeMib: number;
    guestDriverVersion: string;
    mode: string;
    name: string;
    numVirtualDisplayHeads: number;
    /**
     * GPU {segment:bus:device:function} (sbdf) address if assigned.
     */
    pciAddress: string;
    uuid: string;
    vendor: string;
}

export interface GetVirtualMachineMessageList {
    details: {[key: string]: any};
    message: string;
    reason: string;
}

export interface GetVirtualMachineNicList {
    floatingIp: string;
    ipEndpointLists: outputs.GetVirtualMachineNicListIpEndpointList[];
    isConnected: string;
    macAddress: string;
    model: string;
    networkFunctionChainReference: {[key: string]: string};
    networkFunctionNicType: string;
    nicType: string;
    numQueues: number;
    subnetName: string;
    subnetUuid: string;
    uuid: string;
}

export interface GetVirtualMachineNicListIpEndpointList {
    ip: string;
    type: string;
}

export interface GetVirtualMachineSerialPortList {
    index: number;
    isConnected: boolean;
}

export interface GetVpcSpec {
    /**
     * The name of the VPC
     */
    name: string;
    /**
     * VPC resources status
     */
    resources: outputs.GetVpcSpecResource[];
}

export interface GetVpcSpecResource {
    /**
     * List of domain name server IPs.
     */
    commonDomainNameServerIpLists: outputs.GetVpcSpecResourceCommonDomainNameServerIpList[];
    /**
     * List of external subnets attached to this VPC.
     */
    externalSubnetLists: outputs.GetVpcSpecResourceExternalSubnetList[];
    /**
     * List of external routable ip and prefix .
     */
    externallyRoutablePrefixLists: outputs.GetVpcSpecResourceExternallyRoutablePrefixList[];
}

export interface GetVpcSpecResourceCommonDomainNameServerIpList {
    /**
     * ip address of domain name server.
     */
    ip: string;
}

export interface GetVpcSpecResourceExternalSubnetList {
    /**
     * Reference to a subnet.
     */
    externalSubnetReference: {[key: string]: string};
}

export interface GetVpcSpecResourceExternallyRoutablePrefixList {
    /**
     * ip address of domain name server.
     */
    ip: string;
    /**
     * prefix length of routable ip .
     */
    prefixLength: number;
}

export interface GetVpcStatus {
    /**
     * Execution Context of VPC.
     */
    executionContexts: outputs.GetVpcStatusExecutionContext[];
    /**
     * The name of the VPC
     */
    name: string;
    /**
     * VPC resources status
     */
    resources: outputs.GetVpcStatusResource[];
    /**
     * The state of the VPC
     */
    state: string;
}

export interface GetVpcStatusExecutionContext {
    taskUuids: string[];
}

export interface GetVpcStatusResource {
    /**
     * List of domain name server IPs.
     */
    commonDomainNameServerIpLists: outputs.GetVpcStatusResourceCommonDomainNameServerIpList[];
    /**
     * List of external subnets attached to this VPC.
     */
    externalSubnetLists: outputs.GetVpcStatusResourceExternalSubnetList[];
    /**
     * List of external routable ip and prefix .
     */
    externallyRoutablePrefixLists: outputs.GetVpcStatusResourceExternallyRoutablePrefixList[];
}

export interface GetVpcStatusResourceCommonDomainNameServerIpList {
    /**
     * ip address of domain name server.
     */
    ip: string;
}

export interface GetVpcStatusResourceExternalSubnetList {
    /**
     * Active Gateway Node. Only present in VPC Status Resources.
     */
    activeGatewayNodes: outputs.GetVpcStatusResourceExternalSubnetListActiveGatewayNode[];
    /**
     * List of external subnets attached to this VPC. Only present in VPC Status Resources .
     */
    externalIpLists: string[];
    /**
     * Reference to a subnet.
     */
    externalSubnetReference: {[key: string]: string};
}

export interface GetVpcStatusResourceExternalSubnetListActiveGatewayNode {
    /**
     * Reference to host.
     */
    hostReference: {[key: string]: string};
    /**
     * ip address.
     */
    ipAddress: string;
}

export interface GetVpcStatusResourceExternallyRoutablePrefixList {
    /**
     * ip address of domain name server.
     */
    ip: string;
    /**
     * prefix length of routable ip .
     */
    prefixLength: number;
}

export interface GetVpcsEntity {
    metadata: {[key: string]: string};
    /**
     * VPC input spec
     */
    specs: outputs.GetVpcsEntitySpec[];
    /**
     * VPC output status
     */
    statuses: outputs.GetVpcsEntityStatus[];
}

export interface GetVpcsEntitySpec {
    /**
     * The name of the VPC
     */
    name: string;
    /**
     * VPC resources status
     */
    resources: outputs.GetVpcsEntitySpecResource[];
}

export interface GetVpcsEntitySpecResource {
    /**
     * List of domain name server IPs.
     */
    commonDomainNameServerIpLists: outputs.GetVpcsEntitySpecResourceCommonDomainNameServerIpList[];
    /**
     * List of external subnets attached to this VPC.
     */
    externalSubnetLists: outputs.GetVpcsEntitySpecResourceExternalSubnetList[];
    /**
     * List of external routable ip and prefix .
     */
    externallyRoutablePrefixLists: outputs.GetVpcsEntitySpecResourceExternallyRoutablePrefixList[];
}

export interface GetVpcsEntitySpecResourceCommonDomainNameServerIpList {
    /**
     * ip address of domain name server.
     */
    ip: string;
}

export interface GetVpcsEntitySpecResourceExternalSubnetList {
    /**
     * Reference to a subnet.
     */
    externalSubnetReference: {[key: string]: string};
}

export interface GetVpcsEntitySpecResourceExternallyRoutablePrefixList {
    /**
     * ip address of domain name server.
     */
    ip: string;
    /**
     * prefix length of routable ip .
     */
    prefixLength: number;
}

export interface GetVpcsEntityStatus {
    /**
     * Execution Context of VPC.
     */
    executionContexts: outputs.GetVpcsEntityStatusExecutionContext[];
    /**
     * The name of the VPC
     */
    name: string;
    /**
     * VPC resources status
     */
    resources: outputs.GetVpcsEntityStatusResource[];
    /**
     * The state of the VPC
     */
    state: string;
}

export interface GetVpcsEntityStatusExecutionContext {
    taskUuids: string[];
}

export interface GetVpcsEntityStatusResource {
    /**
     * List of domain name server IPs.
     */
    commonDomainNameServerIpLists: outputs.GetVpcsEntityStatusResourceCommonDomainNameServerIpList[];
    /**
     * List of external subnets attached to this VPC.
     */
    externalSubnetLists: outputs.GetVpcsEntityStatusResourceExternalSubnetList[];
    /**
     * List of external routable ip and prefix .
     */
    externallyRoutablePrefixLists: outputs.GetVpcsEntityStatusResourceExternallyRoutablePrefixList[];
}

export interface GetVpcsEntityStatusResourceCommonDomainNameServerIpList {
    /**
     * ip address of domain name server.
     */
    ip: string;
}

export interface GetVpcsEntityStatusResourceExternalSubnetList {
    /**
     * Active Gateway Node. Only present in VPC Status Resources.
     */
    activeGatewayNodes: outputs.GetVpcsEntityStatusResourceExternalSubnetListActiveGatewayNode[];
    /**
     * List of external subnets attached to this VPC. Only present in VPC Status Resources .
     */
    externalIpLists: string[];
    /**
     * Reference to a subnet.
     */
    externalSubnetReference: {[key: string]: string};
}

export interface GetVpcsEntityStatusResourceExternalSubnetListActiveGatewayNode {
    /**
     * Reference to host.
     */
    hostReference: {[key: string]: string};
    /**
     * ip address.
     */
    ipAddress: string;
}

export interface GetVpcsEntityStatusResourceExternallyRoutablePrefixList {
    /**
     * ip address of domain name server.
     */
    ip: string;
    /**
     * prefix length of routable ip .
     */
    prefixLength: number;
}

export interface GetVpcsMetadata {
    filter: string;
    kind: string;
    length: number;
    offset: number;
    sortAttribute: string;
    sortOrder: string;
    totalMatches: number;
}

export interface ImageCategory {
    name: string;
    value: string;
}

export interface ImageClusterReference {
    kind: string;
    name: string;
    uuid: string;
}

export interface ImageCurrentClusterReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface KarbonClusterActivePassiveConfig {
    externalIpv4Address: string;
}

export interface KarbonClusterCniConfig {
    calicoConfig?: outputs.KarbonClusterCniConfigCalicoConfig;
    flannelConfigs?: outputs.KarbonClusterCniConfigFlannelConfig[];
    nodeCidrMaskSize?: number;
    podIpv4Cidr?: string;
    serviceIpv4Cidr?: string;
}

export interface KarbonClusterCniConfigCalicoConfig {
    ipPoolConfigs?: outputs.KarbonClusterCniConfigCalicoConfigIpPoolConfig[];
}

export interface KarbonClusterCniConfigCalicoConfigIpPoolConfig {
    cidr?: string;
}

export interface KarbonClusterCniConfigFlannelConfig {
}

export interface KarbonClusterEtcdNodePool {
    ahvConfig?: outputs.KarbonClusterEtcdNodePoolAhvConfig;
    name?: string;
    nodeOsVersion: string;
    nodes: outputs.KarbonClusterEtcdNodePoolNode[];
    numInstances: number;
}

export interface KarbonClusterEtcdNodePoolAhvConfig {
    cpu?: number;
    diskMib?: number;
    memoryMib?: number;
    networkUuid: string;
    prismElementClusterUuid: string;
}

export interface KarbonClusterEtcdNodePoolNode {
    hostname: string;
    ipv4Address: string;
}

export interface KarbonClusterExternalLbConfig {
    externalIpv4Address: string;
    masterNodesConfigs: outputs.KarbonClusterExternalLbConfigMasterNodesConfig[];
}

export interface KarbonClusterExternalLbConfigMasterNodesConfig {
    ipv4Address: string;
    nodePoolName?: string;
}

export interface KarbonClusterMasterNodePool {
    ahvConfig?: outputs.KarbonClusterMasterNodePoolAhvConfig;
    name?: string;
    nodeOsVersion: string;
    nodes: outputs.KarbonClusterMasterNodePoolNode[];
    numInstances: number;
}

export interface KarbonClusterMasterNodePoolAhvConfig {
    cpu?: number;
    diskMib?: number;
    memoryMib?: number;
    networkUuid: string;
    prismElementClusterUuid: string;
}

export interface KarbonClusterMasterNodePoolNode {
    hostname: string;
    ipv4Address: string;
}

export interface KarbonClusterPrivateRegistry {
    registryName: string;
}

export interface KarbonClusterSingleMasterConfig {
}

export interface KarbonClusterStorageClassConfig {
    name?: string;
    /**
     * Reclaim policy for persistent volumes provisioned using the specified storage class.
     * * `volumes_config.#.file_system` - (Optional) Karbon uses either the ext4 or xfs file-system on the volume disk.
     * * `volumes_config.#.flash_mode` - (Optional) Pins the persistent volumes to the flash tier in case of a `true` value.
     * * `volumes_config.#.password` - (Required) The password of the Prism Element user that the API calls use to provision volumes.
     * * `volumes_config.#.prism_element_cluster_uuid` - (Required) The universally unique identifier (UUID) of the Prism Element cluster.
     * * `volumes_config.#.storage_container` - (Required) Name of the storage container the storage container uses to provision volumes.
     * * `volumes_config.#.username` - (Required) Username of the Prism Element user that the API calls use to provision volumes.
     */
    reclaimPolicy?: string;
    volumesConfig: outputs.KarbonClusterStorageClassConfigVolumesConfig;
}

export interface KarbonClusterStorageClassConfigVolumesConfig {
    fileSystem?: string;
    flashMode?: boolean;
    password: string;
    prismElementClusterUuid: string;
    storageContainer: string;
    username: string;
}

export interface KarbonClusterWorkerNodePool {
    ahvConfig?: outputs.KarbonClusterWorkerNodePoolAhvConfig;
    name?: string;
    nodeOsVersion: string;
    nodes: outputs.KarbonClusterWorkerNodePoolNode[];
    numInstances: number;
}

export interface KarbonClusterWorkerNodePoolAhvConfig {
    cpu?: number;
    diskMib?: number;
    memoryMib?: number;
    networkUuid: string;
    prismElementClusterUuid: string;
}

export interface KarbonClusterWorkerNodePoolNode {
    hostname: string;
    ipv4Address: string;
}

export interface NetworkSecurityRuleAdRuleInboundAllowList {
    addressGroupInclusionLists: outputs.NetworkSecurityRuleAdRuleInboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.NetworkSecurityRuleAdRuleInboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.NetworkSecurityRuleAdRuleInboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.NetworkSecurityRuleAdRuleInboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.NetworkSecurityRuleAdRuleInboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.NetworkSecurityRuleAdRuleInboundAllowListUdpPortRangeList[];
}

export interface NetworkSecurityRuleAdRuleInboundAllowListAddressGroupInclusionList {
    kind: string;
    name: string;
    uuid: string;
}

export interface NetworkSecurityRuleAdRuleInboundAllowListFilterParam {
    name: string;
    values: string[];
}

export interface NetworkSecurityRuleAdRuleInboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface NetworkSecurityRuleAdRuleInboundAllowListServiceGroupList {
    kind: string;
    name: string;
    uuid: string;
}

export interface NetworkSecurityRuleAdRuleInboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAdRuleInboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAdRuleOutboundAllowList {
    addressGroupInclusionLists: outputs.NetworkSecurityRuleAdRuleOutboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.NetworkSecurityRuleAdRuleOutboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.NetworkSecurityRuleAdRuleOutboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.NetworkSecurityRuleAdRuleOutboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.NetworkSecurityRuleAdRuleOutboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.NetworkSecurityRuleAdRuleOutboundAllowListUdpPortRangeList[];
}

export interface NetworkSecurityRuleAdRuleOutboundAllowListAddressGroupInclusionList {
    kind: string;
    name: string;
    uuid: string;
}

export interface NetworkSecurityRuleAdRuleOutboundAllowListFilterParam {
    name: string;
    values: string[];
}

export interface NetworkSecurityRuleAdRuleOutboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface NetworkSecurityRuleAdRuleOutboundAllowListServiceGroupList {
    kind: string;
    name: string;
    uuid: string;
}

export interface NetworkSecurityRuleAdRuleOutboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAdRuleOutboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAdRuleTargetGroupFilterParam {
    name: string;
    values: string[];
}

export interface NetworkSecurityRuleAppRuleInboundAllowList {
    addressGroupInclusionLists: outputs.NetworkSecurityRuleAppRuleInboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.NetworkSecurityRuleAppRuleInboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.NetworkSecurityRuleAppRuleInboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.NetworkSecurityRuleAppRuleInboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.NetworkSecurityRuleAppRuleInboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.NetworkSecurityRuleAppRuleInboundAllowListUdpPortRangeList[];
}

export interface NetworkSecurityRuleAppRuleInboundAllowListAddressGroupInclusionList {
    kind: string;
    name: string;
    uuid: string;
}

export interface NetworkSecurityRuleAppRuleInboundAllowListFilterParam {
    name: string;
    values: string[];
}

export interface NetworkSecurityRuleAppRuleInboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface NetworkSecurityRuleAppRuleInboundAllowListServiceGroupList {
    kind: string;
    name: string;
    uuid: string;
}

export interface NetworkSecurityRuleAppRuleInboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAppRuleInboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAppRuleOutboundAllowList {
    addressGroupInclusionLists: outputs.NetworkSecurityRuleAppRuleOutboundAllowListAddressGroupInclusionList[];
    expirationTime: string;
    filterKindLists: string[];
    filterParams: outputs.NetworkSecurityRuleAppRuleOutboundAllowListFilterParam[];
    filterType: string;
    icmpTypeCodeLists: outputs.NetworkSecurityRuleAppRuleOutboundAllowListIcmpTypeCodeList[];
    ipSubnet: string;
    ipSubnetPrefixLength: string;
    networkFunctionChainReference: {[key: string]: string};
    peerSpecificationType: string;
    protocol: string;
    serviceGroupLists: outputs.NetworkSecurityRuleAppRuleOutboundAllowListServiceGroupList[];
    tcpPortRangeLists: outputs.NetworkSecurityRuleAppRuleOutboundAllowListTcpPortRangeList[];
    udpPortRangeLists: outputs.NetworkSecurityRuleAppRuleOutboundAllowListUdpPortRangeList[];
}

export interface NetworkSecurityRuleAppRuleOutboundAllowListAddressGroupInclusionList {
    kind: string;
    name: string;
    uuid: string;
}

export interface NetworkSecurityRuleAppRuleOutboundAllowListFilterParam {
    name: string;
    values: string[];
}

export interface NetworkSecurityRuleAppRuleOutboundAllowListIcmpTypeCodeList {
    code: string;
    type: string;
}

export interface NetworkSecurityRuleAppRuleOutboundAllowListServiceGroupList {
    kind: string;
    name: string;
    uuid: string;
}

export interface NetworkSecurityRuleAppRuleOutboundAllowListTcpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAppRuleOutboundAllowListUdpPortRangeList {
    endPort: number;
    startPort: number;
}

export interface NetworkSecurityRuleAppRuleTargetGroupFilterParam {
    name: string;
    values: string[];
}

export interface NetworkSecurityRuleCategory {
    name: string;
    value: string;
}

export interface NetworkSecurityRuleIsolationRuleFirstEntityFilterParam {
    name: string;
    values: string[];
}

export interface NetworkSecurityRuleIsolationRuleSecondEntityFilterParam {
    name: string;
    values: string[];
}

export interface PbrDestination {
    addressType?: string;
    prefixLength?: number;
    subnetIp?: string;
}

export interface PbrProtocolParameters {
    icmp?: outputs.PbrProtocolParametersIcmp;
    protocolNumber?: string;
    tcp?: outputs.PbrProtocolParametersTcp;
    udp?: outputs.PbrProtocolParametersUdp;
}

export interface PbrProtocolParametersIcmp {
    icmpCode: number;
    icmpType: number;
}

export interface PbrProtocolParametersTcp {
    destinationPortRangeLists: outputs.PbrProtocolParametersTcpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.PbrProtocolParametersTcpSourcePortRangeList[];
}

export interface PbrProtocolParametersTcpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface PbrProtocolParametersTcpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface PbrProtocolParametersUdp {
    destinationPortRangeLists: outputs.PbrProtocolParametersUdpDestinationPortRangeList[];
    sourcePortRangeLists: outputs.PbrProtocolParametersUdpSourcePortRangeList[];
}

export interface PbrProtocolParametersUdpDestinationPortRangeList {
    endPort: number;
    startPort: number;
}

export interface PbrProtocolParametersUdpSourcePortRangeList {
    endPort: number;
    startPort: number;
}

export interface PbrSource {
    addressType?: string;
    prefixLength?: number;
    subnetIp?: string;
}

export interface ProjectAccountReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectCategory {
    /**
     * The name for the project.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface ProjectDefaultSubnetReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectEnvironmentReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectExternalNetworkList {
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectExternalUserGroupReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectResourceDomain {
    resources: outputs.ProjectResourceDomainResource[];
}

export interface ProjectResourceDomainResource {
    limit: number;
    resourceType: string;
    units: string;
    /**
     * value of the key.
     */
    value: number;
}

export interface ProjectSubnetReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProjectUserReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the project.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface ProtectionRuleAvailabilityZoneConnectivityList {
    destinationAvailabilityZoneIndex: number;
    snapshotScheduleLists: outputs.ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleList[];
    sourceAvailabilityZoneIndex: number;
}

export interface ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleList {
    autoSuspendTimeoutSecs: number;
    localSnapshotRetentionPolicy: outputs.ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicy;
    recoveryPointObjectiveSecs: number;
    remoteSnapshotRetentionPolicy: outputs.ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicy;
    snapshotType: string;
}

export interface ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicy {
    numSnapshots: number;
    rollupRetentionPolicyMultiple: number;
    rollupRetentionPolicySnapshotIntervalType: string;
}

export interface ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicy {
    numSnapshots: number;
    rollupRetentionPolicyMultiple: number;
    rollupRetentionPolicySnapshotIntervalType: string;
}

export interface ProtectionRuleCategory {
    /**
     * The name for the protection rule.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface ProtectionRuleCategoryFilter {
    kindLists: string[];
    params: outputs.ProtectionRuleCategoryFilterParam[];
    type: string;
}

export interface ProtectionRuleCategoryFilterParam {
    /**
     * The name for the protection rule.
     */
    name: string;
    values: string[];
}

export interface ProtectionRuleOrderedAvailabilityZoneList {
    availabilityZoneUrl: string;
    clusterUuid: string;
}

export interface ProtectionRuleOwnerReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the protection rule.
     */
    name?: string;
    /**
     * (Required) the UUID.
     */
    uuid?: string;
}

export interface ProtectionRuleProjectReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the protection rule.
     */
    name?: string;
    /**
     * (Required) the UUID.
     */
    uuid?: string;
}

export interface RecoveryPlanCategory {
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * value of the key.
     */
    value: string;
}

export interface RecoveryPlanOwnerReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the Recovery Plan.
     */
    name?: string;
    /**
     * (Required) the UUID.
     */
    uuid?: string;
}

export interface RecoveryPlanParameters {
    floatingIpAssignmentLists: outputs.RecoveryPlanParametersFloatingIpAssignmentList[];
    networkMappingLists: outputs.RecoveryPlanParametersNetworkMappingList[];
}

export interface RecoveryPlanParametersFloatingIpAssignmentList {
    availabilityZoneUrl: string;
    vmIpAssignmentLists: outputs.RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentList[];
}

export interface RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentList {
    recoveryFloatingIpConfig: outputs.RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfig;
    testFloatingIpConfig: outputs.RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfig;
    vmNicInformation: outputs.RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmNicInformation;
    vmReference: outputs.RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmReference;
}

export interface RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfig {
    ip: string;
    shouldAllocateDynamically: boolean;
}

export interface RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfig {
    ip: string;
    shouldAllocateDynamically: boolean;
}

export interface RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmNicInformation {
    ip: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersNetworkMappingList {
    areNetworksStretched: boolean;
    availabilityZoneNetworkMappingLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingList[];
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingList {
    availabilityZoneUrl: string;
    clusterReferenceLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceList[];
    recoveryIpAssignmentLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentList[];
    recoveryNetwork: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetwork;
    testIpAssignmentLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentList[];
    testNetwork: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetwork;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceList {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentList {
    ipConfigLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigList[];
    vmReference: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReference;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigList {
    ipAddress: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetwork {
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    subnetLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetList[];
    useVpcReference: boolean;
    virtualNetworkReference: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReference;
    vpcReference: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReference;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetList {
    externalConnectivityState: string;
    gatewayIp: string;
    prefixLength: number;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentList {
    ipConfigLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigList[];
    vmReference: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReference;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigList {
    ipAddress: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetwork {
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    subnetLists: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetList[];
    useVpcReference: boolean;
    virtualNetworkReference: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReference;
    vpcReference: outputs.RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReference;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetList {
    externalConnectivityState: string;
    gatewayIp: string;
    prefixLength: number;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind: string;
    /**
     * The name for the Recovery Plan.
     */
    name: string;
    /**
     * (Required) the UUID.
     */
    uuid: string;
}

export interface RecoveryPlanProjectReference {
    /**
     * (Required) The kind name (Default value: `project`).
     */
    kind?: string;
    /**
     * The name for the Recovery Plan.
     */
    name?: string;
    /**
     * (Required) the UUID.
     */
    uuid?: string;
}

export interface RecoveryPlanStageList {
    delayTimeSecs: number;
    stageUuid: string;
    stageWork: outputs.RecoveryPlanStageListStageWork;
}

export interface RecoveryPlanStageListStageWork {
    recoverEntities: outputs.RecoveryPlanStageListStageWorkRecoverEntities;
}

export interface RecoveryPlanStageListStageWorkRecoverEntities {
    entityInfoLists: outputs.RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoList[];
}

export interface RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoList {
    anyEntityReferenceKind?: string;
    anyEntityReferenceName?: string;
    anyEntityReferenceUuid?: string;
    categories?: outputs.RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListCategory[];
    scriptLists: outputs.RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListScriptList[];
}

export interface RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListCategory {
    /**
     * The name for the Recovery Plan.
     */
    name?: string;
    /**
     * value of the key.
     */
    value?: string;
}

export interface RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListScriptList {
    enableScriptExec: boolean;
    timeout: string;
}

export interface RoleCategory {
    name: string;
    value: string;
}

export interface RoleOwnerReference {
    kind?: string;
    name?: string;
    uuid?: string;
}

export interface RolePermissionReferenceList {
    kind?: string;
    name: string;
    uuid: string;
}

export interface RoleProjectReference {
    kind?: string;
    name?: string;
    uuid?: string;
}

export interface ServiceGroupServiceList {
    icmpTypeCodeLists?: outputs.ServiceGroupServiceListIcmpTypeCodeList[];
    protocol?: string;
    tcpPortRangeLists?: outputs.ServiceGroupServiceListTcpPortRangeList[];
    udpPortRangeLists?: outputs.ServiceGroupServiceListUdpPortRangeList[];
}

export interface ServiceGroupServiceListIcmpTypeCodeList {
    code?: string;
    type?: string;
}

export interface ServiceGroupServiceListTcpPortRangeList {
    /**
     * End Port (Int)
     */
    endPort?: number;
    startPort?: number;
}

export interface ServiceGroupServiceListUdpPortRangeList {
    /**
     * End Port (Int)
     */
    endPort?: number;
    startPort?: number;
}

export interface StaticRoutesDefaultRouteNexthop {
    /**
     * Reference to a subnet.
     */
    externalSubnetReferenceUuid?: string;
}

export interface StaticRoutesStaticRoutesList {
    /**
     * Destination ip with prefix.
     */
    destination: string;
    /**
     * Reference to a subnet.
     */
    externalSubnetReferenceUuid?: string;
    /**
     * Reference to a vpn connection.
     */
    vpnConnectionReferenceUuid?: string;
}

export interface SubnetCategory {
    name: string;
    value: string;
}

export interface UserAccessControlPolicyReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface UserCategory {
    name: string;
    value: string;
}

export interface UserDirectoryServiceUser {
    defaultUserPrincipalName: string;
    directoryServiceReference: outputs.UserDirectoryServiceUserDirectoryServiceReference;
    userPrincipalName: string;
}

export interface UserDirectoryServiceUserDirectoryServiceReference {
    kind?: string;
    name: string;
    uuid: string;
}

export interface UserIdentityProviderUser {
    identityProviderReference: outputs.UserIdentityProviderUserIdentityProviderReference;
    username: string;
}

export interface UserIdentityProviderUserIdentityProviderReference {
    kind?: string;
    name: string;
    uuid: string;
}

export interface UserProjectReferenceList {
    kind: string;
    name: string;
    uuid: string;
}

export interface VirtualMachineCategory {
    name: string;
    value: string;
}

export interface VirtualMachineDiskList {
    /**
     * Reference to a data source.
     */
    dataSourceReference: {[key: string]: string};
    /**
     * Properties to a device.
     */
    deviceProperties: outputs.VirtualMachineDiskListDeviceProperties;
    /**
     * Size of the disk in Bytes.
     */
    diskSizeBytes: number;
    /**
     * Size of the disk in MiB. Must match the size specified in 'disk_size_bytes' - rounded up to the nearest MiB - when that field is present.
     */
    diskSizeMib: number;
    storageConfig: outputs.VirtualMachineDiskListStorageConfig;
    uuid: string;
    /**
     * Reference to a volume group.
     */
    volumeGroupReference: {[key: string]: string};
}

export interface VirtualMachineDiskListDeviceProperties {
    deviceType?: string;
    diskAddress: {[key: string]: string};
}

export interface VirtualMachineDiskListStorageConfig {
    flashMode?: string;
    storageContainerReferences: outputs.VirtualMachineDiskListStorageConfigStorageContainerReference[];
}

export interface VirtualMachineDiskListStorageConfigStorageContainerReference {
    kind?: string;
    name: string;
    url: string;
    uuid: string;
}

export interface VirtualMachineGpuList {
    deviceId: number;
    /**
     * Fraction of the physical GPU assigned.
     * * `mode`: - (Optional) The mode of this GPU.
     * * `numVirtualDisplayHeads`: - (ReadOnly) Number of supported virtual display heads.
     * * `guestDriverVersion`: - (ReadOnly) Last determined guest driver version.
     * * `deviceId`: - (Computed) The device ID of the GPU.
     */
    fraction: number;
    frameBufferSizeMib: number;
    guestDriverVersion: string;
    mode: string;
    name: string;
    numVirtualDisplayHeads: number;
    /**
     * GPU {segment:bus:device:function} (sbdf) address if assigned.
     */
    pciAddress: string;
    uuid: string;
    vendor: string;
}

export interface VirtualMachineNicList {
    ipEndpointLists: outputs.VirtualMachineNicListIpEndpointList[];
    isConnected?: string;
    macAddress: string;
    model: string;
    networkFunctionChainReference: {[key: string]: string};
    networkFunctionNicType: string;
    nicType: string;
    numQueues: number;
    subnetName: string;
    subnetUuid?: string;
    uuid: string;
}

export interface VirtualMachineNicListIpEndpointList {
    ip: string;
    type: string;
}

export interface VirtualMachineNicListStatus {
    floatingIp: string;
    ipEndpointLists: outputs.VirtualMachineNicListStatusIpEndpointList[];
    isConnected: string;
    macAddress: string;
    model: string;
    networkFunctionChainReference: {[key: string]: string};
    networkFunctionNicType: string;
    nicType: string;
    numQueues: number;
    subnetName: string;
    subnetUuid: string;
    uuid: string;
}

export interface VirtualMachineNicListStatusIpEndpointList {
    ip: string;
    type: string;
}

export interface VirtualMachineSerialPortList {
    index: number;
    isConnected: boolean;
}

export interface VpcCommonDomainNameServerIpList {
    /**
     * ip address.
     */
    ip: string;
}

export interface VpcExternalSubnetListStatus {
    activeGatewayNode: outputs.VpcExternalSubnetListStatusActiveGatewayNode;
    externalIpLists: string[];
    externalSubnetReference: {[key: string]: string};
}

export interface VpcExternalSubnetListStatusActiveGatewayNode {
    hostReference: {[key: string]: string};
    ipAddress: string;
}

export interface VpcExternallyRoutablePrefixList {
    /**
     * ip address.
     */
    ip: string;
    /**
     * prefix length.
     */
    prefixLength: number;
}

