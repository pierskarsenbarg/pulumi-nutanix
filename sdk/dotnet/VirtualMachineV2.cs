// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace PiersKarsenbarg.Nutanix
{
    /// <summary>
    /// Creates a Virtual Machine with the provided configuration.
    /// </summary>
    [NutanixResourceType("nutanix:index/virtualMachineV2:VirtualMachineV2")]
    public partial class VirtualMachineV2 : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Advanced Processor Compatibility configuration for the VM. Enabling this retains the CPU model for the VM across power cycles and migrations.
        /// </summary>
        [Output("apcConfigs")]
        public Output<ImmutableArray<Outputs.VirtualMachineV2ApcConfig>> ApcConfigs { get; private set; } = null!;

        [Output("availabilityZones")]
        public Output<ImmutableArray<Outputs.VirtualMachineV2AvailabilityZone>> AvailabilityZones { get; private set; } = null!;

        /// <summary>
        /// BIOS UUID of the VM. It should be of type UUID.
        /// </summary>
        [Output("biosUuid")]
        public Output<string> BiosUuid { get; private set; } = null!;

        /// <summary>
        /// Indicates the order of device types in which the VM should try to boot from. If the boot device order is not provided the system will decide an appropriate boot device order.
        /// </summary>
        [Output("bootConfigs")]
        public Output<ImmutableArray<Outputs.VirtualMachineV2BootConfig>> BootConfigs { get; private set; } = null!;

        /// <summary>
        /// Categories for the VM.
        /// </summary>
        [Output("categories")]
        public Output<ImmutableArray<Outputs.VirtualMachineV2Category>> Categories { get; private set; } = null!;

        /// <summary>
        /// CD-ROMs attached to the VM.
        /// </summary>
        [Output("cdRoms")]
        public Output<ImmutableArray<Outputs.VirtualMachineV2CdRom>> CdRoms { get; private set; } = null!;

        /// <summary>
        /// Reference to a cluster.
        /// </summary>
        [Output("clusters")]
        public Output<ImmutableArray<Outputs.VirtualMachineV2Cluster>> Clusters { get; private set; } = null!;

        /// <summary>
        /// VM creation time
        /// </summary>
        [Output("createTime")]
        public Output<string> CreateTime { get; private set; } = null!;

        /// <summary>
        /// VM description
        /// </summary>
        [Output("description")]
        public Output<string> Description { get; private set; } = null!;

        /// <summary>
        /// Disks attached to the VM.
        /// </summary>
        [Output("disks")]
        public Output<ImmutableArray<Outputs.VirtualMachineV2Disk>> Disks { get; private set; } = null!;

        /// <summary>
        /// The list of additional CPU features to be enabled. HardwareVirtualization: Indicates whether hardware assisted virtualization should be enabled for the Guest OS or not. Once enabled, the Guest OS can deploy a nested hypervisor. Valid values are "HARDWARE_VIRTUALIZATION".
        /// </summary>
        [Output("enabledCpuFeatures")]
        public Output<ImmutableArray<string>> EnabledCpuFeatures { get; private set; } = null!;

        /// <summary>
        /// A globally unique identifier of an instance that is suitable for external consumption.
        /// </summary>
        [Output("extId")]
        public Output<string> ExtId { get; private set; } = null!;

        /// <summary>
        /// Generation UUID of the VM. It should be of type UUID.
        /// </summary>
        [Output("generationUuid")]
        public Output<string> GenerationUuid { get; private set; } = null!;

        /// <summary>
        /// GPUs attached to the VM.
        /// </summary>
        [Output("gpuses")]
        public Output<ImmutableArray<Outputs.VirtualMachineV2Gpus>> Gpuses { get; private set; } = null!;

        /// <summary>
        /// Stage a Sysprep or cloud-init configuration file to be used by the guest for the next boot. Note that the Sysprep command must be used to generalize the Windows VMs before triggering this API call.
        /// </summary>
        [Output("guestCustomizations")]
        public Output<ImmutableArray<Outputs.VirtualMachineV2GuestCustomization>> GuestCustomizations { get; private set; } = null!;

        /// <summary>
        /// The details about Nutanix Guest Tools for a VM.
        /// </summary>
        [Output("guestTools")]
        public Output<ImmutableArray<Outputs.VirtualMachineV2GuestTool>> GuestTools { get; private set; } = null!;

        /// <summary>
        /// VM hardware clock timezone in IANA TZDB format (America/Los_Angeles).
        /// </summary>
        [Output("hardwareClockTimezone")]
        public Output<string> HardwareClockTimezone { get; private set; } = null!;

        /// <summary>
        /// Reference to the host, the VM is running on.
        /// </summary>
        [Output("hosts")]
        public Output<ImmutableArray<Outputs.VirtualMachineV2Host>> Hosts { get; private set; } = null!;

        /// <summary>
        /// Indicates whether the VM is an agent VM or not. When their host enters maintenance mode, once the normal VMs are evacuated, the agent VMs are powered off. When the host is restored, agent VMs are powered on before the normal VMs are restored. In other words, agent VMs cannot be HA-protected or live migrated.
        /// </summary>
        [Output("isAgentVm")]
        public Output<bool> IsAgentVm { get; private set; } = null!;

        /// <summary>
        /// Indicates whether to remove AHV branding from VM firmware tables or not.
        /// </summary>
        [Output("isBrandingEnabled")]
        public Output<bool> IsBrandingEnabled { get; private set; } = null!;

        /// <summary>
        /// Indicates whether the VM CPU hotplug is enabled.
        /// </summary>
        [Output("isCpuHotplugEnabled")]
        public Output<bool> IsCpuHotplugEnabled { get; private set; } = null!;

        /// <summary>
        /// Indicates whether to passthrough the host CPU features to the guest or not. Enabling this will make VM incapable of live migration.
        /// </summary>
        [Output("isCpuPassthroughEnabled")]
        public Output<bool> IsCpuPassthroughEnabled { get; private set; } = null!;

        /// <summary>
        /// Indicates whether the vGPU console is enabled or not.
        /// </summary>
        [Output("isGpuConsoleEnabled")]
        public Output<bool> IsGpuConsoleEnabled { get; private set; } = null!;

        /// <summary>
        /// Indicates whether the memory overcommit feature should be enabled for the VM or not. If enabled, parts of the VM memory may reside outside of the hypervisor physical memory. Once enabled, it should be expected that the VM may suffer performance degradation.
        /// </summary>
        [Output("isMemoryOvercommitEnabled")]
        public Output<bool> IsMemoryOvercommitEnabled { get; private set; } = null!;

        /// <summary>
        /// Indicates whether the VM SCSI controller is enabled.
        /// </summary>
        [Output("isScsiControllerEnabled")]
        public Output<bool> IsScsiControllerEnabled { get; private set; } = null!;

        /// <summary>
        /// Indicates whether the vCPUs should be hard pinned to specific pCPUs or not.
        /// </summary>
        [Output("isVcpuHardPinningEnabled")]
        public Output<bool> IsVcpuHardPinningEnabled { get; private set; } = null!;

        /// <summary>
        /// Indicates whether the VGA console should be disabled or not.
        /// </summary>
        [Output("isVgaConsoleEnabled")]
        public Output<bool> IsVgaConsoleEnabled { get; private set; } = null!;

        /// <summary>
        /// Machine type for the VM. Machine type Q35 is required for secure boot and does not support IDE disks. Valid values are "PSERIES", "Q35", "PC" .
        /// </summary>
        [Output("machineType")]
        public Output<string> MachineType { get; private set; } = null!;

        /// <summary>
        /// Memory size in bytes.
        /// </summary>
        [Output("memorySizeBytes")]
        public Output<int> MemorySizeBytes { get; private set; } = null!;

        /// <summary>
        /// VM name.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// NICs attached to the VM.
        /// </summary>
        [Output("nics")]
        public Output<ImmutableArray<Outputs.VirtualMachineV2Nic>> Nics { get; private set; } = null!;

        /// <summary>
        /// Number of cores per socket. Value should be at least 1.
        /// </summary>
        [Output("numCoresPerSocket")]
        public Output<int> NumCoresPerSocket { get; private set; } = null!;

        /// <summary>
        /// Number of NUMA nodes. 0 means NUMA is disabled.
        /// </summary>
        [Output("numNumaNodes")]
        public Output<int> NumNumaNodes { get; private set; } = null!;

        /// <summary>
        /// Number of vCPU sockets. Value should be at least 1.
        /// </summary>
        [Output("numSockets")]
        public Output<int> NumSockets { get; private set; } = null!;

        /// <summary>
        /// Number of threads per core. Value should be at least 1.
        /// </summary>
        [Output("numThreadsPerCore")]
        public Output<int> NumThreadsPerCore { get; private set; } = null!;

        /// <summary>
        /// Ownership information for the VM.
        /// </summary>
        [Output("ownershipInfos")]
        public Output<ImmutableArray<Outputs.VirtualMachineV2OwnershipInfo>> OwnershipInfos { get; private set; } = null!;

        [Output("powerState")]
        public Output<string?> PowerState { get; private set; } = null!;

        /// <summary>
        /// Status of protection policy applied to this VM.
        /// </summary>
        [Output("protectionPolicyStates")]
        public Output<ImmutableArray<Outputs.VirtualMachineV2ProtectionPolicyState>> ProtectionPolicyStates { get; private set; } = null!;

        /// <summary>
        /// The type of protection applied on a VM. Valid values "PD_PROTECTED", "UNPROTECTED", "RULE_PROTECTED".
        /// </summary>
        [Output("protectionType")]
        public Output<string> ProtectionType { get; private set; } = null!;

        /// <summary>
        /// Serial ports configured on the VM.
        /// </summary>
        [Output("serialPorts")]
        public Output<ImmutableArray<Outputs.VirtualMachineV2SerialPort>> SerialPorts { get; private set; } = null!;

        /// <summary>
        /// Reference to an entity that the VM should be cloned or created from. Valid values are "VM", "VM_RECOVERY_POINT".
        /// </summary>
        [Output("sources")]
        public Output<ImmutableArray<Outputs.VirtualMachineV2Source>> Sources { get; private set; } = null!;

        /// <summary>
        /// Storage configuration for VM.
        /// </summary>
        [Output("storageConfigs")]
        public Output<ImmutableArray<Outputs.VirtualMachineV2StorageConfig>> StorageConfigs { get; private set; } = null!;

        /// <summary>
        /// VM last updated time.
        /// </summary>
        [Output("updateTime")]
        public Output<string> UpdateTime { get; private set; } = null!;

        /// <summary>
        /// Indicates how the vTPM for the VM should be configured.
        /// </summary>
        [Output("vtpmConfigs")]
        public Output<ImmutableArray<Outputs.VirtualMachineV2VtpmConfig>> VtpmConfigs { get; private set; } = null!;


        /// <summary>
        /// Create a VirtualMachineV2 resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public VirtualMachineV2(string name, VirtualMachineV2Args? args = null, CustomResourceOptions? options = null)
            : base("nutanix:index/virtualMachineV2:VirtualMachineV2", name, args ?? new VirtualMachineV2Args(), MakeResourceOptions(options, ""))
        {
        }

        private VirtualMachineV2(string name, Input<string> id, VirtualMachineV2State? state = null, CustomResourceOptions? options = null)
            : base("nutanix:index/virtualMachineV2:VirtualMachineV2", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/pierskarsenbarg/pulumi-nutanix",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing VirtualMachineV2 resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static VirtualMachineV2 Get(string name, Input<string> id, VirtualMachineV2State? state = null, CustomResourceOptions? options = null)
        {
            return new VirtualMachineV2(name, id, state, options);
        }
    }

    public sealed class VirtualMachineV2Args : global::Pulumi.ResourceArgs
    {
        [Input("apcConfigs")]
        private InputList<Inputs.VirtualMachineV2ApcConfigArgs>? _apcConfigs;

        /// <summary>
        /// Advanced Processor Compatibility configuration for the VM. Enabling this retains the CPU model for the VM across power cycles and migrations.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2ApcConfigArgs> ApcConfigs
        {
            get => _apcConfigs ?? (_apcConfigs = new InputList<Inputs.VirtualMachineV2ApcConfigArgs>());
            set => _apcConfigs = value;
        }

        [Input("availabilityZones")]
        private InputList<Inputs.VirtualMachineV2AvailabilityZoneArgs>? _availabilityZones;
        public InputList<Inputs.VirtualMachineV2AvailabilityZoneArgs> AvailabilityZones
        {
            get => _availabilityZones ?? (_availabilityZones = new InputList<Inputs.VirtualMachineV2AvailabilityZoneArgs>());
            set => _availabilityZones = value;
        }

        /// <summary>
        /// BIOS UUID of the VM. It should be of type UUID.
        /// </summary>
        [Input("biosUuid")]
        public Input<string>? BiosUuid { get; set; }

        [Input("bootConfigs")]
        private InputList<Inputs.VirtualMachineV2BootConfigArgs>? _bootConfigs;

        /// <summary>
        /// Indicates the order of device types in which the VM should try to boot from. If the boot device order is not provided the system will decide an appropriate boot device order.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2BootConfigArgs> BootConfigs
        {
            get => _bootConfigs ?? (_bootConfigs = new InputList<Inputs.VirtualMachineV2BootConfigArgs>());
            set => _bootConfigs = value;
        }

        [Input("categories")]
        private InputList<Inputs.VirtualMachineV2CategoryArgs>? _categories;

        /// <summary>
        /// Categories for the VM.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2CategoryArgs> Categories
        {
            get => _categories ?? (_categories = new InputList<Inputs.VirtualMachineV2CategoryArgs>());
            set => _categories = value;
        }

        [Input("cdRoms")]
        private InputList<Inputs.VirtualMachineV2CdRomArgs>? _cdRoms;

        /// <summary>
        /// CD-ROMs attached to the VM.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2CdRomArgs> CdRoms
        {
            get => _cdRoms ?? (_cdRoms = new InputList<Inputs.VirtualMachineV2CdRomArgs>());
            set => _cdRoms = value;
        }

        [Input("clusters")]
        private InputList<Inputs.VirtualMachineV2ClusterArgs>? _clusters;

        /// <summary>
        /// Reference to a cluster.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2ClusterArgs> Clusters
        {
            get => _clusters ?? (_clusters = new InputList<Inputs.VirtualMachineV2ClusterArgs>());
            set => _clusters = value;
        }

        /// <summary>
        /// VM description
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("disks")]
        private InputList<Inputs.VirtualMachineV2DiskArgs>? _disks;

        /// <summary>
        /// Disks attached to the VM.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2DiskArgs> Disks
        {
            get => _disks ?? (_disks = new InputList<Inputs.VirtualMachineV2DiskArgs>());
            set => _disks = value;
        }

        [Input("enabledCpuFeatures")]
        private InputList<string>? _enabledCpuFeatures;

        /// <summary>
        /// The list of additional CPU features to be enabled. HardwareVirtualization: Indicates whether hardware assisted virtualization should be enabled for the Guest OS or not. Once enabled, the Guest OS can deploy a nested hypervisor. Valid values are "HARDWARE_VIRTUALIZATION".
        /// </summary>
        public InputList<string> EnabledCpuFeatures
        {
            get => _enabledCpuFeatures ?? (_enabledCpuFeatures = new InputList<string>());
            set => _enabledCpuFeatures = value;
        }

        /// <summary>
        /// Generation UUID of the VM. It should be of type UUID.
        /// </summary>
        [Input("generationUuid")]
        public Input<string>? GenerationUuid { get; set; }

        [Input("gpuses")]
        private InputList<Inputs.VirtualMachineV2GpusArgs>? _gpuses;

        /// <summary>
        /// GPUs attached to the VM.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2GpusArgs> Gpuses
        {
            get => _gpuses ?? (_gpuses = new InputList<Inputs.VirtualMachineV2GpusArgs>());
            set => _gpuses = value;
        }

        [Input("guestCustomizations")]
        private InputList<Inputs.VirtualMachineV2GuestCustomizationArgs>? _guestCustomizations;

        /// <summary>
        /// Stage a Sysprep or cloud-init configuration file to be used by the guest for the next boot. Note that the Sysprep command must be used to generalize the Windows VMs before triggering this API call.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2GuestCustomizationArgs> GuestCustomizations
        {
            get => _guestCustomizations ?? (_guestCustomizations = new InputList<Inputs.VirtualMachineV2GuestCustomizationArgs>());
            set => _guestCustomizations = value;
        }

        [Input("guestTools")]
        private InputList<Inputs.VirtualMachineV2GuestToolArgs>? _guestTools;

        /// <summary>
        /// The details about Nutanix Guest Tools for a VM.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2GuestToolArgs> GuestTools
        {
            get => _guestTools ?? (_guestTools = new InputList<Inputs.VirtualMachineV2GuestToolArgs>());
            set => _guestTools = value;
        }

        /// <summary>
        /// VM hardware clock timezone in IANA TZDB format (America/Los_Angeles).
        /// </summary>
        [Input("hardwareClockTimezone")]
        public Input<string>? HardwareClockTimezone { get; set; }

        [Input("hosts")]
        private InputList<Inputs.VirtualMachineV2HostArgs>? _hosts;

        /// <summary>
        /// Reference to the host, the VM is running on.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2HostArgs> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<Inputs.VirtualMachineV2HostArgs>());
            set => _hosts = value;
        }

        /// <summary>
        /// Indicates whether the VM is an agent VM or not. When their host enters maintenance mode, once the normal VMs are evacuated, the agent VMs are powered off. When the host is restored, agent VMs are powered on before the normal VMs are restored. In other words, agent VMs cannot be HA-protected or live migrated.
        /// </summary>
        [Input("isAgentVm")]
        public Input<bool>? IsAgentVm { get; set; }

        /// <summary>
        /// Indicates whether to remove AHV branding from VM firmware tables or not.
        /// </summary>
        [Input("isBrandingEnabled")]
        public Input<bool>? IsBrandingEnabled { get; set; }

        /// <summary>
        /// Indicates whether the VM CPU hotplug is enabled.
        /// </summary>
        [Input("isCpuHotplugEnabled")]
        public Input<bool>? IsCpuHotplugEnabled { get; set; }

        /// <summary>
        /// Indicates whether to passthrough the host CPU features to the guest or not. Enabling this will make VM incapable of live migration.
        /// </summary>
        [Input("isCpuPassthroughEnabled")]
        public Input<bool>? IsCpuPassthroughEnabled { get; set; }

        /// <summary>
        /// Indicates whether the vGPU console is enabled or not.
        /// </summary>
        [Input("isGpuConsoleEnabled")]
        public Input<bool>? IsGpuConsoleEnabled { get; set; }

        /// <summary>
        /// Indicates whether the memory overcommit feature should be enabled for the VM or not. If enabled, parts of the VM memory may reside outside of the hypervisor physical memory. Once enabled, it should be expected that the VM may suffer performance degradation.
        /// </summary>
        [Input("isMemoryOvercommitEnabled")]
        public Input<bool>? IsMemoryOvercommitEnabled { get; set; }

        /// <summary>
        /// Indicates whether the VM SCSI controller is enabled.
        /// </summary>
        [Input("isScsiControllerEnabled")]
        public Input<bool>? IsScsiControllerEnabled { get; set; }

        /// <summary>
        /// Indicates whether the vCPUs should be hard pinned to specific pCPUs or not.
        /// </summary>
        [Input("isVcpuHardPinningEnabled")]
        public Input<bool>? IsVcpuHardPinningEnabled { get; set; }

        /// <summary>
        /// Indicates whether the VGA console should be disabled or not.
        /// </summary>
        [Input("isVgaConsoleEnabled")]
        public Input<bool>? IsVgaConsoleEnabled { get; set; }

        /// <summary>
        /// Machine type for the VM. Machine type Q35 is required for secure boot and does not support IDE disks. Valid values are "PSERIES", "Q35", "PC" .
        /// </summary>
        [Input("machineType")]
        public Input<string>? MachineType { get; set; }

        /// <summary>
        /// Memory size in bytes.
        /// </summary>
        [Input("memorySizeBytes")]
        public Input<int>? MemorySizeBytes { get; set; }

        /// <summary>
        /// VM name.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("nics")]
        private InputList<Inputs.VirtualMachineV2NicArgs>? _nics;

        /// <summary>
        /// NICs attached to the VM.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2NicArgs> Nics
        {
            get => _nics ?? (_nics = new InputList<Inputs.VirtualMachineV2NicArgs>());
            set => _nics = value;
        }

        /// <summary>
        /// Number of cores per socket. Value should be at least 1.
        /// </summary>
        [Input("numCoresPerSocket")]
        public Input<int>? NumCoresPerSocket { get; set; }

        /// <summary>
        /// Number of NUMA nodes. 0 means NUMA is disabled.
        /// </summary>
        [Input("numNumaNodes")]
        public Input<int>? NumNumaNodes { get; set; }

        /// <summary>
        /// Number of vCPU sockets. Value should be at least 1.
        /// </summary>
        [Input("numSockets")]
        public Input<int>? NumSockets { get; set; }

        /// <summary>
        /// Number of threads per core. Value should be at least 1.
        /// </summary>
        [Input("numThreadsPerCore")]
        public Input<int>? NumThreadsPerCore { get; set; }

        [Input("ownershipInfos")]
        private InputList<Inputs.VirtualMachineV2OwnershipInfoArgs>? _ownershipInfos;

        /// <summary>
        /// Ownership information for the VM.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2OwnershipInfoArgs> OwnershipInfos
        {
            get => _ownershipInfos ?? (_ownershipInfos = new InputList<Inputs.VirtualMachineV2OwnershipInfoArgs>());
            set => _ownershipInfos = value;
        }

        [Input("powerState")]
        public Input<string>? PowerState { get; set; }

        [Input("protectionPolicyStates")]
        private InputList<Inputs.VirtualMachineV2ProtectionPolicyStateArgs>? _protectionPolicyStates;

        /// <summary>
        /// Status of protection policy applied to this VM.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2ProtectionPolicyStateArgs> ProtectionPolicyStates
        {
            get => _protectionPolicyStates ?? (_protectionPolicyStates = new InputList<Inputs.VirtualMachineV2ProtectionPolicyStateArgs>());
            set => _protectionPolicyStates = value;
        }

        /// <summary>
        /// The type of protection applied on a VM. Valid values "PD_PROTECTED", "UNPROTECTED", "RULE_PROTECTED".
        /// </summary>
        [Input("protectionType")]
        public Input<string>? ProtectionType { get; set; }

        [Input("serialPorts")]
        private InputList<Inputs.VirtualMachineV2SerialPortArgs>? _serialPorts;

        /// <summary>
        /// Serial ports configured on the VM.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2SerialPortArgs> SerialPorts
        {
            get => _serialPorts ?? (_serialPorts = new InputList<Inputs.VirtualMachineV2SerialPortArgs>());
            set => _serialPorts = value;
        }

        [Input("sources")]
        private InputList<Inputs.VirtualMachineV2SourceArgs>? _sources;

        /// <summary>
        /// Reference to an entity that the VM should be cloned or created from. Valid values are "VM", "VM_RECOVERY_POINT".
        /// </summary>
        public InputList<Inputs.VirtualMachineV2SourceArgs> Sources
        {
            get => _sources ?? (_sources = new InputList<Inputs.VirtualMachineV2SourceArgs>());
            set => _sources = value;
        }

        [Input("storageConfigs")]
        private InputList<Inputs.VirtualMachineV2StorageConfigArgs>? _storageConfigs;

        /// <summary>
        /// Storage configuration for VM.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2StorageConfigArgs> StorageConfigs
        {
            get => _storageConfigs ?? (_storageConfigs = new InputList<Inputs.VirtualMachineV2StorageConfigArgs>());
            set => _storageConfigs = value;
        }

        [Input("vtpmConfigs")]
        private InputList<Inputs.VirtualMachineV2VtpmConfigArgs>? _vtpmConfigs;

        /// <summary>
        /// Indicates how the vTPM for the VM should be configured.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2VtpmConfigArgs> VtpmConfigs
        {
            get => _vtpmConfigs ?? (_vtpmConfigs = new InputList<Inputs.VirtualMachineV2VtpmConfigArgs>());
            set => _vtpmConfigs = value;
        }

        public VirtualMachineV2Args()
        {
        }
        public static new VirtualMachineV2Args Empty => new VirtualMachineV2Args();
    }

    public sealed class VirtualMachineV2State : global::Pulumi.ResourceArgs
    {
        [Input("apcConfigs")]
        private InputList<Inputs.VirtualMachineV2ApcConfigGetArgs>? _apcConfigs;

        /// <summary>
        /// Advanced Processor Compatibility configuration for the VM. Enabling this retains the CPU model for the VM across power cycles and migrations.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2ApcConfigGetArgs> ApcConfigs
        {
            get => _apcConfigs ?? (_apcConfigs = new InputList<Inputs.VirtualMachineV2ApcConfigGetArgs>());
            set => _apcConfigs = value;
        }

        [Input("availabilityZones")]
        private InputList<Inputs.VirtualMachineV2AvailabilityZoneGetArgs>? _availabilityZones;
        public InputList<Inputs.VirtualMachineV2AvailabilityZoneGetArgs> AvailabilityZones
        {
            get => _availabilityZones ?? (_availabilityZones = new InputList<Inputs.VirtualMachineV2AvailabilityZoneGetArgs>());
            set => _availabilityZones = value;
        }

        /// <summary>
        /// BIOS UUID of the VM. It should be of type UUID.
        /// </summary>
        [Input("biosUuid")]
        public Input<string>? BiosUuid { get; set; }

        [Input("bootConfigs")]
        private InputList<Inputs.VirtualMachineV2BootConfigGetArgs>? _bootConfigs;

        /// <summary>
        /// Indicates the order of device types in which the VM should try to boot from. If the boot device order is not provided the system will decide an appropriate boot device order.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2BootConfigGetArgs> BootConfigs
        {
            get => _bootConfigs ?? (_bootConfigs = new InputList<Inputs.VirtualMachineV2BootConfigGetArgs>());
            set => _bootConfigs = value;
        }

        [Input("categories")]
        private InputList<Inputs.VirtualMachineV2CategoryGetArgs>? _categories;

        /// <summary>
        /// Categories for the VM.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2CategoryGetArgs> Categories
        {
            get => _categories ?? (_categories = new InputList<Inputs.VirtualMachineV2CategoryGetArgs>());
            set => _categories = value;
        }

        [Input("cdRoms")]
        private InputList<Inputs.VirtualMachineV2CdRomGetArgs>? _cdRoms;

        /// <summary>
        /// CD-ROMs attached to the VM.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2CdRomGetArgs> CdRoms
        {
            get => _cdRoms ?? (_cdRoms = new InputList<Inputs.VirtualMachineV2CdRomGetArgs>());
            set => _cdRoms = value;
        }

        [Input("clusters")]
        private InputList<Inputs.VirtualMachineV2ClusterGetArgs>? _clusters;

        /// <summary>
        /// Reference to a cluster.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2ClusterGetArgs> Clusters
        {
            get => _clusters ?? (_clusters = new InputList<Inputs.VirtualMachineV2ClusterGetArgs>());
            set => _clusters = value;
        }

        /// <summary>
        /// VM creation time
        /// </summary>
        [Input("createTime")]
        public Input<string>? CreateTime { get; set; }

        /// <summary>
        /// VM description
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("disks")]
        private InputList<Inputs.VirtualMachineV2DiskGetArgs>? _disks;

        /// <summary>
        /// Disks attached to the VM.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2DiskGetArgs> Disks
        {
            get => _disks ?? (_disks = new InputList<Inputs.VirtualMachineV2DiskGetArgs>());
            set => _disks = value;
        }

        [Input("enabledCpuFeatures")]
        private InputList<string>? _enabledCpuFeatures;

        /// <summary>
        /// The list of additional CPU features to be enabled. HardwareVirtualization: Indicates whether hardware assisted virtualization should be enabled for the Guest OS or not. Once enabled, the Guest OS can deploy a nested hypervisor. Valid values are "HARDWARE_VIRTUALIZATION".
        /// </summary>
        public InputList<string> EnabledCpuFeatures
        {
            get => _enabledCpuFeatures ?? (_enabledCpuFeatures = new InputList<string>());
            set => _enabledCpuFeatures = value;
        }

        /// <summary>
        /// A globally unique identifier of an instance that is suitable for external consumption.
        /// </summary>
        [Input("extId")]
        public Input<string>? ExtId { get; set; }

        /// <summary>
        /// Generation UUID of the VM. It should be of type UUID.
        /// </summary>
        [Input("generationUuid")]
        public Input<string>? GenerationUuid { get; set; }

        [Input("gpuses")]
        private InputList<Inputs.VirtualMachineV2GpusGetArgs>? _gpuses;

        /// <summary>
        /// GPUs attached to the VM.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2GpusGetArgs> Gpuses
        {
            get => _gpuses ?? (_gpuses = new InputList<Inputs.VirtualMachineV2GpusGetArgs>());
            set => _gpuses = value;
        }

        [Input("guestCustomizations")]
        private InputList<Inputs.VirtualMachineV2GuestCustomizationGetArgs>? _guestCustomizations;

        /// <summary>
        /// Stage a Sysprep or cloud-init configuration file to be used by the guest for the next boot. Note that the Sysprep command must be used to generalize the Windows VMs before triggering this API call.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2GuestCustomizationGetArgs> GuestCustomizations
        {
            get => _guestCustomizations ?? (_guestCustomizations = new InputList<Inputs.VirtualMachineV2GuestCustomizationGetArgs>());
            set => _guestCustomizations = value;
        }

        [Input("guestTools")]
        private InputList<Inputs.VirtualMachineV2GuestToolGetArgs>? _guestTools;

        /// <summary>
        /// The details about Nutanix Guest Tools for a VM.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2GuestToolGetArgs> GuestTools
        {
            get => _guestTools ?? (_guestTools = new InputList<Inputs.VirtualMachineV2GuestToolGetArgs>());
            set => _guestTools = value;
        }

        /// <summary>
        /// VM hardware clock timezone in IANA TZDB format (America/Los_Angeles).
        /// </summary>
        [Input("hardwareClockTimezone")]
        public Input<string>? HardwareClockTimezone { get; set; }

        [Input("hosts")]
        private InputList<Inputs.VirtualMachineV2HostGetArgs>? _hosts;

        /// <summary>
        /// Reference to the host, the VM is running on.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2HostGetArgs> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<Inputs.VirtualMachineV2HostGetArgs>());
            set => _hosts = value;
        }

        /// <summary>
        /// Indicates whether the VM is an agent VM or not. When their host enters maintenance mode, once the normal VMs are evacuated, the agent VMs are powered off. When the host is restored, agent VMs are powered on before the normal VMs are restored. In other words, agent VMs cannot be HA-protected or live migrated.
        /// </summary>
        [Input("isAgentVm")]
        public Input<bool>? IsAgentVm { get; set; }

        /// <summary>
        /// Indicates whether to remove AHV branding from VM firmware tables or not.
        /// </summary>
        [Input("isBrandingEnabled")]
        public Input<bool>? IsBrandingEnabled { get; set; }

        /// <summary>
        /// Indicates whether the VM CPU hotplug is enabled.
        /// </summary>
        [Input("isCpuHotplugEnabled")]
        public Input<bool>? IsCpuHotplugEnabled { get; set; }

        /// <summary>
        /// Indicates whether to passthrough the host CPU features to the guest or not. Enabling this will make VM incapable of live migration.
        /// </summary>
        [Input("isCpuPassthroughEnabled")]
        public Input<bool>? IsCpuPassthroughEnabled { get; set; }

        /// <summary>
        /// Indicates whether the vGPU console is enabled or not.
        /// </summary>
        [Input("isGpuConsoleEnabled")]
        public Input<bool>? IsGpuConsoleEnabled { get; set; }

        /// <summary>
        /// Indicates whether the memory overcommit feature should be enabled for the VM or not. If enabled, parts of the VM memory may reside outside of the hypervisor physical memory. Once enabled, it should be expected that the VM may suffer performance degradation.
        /// </summary>
        [Input("isMemoryOvercommitEnabled")]
        public Input<bool>? IsMemoryOvercommitEnabled { get; set; }

        /// <summary>
        /// Indicates whether the VM SCSI controller is enabled.
        /// </summary>
        [Input("isScsiControllerEnabled")]
        public Input<bool>? IsScsiControllerEnabled { get; set; }

        /// <summary>
        /// Indicates whether the vCPUs should be hard pinned to specific pCPUs or not.
        /// </summary>
        [Input("isVcpuHardPinningEnabled")]
        public Input<bool>? IsVcpuHardPinningEnabled { get; set; }

        /// <summary>
        /// Indicates whether the VGA console should be disabled or not.
        /// </summary>
        [Input("isVgaConsoleEnabled")]
        public Input<bool>? IsVgaConsoleEnabled { get; set; }

        /// <summary>
        /// Machine type for the VM. Machine type Q35 is required for secure boot and does not support IDE disks. Valid values are "PSERIES", "Q35", "PC" .
        /// </summary>
        [Input("machineType")]
        public Input<string>? MachineType { get; set; }

        /// <summary>
        /// Memory size in bytes.
        /// </summary>
        [Input("memorySizeBytes")]
        public Input<int>? MemorySizeBytes { get; set; }

        /// <summary>
        /// VM name.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("nics")]
        private InputList<Inputs.VirtualMachineV2NicGetArgs>? _nics;

        /// <summary>
        /// NICs attached to the VM.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2NicGetArgs> Nics
        {
            get => _nics ?? (_nics = new InputList<Inputs.VirtualMachineV2NicGetArgs>());
            set => _nics = value;
        }

        /// <summary>
        /// Number of cores per socket. Value should be at least 1.
        /// </summary>
        [Input("numCoresPerSocket")]
        public Input<int>? NumCoresPerSocket { get; set; }

        /// <summary>
        /// Number of NUMA nodes. 0 means NUMA is disabled.
        /// </summary>
        [Input("numNumaNodes")]
        public Input<int>? NumNumaNodes { get; set; }

        /// <summary>
        /// Number of vCPU sockets. Value should be at least 1.
        /// </summary>
        [Input("numSockets")]
        public Input<int>? NumSockets { get; set; }

        /// <summary>
        /// Number of threads per core. Value should be at least 1.
        /// </summary>
        [Input("numThreadsPerCore")]
        public Input<int>? NumThreadsPerCore { get; set; }

        [Input("ownershipInfos")]
        private InputList<Inputs.VirtualMachineV2OwnershipInfoGetArgs>? _ownershipInfos;

        /// <summary>
        /// Ownership information for the VM.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2OwnershipInfoGetArgs> OwnershipInfos
        {
            get => _ownershipInfos ?? (_ownershipInfos = new InputList<Inputs.VirtualMachineV2OwnershipInfoGetArgs>());
            set => _ownershipInfos = value;
        }

        [Input("powerState")]
        public Input<string>? PowerState { get; set; }

        [Input("protectionPolicyStates")]
        private InputList<Inputs.VirtualMachineV2ProtectionPolicyStateGetArgs>? _protectionPolicyStates;

        /// <summary>
        /// Status of protection policy applied to this VM.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2ProtectionPolicyStateGetArgs> ProtectionPolicyStates
        {
            get => _protectionPolicyStates ?? (_protectionPolicyStates = new InputList<Inputs.VirtualMachineV2ProtectionPolicyStateGetArgs>());
            set => _protectionPolicyStates = value;
        }

        /// <summary>
        /// The type of protection applied on a VM. Valid values "PD_PROTECTED", "UNPROTECTED", "RULE_PROTECTED".
        /// </summary>
        [Input("protectionType")]
        public Input<string>? ProtectionType { get; set; }

        [Input("serialPorts")]
        private InputList<Inputs.VirtualMachineV2SerialPortGetArgs>? _serialPorts;

        /// <summary>
        /// Serial ports configured on the VM.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2SerialPortGetArgs> SerialPorts
        {
            get => _serialPorts ?? (_serialPorts = new InputList<Inputs.VirtualMachineV2SerialPortGetArgs>());
            set => _serialPorts = value;
        }

        [Input("sources")]
        private InputList<Inputs.VirtualMachineV2SourceGetArgs>? _sources;

        /// <summary>
        /// Reference to an entity that the VM should be cloned or created from. Valid values are "VM", "VM_RECOVERY_POINT".
        /// </summary>
        public InputList<Inputs.VirtualMachineV2SourceGetArgs> Sources
        {
            get => _sources ?? (_sources = new InputList<Inputs.VirtualMachineV2SourceGetArgs>());
            set => _sources = value;
        }

        [Input("storageConfigs")]
        private InputList<Inputs.VirtualMachineV2StorageConfigGetArgs>? _storageConfigs;

        /// <summary>
        /// Storage configuration for VM.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2StorageConfigGetArgs> StorageConfigs
        {
            get => _storageConfigs ?? (_storageConfigs = new InputList<Inputs.VirtualMachineV2StorageConfigGetArgs>());
            set => _storageConfigs = value;
        }

        /// <summary>
        /// VM last updated time.
        /// </summary>
        [Input("updateTime")]
        public Input<string>? UpdateTime { get; set; }

        [Input("vtpmConfigs")]
        private InputList<Inputs.VirtualMachineV2VtpmConfigGetArgs>? _vtpmConfigs;

        /// <summary>
        /// Indicates how the vTPM for the VM should be configured.
        /// </summary>
        public InputList<Inputs.VirtualMachineV2VtpmConfigGetArgs> VtpmConfigs
        {
            get => _vtpmConfigs ?? (_vtpmConfigs = new InputList<Inputs.VirtualMachineV2VtpmConfigGetArgs>());
            set => _vtpmConfigs = value;
        }

        public VirtualMachineV2State()
        {
        }
        public static new VirtualMachineV2State Empty => new VirtualMachineV2State();
    }
}
