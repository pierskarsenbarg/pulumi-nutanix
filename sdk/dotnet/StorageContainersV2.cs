// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace PiersKarsenbarg.Nutanix
{
    /// <summary>
    /// Provides Nutanix resource to create VPC.
    /// </summary>
    [NutanixResourceType("nutanix:index/storageContainersV2:StorageContainersV2")]
    public partial class StorageContainersV2 : global::Pulumi.CustomResource
    {
        /// <summary>
        /// -(Optional) Affinity host extId for RF 1 Storage Container.
        /// </summary>
        [Output("affinityHostExtId")]
        public Output<string> AffinityHostExtId { get; private set; } = null!;

        /// <summary>
        /// -(Optional) Indicates the current status of Cache Deduplication for the Container. available values:  `NONE`,    `OFF`,    `ON`
        /// </summary>
        [Output("cacheDeduplication")]
        public Output<string> CacheDeduplication { get; private set; } = null!;

        /// <summary>
        /// - ext id for the cluster owning the storage container.
        /// </summary>
        [Output("clusterExtId")]
        public Output<string> ClusterExtId { get; private set; } = null!;

        /// <summary>
        /// - Corresponding name of the Cluster owning the Storage Container instance.
        /// </summary>
        [Output("clusterName")]
        public Output<string> ClusterName { get; private set; } = null!;

        /// <summary>
        /// -(Optional) The compression delay in seconds.
        /// </summary>
        [Output("compressionDelaySecs")]
        public Output<int> CompressionDelaySecs { get; private set; } = null!;

        /// <summary>
        /// - the storage container ext id
        /// </summary>
        [Output("containerExtId")]
        public Output<string> ContainerExtId { get; private set; } = null!;

        /// <summary>
        /// -(Optional) Indicates the current status value for Erasure Coding for the Container. available values:  `NONE`,    `OFF`,    `ON`
        /// </summary>
        [Output("erasureCode")]
        public Output<string> ErasureCode { get; private set; } = null!;

        /// <summary>
        /// -(Optional) Delay in performing ErasureCode for the current Container instance.
        /// </summary>
        [Output("erasureCodeDelaySecs")]
        public Output<int> ErasureCodeDelaySecs { get; private set; } = null!;

        /// <summary>
        /// - the storage container uuid
        /// </summary>
        [Output("extId")]
        public Output<string> ExtId { get; private set; } = null!;

        /// <summary>
        /// -(Optional) Indicates whether to prefer a higher Erasure Code fault domain.
        /// </summary>
        [Output("hasHigherEcFaultDomainPreference")]
        public Output<bool> HasHigherEcFaultDomainPreference { get; private set; } = null!;

        [Output("ignoreSmallFiles")]
        public Output<bool> IgnoreSmallFiles { get; private set; } = null!;

        /// <summary>
        /// -(Optional) Indicates whether the compression is enabled for the Container.
        /// </summary>
        [Output("isCompressionEnabled")]
        public Output<bool> IsCompressionEnabled { get; private set; } = null!;

        /// <summary>
        /// - Indicates whether the Container is encrypted or not.
        /// </summary>
        [Output("isEncrypted")]
        public Output<bool> IsEncrypted { get; private set; } = null!;

        /// <summary>
        /// -(Optional) Indicates whether data written to this container should be inline erasure coded or not. This field is only considered when ErasureCoding is enabled.
        /// </summary>
        [Output("isInlineEcEnabled")]
        public Output<bool> IsInlineEcEnabled { get; private set; } = null!;

        /// <summary>
        /// - Indicates whether the Container is internal and is managed by Nutanix.
        /// </summary>
        [Output("isInternal")]
        public Output<bool> IsInternal { get; private set; } = null!;

        /// <summary>
        /// - Indicates if the Storage Container is marked for removal. This field is set when the Storage Container is about to be destroyed.
        /// </summary>
        [Output("isMarkedForRemoval")]
        public Output<bool> IsMarkedForRemoval { get; private set; } = null!;

        /// <summary>
        /// -(Optional) Indicates whether the Container instance has software encryption enabled.
        /// </summary>
        [Output("isSoftwareEncryptionEnabled")]
        public Output<bool> IsSoftwareEncryptionEnabled { get; private set; } = null!;

        /// <summary>
        /// - A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        /// </summary>
        [Output("links")]
        public Output<ImmutableArray<Outputs.StorageContainersV2Link>> Links { get; private set; } = null!;

        /// <summary>
        /// -(Optional) Max capacity of the Container as defined by the user.
        /// </summary>
        [Output("logicalAdvertisedCapacityBytes")]
        public Output<int> LogicalAdvertisedCapacityBytes { get; private set; } = null!;

        /// <summary>
        /// -(Optional) Total reserved size (in bytes) of the container (set by Admin). This also accounts for the container's replication factor. The actual reserved capacity of the container will be the maximum of explicitReservedCapacity and implicitReservedCapacity.
        /// </summary>
        [Output("logicalExplicitReservedCapacityBytes")]
        public Output<int> LogicalExplicitReservedCapacityBytes { get; private set; } = null!;

        /// <summary>
        /// - This is the summation of reservations provisioned on all vdisks in the container. The actual reserved capacity of the container will be the maximum of explicitReservedCapacity and implicitReservedCapacity
        /// </summary>
        [Output("logicalImplicitReservedCapacityBytes")]
        public Output<int> LogicalImplicitReservedCapacityBytes { get; private set; } = null!;

        /// <summary>
        /// - Maximum physical capacity of the Storage Container in bytes.
        /// </summary>
        [Output("maxCapacityBytes")]
        public Output<int> MaxCapacityBytes { get; private set; } = null!;

        /// <summary>
        /// -(Required) Name of the storage container.  Note that the name of Storage Container should be unique per cluster.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// -(Optional) List of NFS addresses which need to be whitelisted.
        /// </summary>
        [Output("nfsWhitelistAddresses")]
        public Output<ImmutableArray<Outputs.StorageContainersV2NfsWhitelistAddress>> NfsWhitelistAddresses { get; private set; } = null!;

        /// <summary>
        /// - Indicates the current status of Disk Deduplication for the Container. available values:  `NONE`,    `OFF`,    `POST_PROCESS`
        /// </summary>
        [Output("onDiskDedup")]
        public Output<string> OnDiskDedup { get; private set; } = null!;

        /// <summary>
        /// -(Optional) owner ext id
        /// </summary>
        [Output("ownerExtId")]
        public Output<string> OwnerExtId { get; private set; } = null!;

        /// <summary>
        /// -(Optional) Replication factor of the Storage Container.
        /// </summary>
        [Output("replicationFactor")]
        public Output<int> ReplicationFactor { get; private set; } = null!;

        /// <summary>
        /// - extId of the Storage Pool owning the Storage Container instance.
        /// </summary>
        [Output("storagePoolExtId")]
        public Output<string> StoragePoolExtId { get; private set; } = null!;

        /// <summary>
        /// - A globally unique identifier that represents the tenant that owns this entity.
        /// </summary>
        [Output("tenantId")]
        public Output<string> TenantId { get; private set; } = null!;


        /// <summary>
        /// Create a StorageContainersV2 resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public StorageContainersV2(string name, StorageContainersV2Args args, CustomResourceOptions? options = null)
            : base("nutanix:index/storageContainersV2:StorageContainersV2", name, args ?? new StorageContainersV2Args(), MakeResourceOptions(options, ""))
        {
        }

        private StorageContainersV2(string name, Input<string> id, StorageContainersV2State? state = null, CustomResourceOptions? options = null)
            : base("nutanix:index/storageContainersV2:StorageContainersV2", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/pierskarsenbarg/pulumi-nutanix",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing StorageContainersV2 resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static StorageContainersV2 Get(string name, Input<string> id, StorageContainersV2State? state = null, CustomResourceOptions? options = null)
        {
            return new StorageContainersV2(name, id, state, options);
        }
    }

    public sealed class StorageContainersV2Args : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// -(Optional) Affinity host extId for RF 1 Storage Container.
        /// </summary>
        [Input("affinityHostExtId")]
        public Input<string>? AffinityHostExtId { get; set; }

        /// <summary>
        /// -(Optional) Indicates the current status of Cache Deduplication for the Container. available values:  `NONE`,    `OFF`,    `ON`
        /// </summary>
        [Input("cacheDeduplication")]
        public Input<string>? CacheDeduplication { get; set; }

        /// <summary>
        /// - ext id for the cluster owning the storage container.
        /// </summary>
        [Input("clusterExtId", required: true)]
        public Input<string> ClusterExtId { get; set; } = null!;

        /// <summary>
        /// -(Optional) The compression delay in seconds.
        /// </summary>
        [Input("compressionDelaySecs")]
        public Input<int>? CompressionDelaySecs { get; set; }

        /// <summary>
        /// - the storage container ext id
        /// </summary>
        [Input("containerExtId")]
        public Input<string>? ContainerExtId { get; set; }

        /// <summary>
        /// -(Optional) Indicates the current status value for Erasure Coding for the Container. available values:  `NONE`,    `OFF`,    `ON`
        /// </summary>
        [Input("erasureCode")]
        public Input<string>? ErasureCode { get; set; }

        /// <summary>
        /// -(Optional) Delay in performing ErasureCode for the current Container instance.
        /// </summary>
        [Input("erasureCodeDelaySecs")]
        public Input<int>? ErasureCodeDelaySecs { get; set; }

        /// <summary>
        /// - the storage container uuid
        /// </summary>
        [Input("extId")]
        public Input<string>? ExtId { get; set; }

        /// <summary>
        /// -(Optional) Indicates whether to prefer a higher Erasure Code fault domain.
        /// </summary>
        [Input("hasHigherEcFaultDomainPreference")]
        public Input<bool>? HasHigherEcFaultDomainPreference { get; set; }

        [Input("ignoreSmallFiles")]
        public Input<bool>? IgnoreSmallFiles { get; set; }

        /// <summary>
        /// -(Optional) Indicates whether the compression is enabled for the Container.
        /// </summary>
        [Input("isCompressionEnabled")]
        public Input<bool>? IsCompressionEnabled { get; set; }

        /// <summary>
        /// -(Optional) Indicates whether data written to this container should be inline erasure coded or not. This field is only considered when ErasureCoding is enabled.
        /// </summary>
        [Input("isInlineEcEnabled")]
        public Input<bool>? IsInlineEcEnabled { get; set; }

        /// <summary>
        /// - Indicates whether the Container is internal and is managed by Nutanix.
        /// </summary>
        [Input("isInternal")]
        public Input<bool>? IsInternal { get; set; }

        /// <summary>
        /// -(Optional) Indicates whether the Container instance has software encryption enabled.
        /// </summary>
        [Input("isSoftwareEncryptionEnabled")]
        public Input<bool>? IsSoftwareEncryptionEnabled { get; set; }

        /// <summary>
        /// -(Optional) Max capacity of the Container as defined by the user.
        /// </summary>
        [Input("logicalAdvertisedCapacityBytes")]
        public Input<int>? LogicalAdvertisedCapacityBytes { get; set; }

        /// <summary>
        /// -(Optional) Total reserved size (in bytes) of the container (set by Admin). This also accounts for the container's replication factor. The actual reserved capacity of the container will be the maximum of explicitReservedCapacity and implicitReservedCapacity.
        /// </summary>
        [Input("logicalExplicitReservedCapacityBytes")]
        public Input<int>? LogicalExplicitReservedCapacityBytes { get; set; }

        /// <summary>
        /// -(Required) Name of the storage container.  Note that the name of Storage Container should be unique per cluster.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("nfsWhitelistAddresses")]
        private InputList<Inputs.StorageContainersV2NfsWhitelistAddressArgs>? _nfsWhitelistAddresses;

        /// <summary>
        /// -(Optional) List of NFS addresses which need to be whitelisted.
        /// </summary>
        public InputList<Inputs.StorageContainersV2NfsWhitelistAddressArgs> NfsWhitelistAddresses
        {
            get => _nfsWhitelistAddresses ?? (_nfsWhitelistAddresses = new InputList<Inputs.StorageContainersV2NfsWhitelistAddressArgs>());
            set => _nfsWhitelistAddresses = value;
        }

        /// <summary>
        /// - Indicates the current status of Disk Deduplication for the Container. available values:  `NONE`,    `OFF`,    `POST_PROCESS`
        /// </summary>
        [Input("onDiskDedup")]
        public Input<string>? OnDiskDedup { get; set; }

        /// <summary>
        /// -(Optional) owner ext id
        /// </summary>
        [Input("ownerExtId")]
        public Input<string>? OwnerExtId { get; set; }

        /// <summary>
        /// -(Optional) Replication factor of the Storage Container.
        /// </summary>
        [Input("replicationFactor")]
        public Input<int>? ReplicationFactor { get; set; }

        public StorageContainersV2Args()
        {
        }
        public static new StorageContainersV2Args Empty => new StorageContainersV2Args();
    }

    public sealed class StorageContainersV2State : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// -(Optional) Affinity host extId for RF 1 Storage Container.
        /// </summary>
        [Input("affinityHostExtId")]
        public Input<string>? AffinityHostExtId { get; set; }

        /// <summary>
        /// -(Optional) Indicates the current status of Cache Deduplication for the Container. available values:  `NONE`,    `OFF`,    `ON`
        /// </summary>
        [Input("cacheDeduplication")]
        public Input<string>? CacheDeduplication { get; set; }

        /// <summary>
        /// - ext id for the cluster owning the storage container.
        /// </summary>
        [Input("clusterExtId")]
        public Input<string>? ClusterExtId { get; set; }

        /// <summary>
        /// - Corresponding name of the Cluster owning the Storage Container instance.
        /// </summary>
        [Input("clusterName")]
        public Input<string>? ClusterName { get; set; }

        /// <summary>
        /// -(Optional) The compression delay in seconds.
        /// </summary>
        [Input("compressionDelaySecs")]
        public Input<int>? CompressionDelaySecs { get; set; }

        /// <summary>
        /// - the storage container ext id
        /// </summary>
        [Input("containerExtId")]
        public Input<string>? ContainerExtId { get; set; }

        /// <summary>
        /// -(Optional) Indicates the current status value for Erasure Coding for the Container. available values:  `NONE`,    `OFF`,    `ON`
        /// </summary>
        [Input("erasureCode")]
        public Input<string>? ErasureCode { get; set; }

        /// <summary>
        /// -(Optional) Delay in performing ErasureCode for the current Container instance.
        /// </summary>
        [Input("erasureCodeDelaySecs")]
        public Input<int>? ErasureCodeDelaySecs { get; set; }

        /// <summary>
        /// - the storage container uuid
        /// </summary>
        [Input("extId")]
        public Input<string>? ExtId { get; set; }

        /// <summary>
        /// -(Optional) Indicates whether to prefer a higher Erasure Code fault domain.
        /// </summary>
        [Input("hasHigherEcFaultDomainPreference")]
        public Input<bool>? HasHigherEcFaultDomainPreference { get; set; }

        [Input("ignoreSmallFiles")]
        public Input<bool>? IgnoreSmallFiles { get; set; }

        /// <summary>
        /// -(Optional) Indicates whether the compression is enabled for the Container.
        /// </summary>
        [Input("isCompressionEnabled")]
        public Input<bool>? IsCompressionEnabled { get; set; }

        /// <summary>
        /// - Indicates whether the Container is encrypted or not.
        /// </summary>
        [Input("isEncrypted")]
        public Input<bool>? IsEncrypted { get; set; }

        /// <summary>
        /// -(Optional) Indicates whether data written to this container should be inline erasure coded or not. This field is only considered when ErasureCoding is enabled.
        /// </summary>
        [Input("isInlineEcEnabled")]
        public Input<bool>? IsInlineEcEnabled { get; set; }

        /// <summary>
        /// - Indicates whether the Container is internal and is managed by Nutanix.
        /// </summary>
        [Input("isInternal")]
        public Input<bool>? IsInternal { get; set; }

        /// <summary>
        /// - Indicates if the Storage Container is marked for removal. This field is set when the Storage Container is about to be destroyed.
        /// </summary>
        [Input("isMarkedForRemoval")]
        public Input<bool>? IsMarkedForRemoval { get; set; }

        /// <summary>
        /// -(Optional) Indicates whether the Container instance has software encryption enabled.
        /// </summary>
        [Input("isSoftwareEncryptionEnabled")]
        public Input<bool>? IsSoftwareEncryptionEnabled { get; set; }

        [Input("links")]
        private InputList<Inputs.StorageContainersV2LinkGetArgs>? _links;

        /// <summary>
        /// - A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        /// </summary>
        public InputList<Inputs.StorageContainersV2LinkGetArgs> Links
        {
            get => _links ?? (_links = new InputList<Inputs.StorageContainersV2LinkGetArgs>());
            set => _links = value;
        }

        /// <summary>
        /// -(Optional) Max capacity of the Container as defined by the user.
        /// </summary>
        [Input("logicalAdvertisedCapacityBytes")]
        public Input<int>? LogicalAdvertisedCapacityBytes { get; set; }

        /// <summary>
        /// -(Optional) Total reserved size (in bytes) of the container (set by Admin). This also accounts for the container's replication factor. The actual reserved capacity of the container will be the maximum of explicitReservedCapacity and implicitReservedCapacity.
        /// </summary>
        [Input("logicalExplicitReservedCapacityBytes")]
        public Input<int>? LogicalExplicitReservedCapacityBytes { get; set; }

        /// <summary>
        /// - This is the summation of reservations provisioned on all vdisks in the container. The actual reserved capacity of the container will be the maximum of explicitReservedCapacity and implicitReservedCapacity
        /// </summary>
        [Input("logicalImplicitReservedCapacityBytes")]
        public Input<int>? LogicalImplicitReservedCapacityBytes { get; set; }

        /// <summary>
        /// - Maximum physical capacity of the Storage Container in bytes.
        /// </summary>
        [Input("maxCapacityBytes")]
        public Input<int>? MaxCapacityBytes { get; set; }

        /// <summary>
        /// -(Required) Name of the storage container.  Note that the name of Storage Container should be unique per cluster.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("nfsWhitelistAddresses")]
        private InputList<Inputs.StorageContainersV2NfsWhitelistAddressGetArgs>? _nfsWhitelistAddresses;

        /// <summary>
        /// -(Optional) List of NFS addresses which need to be whitelisted.
        /// </summary>
        public InputList<Inputs.StorageContainersV2NfsWhitelistAddressGetArgs> NfsWhitelistAddresses
        {
            get => _nfsWhitelistAddresses ?? (_nfsWhitelistAddresses = new InputList<Inputs.StorageContainersV2NfsWhitelistAddressGetArgs>());
            set => _nfsWhitelistAddresses = value;
        }

        /// <summary>
        /// - Indicates the current status of Disk Deduplication for the Container. available values:  `NONE`,    `OFF`,    `POST_PROCESS`
        /// </summary>
        [Input("onDiskDedup")]
        public Input<string>? OnDiskDedup { get; set; }

        /// <summary>
        /// -(Optional) owner ext id
        /// </summary>
        [Input("ownerExtId")]
        public Input<string>? OwnerExtId { get; set; }

        /// <summary>
        /// -(Optional) Replication factor of the Storage Container.
        /// </summary>
        [Input("replicationFactor")]
        public Input<int>? ReplicationFactor { get; set; }

        /// <summary>
        /// - extId of the Storage Pool owning the Storage Container instance.
        /// </summary>
        [Input("storagePoolExtId")]
        public Input<string>? StoragePoolExtId { get; set; }

        /// <summary>
        /// - A globally unique identifier that represents the tenant that owns this entity.
        /// </summary>
        [Input("tenantId")]
        public Input<string>? TenantId { get; set; }

        public StorageContainersV2State()
        {
        }
        public static new StorageContainersV2State Empty => new StorageContainersV2State();
    }
}
