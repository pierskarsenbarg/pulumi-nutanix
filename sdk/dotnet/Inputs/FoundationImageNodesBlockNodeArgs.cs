// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace PiersKarsenbarg.Nutanix.Inputs
{

    public sealed class FoundationImageNodesBlockNodeArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// - (Required if node is lacp configured) slow or fast if lacp if being used at the switch
        /// </summary>
        [Input("bondLacpRate")]
        public Input<string>? BondLacpRate { get; set; }

        /// <summary>
        /// - (Required if node is capable) dynamic if using LACP, static for LAG
        /// </summary>
        [Input("bondMode")]
        public Input<string>? BondMode { get; set; }

        /// <summary>
        /// - MAC Addresses of NICs in a team/bond
        /// </summary>
        [Input("bondUplinks")]
        public Input<string>? BondUplinks { get; set; }

        /// <summary>
        /// - ID of cluster.
        /// </summary>
        [Input("clusterId")]
        public Input<string>? ClusterId { get; set; }

        /// <summary>
        /// - Current CVM vlan tag. 0 Value with remove vlan tag.
        /// </summary>
        [Input("currentCvmVlanTag")]
        public Input<int>? CurrentCvmVlanTag { get; set; }

        /// <summary>
        /// - CVM current network interface.
        /// </summary>
        [Input("currentNetworkInterface")]
        public Input<string>? CurrentNetworkInterface { get; set; }

        /// <summary>
        /// - RAM capacity of CVM in GB.
        /// </summary>
        [Input("cvmGbRam")]
        public Input<int>? CvmGbRam { get; set; }

        [Input("cvmIp")]
        public Input<string>? CvmIp { get; set; }

        /// <summary>
        /// - Number of CVM vcpus.
        /// </summary>
        [Input("cvmNumVcpus")]
        public Input<int>? CvmNumVcpus { get; set; }

        /// <summary>
        /// - use "VmInstaller" to enable CVM imaging from standalone.
        /// </summary>
        [Input("deviceHint")]
        public Input<string>? DeviceHint { get; set; }

        /// <summary>
        /// - serial of boot device to be excluded (used by NX G6 platforms)
        /// </summary>
        [Input("exludeBootSerial")]
        public Input<string>? ExludeBootSerial { get; set; }

        [Input("hypervisor")]
        public Input<string>? Hypervisor { get; set; }

        /// <summary>
        /// - (Required) Hypervisor Hostname.
        /// </summary>
        [Input("hypervisorHostname", required: true)]
        public Input<string> HypervisorHostname { get; set; } = null!;

        /// <summary>
        /// - (Required) Hypervisor IP address.
        /// </summary>
        [Input("hypervisorIp", required: true)]
        public Input<string> HypervisorIp { get; set; } = null!;

        /// <summary>
        /// - Imaging delay.
        /// </summary>
        [Input("imageDelay")]
        public Input<int>? ImageDelay { get; set; }

        /// <summary>
        /// - (Optional, Default = true) If the node should be imaged now.
        /// </summary>
        [Input("imageNow")]
        public Input<bool>? ImageNow { get; set; }

        [Input("imageSuccessful")]
        public Input<bool>? ImageSuccessful { get; set; }

        /// <summary>
        /// - Whether IPMI should be configured.
        /// </summary>
        [Input("ipmiConfigureNow")]
        public Input<bool>? IpmiConfigureNow { get; set; }

        /// <summary>
        /// - (Required incase using IPMI based imaging either here or outside blocks) IPMI gateway for this node
        /// </summary>
        [Input("ipmiGateway")]
        public Input<string>? IpmiGateway { get; set; }

        /// <summary>
        /// - (Required) IPMI IP address.
        /// </summary>
        [Input("ipmiIp")]
        public Input<string>? IpmiIp { get; set; }

        /// <summary>
        /// - IPMI MAC address.
        /// </summary>
        [Input("ipmiMac")]
        public Input<string>? IpmiMac { get; set; }

        /// <summary>
        /// - (Required incase using IPMI based imaging either here or outside blocks) IPMI netmask for this node
        /// </summary>
        [Input("ipmiNetmask")]
        public Input<string>? IpmiNetmask { get; set; }

        /// <summary>
        /// - (Required incase using IPMI based imaging either here or outside blocks) IPMI username
        /// </summary>
        [Input("ipmiPassword")]
        public Input<string>? IpmiPassword { get; set; }

        /// <summary>
        /// - (Required incase using IPMI based imaging either here or outside blocks) IPMI password
        /// </summary>
        [Input("ipmiUser")]
        public Input<string>? IpmiUser { get; set; }

        /// <summary>
        /// - (Required when DeviceHint = "VmInstaller" for imaging using node's existing cvm for imaging) IPV6 address.
        /// </summary>
        [Input("ipv6Address")]
        public Input<string>? Ipv6Address { get; set; }

        /// <summary>
        /// - (Required when DeviceHint = "VmInstaller" for imaging using node's existing cvm for imaging) ipv6 interface.
        /// </summary>
        [Input("ipv6Interface")]
        public Input<string>? Ipv6Interface { get; set; }

        /// <summary>
        /// - relocate bootbank files to make space for phoenix files.
        /// </summary>
        [Input("mitigateLowBootSpace")]
        public Input<bool>? MitigateLowBootSpace { get; set; }

        /// <summary>
        /// - (Required) Position of the node in the block.
        /// </summary>
        [Input("nodePosition", required: true)]
        public Input<string> NodePosition { get; set; } = null!;

        /// <summary>
        /// - serial number of the node.
        /// </summary>
        [Input("nodeSerial")]
        public Input<string>? NodeSerial { get; set; }

        /// <summary>
        /// - mac address of nic to be used for rdma
        /// </summary>
        [Input("rdmaMacAddr")]
        public Input<string>? RdmaMacAddr { get; set; }

        /// <summary>
        /// - (Required if node is capable) passthru RDMA nic to CVM if possible, default to false
        /// </summary>
        [Input("rdmaPassthrough")]
        public Input<bool>? RdmaPassthrough { get; set; }

        /// <summary>
        /// - UCSM Managed mode.
        /// </summary>
        [Input("ucsmManagedMode")]
        public Input<string>? UcsmManagedMode { get; set; }

        /// <summary>
        /// - UCSM node serial.
        /// </summary>
        [Input("ucsmNodeSerial")]
        public Input<string>? UcsmNodeSerial { get; set; }

        /// <summary>
        /// - Object of UCSM parameters.
        /// * `ucsm_params.native_vlan` :- If the vlan is native.
        /// * `ucsm_params.keep_ucsm_settings` :- Whether UCSM settings should be kept.
        /// * `ucsm_params.mac_pool` :- Mac address pool.
        /// * `ucsm_params.vlan_name` :- Name of vlan.
        /// </summary>
        [Input("ucsmParams")]
        public Input<Inputs.FoundationImageNodesBlockNodeUcsmParamsArgs>? UcsmParams { get; set; }

        [Input("vswitches")]
        private InputList<Inputs.FoundationImageNodesBlockNodeVswitchArgs>? _vswitches;
        public InputList<Inputs.FoundationImageNodesBlockNodeVswitchArgs> Vswitches
        {
            get => _vswitches ?? (_vswitches = new InputList<Inputs.FoundationImageNodesBlockNodeVswitchArgs>());
            set => _vswitches = value;
        }

        public FoundationImageNodesBlockNodeArgs()
        {
        }
        public static new FoundationImageNodesBlockNodeArgs Empty => new FoundationImageNodesBlockNodeArgs();
    }
}
