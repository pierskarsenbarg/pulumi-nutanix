// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace PiersKarsenbarg.Nutanix
{
    /// <summary>
    /// Provides a Nutanix Virtual Machine resource to Create a virtual machine.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using Pulumi;
    /// using Nutanix = PiersKarsenbarg.Nutanix;
    /// using Nutanix = Pulumi.Nutanix;
    /// 
    /// class MyStack : Stack
    /// {
    ///     public MyStack()
    ///     {
    ///         var clusters = Output.Create(Nutanix.GetClusters.InvokeAsync());
    ///         var vm1 = new Nutanix.VirtualMachine("vm1", new Nutanix.VirtualMachineArgs
    ///         {
    ///             ClusterUuid = clusters.Apply(clusters =&gt; clusters.Entities?[0]?.Metadata?.Uuid),
    ///             Categories = 
    ///             {
    ///                 new Nutanix.Inputs.VirtualMachineCategoryArgs
    ///                 {
    ///                     Name = "Environment",
    ///                     Value = "Staging",
    ///                 },
    ///             },
    ///             NumVcpusPerSocket = 1,
    ///             NumSockets = 1,
    ///             MemorySizeMib = 2048,
    ///         });
    ///     }
    /// 
    /// }
    /// ```
    /// ### With Storage Config
    /// ```csharp
    /// using Pulumi;
    /// using Nutanix = PiersKarsenbarg.Nutanix;
    /// using Nutanix = Pulumi.Nutanix;
    /// 
    /// class MyStack : Stack
    /// {
    ///     public MyStack()
    ///     {
    ///         var clusters = Output.Create(Nutanix.GetClusters.InvokeAsync());
    ///         var vm = new Nutanix.VirtualMachine("vm", new Nutanix.VirtualMachineArgs
    ///         {
    ///             ClusterUuid = clusters.Apply(clusters =&gt; clusters.Entities?[0]?.Metadata?.Uuid),
    ///             NumVcpusPerSocket = 1,
    ///             NumSockets = 1,
    ///             MemorySizeMib = 186,
    ///             DiskLists = 
    ///             {
    ///                 new Nutanix.Inputs.VirtualMachineDiskListArgs
    ///                 {
    ///                     DiskSizeBytes = 68157440,
    ///                     DiskSizeMib = 65,
    ///                     StorageConfig = new Nutanix.Inputs.VirtualMachineDiskListStorageConfigArgs
    ///                     {
    ///                         StorageContainerReferences = 
    ///                         {
    ///                             new Nutanix.Inputs.VirtualMachineDiskListStorageConfigStorageContainerReferenceArgs
    ///                             {
    ///                                 Kind = "storage_container",
    ///                                 Uuid = "2bbe67bc-fd14-4637-8de1-6379257f4219",
    ///                             },
    ///                         },
    ///                     },
    ///                 },
    ///             },
    ///         });
    ///     }
    /// 
    /// }
    /// ```
    /// </summary>
    [NutanixResourceType("nutanix:index/virtualMachine:VirtualMachine")]
    public partial class VirtualMachine : Pulumi.CustomResource
    {
        /// <summary>
        /// The version of the API.
        /// * `state`: - The state of the vm.
        /// * `cluster_name`: - The name of the cluster.
        /// * `host_reference`: - Reference to a host.
        /// * `hypervisor_type`: - The hypervisor type for the hypervisor the VM is hosted on.
        /// * `nic_list_status`: - Status NICs attached to the VM.
        /// </summary>
        [Output("apiVersion")]
        public Output<string> ApiVersion { get; private set; } = null!;

        [Output("availabilityZoneReference")]
        public Output<ImmutableDictionary<string, string>> AvailabilityZoneReference { get; private set; } = null!;

        [Output("bootDeviceDiskAddress")]
        public Output<ImmutableDictionary<string, string>> BootDeviceDiskAddress { get; private set; } = null!;

        [Output("bootDeviceMacAddress")]
        public Output<string> BootDeviceMacAddress { get; private set; } = null!;

        [Output("bootDeviceOrderLists")]
        public Output<ImmutableArray<string>> BootDeviceOrderLists { get; private set; } = null!;

        [Output("bootType")]
        public Output<string> BootType { get; private set; } = null!;

        [Output("categories")]
        public Output<ImmutableArray<Outputs.VirtualMachineCategory>> Categories { get; private set; } = null!;

        [Output("cloudInitCdromUuid")]
        public Output<string> CloudInitCdromUuid { get; private set; } = null!;

        [Output("clusterName")]
        public Output<string> ClusterName { get; private set; } = null!;

        [Output("clusterUuid")]
        public Output<string> ClusterUuid { get; private set; } = null!;

        [Output("description")]
        public Output<string> Description { get; private set; } = null!;

        /// <summary>
        /// Disks attached to the VM.
        /// * `use_hot_add`: - (Optional) Use Hot Add when modifying VM resources. Passing value false will result in VM reboots. Default value is `true`.
        /// * `num_threads_per_core`: - (Optional) Number of threads per core.
        /// * `enable_cpu_passthrough`: - (Optional) Add true to enable CPU passthrough.
        /// * `is_vcpu_hard_pinned`: - (Optional) Add true to enable CPU pinning.
        /// </summary>
        [Output("diskLists")]
        public Output<ImmutableArray<Outputs.VirtualMachineDiskList>> DiskLists { get; private set; } = null!;

        [Output("enableCpuPassthrough")]
        public Output<bool?> EnableCpuPassthrough { get; private set; } = null!;

        [Output("enableScriptExec")]
        public Output<bool> EnableScriptExec { get; private set; } = null!;

        [Output("gpuLists")]
        public Output<ImmutableArray<Outputs.VirtualMachineGpuList>> GpuLists { get; private set; } = null!;

        [Output("guestCustomizationCloudInitCustomKeyValues")]
        public Output<ImmutableDictionary<string, string>> GuestCustomizationCloudInitCustomKeyValues { get; private set; } = null!;

        /// <summary>
        /// The contents of the meta_data configuration for cloud-init. This can be formatted as YAML or JSON. The value must be base64 encoded.
        /// * `guest_customization_cloud_init_custom_key_values`: - (Optional) Generic key value pair used for custom attributes in cloud init.
        /// * `guest_customization_is_overridable`: - (Optional) Flag to allow override of customization by deployer.
        /// * `guest_customization_sysprep`: - (Optional) VM guests may be customized at boot time using one of several different methods. Currently, cloud-init w/ ConfigDriveV2 (for Linux VMs) and Sysprep (for Windows VMs) are supported. Only ONE OF sysprep or cloud_init should be provided. Note that guest customization can currently only be set during VM creation. Attempting to change it after creation will result in an error. Additional properties can be specified. For example - in the context of VM template creation if \"override_script\" is set to \"True\" then the deployer can upload their own custom script.
        /// * `guest_customization_sysrep_custom_key_values`: - (Optional) Generic key value pair used for custom attributes in sysrep.
        /// * `should_fail_on_script_failure`: - (Optional)  Extra configs related to power state transition. Indicates whether to abort ngt shutdown/reboot if script fails.
        /// * `enable_script_exec`: - (Optional) Extra configs related to power state transition. Indicates whether to execute set script before ngt shutdown/reboot.
        /// * `power_state_mechanism`: - (Optional) Indicates the mechanism guiding the VM power state transition. Currently used for the transition to \"OFF\" state. Power state mechanism (ACPI/GUEST/HARD).
        /// * `vga_console_enabled`: - (Optional) Indicates whether VGA console should be enabled or not.
        /// </summary>
        [Output("guestCustomizationCloudInitMetaData")]
        public Output<string> GuestCustomizationCloudInitMetaData { get; private set; } = null!;

        [Output("guestCustomizationCloudInitUserData")]
        public Output<string> GuestCustomizationCloudInitUserData { get; private set; } = null!;

        [Output("guestCustomizationIsOverridable")]
        public Output<bool> GuestCustomizationIsOverridable { get; private set; } = null!;

        [Output("guestCustomizationSysprep")]
        public Output<ImmutableDictionary<string, string>> GuestCustomizationSysprep { get; private set; } = null!;

        [Output("guestCustomizationSysprepCustomKeyValues")]
        public Output<ImmutableDictionary<string, object>> GuestCustomizationSysprepCustomKeyValues { get; private set; } = null!;

        [Output("guestOsId")]
        public Output<string> GuestOsId { get; private set; } = null!;

        [Output("hardwareClockTimezone")]
        public Output<string> HardwareClockTimezone { get; private set; } = null!;

        [Output("hostReference")]
        public Output<ImmutableDictionary<string, string>> HostReference { get; private set; } = null!;

        [Output("hypervisorType")]
        public Output<string> HypervisorType { get; private set; } = null!;

        [Output("isVcpuHardPinned")]
        public Output<bool?> IsVcpuHardPinned { get; private set; } = null!;

        [Output("machineType")]
        public Output<string> MachineType { get; private set; } = null!;

        [Output("memorySizeMib")]
        public Output<int> MemorySizeMib { get; private set; } = null!;

        [Output("metadata")]
        public Output<ImmutableDictionary<string, string>> Metadata { get; private set; } = null!;

        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        [Output("ngtCredentials")]
        public Output<ImmutableDictionary<string, object>> NgtCredentials { get; private set; } = null!;

        /// <summary>
        /// Application names that are enabled.
        /// * `num_vcpus_per_socket`: - (Optional) Number of vCPUs per socket.
        /// * `num_sockets`: - (Optional) Number of vCPU sockets.
        /// * `gpu_list`: - (Optional) GPUs attached to the VM.
        /// * `parent_referece`: - (Optional) Reference to an entity that the VM cloned from.
        /// * `memory_size_mib`: - (Optional) Memory size in MiB.
        /// * `boot_device_order_list`: - (Optional) Indicates the order of device types in which VM should try to boot from. If boot device order is not provided the system will decide appropriate boot device order.
        /// * `boot_device_disk_address`: - (Optional) Address of disk to boot from.
        /// * `boot_device_mac_address`: - (Optional) MAC address of nic to boot from.
        /// * `boot_type`: - (Optional) Indicates whether the VM should use Secure boot, UEFI boot or Legacy boot.If UEFI or; Secure boot is enabled then other legacy boot options (like boot_device and; boot_device_order_list) are ignored. Secure boot depends on UEFI boot, i.e. enabling; Secure boot means that UEFI boot is also enabled. The possible value are: UEFI", "LEGACY", "SECURE_BOOT".
        /// * `machine_type`: - Machine type for the VM. Machine type Q35 is required for secure boot and does not support IDE disks.
        /// * `hardware_clock_timezone`: - (Optional) VM's hardware clock timezone in IANA TZDB format (America/Los_Angeles).
        /// * `guest_customization_cloud_init_user_data`: - (Optional) The contents of the user_data configuration for cloud-init. This can be formatted as YAML, JSON, or could be a shell script. The value must be base64 encoded.
        /// </summary>
        [Output("ngtEnabledCapabilityLists")]
        public Output<ImmutableArray<string>> NgtEnabledCapabilityLists { get; private set; } = null!;

        [Output("nicListStatuses")]
        public Output<ImmutableArray<Outputs.VirtualMachineNicListStatus>> NicListStatuses { get; private set; } = null!;

        [Output("nicLists")]
        public Output<ImmutableArray<Outputs.VirtualMachineNicList>> NicLists { get; private set; } = null!;

        [Output("numSockets")]
        public Output<int> NumSockets { get; private set; } = null!;

        [Output("numVcpusPerSocket")]
        public Output<int> NumVcpusPerSocket { get; private set; } = null!;

        [Output("numVnumaNodes")]
        public Output<int> NumVnumaNodes { get; private set; } = null!;

        [Output("nutanixGuestTools")]
        public Output<ImmutableDictionary<string, string>> NutanixGuestTools { get; private set; } = null!;

        [Output("ownerReference")]
        public Output<ImmutableDictionary<string, string>> OwnerReference { get; private set; } = null!;

        [Output("parentReference")]
        public Output<ImmutableDictionary<string, string>> ParentReference { get; private set; } = null!;

        [Output("powerState")]
        public Output<string> PowerState { get; private set; } = null!;

        [Output("powerStateMechanism")]
        public Output<string> PowerStateMechanism { get; private set; } = null!;

        [Output("projectReference")]
        public Output<ImmutableDictionary<string, string>> ProjectReference { get; private set; } = null!;

        [Output("serialPortLists")]
        public Output<ImmutableArray<Outputs.VirtualMachineSerialPortList>> SerialPortLists { get; private set; } = null!;

        [Output("shouldFailOnScriptFailure")]
        public Output<bool> ShouldFailOnScriptFailure { get; private set; } = null!;

        [Output("state")]
        public Output<string> State { get; private set; } = null!;

        [Output("useHotAdd")]
        public Output<bool?> UseHotAdd { get; private set; } = null!;

        [Output("vgaConsoleEnabled")]
        public Output<bool> VgaConsoleEnabled { get; private set; } = null!;


        /// <summary>
        /// Create a VirtualMachine resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public VirtualMachine(string name, VirtualMachineArgs args, CustomResourceOptions? options = null)
            : base("nutanix:index/virtualMachine:VirtualMachine", name, args ?? new VirtualMachineArgs(), MakeResourceOptions(options, ""))
        {
        }

        private VirtualMachine(string name, Input<string> id, VirtualMachineState? state = null, CustomResourceOptions? options = null)
            : base("nutanix:index/virtualMachine:VirtualMachine", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "https://github.com/pierskarsenbarg/pulumi-nutanix/releases/download/${VERSION}",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing VirtualMachine resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static VirtualMachine Get(string name, Input<string> id, VirtualMachineState? state = null, CustomResourceOptions? options = null)
        {
            return new VirtualMachine(name, id, state, options);
        }
    }

    public sealed class VirtualMachineArgs : Pulumi.ResourceArgs
    {
        [Input("availabilityZoneReference")]
        private InputMap<string>? _availabilityZoneReference;
        public InputMap<string> AvailabilityZoneReference
        {
            get => _availabilityZoneReference ?? (_availabilityZoneReference = new InputMap<string>());
            set => _availabilityZoneReference = value;
        }

        [Input("bootDeviceDiskAddress")]
        private InputMap<string>? _bootDeviceDiskAddress;
        public InputMap<string> BootDeviceDiskAddress
        {
            get => _bootDeviceDiskAddress ?? (_bootDeviceDiskAddress = new InputMap<string>());
            set => _bootDeviceDiskAddress = value;
        }

        [Input("bootDeviceMacAddress")]
        public Input<string>? BootDeviceMacAddress { get; set; }

        [Input("bootDeviceOrderLists")]
        private InputList<string>? _bootDeviceOrderLists;
        public InputList<string> BootDeviceOrderLists
        {
            get => _bootDeviceOrderLists ?? (_bootDeviceOrderLists = new InputList<string>());
            set => _bootDeviceOrderLists = value;
        }

        [Input("bootType")]
        public Input<string>? BootType { get; set; }

        [Input("categories")]
        private InputList<Inputs.VirtualMachineCategoryArgs>? _categories;
        public InputList<Inputs.VirtualMachineCategoryArgs> Categories
        {
            get => _categories ?? (_categories = new InputList<Inputs.VirtualMachineCategoryArgs>());
            set => _categories = value;
        }

        [Input("cloudInitCdromUuid")]
        public Input<string>? CloudInitCdromUuid { get; set; }

        [Input("clusterUuid", required: true)]
        public Input<string> ClusterUuid { get; set; } = null!;

        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("diskLists")]
        private InputList<Inputs.VirtualMachineDiskListArgs>? _diskLists;

        /// <summary>
        /// Disks attached to the VM.
        /// * `use_hot_add`: - (Optional) Use Hot Add when modifying VM resources. Passing value false will result in VM reboots. Default value is `true`.
        /// * `num_threads_per_core`: - (Optional) Number of threads per core.
        /// * `enable_cpu_passthrough`: - (Optional) Add true to enable CPU passthrough.
        /// * `is_vcpu_hard_pinned`: - (Optional) Add true to enable CPU pinning.
        /// </summary>
        public InputList<Inputs.VirtualMachineDiskListArgs> DiskLists
        {
            get => _diskLists ?? (_diskLists = new InputList<Inputs.VirtualMachineDiskListArgs>());
            set => _diskLists = value;
        }

        [Input("enableCpuPassthrough")]
        public Input<bool>? EnableCpuPassthrough { get; set; }

        [Input("enableScriptExec")]
        public Input<bool>? EnableScriptExec { get; set; }

        [Input("gpuLists")]
        private InputList<Inputs.VirtualMachineGpuListArgs>? _gpuLists;
        public InputList<Inputs.VirtualMachineGpuListArgs> GpuLists
        {
            get => _gpuLists ?? (_gpuLists = new InputList<Inputs.VirtualMachineGpuListArgs>());
            set => _gpuLists = value;
        }

        [Input("guestCustomizationCloudInitCustomKeyValues")]
        private InputMap<string>? _guestCustomizationCloudInitCustomKeyValues;
        public InputMap<string> GuestCustomizationCloudInitCustomKeyValues
        {
            get => _guestCustomizationCloudInitCustomKeyValues ?? (_guestCustomizationCloudInitCustomKeyValues = new InputMap<string>());
            set => _guestCustomizationCloudInitCustomKeyValues = value;
        }

        /// <summary>
        /// The contents of the meta_data configuration for cloud-init. This can be formatted as YAML or JSON. The value must be base64 encoded.
        /// * `guest_customization_cloud_init_custom_key_values`: - (Optional) Generic key value pair used for custom attributes in cloud init.
        /// * `guest_customization_is_overridable`: - (Optional) Flag to allow override of customization by deployer.
        /// * `guest_customization_sysprep`: - (Optional) VM guests may be customized at boot time using one of several different methods. Currently, cloud-init w/ ConfigDriveV2 (for Linux VMs) and Sysprep (for Windows VMs) are supported. Only ONE OF sysprep or cloud_init should be provided. Note that guest customization can currently only be set during VM creation. Attempting to change it after creation will result in an error. Additional properties can be specified. For example - in the context of VM template creation if \"override_script\" is set to \"True\" then the deployer can upload their own custom script.
        /// * `guest_customization_sysrep_custom_key_values`: - (Optional) Generic key value pair used for custom attributes in sysrep.
        /// * `should_fail_on_script_failure`: - (Optional)  Extra configs related to power state transition. Indicates whether to abort ngt shutdown/reboot if script fails.
        /// * `enable_script_exec`: - (Optional) Extra configs related to power state transition. Indicates whether to execute set script before ngt shutdown/reboot.
        /// * `power_state_mechanism`: - (Optional) Indicates the mechanism guiding the VM power state transition. Currently used for the transition to \"OFF\" state. Power state mechanism (ACPI/GUEST/HARD).
        /// * `vga_console_enabled`: - (Optional) Indicates whether VGA console should be enabled or not.
        /// </summary>
        [Input("guestCustomizationCloudInitMetaData")]
        public Input<string>? GuestCustomizationCloudInitMetaData { get; set; }

        [Input("guestCustomizationCloudInitUserData")]
        public Input<string>? GuestCustomizationCloudInitUserData { get; set; }

        [Input("guestCustomizationIsOverridable")]
        public Input<bool>? GuestCustomizationIsOverridable { get; set; }

        [Input("guestCustomizationSysprep")]
        private InputMap<string>? _guestCustomizationSysprep;
        public InputMap<string> GuestCustomizationSysprep
        {
            get => _guestCustomizationSysprep ?? (_guestCustomizationSysprep = new InputMap<string>());
            set => _guestCustomizationSysprep = value;
        }

        [Input("guestCustomizationSysprepCustomKeyValues")]
        private InputMap<object>? _guestCustomizationSysprepCustomKeyValues;
        public InputMap<object> GuestCustomizationSysprepCustomKeyValues
        {
            get => _guestCustomizationSysprepCustomKeyValues ?? (_guestCustomizationSysprepCustomKeyValues = new InputMap<object>());
            set => _guestCustomizationSysprepCustomKeyValues = value;
        }

        [Input("guestOsId")]
        public Input<string>? GuestOsId { get; set; }

        [Input("hardwareClockTimezone")]
        public Input<string>? HardwareClockTimezone { get; set; }

        [Input("isVcpuHardPinned")]
        public Input<bool>? IsVcpuHardPinned { get; set; }

        [Input("machineType")]
        public Input<string>? MachineType { get; set; }

        [Input("memorySizeMib")]
        public Input<int>? MemorySizeMib { get; set; }

        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("ngtCredentials")]
        private InputMap<object>? _ngtCredentials;
        public InputMap<object> NgtCredentials
        {
            get => _ngtCredentials ?? (_ngtCredentials = new InputMap<object>());
            set => _ngtCredentials = value;
        }

        [Input("ngtEnabledCapabilityLists")]
        private InputList<string>? _ngtEnabledCapabilityLists;

        /// <summary>
        /// Application names that are enabled.
        /// * `num_vcpus_per_socket`: - (Optional) Number of vCPUs per socket.
        /// * `num_sockets`: - (Optional) Number of vCPU sockets.
        /// * `gpu_list`: - (Optional) GPUs attached to the VM.
        /// * `parent_referece`: - (Optional) Reference to an entity that the VM cloned from.
        /// * `memory_size_mib`: - (Optional) Memory size in MiB.
        /// * `boot_device_order_list`: - (Optional) Indicates the order of device types in which VM should try to boot from. If boot device order is not provided the system will decide appropriate boot device order.
        /// * `boot_device_disk_address`: - (Optional) Address of disk to boot from.
        /// * `boot_device_mac_address`: - (Optional) MAC address of nic to boot from.
        /// * `boot_type`: - (Optional) Indicates whether the VM should use Secure boot, UEFI boot or Legacy boot.If UEFI or; Secure boot is enabled then other legacy boot options (like boot_device and; boot_device_order_list) are ignored. Secure boot depends on UEFI boot, i.e. enabling; Secure boot means that UEFI boot is also enabled. The possible value are: UEFI", "LEGACY", "SECURE_BOOT".
        /// * `machine_type`: - Machine type for the VM. Machine type Q35 is required for secure boot and does not support IDE disks.
        /// * `hardware_clock_timezone`: - (Optional) VM's hardware clock timezone in IANA TZDB format (America/Los_Angeles).
        /// * `guest_customization_cloud_init_user_data`: - (Optional) The contents of the user_data configuration for cloud-init. This can be formatted as YAML, JSON, or could be a shell script. The value must be base64 encoded.
        /// </summary>
        public InputList<string> NgtEnabledCapabilityLists
        {
            get => _ngtEnabledCapabilityLists ?? (_ngtEnabledCapabilityLists = new InputList<string>());
            set => _ngtEnabledCapabilityLists = value;
        }

        [Input("nicLists")]
        private InputList<Inputs.VirtualMachineNicListArgs>? _nicLists;
        public InputList<Inputs.VirtualMachineNicListArgs> NicLists
        {
            get => _nicLists ?? (_nicLists = new InputList<Inputs.VirtualMachineNicListArgs>());
            set => _nicLists = value;
        }

        [Input("numSockets")]
        public Input<int>? NumSockets { get; set; }

        [Input("numVcpusPerSocket")]
        public Input<int>? NumVcpusPerSocket { get; set; }

        [Input("numVnumaNodes")]
        public Input<int>? NumVnumaNodes { get; set; }

        [Input("nutanixGuestTools")]
        private InputMap<string>? _nutanixGuestTools;
        public InputMap<string> NutanixGuestTools
        {
            get => _nutanixGuestTools ?? (_nutanixGuestTools = new InputMap<string>());
            set => _nutanixGuestTools = value;
        }

        [Input("ownerReference")]
        private InputMap<string>? _ownerReference;
        public InputMap<string> OwnerReference
        {
            get => _ownerReference ?? (_ownerReference = new InputMap<string>());
            set => _ownerReference = value;
        }

        [Input("parentReference")]
        private InputMap<string>? _parentReference;
        public InputMap<string> ParentReference
        {
            get => _parentReference ?? (_parentReference = new InputMap<string>());
            set => _parentReference = value;
        }

        [Input("powerStateMechanism")]
        public Input<string>? PowerStateMechanism { get; set; }

        [Input("projectReference")]
        private InputMap<string>? _projectReference;
        public InputMap<string> ProjectReference
        {
            get => _projectReference ?? (_projectReference = new InputMap<string>());
            set => _projectReference = value;
        }

        [Input("serialPortLists")]
        private InputList<Inputs.VirtualMachineSerialPortListArgs>? _serialPortLists;
        public InputList<Inputs.VirtualMachineSerialPortListArgs> SerialPortLists
        {
            get => _serialPortLists ?? (_serialPortLists = new InputList<Inputs.VirtualMachineSerialPortListArgs>());
            set => _serialPortLists = value;
        }

        [Input("shouldFailOnScriptFailure")]
        public Input<bool>? ShouldFailOnScriptFailure { get; set; }

        [Input("useHotAdd")]
        public Input<bool>? UseHotAdd { get; set; }

        [Input("vgaConsoleEnabled")]
        public Input<bool>? VgaConsoleEnabled { get; set; }

        public VirtualMachineArgs()
        {
        }
    }

    public sealed class VirtualMachineState : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The version of the API.
        /// * `state`: - The state of the vm.
        /// * `cluster_name`: - The name of the cluster.
        /// * `host_reference`: - Reference to a host.
        /// * `hypervisor_type`: - The hypervisor type for the hypervisor the VM is hosted on.
        /// * `nic_list_status`: - Status NICs attached to the VM.
        /// </summary>
        [Input("apiVersion")]
        public Input<string>? ApiVersion { get; set; }

        [Input("availabilityZoneReference")]
        private InputMap<string>? _availabilityZoneReference;
        public InputMap<string> AvailabilityZoneReference
        {
            get => _availabilityZoneReference ?? (_availabilityZoneReference = new InputMap<string>());
            set => _availabilityZoneReference = value;
        }

        [Input("bootDeviceDiskAddress")]
        private InputMap<string>? _bootDeviceDiskAddress;
        public InputMap<string> BootDeviceDiskAddress
        {
            get => _bootDeviceDiskAddress ?? (_bootDeviceDiskAddress = new InputMap<string>());
            set => _bootDeviceDiskAddress = value;
        }

        [Input("bootDeviceMacAddress")]
        public Input<string>? BootDeviceMacAddress { get; set; }

        [Input("bootDeviceOrderLists")]
        private InputList<string>? _bootDeviceOrderLists;
        public InputList<string> BootDeviceOrderLists
        {
            get => _bootDeviceOrderLists ?? (_bootDeviceOrderLists = new InputList<string>());
            set => _bootDeviceOrderLists = value;
        }

        [Input("bootType")]
        public Input<string>? BootType { get; set; }

        [Input("categories")]
        private InputList<Inputs.VirtualMachineCategoryGetArgs>? _categories;
        public InputList<Inputs.VirtualMachineCategoryGetArgs> Categories
        {
            get => _categories ?? (_categories = new InputList<Inputs.VirtualMachineCategoryGetArgs>());
            set => _categories = value;
        }

        [Input("cloudInitCdromUuid")]
        public Input<string>? CloudInitCdromUuid { get; set; }

        [Input("clusterName")]
        public Input<string>? ClusterName { get; set; }

        [Input("clusterUuid")]
        public Input<string>? ClusterUuid { get; set; }

        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("diskLists")]
        private InputList<Inputs.VirtualMachineDiskListGetArgs>? _diskLists;

        /// <summary>
        /// Disks attached to the VM.
        /// * `use_hot_add`: - (Optional) Use Hot Add when modifying VM resources. Passing value false will result in VM reboots. Default value is `true`.
        /// * `num_threads_per_core`: - (Optional) Number of threads per core.
        /// * `enable_cpu_passthrough`: - (Optional) Add true to enable CPU passthrough.
        /// * `is_vcpu_hard_pinned`: - (Optional) Add true to enable CPU pinning.
        /// </summary>
        public InputList<Inputs.VirtualMachineDiskListGetArgs> DiskLists
        {
            get => _diskLists ?? (_diskLists = new InputList<Inputs.VirtualMachineDiskListGetArgs>());
            set => _diskLists = value;
        }

        [Input("enableCpuPassthrough")]
        public Input<bool>? EnableCpuPassthrough { get; set; }

        [Input("enableScriptExec")]
        public Input<bool>? EnableScriptExec { get; set; }

        [Input("gpuLists")]
        private InputList<Inputs.VirtualMachineGpuListGetArgs>? _gpuLists;
        public InputList<Inputs.VirtualMachineGpuListGetArgs> GpuLists
        {
            get => _gpuLists ?? (_gpuLists = new InputList<Inputs.VirtualMachineGpuListGetArgs>());
            set => _gpuLists = value;
        }

        [Input("guestCustomizationCloudInitCustomKeyValues")]
        private InputMap<string>? _guestCustomizationCloudInitCustomKeyValues;
        public InputMap<string> GuestCustomizationCloudInitCustomKeyValues
        {
            get => _guestCustomizationCloudInitCustomKeyValues ?? (_guestCustomizationCloudInitCustomKeyValues = new InputMap<string>());
            set => _guestCustomizationCloudInitCustomKeyValues = value;
        }

        /// <summary>
        /// The contents of the meta_data configuration for cloud-init. This can be formatted as YAML or JSON. The value must be base64 encoded.
        /// * `guest_customization_cloud_init_custom_key_values`: - (Optional) Generic key value pair used for custom attributes in cloud init.
        /// * `guest_customization_is_overridable`: - (Optional) Flag to allow override of customization by deployer.
        /// * `guest_customization_sysprep`: - (Optional) VM guests may be customized at boot time using one of several different methods. Currently, cloud-init w/ ConfigDriveV2 (for Linux VMs) and Sysprep (for Windows VMs) are supported. Only ONE OF sysprep or cloud_init should be provided. Note that guest customization can currently only be set during VM creation. Attempting to change it after creation will result in an error. Additional properties can be specified. For example - in the context of VM template creation if \"override_script\" is set to \"True\" then the deployer can upload their own custom script.
        /// * `guest_customization_sysrep_custom_key_values`: - (Optional) Generic key value pair used for custom attributes in sysrep.
        /// * `should_fail_on_script_failure`: - (Optional)  Extra configs related to power state transition. Indicates whether to abort ngt shutdown/reboot if script fails.
        /// * `enable_script_exec`: - (Optional) Extra configs related to power state transition. Indicates whether to execute set script before ngt shutdown/reboot.
        /// * `power_state_mechanism`: - (Optional) Indicates the mechanism guiding the VM power state transition. Currently used for the transition to \"OFF\" state. Power state mechanism (ACPI/GUEST/HARD).
        /// * `vga_console_enabled`: - (Optional) Indicates whether VGA console should be enabled or not.
        /// </summary>
        [Input("guestCustomizationCloudInitMetaData")]
        public Input<string>? GuestCustomizationCloudInitMetaData { get; set; }

        [Input("guestCustomizationCloudInitUserData")]
        public Input<string>? GuestCustomizationCloudInitUserData { get; set; }

        [Input("guestCustomizationIsOverridable")]
        public Input<bool>? GuestCustomizationIsOverridable { get; set; }

        [Input("guestCustomizationSysprep")]
        private InputMap<string>? _guestCustomizationSysprep;
        public InputMap<string> GuestCustomizationSysprep
        {
            get => _guestCustomizationSysprep ?? (_guestCustomizationSysprep = new InputMap<string>());
            set => _guestCustomizationSysprep = value;
        }

        [Input("guestCustomizationSysprepCustomKeyValues")]
        private InputMap<object>? _guestCustomizationSysprepCustomKeyValues;
        public InputMap<object> GuestCustomizationSysprepCustomKeyValues
        {
            get => _guestCustomizationSysprepCustomKeyValues ?? (_guestCustomizationSysprepCustomKeyValues = new InputMap<object>());
            set => _guestCustomizationSysprepCustomKeyValues = value;
        }

        [Input("guestOsId")]
        public Input<string>? GuestOsId { get; set; }

        [Input("hardwareClockTimezone")]
        public Input<string>? HardwareClockTimezone { get; set; }

        [Input("hostReference")]
        private InputMap<string>? _hostReference;
        public InputMap<string> HostReference
        {
            get => _hostReference ?? (_hostReference = new InputMap<string>());
            set => _hostReference = value;
        }

        [Input("hypervisorType")]
        public Input<string>? HypervisorType { get; set; }

        [Input("isVcpuHardPinned")]
        public Input<bool>? IsVcpuHardPinned { get; set; }

        [Input("machineType")]
        public Input<string>? MachineType { get; set; }

        [Input("memorySizeMib")]
        public Input<int>? MemorySizeMib { get; set; }

        [Input("metadata")]
        private InputMap<string>? _metadata;
        public InputMap<string> Metadata
        {
            get => _metadata ?? (_metadata = new InputMap<string>());
            set => _metadata = value;
        }

        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("ngtCredentials")]
        private InputMap<object>? _ngtCredentials;
        public InputMap<object> NgtCredentials
        {
            get => _ngtCredentials ?? (_ngtCredentials = new InputMap<object>());
            set => _ngtCredentials = value;
        }

        [Input("ngtEnabledCapabilityLists")]
        private InputList<string>? _ngtEnabledCapabilityLists;

        /// <summary>
        /// Application names that are enabled.
        /// * `num_vcpus_per_socket`: - (Optional) Number of vCPUs per socket.
        /// * `num_sockets`: - (Optional) Number of vCPU sockets.
        /// * `gpu_list`: - (Optional) GPUs attached to the VM.
        /// * `parent_referece`: - (Optional) Reference to an entity that the VM cloned from.
        /// * `memory_size_mib`: - (Optional) Memory size in MiB.
        /// * `boot_device_order_list`: - (Optional) Indicates the order of device types in which VM should try to boot from. If boot device order is not provided the system will decide appropriate boot device order.
        /// * `boot_device_disk_address`: - (Optional) Address of disk to boot from.
        /// * `boot_device_mac_address`: - (Optional) MAC address of nic to boot from.
        /// * `boot_type`: - (Optional) Indicates whether the VM should use Secure boot, UEFI boot or Legacy boot.If UEFI or; Secure boot is enabled then other legacy boot options (like boot_device and; boot_device_order_list) are ignored. Secure boot depends on UEFI boot, i.e. enabling; Secure boot means that UEFI boot is also enabled. The possible value are: UEFI", "LEGACY", "SECURE_BOOT".
        /// * `machine_type`: - Machine type for the VM. Machine type Q35 is required for secure boot and does not support IDE disks.
        /// * `hardware_clock_timezone`: - (Optional) VM's hardware clock timezone in IANA TZDB format (America/Los_Angeles).
        /// * `guest_customization_cloud_init_user_data`: - (Optional) The contents of the user_data configuration for cloud-init. This can be formatted as YAML, JSON, or could be a shell script. The value must be base64 encoded.
        /// </summary>
        public InputList<string> NgtEnabledCapabilityLists
        {
            get => _ngtEnabledCapabilityLists ?? (_ngtEnabledCapabilityLists = new InputList<string>());
            set => _ngtEnabledCapabilityLists = value;
        }

        [Input("nicListStatuses")]
        private InputList<Inputs.VirtualMachineNicListStatusGetArgs>? _nicListStatuses;
        public InputList<Inputs.VirtualMachineNicListStatusGetArgs> NicListStatuses
        {
            get => _nicListStatuses ?? (_nicListStatuses = new InputList<Inputs.VirtualMachineNicListStatusGetArgs>());
            set => _nicListStatuses = value;
        }

        [Input("nicLists")]
        private InputList<Inputs.VirtualMachineNicListGetArgs>? _nicLists;
        public InputList<Inputs.VirtualMachineNicListGetArgs> NicLists
        {
            get => _nicLists ?? (_nicLists = new InputList<Inputs.VirtualMachineNicListGetArgs>());
            set => _nicLists = value;
        }

        [Input("numSockets")]
        public Input<int>? NumSockets { get; set; }

        [Input("numVcpusPerSocket")]
        public Input<int>? NumVcpusPerSocket { get; set; }

        [Input("numVnumaNodes")]
        public Input<int>? NumVnumaNodes { get; set; }

        [Input("nutanixGuestTools")]
        private InputMap<string>? _nutanixGuestTools;
        public InputMap<string> NutanixGuestTools
        {
            get => _nutanixGuestTools ?? (_nutanixGuestTools = new InputMap<string>());
            set => _nutanixGuestTools = value;
        }

        [Input("ownerReference")]
        private InputMap<string>? _ownerReference;
        public InputMap<string> OwnerReference
        {
            get => _ownerReference ?? (_ownerReference = new InputMap<string>());
            set => _ownerReference = value;
        }

        [Input("parentReference")]
        private InputMap<string>? _parentReference;
        public InputMap<string> ParentReference
        {
            get => _parentReference ?? (_parentReference = new InputMap<string>());
            set => _parentReference = value;
        }

        [Input("powerState")]
        public Input<string>? PowerState { get; set; }

        [Input("powerStateMechanism")]
        public Input<string>? PowerStateMechanism { get; set; }

        [Input("projectReference")]
        private InputMap<string>? _projectReference;
        public InputMap<string> ProjectReference
        {
            get => _projectReference ?? (_projectReference = new InputMap<string>());
            set => _projectReference = value;
        }

        [Input("serialPortLists")]
        private InputList<Inputs.VirtualMachineSerialPortListGetArgs>? _serialPortLists;
        public InputList<Inputs.VirtualMachineSerialPortListGetArgs> SerialPortLists
        {
            get => _serialPortLists ?? (_serialPortLists = new InputList<Inputs.VirtualMachineSerialPortListGetArgs>());
            set => _serialPortLists = value;
        }

        [Input("shouldFailOnScriptFailure")]
        public Input<bool>? ShouldFailOnScriptFailure { get; set; }

        [Input("state")]
        public Input<string>? State { get; set; }

        [Input("useHotAdd")]
        public Input<bool>? UseHotAdd { get; set; }

        [Input("vgaConsoleEnabled")]
        public Input<bool>? VgaConsoleEnabled { get; set; }

        public VirtualMachineState()
        {
        }
    }
}
